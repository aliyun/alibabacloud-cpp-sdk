// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_RDS20140815_H_
#define ALIBABACLOUD_RDS20140815_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Rds20140815 {
class AddTagsToResourceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AddTagsToResourceRequestTag() {}

  explicit AddTagsToResourceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~AddTagsToResourceRequestTag() = default;
};
class AddTagsToResourceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddTagsToResourceRequestTag>> tag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> proxyId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> tags{};
  shared_ptr<string> ownerAccount{};

  AddTagsToResourceRequest() {}

  explicit AddTagsToResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (proxyId) {
      res["proxyId"] = boost::any(*proxyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AddTagsToResourceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddTagsToResourceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AddTagsToResourceRequestTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("proxyId") != m.end() && !m["proxyId"].empty()) {
      proxyId = make_shared<string>(boost::any_cast<string>(m["proxyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~AddTagsToResourceRequest() = default;
};
class AddTagsToResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddTagsToResourceResponseBody() {}

  explicit AddTagsToResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddTagsToResourceResponseBody() = default;
};
class AddTagsToResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddTagsToResourceResponseBody> body{};

  AddTagsToResourceResponse() {}

  explicit AddTagsToResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTagsToResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTagsToResourceResponseBody>(model1);
      }
    }
  }


  virtual ~AddTagsToResourceResponse() = default;
};
class AllocateInstancePublicConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> connectionStringPrefix{};
  shared_ptr<string> port{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> generalGroupName{};

  AllocateInstancePublicConnectionRequest() {}

  explicit AllocateInstancePublicConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (connectionStringPrefix) {
      res["ConnectionStringPrefix"] = boost::any(*connectionStringPrefix);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (generalGroupName) {
      res["GeneralGroupName"] = boost::any(*generalGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ConnectionStringPrefix") != m.end() && !m["ConnectionStringPrefix"].empty()) {
      connectionStringPrefix = make_shared<string>(boost::any_cast<string>(m["ConnectionStringPrefix"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("GeneralGroupName") != m.end() && !m["GeneralGroupName"].empty()) {
      generalGroupName = make_shared<string>(boost::any_cast<string>(m["GeneralGroupName"]));
    }
  }


  virtual ~AllocateInstancePublicConnectionRequest() = default;
};
class AllocateInstancePublicConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dbInstanceName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> connectionString{};

  AllocateInstancePublicConnectionResponseBody() {}

  explicit AllocateInstancePublicConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbInstanceName) {
      res["DbInstanceName"] = boost::any(*dbInstanceName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (connectionString) {
      res["ConnectionString"] = boost::any(*connectionString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbInstanceName") != m.end() && !m["DbInstanceName"].empty()) {
      dbInstanceName = make_shared<string>(boost::any_cast<string>(m["DbInstanceName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ConnectionString") != m.end() && !m["ConnectionString"].empty()) {
      connectionString = make_shared<string>(boost::any_cast<string>(m["ConnectionString"]));
    }
  }


  virtual ~AllocateInstancePublicConnectionResponseBody() = default;
};
class AllocateInstancePublicConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AllocateInstancePublicConnectionResponseBody> body{};

  AllocateInstancePublicConnectionResponse() {}

  explicit AllocateInstancePublicConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllocateInstancePublicConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllocateInstancePublicConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~AllocateInstancePublicConnectionResponse() = default;
};
class AllocateReadWriteSplittingConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> connectionStringPrefix{};
  shared_ptr<string> port{};
  shared_ptr<string> maxDelayTime{};
  shared_ptr<string> netType{};
  shared_ptr<string> distributionType{};
  shared_ptr<string> weight{};

  AllocateReadWriteSplittingConnectionRequest() {}

  explicit AllocateReadWriteSplittingConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (connectionStringPrefix) {
      res["ConnectionStringPrefix"] = boost::any(*connectionStringPrefix);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (maxDelayTime) {
      res["MaxDelayTime"] = boost::any(*maxDelayTime);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (distributionType) {
      res["DistributionType"] = boost::any(*distributionType);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ConnectionStringPrefix") != m.end() && !m["ConnectionStringPrefix"].empty()) {
      connectionStringPrefix = make_shared<string>(boost::any_cast<string>(m["ConnectionStringPrefix"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("MaxDelayTime") != m.end() && !m["MaxDelayTime"].empty()) {
      maxDelayTime = make_shared<string>(boost::any_cast<string>(m["MaxDelayTime"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("DistributionType") != m.end() && !m["DistributionType"].empty()) {
      distributionType = make_shared<string>(boost::any_cast<string>(m["DistributionType"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~AllocateReadWriteSplittingConnectionRequest() = default;
};
class AllocateReadWriteSplittingConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AllocateReadWriteSplittingConnectionResponseBody() {}

  explicit AllocateReadWriteSplittingConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AllocateReadWriteSplittingConnectionResponseBody() = default;
};
class AllocateReadWriteSplittingConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AllocateReadWriteSplittingConnectionResponseBody> body{};

  AllocateReadWriteSplittingConnectionResponse() {}

  explicit AllocateReadWriteSplittingConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllocateReadWriteSplittingConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllocateReadWriteSplittingConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~AllocateReadWriteSplittingConnectionResponse() = default;
};
class CalculateDBInstanceWeightRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};

  CalculateDBInstanceWeightRequest() {}

  explicit CalculateDBInstanceWeightRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~CalculateDBInstanceWeightRequest() = default;
};
class CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight : public Darabonba::Model {
public:
  shared_ptr<string> readonlyInstanceSQLDelayedTime{};
  shared_ptr<string> weight{};
  shared_ptr<string> DBInstanceType{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> role{};

  CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight() {}

  explicit CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (readonlyInstanceSQLDelayedTime) {
      res["ReadonlyInstanceSQLDelayedTime"] = boost::any(*readonlyInstanceSQLDelayedTime);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    if (DBInstanceType) {
      res["DBInstanceType"] = boost::any(*DBInstanceType);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReadonlyInstanceSQLDelayedTime") != m.end() && !m["ReadonlyInstanceSQLDelayedTime"].empty()) {
      readonlyInstanceSQLDelayedTime = make_shared<string>(boost::any_cast<string>(m["ReadonlyInstanceSQLDelayedTime"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
    if (m.find("DBInstanceType") != m.end() && !m["DBInstanceType"].empty()) {
      DBInstanceType = make_shared<string>(boost::any_cast<string>(m["DBInstanceType"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight() = default;
};
class CalculateDBInstanceWeightResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight>> DBInstanceWeight{};

  CalculateDBInstanceWeightResponseBodyItems() {}

  explicit CalculateDBInstanceWeightResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceWeight) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstanceWeight){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstanceWeight"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceWeight") != m.end() && !m["DBInstanceWeight"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstanceWeight"].type()) {
        vector<CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstanceWeight"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstanceWeight = make_shared<vector<CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight>>(expect1);
      }
    }
  }


  virtual ~CalculateDBInstanceWeightResponseBodyItems() = default;
};
class CalculateDBInstanceWeightResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CalculateDBInstanceWeightResponseBodyItems> items{};

  CalculateDBInstanceWeightResponseBody() {}

  explicit CalculateDBInstanceWeightResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        CalculateDBInstanceWeightResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<CalculateDBInstanceWeightResponseBodyItems>(model1);
      }
    }
  }


  virtual ~CalculateDBInstanceWeightResponseBody() = default;
};
class CalculateDBInstanceWeightResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CalculateDBInstanceWeightResponseBody> body{};

  CalculateDBInstanceWeightResponse() {}

  explicit CalculateDBInstanceWeightResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CalculateDBInstanceWeightResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CalculateDBInstanceWeightResponseBody>(model1);
      }
    }
  }


  virtual ~CalculateDBInstanceWeightResponse() = default;
};
class CancelImportRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> importId{};
  shared_ptr<string> ownerAccount{};

  CancelImportRequest() {}

  explicit CancelImportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (importId) {
      res["ImportId"] = boost::any(*importId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ImportId") != m.end() && !m["ImportId"].empty()) {
      importId = make_shared<long>(boost::any_cast<long>(m["ImportId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~CancelImportRequest() = default;
};
class CancelImportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelImportResponseBody() {}

  explicit CancelImportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelImportResponseBody() = default;
};
class CancelImportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelImportResponseBody> body{};

  CancelImportResponse() {}

  explicit CancelImportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelImportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelImportResponseBody>(model1);
      }
    }
  }


  virtual ~CancelImportResponse() = default;
};
class CheckAccountNameAvailableRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> ownerAccount{};

  CheckAccountNameAvailableRequest() {}

  explicit CheckAccountNameAvailableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~CheckAccountNameAvailableRequest() = default;
};
class CheckAccountNameAvailableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CheckAccountNameAvailableResponseBody() {}

  explicit CheckAccountNameAvailableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckAccountNameAvailableResponseBody() = default;
};
class CheckAccountNameAvailableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CheckAccountNameAvailableResponseBody> body{};

  CheckAccountNameAvailableResponse() {}

  explicit CheckAccountNameAvailableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckAccountNameAvailableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckAccountNameAvailableResponseBody>(model1);
      }
    }
  }


  virtual ~CheckAccountNameAvailableResponse() = default;
};
class CheckCloudResourceAuthorizedRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> targetRegionId{};

  CheckCloudResourceAuthorizedRequest() {}

  explicit CheckCloudResourceAuthorizedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (targetRegionId) {
      res["TargetRegionId"] = boost::any(*targetRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("TargetRegionId") != m.end() && !m["TargetRegionId"].empty()) {
      targetRegionId = make_shared<string>(boost::any_cast<string>(m["TargetRegionId"]));
    }
  }


  virtual ~CheckCloudResourceAuthorizedRequest() = default;
};
class CheckCloudResourceAuthorizedResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> roleArn{};
  shared_ptr<long> authorizationState{};

  CheckCloudResourceAuthorizedResponseBody() {}

  explicit CheckCloudResourceAuthorizedResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (authorizationState) {
      res["AuthorizationState"] = boost::any(*authorizationState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("AuthorizationState") != m.end() && !m["AuthorizationState"].empty()) {
      authorizationState = make_shared<long>(boost::any_cast<long>(m["AuthorizationState"]));
    }
  }


  virtual ~CheckCloudResourceAuthorizedResponseBody() = default;
};
class CheckCloudResourceAuthorizedResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CheckCloudResourceAuthorizedResponseBody> body{};

  CheckCloudResourceAuthorizedResponse() {}

  explicit CheckCloudResourceAuthorizedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckCloudResourceAuthorizedResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckCloudResourceAuthorizedResponseBody>(model1);
      }
    }
  }


  virtual ~CheckCloudResourceAuthorizedResponse() = default;
};
class CheckCreateDdrDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> engine{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<long> DBInstanceStorage{};
  shared_ptr<string> restoreType{};
  shared_ptr<string> backupSetId{};
  shared_ptr<string> restoreTime{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> sourceDBInstanceName{};
  shared_ptr<string> binlogName{};
  shared_ptr<string> binlogPosition{};
  shared_ptr<string> binlogRole{};

  CheckCreateDdrDBInstanceRequest() {}

  explicit CheckCreateDdrDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (DBInstanceStorage) {
      res["DBInstanceStorage"] = boost::any(*DBInstanceStorage);
    }
    if (restoreType) {
      res["RestoreType"] = boost::any(*restoreType);
    }
    if (backupSetId) {
      res["BackupSetId"] = boost::any(*backupSetId);
    }
    if (restoreTime) {
      res["RestoreTime"] = boost::any(*restoreTime);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (sourceDBInstanceName) {
      res["SourceDBInstanceName"] = boost::any(*sourceDBInstanceName);
    }
    if (binlogName) {
      res["BinlogName"] = boost::any(*binlogName);
    }
    if (binlogPosition) {
      res["BinlogPosition"] = boost::any(*binlogPosition);
    }
    if (binlogRole) {
      res["BinlogRole"] = boost::any(*binlogRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("DBInstanceStorage") != m.end() && !m["DBInstanceStorage"].empty()) {
      DBInstanceStorage = make_shared<long>(boost::any_cast<long>(m["DBInstanceStorage"]));
    }
    if (m.find("RestoreType") != m.end() && !m["RestoreType"].empty()) {
      restoreType = make_shared<string>(boost::any_cast<string>(m["RestoreType"]));
    }
    if (m.find("BackupSetId") != m.end() && !m["BackupSetId"].empty()) {
      backupSetId = make_shared<string>(boost::any_cast<string>(m["BackupSetId"]));
    }
    if (m.find("RestoreTime") != m.end() && !m["RestoreTime"].empty()) {
      restoreTime = make_shared<string>(boost::any_cast<string>(m["RestoreTime"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("SourceDBInstanceName") != m.end() && !m["SourceDBInstanceName"].empty()) {
      sourceDBInstanceName = make_shared<string>(boost::any_cast<string>(m["SourceDBInstanceName"]));
    }
    if (m.find("BinlogName") != m.end() && !m["BinlogName"].empty()) {
      binlogName = make_shared<string>(boost::any_cast<string>(m["BinlogName"]));
    }
    if (m.find("BinlogPosition") != m.end() && !m["BinlogPosition"].empty()) {
      binlogPosition = make_shared<string>(boost::any_cast<string>(m["BinlogPosition"]));
    }
    if (m.find("BinlogRole") != m.end() && !m["BinlogRole"].empty()) {
      binlogRole = make_shared<string>(boost::any_cast<string>(m["BinlogRole"]));
    }
  }


  virtual ~CheckCreateDdrDBInstanceRequest() = default;
};
class CheckCreateDdrDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> isValid{};
  shared_ptr<string> requestId{};

  CheckCreateDdrDBInstanceResponseBody() {}

  explicit CheckCreateDdrDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isValid) {
      res["IsValid"] = boost::any(*isValid);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsValid") != m.end() && !m["IsValid"].empty()) {
      isValid = make_shared<string>(boost::any_cast<string>(m["IsValid"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckCreateDdrDBInstanceResponseBody() = default;
};
class CheckCreateDdrDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CheckCreateDdrDBInstanceResponseBody> body{};

  CheckCreateDdrDBInstanceResponse() {}

  explicit CheckCreateDdrDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckCreateDdrDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckCreateDdrDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CheckCreateDdrDBInstanceResponse() = default;
};
class CheckDBNameAvailableRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBName{};
  shared_ptr<string> ownerAccount{};

  CheckDBNameAvailableRequest() {}

  explicit CheckDBNameAvailableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~CheckDBNameAvailableRequest() = default;
};
class CheckDBNameAvailableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CheckDBNameAvailableResponseBody() {}

  explicit CheckDBNameAvailableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckDBNameAvailableResponseBody() = default;
};
class CheckDBNameAvailableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CheckDBNameAvailableResponseBody> body{};

  CheckDBNameAvailableResponse() {}

  explicit CheckDBNameAvailableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckDBNameAvailableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckDBNameAvailableResponseBody>(model1);
      }
    }
  }


  virtual ~CheckDBNameAvailableResponse() = default;
};
class CheckInstanceExistRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};

  CheckInstanceExistRequest() {}

  explicit CheckInstanceExistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~CheckInstanceExistRequest() = default;
};
class CheckInstanceExistResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isExistInstance{};
  shared_ptr<string> requestId{};

  CheckInstanceExistResponseBody() {}

  explicit CheckInstanceExistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isExistInstance) {
      res["IsExistInstance"] = boost::any(*isExistInstance);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsExistInstance") != m.end() && !m["IsExistInstance"].empty()) {
      isExistInstance = make_shared<bool>(boost::any_cast<bool>(m["IsExistInstance"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckInstanceExistResponseBody() = default;
};
class CheckInstanceExistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CheckInstanceExistResponseBody> body{};

  CheckInstanceExistResponse() {}

  explicit CheckInstanceExistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckInstanceExistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckInstanceExistResponseBody>(model1);
      }
    }
  }


  virtual ~CheckInstanceExistResponse() = default;
};
class ClearDedicatedHostRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> failoverMode{};

  ClearDedicatedHostRequest() {}

  explicit ClearDedicatedHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (failoverMode) {
      res["FailoverMode"] = boost::any(*failoverMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("FailoverMode") != m.end() && !m["FailoverMode"].empty()) {
      failoverMode = make_shared<string>(boost::any_cast<string>(m["FailoverMode"]));
    }
  }


  virtual ~ClearDedicatedHostRequest() = default;
};
class ClearDedicatedHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> requestId{};

  ClearDedicatedHostResponseBody() {}

  explicit ClearDedicatedHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ClearDedicatedHostResponseBody() = default;
};
class ClearDedicatedHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ClearDedicatedHostResponseBody> body{};

  ClearDedicatedHostResponse() {}

  explicit ClearDedicatedHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClearDedicatedHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClearDedicatedHostResponseBody>(model1);
      }
    }
  }


  virtual ~ClearDedicatedHostResponse() = default;
};
class CloneDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<long> DBInstanceStorage{};
  shared_ptr<string> dbNames{};
  shared_ptr<string> payType{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> backupId{};
  shared_ptr<string> restoreTime{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<long> usedTime{};
  shared_ptr<string> period{};
  shared_ptr<string> category{};
  shared_ptr<string> DBInstanceStorageType{};
  shared_ptr<string> restoreTable{};
  shared_ptr<string> tableMeta{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> backupType{};

  CloneDBInstanceRequest() {}

  explicit CloneDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (DBInstanceStorage) {
      res["DBInstanceStorage"] = boost::any(*DBInstanceStorage);
    }
    if (dbNames) {
      res["DbNames"] = boost::any(*dbNames);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (restoreTime) {
      res["RestoreTime"] = boost::any(*restoreTime);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (DBInstanceStorageType) {
      res["DBInstanceStorageType"] = boost::any(*DBInstanceStorageType);
    }
    if (restoreTable) {
      res["RestoreTable"] = boost::any(*restoreTable);
    }
    if (tableMeta) {
      res["TableMeta"] = boost::any(*tableMeta);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (backupType) {
      res["BackupType"] = boost::any(*backupType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("DBInstanceStorage") != m.end() && !m["DBInstanceStorage"].empty()) {
      DBInstanceStorage = make_shared<long>(boost::any_cast<long>(m["DBInstanceStorage"]));
    }
    if (m.find("DbNames") != m.end() && !m["DbNames"].empty()) {
      dbNames = make_shared<string>(boost::any_cast<string>(m["DbNames"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("RestoreTime") != m.end() && !m["RestoreTime"].empty()) {
      restoreTime = make_shared<string>(boost::any_cast<string>(m["RestoreTime"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<long>(boost::any_cast<long>(m["UsedTime"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DBInstanceStorageType") != m.end() && !m["DBInstanceStorageType"].empty()) {
      DBInstanceStorageType = make_shared<string>(boost::any_cast<string>(m["DBInstanceStorageType"]));
    }
    if (m.find("RestoreTable") != m.end() && !m["RestoreTable"].empty()) {
      restoreTable = make_shared<string>(boost::any_cast<string>(m["RestoreTable"]));
    }
    if (m.find("TableMeta") != m.end() && !m["TableMeta"].empty()) {
      tableMeta = make_shared<string>(boost::any_cast<string>(m["TableMeta"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("BackupType") != m.end() && !m["BackupType"].empty()) {
      backupType = make_shared<string>(boost::any_cast<string>(m["BackupType"]));
    }
  }


  virtual ~CloneDBInstanceRequest() = default;
};
class CloneDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> orderId{};

  CloneDBInstanceResponseBody() {}

  explicit CloneDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~CloneDBInstanceResponseBody() = default;
};
class CloneDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CloneDBInstanceResponseBody> body{};

  CloneDBInstanceResponse() {}

  explicit CloneDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloneDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloneDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CloneDBInstanceResponse() = default;
};
class CloneParameterGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> targetRegionId{};
  shared_ptr<string> parameterGroupId{};
  shared_ptr<string> parameterGroupName{};
  shared_ptr<string> parameterGroupDesc{};

  CloneParameterGroupRequest() {}

  explicit CloneParameterGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (targetRegionId) {
      res["TargetRegionId"] = boost::any(*targetRegionId);
    }
    if (parameterGroupId) {
      res["ParameterGroupId"] = boost::any(*parameterGroupId);
    }
    if (parameterGroupName) {
      res["ParameterGroupName"] = boost::any(*parameterGroupName);
    }
    if (parameterGroupDesc) {
      res["ParameterGroupDesc"] = boost::any(*parameterGroupDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TargetRegionId") != m.end() && !m["TargetRegionId"].empty()) {
      targetRegionId = make_shared<string>(boost::any_cast<string>(m["TargetRegionId"]));
    }
    if (m.find("ParameterGroupId") != m.end() && !m["ParameterGroupId"].empty()) {
      parameterGroupId = make_shared<string>(boost::any_cast<string>(m["ParameterGroupId"]));
    }
    if (m.find("ParameterGroupName") != m.end() && !m["ParameterGroupName"].empty()) {
      parameterGroupName = make_shared<string>(boost::any_cast<string>(m["ParameterGroupName"]));
    }
    if (m.find("ParameterGroupDesc") != m.end() && !m["ParameterGroupDesc"].empty()) {
      parameterGroupDesc = make_shared<string>(boost::any_cast<string>(m["ParameterGroupDesc"]));
    }
  }


  virtual ~CloneParameterGroupRequest() = default;
};
class CloneParameterGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CloneParameterGroupResponseBody() {}

  explicit CloneParameterGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CloneParameterGroupResponseBody() = default;
};
class CloneParameterGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CloneParameterGroupResponseBody> body{};

  CloneParameterGroupResponse() {}

  explicit CloneParameterGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloneParameterGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloneParameterGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CloneParameterGroupResponse() = default;
};
class CopyDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CopyDatabaseRequest() {}

  explicit CopyDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CopyDatabaseRequest() = default;
};
class CopyDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBName{};
  shared_ptr<string> taskId{};
  shared_ptr<string> DBStatus{};

  CopyDatabaseResponseBody() {}

  explicit CopyDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (DBStatus) {
      res["DBStatus"] = boost::any(*DBStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("DBStatus") != m.end() && !m["DBStatus"].empty()) {
      DBStatus = make_shared<string>(boost::any_cast<string>(m["DBStatus"]));
    }
  }


  virtual ~CopyDatabaseResponseBody() = default;
};
class CopyDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CopyDatabaseResponseBody> body{};

  CopyDatabaseResponse() {}

  explicit CopyDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~CopyDatabaseResponse() = default;
};
class CopyDatabaseBetweenInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> targetDBInstanceId{};
  shared_ptr<string> dbNames{};
  shared_ptr<string> backupId{};
  shared_ptr<string> restoreTime{};
  shared_ptr<string> syncUserPrivilege{};

  CopyDatabaseBetweenInstancesRequest() {}

  explicit CopyDatabaseBetweenInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (targetDBInstanceId) {
      res["TargetDBInstanceId"] = boost::any(*targetDBInstanceId);
    }
    if (dbNames) {
      res["DbNames"] = boost::any(*dbNames);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (restoreTime) {
      res["RestoreTime"] = boost::any(*restoreTime);
    }
    if (syncUserPrivilege) {
      res["SyncUserPrivilege"] = boost::any(*syncUserPrivilege);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("TargetDBInstanceId") != m.end() && !m["TargetDBInstanceId"].empty()) {
      targetDBInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetDBInstanceId"]));
    }
    if (m.find("DbNames") != m.end() && !m["DbNames"].empty()) {
      dbNames = make_shared<string>(boost::any_cast<string>(m["DbNames"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("RestoreTime") != m.end() && !m["RestoreTime"].empty()) {
      restoreTime = make_shared<string>(boost::any_cast<string>(m["RestoreTime"]));
    }
    if (m.find("SyncUserPrivilege") != m.end() && !m["SyncUserPrivilege"].empty()) {
      syncUserPrivilege = make_shared<string>(boost::any_cast<string>(m["SyncUserPrivilege"]));
    }
  }


  virtual ~CopyDatabaseBetweenInstancesRequest() = default;
};
class CopyDatabaseBetweenInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};

  CopyDatabaseBetweenInstancesResponseBody() {}

  explicit CopyDatabaseBetweenInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopyDatabaseBetweenInstancesResponseBody() = default;
};
class CopyDatabaseBetweenInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CopyDatabaseBetweenInstancesResponseBody> body{};

  CopyDatabaseBetweenInstancesResponse() {}

  explicit CopyDatabaseBetweenInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyDatabaseBetweenInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyDatabaseBetweenInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~CopyDatabaseBetweenInstancesResponse() = default;
};
class CreateAccountRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> accountPassword{};
  shared_ptr<string> accountDescription{};
  shared_ptr<string> accountType{};
  shared_ptr<string> ownerAccount{};

  CreateAccountRequest() {}

  explicit CreateAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountPassword) {
      res["AccountPassword"] = boost::any(*accountPassword);
    }
    if (accountDescription) {
      res["AccountDescription"] = boost::any(*accountDescription);
    }
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountPassword") != m.end() && !m["AccountPassword"].empty()) {
      accountPassword = make_shared<string>(boost::any_cast<string>(m["AccountPassword"]));
    }
    if (m.find("AccountDescription") != m.end() && !m["AccountDescription"].empty()) {
      accountDescription = make_shared<string>(boost::any_cast<string>(m["AccountDescription"]));
    }
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~CreateAccountRequest() = default;
};
class CreateAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateAccountResponseBody() {}

  explicit CreateAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAccountResponseBody() = default;
};
class CreateAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateAccountResponseBody> body{};

  CreateAccountResponse() {}

  explicit CreateAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAccountResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAccountResponse() = default;
};
class CreateBackupRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBName{};
  shared_ptr<string> backupStrategy{};
  shared_ptr<string> backupMethod{};
  shared_ptr<string> backupType{};

  CreateBackupRequest() {}

  explicit CreateBackupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (backupStrategy) {
      res["BackupStrategy"] = boost::any(*backupStrategy);
    }
    if (backupMethod) {
      res["BackupMethod"] = boost::any(*backupMethod);
    }
    if (backupType) {
      res["BackupType"] = boost::any(*backupType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("BackupStrategy") != m.end() && !m["BackupStrategy"].empty()) {
      backupStrategy = make_shared<string>(boost::any_cast<string>(m["BackupStrategy"]));
    }
    if (m.find("BackupMethod") != m.end() && !m["BackupMethod"].empty()) {
      backupMethod = make_shared<string>(boost::any_cast<string>(m["BackupMethod"]));
    }
    if (m.find("BackupType") != m.end() && !m["BackupType"].empty()) {
      backupType = make_shared<string>(boost::any_cast<string>(m["BackupType"]));
    }
  }


  virtual ~CreateBackupRequest() = default;
};
class CreateBackupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> backupJobId{};
  shared_ptr<string> requestId{};

  CreateBackupResponseBody() {}

  explicit CreateBackupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupJobId) {
      res["BackupJobId"] = boost::any(*backupJobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupJobId") != m.end() && !m["BackupJobId"].empty()) {
      backupJobId = make_shared<string>(boost::any_cast<string>(m["BackupJobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBackupResponseBody() = default;
};
class CreateBackupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateBackupResponseBody> body{};

  CreateBackupResponse() {}

  explicit CreateBackupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBackupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBackupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBackupResponse() = default;
};
class CreateDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBName{};
  shared_ptr<string> characterSetName{};
  shared_ptr<string> DBDescription{};
  shared_ptr<string> ownerAccount{};

  CreateDatabaseRequest() {}

  explicit CreateDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (characterSetName) {
      res["CharacterSetName"] = boost::any(*characterSetName);
    }
    if (DBDescription) {
      res["DBDescription"] = boost::any(*DBDescription);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("CharacterSetName") != m.end() && !m["CharacterSetName"].empty()) {
      characterSetName = make_shared<string>(boost::any_cast<string>(m["CharacterSetName"]));
    }
    if (m.find("DBDescription") != m.end() && !m["DBDescription"].empty()) {
      DBDescription = make_shared<string>(boost::any_cast<string>(m["DBDescription"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~CreateDatabaseRequest() = default;
};
class CreateDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateDatabaseResponseBody() {}

  explicit CreateDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDatabaseResponseBody() = default;
};
class CreateDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDatabaseResponseBody> body{};

  CreateDatabaseResponse() {}

  explicit CreateDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDatabaseResponse() = default;
};
class CreateDBInstanceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDBInstanceRequestTag() {}

  explicit CreateDBInstanceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDBInstanceRequestTag() = default;
};
class CreateDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> engine{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<long> DBInstanceStorage{};
  shared_ptr<string> systemDBCharset{};
  shared_ptr<string> DBInstanceNetType{};
  shared_ptr<string> DBInstanceDescription{};
  shared_ptr<string> securityIPList{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> payType{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> zoneIdSlave1{};
  shared_ptr<string> zoneIdSlave2{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> connectionMode{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> usedTime{};
  shared_ptr<string> period{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> DBInstanceStorageType{};
  shared_ptr<string> businessInfo{};
  shared_ptr<string> encryptionKey{};
  shared_ptr<string> roleARN{};
  shared_ptr<string> autoRenew{};
  shared_ptr<string> category{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> targetDedicatedHostIdForMaster{};
  shared_ptr<string> targetDedicatedHostIdForSlave{};
  shared_ptr<string> targetDedicatedHostIdForLog{};
  shared_ptr<string> DBParamGroupId{};
  shared_ptr<string> DBTimeZone{};
  shared_ptr<string> DBIsIgnoreCase{};
  shared_ptr<string> targetMinorVersion{};
  shared_ptr<string> storageAutoScale{};
  shared_ptr<long> storageThreshold{};
  shared_ptr<long> storageUpperBound{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> userBackupId{};
  shared_ptr<long> amount{};
  shared_ptr<string> createStrategy{};
  shared_ptr<vector<CreateDBInstanceRequestTag>> tag{};

  CreateDBInstanceRequest() {}

  explicit CreateDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (DBInstanceStorage) {
      res["DBInstanceStorage"] = boost::any(*DBInstanceStorage);
    }
    if (systemDBCharset) {
      res["SystemDBCharset"] = boost::any(*systemDBCharset);
    }
    if (DBInstanceNetType) {
      res["DBInstanceNetType"] = boost::any(*DBInstanceNetType);
    }
    if (DBInstanceDescription) {
      res["DBInstanceDescription"] = boost::any(*DBInstanceDescription);
    }
    if (securityIPList) {
      res["SecurityIPList"] = boost::any(*securityIPList);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (zoneIdSlave1) {
      res["ZoneIdSlave1"] = boost::any(*zoneIdSlave1);
    }
    if (zoneIdSlave2) {
      res["ZoneIdSlave2"] = boost::any(*zoneIdSlave2);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (connectionMode) {
      res["ConnectionMode"] = boost::any(*connectionMode);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (DBInstanceStorageType) {
      res["DBInstanceStorageType"] = boost::any(*DBInstanceStorageType);
    }
    if (businessInfo) {
      res["BusinessInfo"] = boost::any(*businessInfo);
    }
    if (encryptionKey) {
      res["EncryptionKey"] = boost::any(*encryptionKey);
    }
    if (roleARN) {
      res["RoleARN"] = boost::any(*roleARN);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (targetDedicatedHostIdForMaster) {
      res["TargetDedicatedHostIdForMaster"] = boost::any(*targetDedicatedHostIdForMaster);
    }
    if (targetDedicatedHostIdForSlave) {
      res["TargetDedicatedHostIdForSlave"] = boost::any(*targetDedicatedHostIdForSlave);
    }
    if (targetDedicatedHostIdForLog) {
      res["TargetDedicatedHostIdForLog"] = boost::any(*targetDedicatedHostIdForLog);
    }
    if (DBParamGroupId) {
      res["DBParamGroupId"] = boost::any(*DBParamGroupId);
    }
    if (DBTimeZone) {
      res["DBTimeZone"] = boost::any(*DBTimeZone);
    }
    if (DBIsIgnoreCase) {
      res["DBIsIgnoreCase"] = boost::any(*DBIsIgnoreCase);
    }
    if (targetMinorVersion) {
      res["TargetMinorVersion"] = boost::any(*targetMinorVersion);
    }
    if (storageAutoScale) {
      res["StorageAutoScale"] = boost::any(*storageAutoScale);
    }
    if (storageThreshold) {
      res["StorageThreshold"] = boost::any(*storageThreshold);
    }
    if (storageUpperBound) {
      res["StorageUpperBound"] = boost::any(*storageUpperBound);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (userBackupId) {
      res["UserBackupId"] = boost::any(*userBackupId);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (createStrategy) {
      res["CreateStrategy"] = boost::any(*createStrategy);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("DBInstanceStorage") != m.end() && !m["DBInstanceStorage"].empty()) {
      DBInstanceStorage = make_shared<long>(boost::any_cast<long>(m["DBInstanceStorage"]));
    }
    if (m.find("SystemDBCharset") != m.end() && !m["SystemDBCharset"].empty()) {
      systemDBCharset = make_shared<string>(boost::any_cast<string>(m["SystemDBCharset"]));
    }
    if (m.find("DBInstanceNetType") != m.end() && !m["DBInstanceNetType"].empty()) {
      DBInstanceNetType = make_shared<string>(boost::any_cast<string>(m["DBInstanceNetType"]));
    }
    if (m.find("DBInstanceDescription") != m.end() && !m["DBInstanceDescription"].empty()) {
      DBInstanceDescription = make_shared<string>(boost::any_cast<string>(m["DBInstanceDescription"]));
    }
    if (m.find("SecurityIPList") != m.end() && !m["SecurityIPList"].empty()) {
      securityIPList = make_shared<string>(boost::any_cast<string>(m["SecurityIPList"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ZoneIdSlave1") != m.end() && !m["ZoneIdSlave1"].empty()) {
      zoneIdSlave1 = make_shared<string>(boost::any_cast<string>(m["ZoneIdSlave1"]));
    }
    if (m.find("ZoneIdSlave2") != m.end() && !m["ZoneIdSlave2"].empty()) {
      zoneIdSlave2 = make_shared<string>(boost::any_cast<string>(m["ZoneIdSlave2"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("ConnectionMode") != m.end() && !m["ConnectionMode"].empty()) {
      connectionMode = make_shared<string>(boost::any_cast<string>(m["ConnectionMode"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<string>(boost::any_cast<string>(m["UsedTime"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("DBInstanceStorageType") != m.end() && !m["DBInstanceStorageType"].empty()) {
      DBInstanceStorageType = make_shared<string>(boost::any_cast<string>(m["DBInstanceStorageType"]));
    }
    if (m.find("BusinessInfo") != m.end() && !m["BusinessInfo"].empty()) {
      businessInfo = make_shared<string>(boost::any_cast<string>(m["BusinessInfo"]));
    }
    if (m.find("EncryptionKey") != m.end() && !m["EncryptionKey"].empty()) {
      encryptionKey = make_shared<string>(boost::any_cast<string>(m["EncryptionKey"]));
    }
    if (m.find("RoleARN") != m.end() && !m["RoleARN"].empty()) {
      roleARN = make_shared<string>(boost::any_cast<string>(m["RoleARN"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<string>(boost::any_cast<string>(m["AutoRenew"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("TargetDedicatedHostIdForMaster") != m.end() && !m["TargetDedicatedHostIdForMaster"].empty()) {
      targetDedicatedHostIdForMaster = make_shared<string>(boost::any_cast<string>(m["TargetDedicatedHostIdForMaster"]));
    }
    if (m.find("TargetDedicatedHostIdForSlave") != m.end() && !m["TargetDedicatedHostIdForSlave"].empty()) {
      targetDedicatedHostIdForSlave = make_shared<string>(boost::any_cast<string>(m["TargetDedicatedHostIdForSlave"]));
    }
    if (m.find("TargetDedicatedHostIdForLog") != m.end() && !m["TargetDedicatedHostIdForLog"].empty()) {
      targetDedicatedHostIdForLog = make_shared<string>(boost::any_cast<string>(m["TargetDedicatedHostIdForLog"]));
    }
    if (m.find("DBParamGroupId") != m.end() && !m["DBParamGroupId"].empty()) {
      DBParamGroupId = make_shared<string>(boost::any_cast<string>(m["DBParamGroupId"]));
    }
    if (m.find("DBTimeZone") != m.end() && !m["DBTimeZone"].empty()) {
      DBTimeZone = make_shared<string>(boost::any_cast<string>(m["DBTimeZone"]));
    }
    if (m.find("DBIsIgnoreCase") != m.end() && !m["DBIsIgnoreCase"].empty()) {
      DBIsIgnoreCase = make_shared<string>(boost::any_cast<string>(m["DBIsIgnoreCase"]));
    }
    if (m.find("TargetMinorVersion") != m.end() && !m["TargetMinorVersion"].empty()) {
      targetMinorVersion = make_shared<string>(boost::any_cast<string>(m["TargetMinorVersion"]));
    }
    if (m.find("StorageAutoScale") != m.end() && !m["StorageAutoScale"].empty()) {
      storageAutoScale = make_shared<string>(boost::any_cast<string>(m["StorageAutoScale"]));
    }
    if (m.find("StorageThreshold") != m.end() && !m["StorageThreshold"].empty()) {
      storageThreshold = make_shared<long>(boost::any_cast<long>(m["StorageThreshold"]));
    }
    if (m.find("StorageUpperBound") != m.end() && !m["StorageUpperBound"].empty()) {
      storageUpperBound = make_shared<long>(boost::any_cast<long>(m["StorageUpperBound"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("UserBackupId") != m.end() && !m["UserBackupId"].empty()) {
      userBackupId = make_shared<string>(boost::any_cast<string>(m["UserBackupId"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("CreateStrategy") != m.end() && !m["CreateStrategy"].empty()) {
      createStrategy = make_shared<string>(boost::any_cast<string>(m["CreateStrategy"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDBInstanceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDBInstanceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDBInstanceRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateDBInstanceRequest() = default;
};
class CreateDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> dryRunResult{};
  shared_ptr<bool> tagResult{};
  shared_ptr<string> requestId{};
  shared_ptr<string> connectionString{};
  shared_ptr<string> message{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> port{};
  shared_ptr<string> taskId{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> orderId{};

  CreateDBInstanceResponseBody() {}

  explicit CreateDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRunResult) {
      res["DryRunResult"] = boost::any(*dryRunResult);
    }
    if (tagResult) {
      res["TagResult"] = boost::any(*tagResult);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (connectionString) {
      res["ConnectionString"] = boost::any(*connectionString);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRunResult") != m.end() && !m["DryRunResult"].empty()) {
      dryRunResult = make_shared<bool>(boost::any_cast<bool>(m["DryRunResult"]));
    }
    if (m.find("TagResult") != m.end() && !m["TagResult"].empty()) {
      tagResult = make_shared<bool>(boost::any_cast<bool>(m["TagResult"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ConnectionString") != m.end() && !m["ConnectionString"].empty()) {
      connectionString = make_shared<string>(boost::any_cast<string>(m["ConnectionString"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~CreateDBInstanceResponseBody() = default;
};
class CreateDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDBInstanceResponseBody> body{};

  CreateDBInstanceResponse() {}

  explicit CreateDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDBInstanceResponse() = default;
};
class CreateDBProxyEndpointAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBProxyEndpointId{};
  shared_ptr<string> connectionStringPrefix{};
  shared_ptr<string> DBProxyNewConnectStringPort{};
  shared_ptr<string> DBProxyConnectStringNetType{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> vSwitchId{};

  CreateDBProxyEndpointAddressRequest() {}

  explicit CreateDBProxyEndpointAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBProxyEndpointId) {
      res["DBProxyEndpointId"] = boost::any(*DBProxyEndpointId);
    }
    if (connectionStringPrefix) {
      res["ConnectionStringPrefix"] = boost::any(*connectionStringPrefix);
    }
    if (DBProxyNewConnectStringPort) {
      res["DBProxyNewConnectStringPort"] = boost::any(*DBProxyNewConnectStringPort);
    }
    if (DBProxyConnectStringNetType) {
      res["DBProxyConnectStringNetType"] = boost::any(*DBProxyConnectStringNetType);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBProxyEndpointId") != m.end() && !m["DBProxyEndpointId"].empty()) {
      DBProxyEndpointId = make_shared<string>(boost::any_cast<string>(m["DBProxyEndpointId"]));
    }
    if (m.find("ConnectionStringPrefix") != m.end() && !m["ConnectionStringPrefix"].empty()) {
      connectionStringPrefix = make_shared<string>(boost::any_cast<string>(m["ConnectionStringPrefix"]));
    }
    if (m.find("DBProxyNewConnectStringPort") != m.end() && !m["DBProxyNewConnectStringPort"].empty()) {
      DBProxyNewConnectStringPort = make_shared<string>(boost::any_cast<string>(m["DBProxyNewConnectStringPort"]));
    }
    if (m.find("DBProxyConnectStringNetType") != m.end() && !m["DBProxyConnectStringNetType"].empty()) {
      DBProxyConnectStringNetType = make_shared<string>(boost::any_cast<string>(m["DBProxyConnectStringNetType"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateDBProxyEndpointAddressRequest() = default;
};
class CreateDBProxyEndpointAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateDBProxyEndpointAddressResponseBody() {}

  explicit CreateDBProxyEndpointAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDBProxyEndpointAddressResponseBody() = default;
};
class CreateDBProxyEndpointAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDBProxyEndpointAddressResponseBody> body{};

  CreateDBProxyEndpointAddressResponse() {}

  explicit CreateDBProxyEndpointAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDBProxyEndpointAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDBProxyEndpointAddressResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDBProxyEndpointAddressResponse() = default;
};
class CreateDdrInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> engine{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<long> DBInstanceStorage{};
  shared_ptr<string> systemDBCharset{};
  shared_ptr<string> DBInstanceNetType{};
  shared_ptr<string> DBInstanceDescription{};
  shared_ptr<string> securityIPList{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> payType{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> connectionMode{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> usedTime{};
  shared_ptr<string> period{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> restoreType{};
  shared_ptr<string> backupSetId{};
  shared_ptr<string> restoreTime{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> sourceDBInstanceName{};
  shared_ptr<string> DBInstanceStorageType{};
  shared_ptr<string> binlogName{};
  shared_ptr<string> binlogPosition{};
  shared_ptr<string> binlogRole{};

  CreateDdrInstanceRequest() {}

  explicit CreateDdrInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (DBInstanceStorage) {
      res["DBInstanceStorage"] = boost::any(*DBInstanceStorage);
    }
    if (systemDBCharset) {
      res["SystemDBCharset"] = boost::any(*systemDBCharset);
    }
    if (DBInstanceNetType) {
      res["DBInstanceNetType"] = boost::any(*DBInstanceNetType);
    }
    if (DBInstanceDescription) {
      res["DBInstanceDescription"] = boost::any(*DBInstanceDescription);
    }
    if (securityIPList) {
      res["SecurityIPList"] = boost::any(*securityIPList);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (connectionMode) {
      res["ConnectionMode"] = boost::any(*connectionMode);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (restoreType) {
      res["RestoreType"] = boost::any(*restoreType);
    }
    if (backupSetId) {
      res["BackupSetId"] = boost::any(*backupSetId);
    }
    if (restoreTime) {
      res["RestoreTime"] = boost::any(*restoreTime);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (sourceDBInstanceName) {
      res["SourceDBInstanceName"] = boost::any(*sourceDBInstanceName);
    }
    if (DBInstanceStorageType) {
      res["DBInstanceStorageType"] = boost::any(*DBInstanceStorageType);
    }
    if (binlogName) {
      res["BinlogName"] = boost::any(*binlogName);
    }
    if (binlogPosition) {
      res["BinlogPosition"] = boost::any(*binlogPosition);
    }
    if (binlogRole) {
      res["BinlogRole"] = boost::any(*binlogRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("DBInstanceStorage") != m.end() && !m["DBInstanceStorage"].empty()) {
      DBInstanceStorage = make_shared<long>(boost::any_cast<long>(m["DBInstanceStorage"]));
    }
    if (m.find("SystemDBCharset") != m.end() && !m["SystemDBCharset"].empty()) {
      systemDBCharset = make_shared<string>(boost::any_cast<string>(m["SystemDBCharset"]));
    }
    if (m.find("DBInstanceNetType") != m.end() && !m["DBInstanceNetType"].empty()) {
      DBInstanceNetType = make_shared<string>(boost::any_cast<string>(m["DBInstanceNetType"]));
    }
    if (m.find("DBInstanceDescription") != m.end() && !m["DBInstanceDescription"].empty()) {
      DBInstanceDescription = make_shared<string>(boost::any_cast<string>(m["DBInstanceDescription"]));
    }
    if (m.find("SecurityIPList") != m.end() && !m["SecurityIPList"].empty()) {
      securityIPList = make_shared<string>(boost::any_cast<string>(m["SecurityIPList"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("ConnectionMode") != m.end() && !m["ConnectionMode"].empty()) {
      connectionMode = make_shared<string>(boost::any_cast<string>(m["ConnectionMode"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<string>(boost::any_cast<string>(m["UsedTime"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RestoreType") != m.end() && !m["RestoreType"].empty()) {
      restoreType = make_shared<string>(boost::any_cast<string>(m["RestoreType"]));
    }
    if (m.find("BackupSetId") != m.end() && !m["BackupSetId"].empty()) {
      backupSetId = make_shared<string>(boost::any_cast<string>(m["BackupSetId"]));
    }
    if (m.find("RestoreTime") != m.end() && !m["RestoreTime"].empty()) {
      restoreTime = make_shared<string>(boost::any_cast<string>(m["RestoreTime"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("SourceDBInstanceName") != m.end() && !m["SourceDBInstanceName"].empty()) {
      sourceDBInstanceName = make_shared<string>(boost::any_cast<string>(m["SourceDBInstanceName"]));
    }
    if (m.find("DBInstanceStorageType") != m.end() && !m["DBInstanceStorageType"].empty()) {
      DBInstanceStorageType = make_shared<string>(boost::any_cast<string>(m["DBInstanceStorageType"]));
    }
    if (m.find("BinlogName") != m.end() && !m["BinlogName"].empty()) {
      binlogName = make_shared<string>(boost::any_cast<string>(m["BinlogName"]));
    }
    if (m.find("BinlogPosition") != m.end() && !m["BinlogPosition"].empty()) {
      binlogPosition = make_shared<string>(boost::any_cast<string>(m["BinlogPosition"]));
    }
    if (m.find("BinlogRole") != m.end() && !m["BinlogRole"].empty()) {
      binlogRole = make_shared<string>(boost::any_cast<string>(m["BinlogRole"]));
    }
  }


  virtual ~CreateDdrInstanceRequest() = default;
};
class CreateDdrInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> port{};
  shared_ptr<string> connectionString{};
  shared_ptr<string> orderId{};

  CreateDdrInstanceResponseBody() {}

  explicit CreateDdrInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (connectionString) {
      res["ConnectionString"] = boost::any(*connectionString);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ConnectionString") != m.end() && !m["ConnectionString"].empty()) {
      connectionString = make_shared<string>(boost::any_cast<string>(m["ConnectionString"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~CreateDdrInstanceResponseBody() = default;
};
class CreateDdrInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDdrInstanceResponseBody> body{};

  CreateDdrInstanceResponse() {}

  explicit CreateDdrInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDdrInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDdrInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDdrInstanceResponse() = default;
};
class CreateDedicatedHostRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> hostClass{};
  shared_ptr<string> payType{};
  shared_ptr<string> period{};
  shared_ptr<string> usedTime{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> autoRenew{};

  CreateDedicatedHostRequest() {}

  explicit CreateDedicatedHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (hostClass) {
      res["HostClass"] = boost::any(*hostClass);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("HostClass") != m.end() && !m["HostClass"].empty()) {
      hostClass = make_shared<string>(boost::any_cast<string>(m["HostClass"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<string>(boost::any_cast<string>(m["UsedTime"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<string>(boost::any_cast<string>(m["AutoRenew"]));
    }
  }


  virtual ~CreateDedicatedHostRequest() = default;
};
class CreateDedicatedHostResponseBodyDedicateHostListDedicateHostList : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostId{};

  CreateDedicatedHostResponseBodyDedicateHostListDedicateHostList() {}

  explicit CreateDedicatedHostResponseBodyDedicateHostListDedicateHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
  }


  virtual ~CreateDedicatedHostResponseBodyDedicateHostListDedicateHostList() = default;
};
class CreateDedicatedHostResponseBodyDedicateHostList : public Darabonba::Model {
public:
  shared_ptr<vector<CreateDedicatedHostResponseBodyDedicateHostListDedicateHostList>> dedicateHostList{};

  CreateDedicatedHostResponseBodyDedicateHostList() {}

  explicit CreateDedicatedHostResponseBodyDedicateHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicateHostList) {
      vector<boost::any> temp1;
      for(auto item1:*dedicateHostList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicateHostList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicateHostList") != m.end() && !m["DedicateHostList"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicateHostList"].type()) {
        vector<CreateDedicatedHostResponseBodyDedicateHostListDedicateHostList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicateHostList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDedicatedHostResponseBodyDedicateHostListDedicateHostList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicateHostList = make_shared<vector<CreateDedicatedHostResponseBodyDedicateHostListDedicateHostList>>(expect1);
      }
    }
  }


  virtual ~CreateDedicatedHostResponseBodyDedicateHostList() = default;
};
class CreateDedicatedHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateDedicatedHostResponseBodyDedicateHostList> dedicateHostList{};
  shared_ptr<long> orderId{};

  CreateDedicatedHostResponseBody() {}

  explicit CreateDedicatedHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dedicateHostList) {
      res["DedicateHostList"] = dedicateHostList ? boost::any(dedicateHostList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DedicateHostList") != m.end() && !m["DedicateHostList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicateHostList"].type()) {
        CreateDedicatedHostResponseBodyDedicateHostList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicateHostList"]));
        dedicateHostList = make_shared<CreateDedicatedHostResponseBodyDedicateHostList>(model1);
      }
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
  }


  virtual ~CreateDedicatedHostResponseBody() = default;
};
class CreateDedicatedHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDedicatedHostResponseBody> body{};

  CreateDedicatedHostResponse() {}

  explicit CreateDedicatedHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDedicatedHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDedicatedHostResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDedicatedHostResponse() = default;
};
class CreateDedicatedHostAccountRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> accountPassword{};
  shared_ptr<string> regionId{};

  CreateDedicatedHostAccountRequest() {}

  explicit CreateDedicatedHostAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountPassword) {
      res["AccountPassword"] = boost::any(*accountPassword);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountPassword") != m.end() && !m["AccountPassword"].empty()) {
      accountPassword = make_shared<string>(boost::any_cast<string>(m["AccountPassword"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateDedicatedHostAccountRequest() = default;
};
class CreateDedicatedHostAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateDedicatedHostAccountResponseBody() {}

  explicit CreateDedicatedHostAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDedicatedHostAccountResponseBody() = default;
};
class CreateDedicatedHostAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDedicatedHostAccountResponseBody> body{};

  CreateDedicatedHostAccountResponse() {}

  explicit CreateDedicatedHostAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDedicatedHostAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDedicatedHostAccountResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDedicatedHostAccountResponse() = default;
};
class CreateDedicatedHostGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> engine{};
  shared_ptr<long> cpuAllocationRatio{};
  shared_ptr<long> memAllocationRatio{};
  shared_ptr<long> diskAllocationRatio{};
  shared_ptr<string> allocationPolicy{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> hostReplacePolicy{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> openPermission{};

  CreateDedicatedHostGroupRequest() {}

  explicit CreateDedicatedHostGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (cpuAllocationRatio) {
      res["CpuAllocationRatio"] = boost::any(*cpuAllocationRatio);
    }
    if (memAllocationRatio) {
      res["MemAllocationRatio"] = boost::any(*memAllocationRatio);
    }
    if (diskAllocationRatio) {
      res["DiskAllocationRatio"] = boost::any(*diskAllocationRatio);
    }
    if (allocationPolicy) {
      res["AllocationPolicy"] = boost::any(*allocationPolicy);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (hostReplacePolicy) {
      res["HostReplacePolicy"] = boost::any(*hostReplacePolicy);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (openPermission) {
      res["OpenPermission"] = boost::any(*openPermission);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("CpuAllocationRatio") != m.end() && !m["CpuAllocationRatio"].empty()) {
      cpuAllocationRatio = make_shared<long>(boost::any_cast<long>(m["CpuAllocationRatio"]));
    }
    if (m.find("MemAllocationRatio") != m.end() && !m["MemAllocationRatio"].empty()) {
      memAllocationRatio = make_shared<long>(boost::any_cast<long>(m["MemAllocationRatio"]));
    }
    if (m.find("DiskAllocationRatio") != m.end() && !m["DiskAllocationRatio"].empty()) {
      diskAllocationRatio = make_shared<long>(boost::any_cast<long>(m["DiskAllocationRatio"]));
    }
    if (m.find("AllocationPolicy") != m.end() && !m["AllocationPolicy"].empty()) {
      allocationPolicy = make_shared<string>(boost::any_cast<string>(m["AllocationPolicy"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("HostReplacePolicy") != m.end() && !m["HostReplacePolicy"].empty()) {
      hostReplacePolicy = make_shared<string>(boost::any_cast<string>(m["HostReplacePolicy"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OpenPermission") != m.end() && !m["OpenPermission"].empty()) {
      openPermission = make_shared<long>(boost::any_cast<long>(m["OpenPermission"]));
    }
  }


  virtual ~CreateDedicatedHostGroupRequest() = default;
};
class CreateDedicatedHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> dedicatedHostGroupId{};

  CreateDedicatedHostGroupResponseBody() {}

  explicit CreateDedicatedHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
  }


  virtual ~CreateDedicatedHostGroupResponseBody() = default;
};
class CreateDedicatedHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDedicatedHostGroupResponseBody> body{};

  CreateDedicatedHostGroupResponse() {}

  explicit CreateDedicatedHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDedicatedHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDedicatedHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDedicatedHostGroupResponse() = default;
};
class CreateDedicatedHostUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> dedicatedHostName{};
  shared_ptr<string> userName{};
  shared_ptr<string> userPassword{};
  shared_ptr<string> regionId{};

  CreateDedicatedHostUserRequest() {}

  explicit CreateDedicatedHostUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (dedicatedHostName) {
      res["DedicatedHostName"] = boost::any(*dedicatedHostName);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userPassword) {
      res["UserPassword"] = boost::any(*userPassword);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DedicatedHostName") != m.end() && !m["DedicatedHostName"].empty()) {
      dedicatedHostName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostName"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserPassword") != m.end() && !m["UserPassword"].empty()) {
      userPassword = make_shared<string>(boost::any_cast<string>(m["UserPassword"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateDedicatedHostUserRequest() = default;
};
class CreateDedicatedHostUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateDedicatedHostUserResponseBody() {}

  explicit CreateDedicatedHostUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDedicatedHostUserResponseBody() = default;
};
class CreateDedicatedHostUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDedicatedHostUserResponseBody> body{};

  CreateDedicatedHostUserResponse() {}

  explicit CreateDedicatedHostUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDedicatedHostUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDedicatedHostUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDedicatedHostUserResponse() = default;
};
class CreateDiagnosticReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  CreateDiagnosticReportRequest() {}

  explicit CreateDiagnosticReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~CreateDiagnosticReportRequest() = default;
};
class CreateDiagnosticReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> reportId{};
  shared_ptr<string> requestId{};

  CreateDiagnosticReportResponseBody() {}

  explicit CreateDiagnosticReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDiagnosticReportResponseBody() = default;
};
class CreateDiagnosticReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDiagnosticReportResponseBody> body{};

  CreateDiagnosticReportResponse() {}

  explicit CreateDiagnosticReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDiagnosticReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDiagnosticReportResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDiagnosticReportResponse() = default;
};
class CreateMigrateTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBName{};
  shared_ptr<string> backupMode{};
  shared_ptr<string> isOnlineDB{};
  shared_ptr<string> checkDBMode{};
  shared_ptr<string> ossObjectPositions{};
  shared_ptr<string> OSSUrls{};
  shared_ptr<string> migrateTaskId{};

  CreateMigrateTaskRequest() {}

  explicit CreateMigrateTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (backupMode) {
      res["BackupMode"] = boost::any(*backupMode);
    }
    if (isOnlineDB) {
      res["IsOnlineDB"] = boost::any(*isOnlineDB);
    }
    if (checkDBMode) {
      res["CheckDBMode"] = boost::any(*checkDBMode);
    }
    if (ossObjectPositions) {
      res["OssObjectPositions"] = boost::any(*ossObjectPositions);
    }
    if (OSSUrls) {
      res["OSSUrls"] = boost::any(*OSSUrls);
    }
    if (migrateTaskId) {
      res["MigrateTaskId"] = boost::any(*migrateTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("BackupMode") != m.end() && !m["BackupMode"].empty()) {
      backupMode = make_shared<string>(boost::any_cast<string>(m["BackupMode"]));
    }
    if (m.find("IsOnlineDB") != m.end() && !m["IsOnlineDB"].empty()) {
      isOnlineDB = make_shared<string>(boost::any_cast<string>(m["IsOnlineDB"]));
    }
    if (m.find("CheckDBMode") != m.end() && !m["CheckDBMode"].empty()) {
      checkDBMode = make_shared<string>(boost::any_cast<string>(m["CheckDBMode"]));
    }
    if (m.find("OssObjectPositions") != m.end() && !m["OssObjectPositions"].empty()) {
      ossObjectPositions = make_shared<string>(boost::any_cast<string>(m["OssObjectPositions"]));
    }
    if (m.find("OSSUrls") != m.end() && !m["OSSUrls"].empty()) {
      OSSUrls = make_shared<string>(boost::any_cast<string>(m["OSSUrls"]));
    }
    if (m.find("MigrateTaskId") != m.end() && !m["MigrateTaskId"].empty()) {
      migrateTaskId = make_shared<string>(boost::any_cast<string>(m["MigrateTaskId"]));
    }
  }


  virtual ~CreateMigrateTaskRequest() = default;
};
class CreateMigrateTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> DBName{};
  shared_ptr<string> backupMode{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> migrateTaskId{};
  shared_ptr<string> taskId{};

  CreateMigrateTaskResponseBody() {}

  explicit CreateMigrateTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (backupMode) {
      res["BackupMode"] = boost::any(*backupMode);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (migrateTaskId) {
      res["MigrateTaskId"] = boost::any(*migrateTaskId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("BackupMode") != m.end() && !m["BackupMode"].empty()) {
      backupMode = make_shared<string>(boost::any_cast<string>(m["BackupMode"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("MigrateTaskId") != m.end() && !m["MigrateTaskId"].empty()) {
      migrateTaskId = make_shared<string>(boost::any_cast<string>(m["MigrateTaskId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateMigrateTaskResponseBody() = default;
};
class CreateMigrateTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateMigrateTaskResponseBody> body{};

  CreateMigrateTaskResponse() {}

  explicit CreateMigrateTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMigrateTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMigrateTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMigrateTaskResponse() = default;
};
class CreateMigrateTaskForSQLServerRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBName{};
  shared_ptr<string> taskType{};
  shared_ptr<string> isOnlineDB{};
  shared_ptr<string> OSSUrls{};

  CreateMigrateTaskForSQLServerRequest() {}

  explicit CreateMigrateTaskForSQLServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (isOnlineDB) {
      res["IsOnlineDB"] = boost::any(*isOnlineDB);
    }
    if (OSSUrls) {
      res["OSSUrls"] = boost::any(*OSSUrls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("IsOnlineDB") != m.end() && !m["IsOnlineDB"].empty()) {
      isOnlineDB = make_shared<string>(boost::any_cast<string>(m["IsOnlineDB"]));
    }
    if (m.find("OSSUrls") != m.end() && !m["OSSUrls"].empty()) {
      OSSUrls = make_shared<string>(boost::any_cast<string>(m["OSSUrls"]));
    }
  }


  virtual ~CreateMigrateTaskForSQLServerRequest() = default;
};
class CreateMigrateTaskForSQLServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> migrateIaskId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> DBInstanceName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> DBName{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> taskId{};

  CreateMigrateTaskForSQLServerResponseBody() {}

  explicit CreateMigrateTaskForSQLServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrateIaskId) {
      res["MigrateIaskId"] = boost::any(*migrateIaskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrateIaskId") != m.end() && !m["MigrateIaskId"].empty()) {
      migrateIaskId = make_shared<string>(boost::any_cast<string>(m["MigrateIaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateMigrateTaskForSQLServerResponseBody() = default;
};
class CreateMigrateTaskForSQLServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateMigrateTaskForSQLServerResponseBody> body{};

  CreateMigrateTaskForSQLServerResponse() {}

  explicit CreateMigrateTaskForSQLServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMigrateTaskForSQLServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMigrateTaskForSQLServerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMigrateTaskForSQLServerResponse() = default;
};
class CreateOnlineDatabaseTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBName{};
  shared_ptr<string> migrateTaskId{};
  shared_ptr<string> checkDBMode{};
  shared_ptr<string> ownerAccount{};

  CreateOnlineDatabaseTaskRequest() {}

  explicit CreateOnlineDatabaseTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (migrateTaskId) {
      res["MigrateTaskId"] = boost::any(*migrateTaskId);
    }
    if (checkDBMode) {
      res["CheckDBMode"] = boost::any(*checkDBMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("MigrateTaskId") != m.end() && !m["MigrateTaskId"].empty()) {
      migrateTaskId = make_shared<string>(boost::any_cast<string>(m["MigrateTaskId"]));
    }
    if (m.find("CheckDBMode") != m.end() && !m["CheckDBMode"].empty()) {
      checkDBMode = make_shared<string>(boost::any_cast<string>(m["CheckDBMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~CreateOnlineDatabaseTaskRequest() = default;
};
class CreateOnlineDatabaseTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateOnlineDatabaseTaskResponseBody() {}

  explicit CreateOnlineDatabaseTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOnlineDatabaseTaskResponseBody() = default;
};
class CreateOnlineDatabaseTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateOnlineDatabaseTaskResponseBody> body{};

  CreateOnlineDatabaseTaskResponse() {}

  explicit CreateOnlineDatabaseTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOnlineDatabaseTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOnlineDatabaseTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOnlineDatabaseTaskResponse() = default;
};
class CreateParameterGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> parameterGroupName{};
  shared_ptr<string> engine{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> parameters{};
  shared_ptr<string> parameterGroupDesc{};

  CreateParameterGroupRequest() {}

  explicit CreateParameterGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (parameterGroupName) {
      res["ParameterGroupName"] = boost::any(*parameterGroupName);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (parameterGroupDesc) {
      res["ParameterGroupDesc"] = boost::any(*parameterGroupDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ParameterGroupName") != m.end() && !m["ParameterGroupName"].empty()) {
      parameterGroupName = make_shared<string>(boost::any_cast<string>(m["ParameterGroupName"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("ParameterGroupDesc") != m.end() && !m["ParameterGroupDesc"].empty()) {
      parameterGroupDesc = make_shared<string>(boost::any_cast<string>(m["ParameterGroupDesc"]));
    }
  }


  virtual ~CreateParameterGroupRequest() = default;
};
class CreateParameterGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> parameterGroupId{};
  shared_ptr<string> requestId{};

  CreateParameterGroupResponseBody() {}

  explicit CreateParameterGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterGroupId) {
      res["ParameterGroupId"] = boost::any(*parameterGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterGroupId") != m.end() && !m["ParameterGroupId"].empty()) {
      parameterGroupId = make_shared<string>(boost::any_cast<string>(m["ParameterGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateParameterGroupResponseBody() = default;
};
class CreateParameterGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateParameterGroupResponseBody> body{};

  CreateParameterGroupResponse() {}

  explicit CreateParameterGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateParameterGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateParameterGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateParameterGroupResponse() = default;
};
class CreateReadOnlyDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<long> DBInstanceStorage{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> payType{};
  shared_ptr<string> DBInstanceDescription{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> category{};
  shared_ptr<string> DBInstanceStorageType{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> targetDedicatedHostIdForMaster{};
  shared_ptr<string> gdnInstanceName{};
  shared_ptr<string> tddlBizType{};
  shared_ptr<string> tddlRegionConfig{};
  shared_ptr<string> instructionSetArch{};
  shared_ptr<string> usedTime{};
  shared_ptr<string> period{};
  shared_ptr<string> autoRenew{};

  CreateReadOnlyDBInstanceRequest() {}

  explicit CreateReadOnlyDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (DBInstanceStorage) {
      res["DBInstanceStorage"] = boost::any(*DBInstanceStorage);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (DBInstanceDescription) {
      res["DBInstanceDescription"] = boost::any(*DBInstanceDescription);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (DBInstanceStorageType) {
      res["DBInstanceStorageType"] = boost::any(*DBInstanceStorageType);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (targetDedicatedHostIdForMaster) {
      res["TargetDedicatedHostIdForMaster"] = boost::any(*targetDedicatedHostIdForMaster);
    }
    if (gdnInstanceName) {
      res["GdnInstanceName"] = boost::any(*gdnInstanceName);
    }
    if (tddlBizType) {
      res["TddlBizType"] = boost::any(*tddlBizType);
    }
    if (tddlRegionConfig) {
      res["TddlRegionConfig"] = boost::any(*tddlRegionConfig);
    }
    if (instructionSetArch) {
      res["InstructionSetArch"] = boost::any(*instructionSetArch);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("DBInstanceStorage") != m.end() && !m["DBInstanceStorage"].empty()) {
      DBInstanceStorage = make_shared<long>(boost::any_cast<long>(m["DBInstanceStorage"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("DBInstanceDescription") != m.end() && !m["DBInstanceDescription"].empty()) {
      DBInstanceDescription = make_shared<string>(boost::any_cast<string>(m["DBInstanceDescription"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DBInstanceStorageType") != m.end() && !m["DBInstanceStorageType"].empty()) {
      DBInstanceStorageType = make_shared<string>(boost::any_cast<string>(m["DBInstanceStorageType"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("TargetDedicatedHostIdForMaster") != m.end() && !m["TargetDedicatedHostIdForMaster"].empty()) {
      targetDedicatedHostIdForMaster = make_shared<string>(boost::any_cast<string>(m["TargetDedicatedHostIdForMaster"]));
    }
    if (m.find("GdnInstanceName") != m.end() && !m["GdnInstanceName"].empty()) {
      gdnInstanceName = make_shared<string>(boost::any_cast<string>(m["GdnInstanceName"]));
    }
    if (m.find("TddlBizType") != m.end() && !m["TddlBizType"].empty()) {
      tddlBizType = make_shared<string>(boost::any_cast<string>(m["TddlBizType"]));
    }
    if (m.find("TddlRegionConfig") != m.end() && !m["TddlRegionConfig"].empty()) {
      tddlRegionConfig = make_shared<string>(boost::any_cast<string>(m["TddlRegionConfig"]));
    }
    if (m.find("InstructionSetArch") != m.end() && !m["InstructionSetArch"].empty()) {
      instructionSetArch = make_shared<string>(boost::any_cast<string>(m["InstructionSetArch"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<string>(boost::any_cast<string>(m["UsedTime"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<string>(boost::any_cast<string>(m["AutoRenew"]));
    }
  }


  virtual ~CreateReadOnlyDBInstanceRequest() = default;
};
class CreateReadOnlyDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> port{};
  shared_ptr<string> connectionString{};
  shared_ptr<string> orderId{};

  CreateReadOnlyDBInstanceResponseBody() {}

  explicit CreateReadOnlyDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (connectionString) {
      res["ConnectionString"] = boost::any(*connectionString);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ConnectionString") != m.end() && !m["ConnectionString"].empty()) {
      connectionString = make_shared<string>(boost::any_cast<string>(m["ConnectionString"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~CreateReadOnlyDBInstanceResponseBody() = default;
};
class CreateReadOnlyDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateReadOnlyDBInstanceResponseBody> body{};

  CreateReadOnlyDBInstanceResponse() {}

  explicit CreateReadOnlyDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateReadOnlyDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateReadOnlyDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateReadOnlyDBInstanceResponse() = default;
};
class CreateTempDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> backupId{};
  shared_ptr<string> restoreTime{};
  shared_ptr<string> ownerAccount{};

  CreateTempDBInstanceRequest() {}

  explicit CreateTempDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (restoreTime) {
      res["RestoreTime"] = boost::any(*restoreTime);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<long>(boost::any_cast<long>(m["BackupId"]));
    }
    if (m.find("RestoreTime") != m.end() && !m["RestoreTime"].empty()) {
      restoreTime = make_shared<string>(boost::any_cast<string>(m["RestoreTime"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~CreateTempDBInstanceRequest() = default;
};
class CreateTempDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> tempDBInstanceId{};
  shared_ptr<string> requestId{};

  CreateTempDBInstanceResponseBody() {}

  explicit CreateTempDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tempDBInstanceId) {
      res["TempDBInstanceId"] = boost::any(*tempDBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TempDBInstanceId") != m.end() && !m["TempDBInstanceId"].empty()) {
      tempDBInstanceId = make_shared<string>(boost::any_cast<string>(m["TempDBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateTempDBInstanceResponseBody() = default;
};
class CreateTempDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateTempDBInstanceResponseBody> body{};

  CreateTempDBInstanceResponse() {}

  explicit CreateTempDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTempDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTempDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTempDBInstanceResponse() = default;
};
class DeleteAccountRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> ownerAccount{};

  DeleteAccountRequest() {}

  explicit DeleteAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteAccountRequest() = default;
};
class DeleteAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAccountResponseBody() {}

  explicit DeleteAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAccountResponseBody() = default;
};
class DeleteAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteAccountResponseBody> body{};

  DeleteAccountResponse() {}

  explicit DeleteAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAccountResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAccountResponse() = default;
};
class DeleteBackupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> backupId{};
  shared_ptr<string> ownerAccount{};

  DeleteBackupRequest() {}

  explicit DeleteBackupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteBackupRequest() = default;
};
class DeleteBackupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBackupResponseBody() {}

  explicit DeleteBackupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBackupResponseBody() = default;
};
class DeleteBackupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteBackupResponseBody> body{};

  DeleteBackupResponse() {}

  explicit DeleteBackupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBackupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBackupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBackupResponse() = default;
};
class DeleteBackupFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> backupId{};
  shared_ptr<string> DBName{};
  shared_ptr<string> backupTime{};

  DeleteBackupFileRequest() {}

  explicit DeleteBackupFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (backupTime) {
      res["BackupTime"] = boost::any(*backupTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("BackupTime") != m.end() && !m["BackupTime"].empty()) {
      backupTime = make_shared<string>(boost::any_cast<string>(m["BackupTime"]));
    }
  }


  virtual ~DeleteBackupFileRequest() = default;
};
class DeleteBackupFileResponseBodyDeletedBaksetIds : public Darabonba::Model {
public:
  shared_ptr<vector<long>> deletedBaksetIds{};

  DeleteBackupFileResponseBodyDeletedBaksetIds() {}

  explicit DeleteBackupFileResponseBodyDeletedBaksetIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deletedBaksetIds) {
      res["DeletedBaksetIds"] = boost::any(*deletedBaksetIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeletedBaksetIds") != m.end() && !m["DeletedBaksetIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DeletedBaksetIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeletedBaksetIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      deletedBaksetIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~DeleteBackupFileResponseBodyDeletedBaksetIds() = default;
};
class DeleteBackupFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeleteBackupFileResponseBodyDeletedBaksetIds> deletedBaksetIds{};

  DeleteBackupFileResponseBody() {}

  explicit DeleteBackupFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deletedBaksetIds) {
      res["DeletedBaksetIds"] = deletedBaksetIds ? boost::any(deletedBaksetIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeletedBaksetIds") != m.end() && !m["DeletedBaksetIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeletedBaksetIds"].type()) {
        DeleteBackupFileResponseBodyDeletedBaksetIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeletedBaksetIds"]));
        deletedBaksetIds = make_shared<DeleteBackupFileResponseBodyDeletedBaksetIds>(model1);
      }
    }
  }


  virtual ~DeleteBackupFileResponseBody() = default;
};
class DeleteBackupFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteBackupFileResponseBody> body{};

  DeleteBackupFileResponse() {}

  explicit DeleteBackupFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBackupFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBackupFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBackupFileResponse() = default;
};
class DeleteDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBName{};

  DeleteDatabaseRequest() {}

  explicit DeleteDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
  }


  virtual ~DeleteDatabaseRequest() = default;
};
class DeleteDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDatabaseResponseBody() {}

  explicit DeleteDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDatabaseResponseBody() = default;
};
class DeleteDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDatabaseResponseBody> body{};

  DeleteDatabaseResponse() {}

  explicit DeleteDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDatabaseResponse() = default;
};
class DeleteDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> releasedKeepPolicy{};

  DeleteDBInstanceRequest() {}

  explicit DeleteDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (releasedKeepPolicy) {
      res["ReleasedKeepPolicy"] = boost::any(*releasedKeepPolicy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ReleasedKeepPolicy") != m.end() && !m["ReleasedKeepPolicy"].empty()) {
      releasedKeepPolicy = make_shared<string>(boost::any_cast<string>(m["ReleasedKeepPolicy"]));
    }
  }


  virtual ~DeleteDBInstanceRequest() = default;
};
class DeleteDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};

  DeleteDBInstanceResponseBody() {}

  explicit DeleteDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDBInstanceResponseBody() = default;
};
class DeleteDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDBInstanceResponseBody> body{};

  DeleteDBInstanceResponse() {}

  explicit DeleteDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDBInstanceResponse() = default;
};
class DeleteDBProxyEndpointAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBProxyEndpointId{};
  shared_ptr<string> DBProxyConnectStringNetType{};

  DeleteDBProxyEndpointAddressRequest() {}

  explicit DeleteDBProxyEndpointAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBProxyEndpointId) {
      res["DBProxyEndpointId"] = boost::any(*DBProxyEndpointId);
    }
    if (DBProxyConnectStringNetType) {
      res["DBProxyConnectStringNetType"] = boost::any(*DBProxyConnectStringNetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBProxyEndpointId") != m.end() && !m["DBProxyEndpointId"].empty()) {
      DBProxyEndpointId = make_shared<string>(boost::any_cast<string>(m["DBProxyEndpointId"]));
    }
    if (m.find("DBProxyConnectStringNetType") != m.end() && !m["DBProxyConnectStringNetType"].empty()) {
      DBProxyConnectStringNetType = make_shared<string>(boost::any_cast<string>(m["DBProxyConnectStringNetType"]));
    }
  }


  virtual ~DeleteDBProxyEndpointAddressRequest() = default;
};
class DeleteDBProxyEndpointAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDBProxyEndpointAddressResponseBody() {}

  explicit DeleteDBProxyEndpointAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDBProxyEndpointAddressResponseBody() = default;
};
class DeleteDBProxyEndpointAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDBProxyEndpointAddressResponseBody> body{};

  DeleteDBProxyEndpointAddressResponse() {}

  explicit DeleteDBProxyEndpointAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDBProxyEndpointAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDBProxyEndpointAddressResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDBProxyEndpointAddressResponse() = default;
};
class DeleteDedicatedHostAccountRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> regionId{};

  DeleteDedicatedHostAccountRequest() {}

  explicit DeleteDedicatedHostAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDedicatedHostAccountRequest() = default;
};
class DeleteDedicatedHostAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDedicatedHostAccountResponseBody() {}

  explicit DeleteDedicatedHostAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDedicatedHostAccountResponseBody() = default;
};
class DeleteDedicatedHostAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDedicatedHostAccountResponseBody> body{};

  DeleteDedicatedHostAccountResponse() {}

  explicit DeleteDedicatedHostAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDedicatedHostAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDedicatedHostAccountResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDedicatedHostAccountResponse() = default;
};
class DeleteDedicatedHostGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> regionId{};

  DeleteDedicatedHostGroupRequest() {}

  explicit DeleteDedicatedHostGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDedicatedHostGroupRequest() = default;
};
class DeleteDedicatedHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDedicatedHostGroupResponseBody() {}

  explicit DeleteDedicatedHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDedicatedHostGroupResponseBody() = default;
};
class DeleteDedicatedHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDedicatedHostGroupResponseBody> body{};

  DeleteDedicatedHostGroupResponse() {}

  explicit DeleteDedicatedHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDedicatedHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDedicatedHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDedicatedHostGroupResponse() = default;
};
class DeleteParameterGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> parameterGroupId{};

  DeleteParameterGroupRequest() {}

  explicit DeleteParameterGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (parameterGroupId) {
      res["ParameterGroupId"] = boost::any(*parameterGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ParameterGroupId") != m.end() && !m["ParameterGroupId"].empty()) {
      parameterGroupId = make_shared<string>(boost::any_cast<string>(m["ParameterGroupId"]));
    }
  }


  virtual ~DeleteParameterGroupRequest() = default;
};
class DeleteParameterGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> parameterGroupId{};
  shared_ptr<string> requestId{};

  DeleteParameterGroupResponseBody() {}

  explicit DeleteParameterGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterGroupId) {
      res["ParameterGroupId"] = boost::any(*parameterGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterGroupId") != m.end() && !m["ParameterGroupId"].empty()) {
      parameterGroupId = make_shared<string>(boost::any_cast<string>(m["ParameterGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteParameterGroupResponseBody() = default;
};
class DeleteParameterGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteParameterGroupResponseBody> body{};

  DeleteParameterGroupResponse() {}

  explicit DeleteParameterGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteParameterGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteParameterGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteParameterGroupResponse() = default;
};
class DeleteUserBackupFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> backupId{};
  shared_ptr<string> regionId{};

  DeleteUserBackupFileRequest() {}

  explicit DeleteUserBackupFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteUserBackupFileRequest() = default;
};
class DeleteUserBackupFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> backupId{};
  shared_ptr<string> requestId{};

  DeleteUserBackupFileResponseBody() {}

  explicit DeleteUserBackupFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUserBackupFileResponseBody() = default;
};
class DeleteUserBackupFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteUserBackupFileResponseBody> body{};

  DeleteUserBackupFileResponse() {}

  explicit DeleteUserBackupFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserBackupFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserBackupFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserBackupFileResponse() = default;
};
class DescibeImportsFromDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> engine{};
  shared_ptr<long> importId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> ownerAccount{};

  DescibeImportsFromDatabaseRequest() {}

  explicit DescibeImportsFromDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (importId) {
      res["ImportId"] = boost::any(*importId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("ImportId") != m.end() && !m["ImportId"].empty()) {
      importId = make_shared<long>(boost::any_cast<long>(m["ImportId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescibeImportsFromDatabaseRequest() = default;
};
class DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB : public Darabonba::Model {
public:
  shared_ptr<string> incrementalImportingTime{};
  shared_ptr<long> importId{};
  shared_ptr<string> importDataStatus{};
  shared_ptr<string> importDataType{};
  shared_ptr<string> importDataStatusDescription{};

  DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB() {}

  explicit DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (incrementalImportingTime) {
      res["IncrementalImportingTime"] = boost::any(*incrementalImportingTime);
    }
    if (importId) {
      res["ImportId"] = boost::any(*importId);
    }
    if (importDataStatus) {
      res["ImportDataStatus"] = boost::any(*importDataStatus);
    }
    if (importDataType) {
      res["ImportDataType"] = boost::any(*importDataType);
    }
    if (importDataStatusDescription) {
      res["ImportDataStatusDescription"] = boost::any(*importDataStatusDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IncrementalImportingTime") != m.end() && !m["IncrementalImportingTime"].empty()) {
      incrementalImportingTime = make_shared<string>(boost::any_cast<string>(m["IncrementalImportingTime"]));
    }
    if (m.find("ImportId") != m.end() && !m["ImportId"].empty()) {
      importId = make_shared<long>(boost::any_cast<long>(m["ImportId"]));
    }
    if (m.find("ImportDataStatus") != m.end() && !m["ImportDataStatus"].empty()) {
      importDataStatus = make_shared<string>(boost::any_cast<string>(m["ImportDataStatus"]));
    }
    if (m.find("ImportDataType") != m.end() && !m["ImportDataType"].empty()) {
      importDataType = make_shared<string>(boost::any_cast<string>(m["ImportDataType"]));
    }
    if (m.find("ImportDataStatusDescription") != m.end() && !m["ImportDataStatusDescription"].empty()) {
      importDataStatusDescription = make_shared<string>(boost::any_cast<string>(m["ImportDataStatusDescription"]));
    }
  }


  virtual ~DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB() = default;
};
class DescibeImportsFromDatabaseResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB>> importResultFromDB{};

  DescibeImportsFromDatabaseResponseBodyItems() {}

  explicit DescibeImportsFromDatabaseResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (importResultFromDB) {
      vector<boost::any> temp1;
      for(auto item1:*importResultFromDB){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImportResultFromDB"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImportResultFromDB") != m.end() && !m["ImportResultFromDB"].empty()) {
      if (typeid(vector<boost::any>) == m["ImportResultFromDB"].type()) {
        vector<DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImportResultFromDB"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        importResultFromDB = make_shared<vector<DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB>>(expect1);
      }
    }
  }


  virtual ~DescibeImportsFromDatabaseResponseBodyItems() = default;
};
class DescibeImportsFromDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescibeImportsFromDatabaseResponseBodyItems> items{};

  DescibeImportsFromDatabaseResponseBody() {}

  explicit DescibeImportsFromDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescibeImportsFromDatabaseResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescibeImportsFromDatabaseResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescibeImportsFromDatabaseResponseBody() = default;
};
class DescibeImportsFromDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescibeImportsFromDatabaseResponseBody> body{};

  DescibeImportsFromDatabaseResponse() {}

  explicit DescibeImportsFromDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescibeImportsFromDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescibeImportsFromDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~DescibeImportsFromDatabaseResponse() = default;
};
class DescribeAccountsRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> accountName{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeAccountsRequest() {}

  explicit DescribeAccountsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeAccountsRequest() = default;
};
class DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege : public Darabonba::Model {
public:
  shared_ptr<string> DBName{};
  shared_ptr<string> accountPrivilege{};
  shared_ptr<string> accountPrivilegeDetail{};

  DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege() {}

  explicit DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (accountPrivilege) {
      res["AccountPrivilege"] = boost::any(*accountPrivilege);
    }
    if (accountPrivilegeDetail) {
      res["AccountPrivilegeDetail"] = boost::any(*accountPrivilegeDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("AccountPrivilege") != m.end() && !m["AccountPrivilege"].empty()) {
      accountPrivilege = make_shared<string>(boost::any_cast<string>(m["AccountPrivilege"]));
    }
    if (m.find("AccountPrivilegeDetail") != m.end() && !m["AccountPrivilegeDetail"].empty()) {
      accountPrivilegeDetail = make_shared<string>(boost::any_cast<string>(m["AccountPrivilegeDetail"]));
    }
  }


  virtual ~DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege() = default;
};
class DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege>> databasePrivilege{};

  DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges() {}

  explicit DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databasePrivilege) {
      vector<boost::any> temp1;
      for(auto item1:*databasePrivilege){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabasePrivilege"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabasePrivilege") != m.end() && !m["DatabasePrivilege"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabasePrivilege"].type()) {
        vector<DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabasePrivilege"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databasePrivilege = make_shared<vector<DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege>>(expect1);
      }
    }
  }


  virtual ~DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges() = default;
};
class DescribeAccountsResponseBodyAccountsDBInstanceAccount : public Darabonba::Model {
public:
  shared_ptr<string> accountStatus{};
  shared_ptr<string> accountDescription{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> privExceeded{};
  shared_ptr<string> accountType{};
  shared_ptr<string> accountName{};
  shared_ptr<DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges> databasePrivileges{};

  DescribeAccountsResponseBodyAccountsDBInstanceAccount() {}

  explicit DescribeAccountsResponseBodyAccountsDBInstanceAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountStatus) {
      res["AccountStatus"] = boost::any(*accountStatus);
    }
    if (accountDescription) {
      res["AccountDescription"] = boost::any(*accountDescription);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (privExceeded) {
      res["PrivExceeded"] = boost::any(*privExceeded);
    }
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (databasePrivileges) {
      res["DatabasePrivileges"] = databasePrivileges ? boost::any(databasePrivileges->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountStatus") != m.end() && !m["AccountStatus"].empty()) {
      accountStatus = make_shared<string>(boost::any_cast<string>(m["AccountStatus"]));
    }
    if (m.find("AccountDescription") != m.end() && !m["AccountDescription"].empty()) {
      accountDescription = make_shared<string>(boost::any_cast<string>(m["AccountDescription"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("PrivExceeded") != m.end() && !m["PrivExceeded"].empty()) {
      privExceeded = make_shared<string>(boost::any_cast<string>(m["PrivExceeded"]));
    }
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("DatabasePrivileges") != m.end() && !m["DatabasePrivileges"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatabasePrivileges"].type()) {
        DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatabasePrivileges"]));
        databasePrivileges = make_shared<DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges>(model1);
      }
    }
  }


  virtual ~DescribeAccountsResponseBodyAccountsDBInstanceAccount() = default;
};
class DescribeAccountsResponseBodyAccounts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccountsResponseBodyAccountsDBInstanceAccount>> DBInstanceAccount{};

  DescribeAccountsResponseBodyAccounts() {}

  explicit DescribeAccountsResponseBodyAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceAccount) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstanceAccount){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstanceAccount"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceAccount") != m.end() && !m["DBInstanceAccount"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstanceAccount"].type()) {
        vector<DescribeAccountsResponseBodyAccountsDBInstanceAccount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstanceAccount"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccountsResponseBodyAccountsDBInstanceAccount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstanceAccount = make_shared<vector<DescribeAccountsResponseBodyAccountsDBInstanceAccount>>(expect1);
      }
    }
  }


  virtual ~DescribeAccountsResponseBodyAccounts() = default;
};
class DescribeAccountsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> systemAdminAccountStatus{};
  shared_ptr<string> systemAdminAccountFirstActivationTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeAccountsResponseBodyAccounts> accounts{};

  DescribeAccountsResponseBody() {}

  explicit DescribeAccountsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemAdminAccountStatus) {
      res["SystemAdminAccountStatus"] = boost::any(*systemAdminAccountStatus);
    }
    if (systemAdminAccountFirstActivationTime) {
      res["SystemAdminAccountFirstActivationTime"] = boost::any(*systemAdminAccountFirstActivationTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (accounts) {
      res["Accounts"] = accounts ? boost::any(accounts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemAdminAccountStatus") != m.end() && !m["SystemAdminAccountStatus"].empty()) {
      systemAdminAccountStatus = make_shared<string>(boost::any_cast<string>(m["SystemAdminAccountStatus"]));
    }
    if (m.find("SystemAdminAccountFirstActivationTime") != m.end() && !m["SystemAdminAccountFirstActivationTime"].empty()) {
      systemAdminAccountFirstActivationTime = make_shared<string>(boost::any_cast<string>(m["SystemAdminAccountFirstActivationTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Accounts"].type()) {
        DescribeAccountsResponseBodyAccounts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Accounts"]));
        accounts = make_shared<DescribeAccountsResponseBodyAccounts>(model1);
      }
    }
  }


  virtual ~DescribeAccountsResponseBody() = default;
};
class DescribeAccountsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAccountsResponseBody> body{};

  DescribeAccountsResponse() {}

  explicit DescribeAccountsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccountsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccountsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccountsResponse() = default;
};
class DescribeActionEventPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};

  DescribeActionEventPolicyRequest() {}

  explicit DescribeActionEventPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeActionEventPolicyRequest() = default;
};
class DescribeActionEventPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> enableEventLog{};
  shared_ptr<string> requestId{};
  shared_ptr<string> regionId{};

  DescribeActionEventPolicyResponseBody() {}

  explicit DescribeActionEventPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableEventLog) {
      res["EnableEventLog"] = boost::any(*enableEventLog);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableEventLog") != m.end() && !m["EnableEventLog"].empty()) {
      enableEventLog = make_shared<string>(boost::any_cast<string>(m["EnableEventLog"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeActionEventPolicyResponseBody() = default;
};
class DescribeActionEventPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeActionEventPolicyResponseBody> body{};

  DescribeActionEventPolicyResponse() {}

  explicit DescribeActionEventPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeActionEventPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeActionEventPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeActionEventPolicyResponse() = default;
};
class DescribeAvailableClassesRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> engine{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> orderType{};
  shared_ptr<string> DBInstanceStorageType{};
  shared_ptr<string> category{};
  shared_ptr<string> commodityCode{};

  DescribeAvailableClassesRequest() {}

  explicit DescribeAvailableClassesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (DBInstanceStorageType) {
      res["DBInstanceStorageType"] = boost::any(*DBInstanceStorageType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("DBInstanceStorageType") != m.end() && !m["DBInstanceStorageType"].empty()) {
      DBInstanceStorageType = make_shared<string>(boost::any_cast<string>(m["DBInstanceStorageType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
  }


  virtual ~DescribeAvailableClassesRequest() = default;
};
class DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange : public Darabonba::Model {
public:
  shared_ptr<long> step{};
  shared_ptr<long> minValue{};
  shared_ptr<long> maxValue{};

  DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange() {}

  explicit DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (step) {
      res["Step"] = boost::any(*step);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
  }


  virtual ~DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange() = default;
};
class DescribeAvailableClassesResponseBodyDBInstanceClasses : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange> DBInstanceStorageRange{};

  DescribeAvailableClassesResponseBodyDBInstanceClasses() {}

  explicit DescribeAvailableClassesResponseBodyDBInstanceClasses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (DBInstanceStorageRange) {
      res["DBInstanceStorageRange"] = DBInstanceStorageRange ? boost::any(DBInstanceStorageRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("DBInstanceStorageRange") != m.end() && !m["DBInstanceStorageRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["DBInstanceStorageRange"].type()) {
        DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DBInstanceStorageRange"]));
        DBInstanceStorageRange = make_shared<DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange>(model1);
      }
    }
  }


  virtual ~DescribeAvailableClassesResponseBodyDBInstanceClasses() = default;
};
class DescribeAvailableClassesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAvailableClassesResponseBodyDBInstanceClasses>> DBInstanceClasses{};

  DescribeAvailableClassesResponseBody() {}

  explicit DescribeAvailableClassesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (DBInstanceClasses) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstanceClasses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstanceClasses"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DBInstanceClasses") != m.end() && !m["DBInstanceClasses"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstanceClasses"].type()) {
        vector<DescribeAvailableClassesResponseBodyDBInstanceClasses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstanceClasses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableClassesResponseBodyDBInstanceClasses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstanceClasses = make_shared<vector<DescribeAvailableClassesResponseBodyDBInstanceClasses>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableClassesResponseBody() = default;
};
class DescribeAvailableClassesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAvailableClassesResponseBody> body{};

  DescribeAvailableClassesResponse() {}

  explicit DescribeAvailableClassesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableClassesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableClassesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableClassesResponse() = default;
};
class DescribeAvailableCrossRegionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};

  DescribeAvailableCrossRegionRequest() {}

  explicit DescribeAvailableCrossRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeAvailableCrossRegionRequest() = default;
};
class DescribeAvailableCrossRegionResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> region{};

  DescribeAvailableCrossRegionResponseBodyRegions() {}

  explicit DescribeAvailableCrossRegionResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Region"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Region"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      region = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAvailableCrossRegionResponseBodyRegions() = default;
};
class DescribeAvailableCrossRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAvailableCrossRegionResponseBodyRegions> regions{};

  DescribeAvailableCrossRegionResponseBody() {}

  explicit DescribeAvailableCrossRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeAvailableCrossRegionResponseBodyRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeAvailableCrossRegionResponseBodyRegions>(model1);
      }
    }
  }


  virtual ~DescribeAvailableCrossRegionResponseBody() = default;
};
class DescribeAvailableCrossRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAvailableCrossRegionResponseBody> body{};

  DescribeAvailableCrossRegionResponse() {}

  explicit DescribeAvailableCrossRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableCrossRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableCrossRegionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableCrossRegionResponse() = default;
};
class DescribeAvailableDedicatedHostClassesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> storageType{};

  DescribeAvailableDedicatedHostClassesRequest() {}

  explicit DescribeAvailableDedicatedHostClassesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~DescribeAvailableDedicatedHostClassesRequest() = default;
};
class DescribeAvailableDedicatedHostClassesResponseBodyHostClassesHostClasses : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> hostClassName{};

  DescribeAvailableDedicatedHostClassesResponseBodyHostClassesHostClasses() {}

  explicit DescribeAvailableDedicatedHostClassesResponseBodyHostClassesHostClasses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hostClassName) {
      res["HostClassName"] = boost::any(*hostClassName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HostClassName") != m.end() && !m["HostClassName"].empty()) {
      hostClassName = make_shared<string>(boost::any_cast<string>(m["HostClassName"]));
    }
  }


  virtual ~DescribeAvailableDedicatedHostClassesResponseBodyHostClassesHostClasses() = default;
};
class DescribeAvailableDedicatedHostClassesResponseBodyHostClasses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableDedicatedHostClassesResponseBodyHostClassesHostClasses>> hostClasses{};

  DescribeAvailableDedicatedHostClassesResponseBodyHostClasses() {}

  explicit DescribeAvailableDedicatedHostClassesResponseBodyHostClasses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostClasses) {
      vector<boost::any> temp1;
      for(auto item1:*hostClasses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostClasses"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostClasses") != m.end() && !m["HostClasses"].empty()) {
      if (typeid(vector<boost::any>) == m["HostClasses"].type()) {
        vector<DescribeAvailableDedicatedHostClassesResponseBodyHostClassesHostClasses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostClasses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableDedicatedHostClassesResponseBodyHostClassesHostClasses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostClasses = make_shared<vector<DescribeAvailableDedicatedHostClassesResponseBodyHostClassesHostClasses>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableDedicatedHostClassesResponseBodyHostClasses() = default;
};
class DescribeAvailableDedicatedHostClassesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAvailableDedicatedHostClassesResponseBodyHostClasses> hostClasses{};

  DescribeAvailableDedicatedHostClassesResponseBody() {}

  explicit DescribeAvailableDedicatedHostClassesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (hostClasses) {
      res["HostClasses"] = hostClasses ? boost::any(hostClasses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HostClasses") != m.end() && !m["HostClasses"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostClasses"].type()) {
        DescribeAvailableDedicatedHostClassesResponseBodyHostClasses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostClasses"]));
        hostClasses = make_shared<DescribeAvailableDedicatedHostClassesResponseBodyHostClasses>(model1);
      }
    }
  }


  virtual ~DescribeAvailableDedicatedHostClassesResponseBody() = default;
};
class DescribeAvailableDedicatedHostClassesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAvailableDedicatedHostClassesResponseBody> body{};

  DescribeAvailableDedicatedHostClassesResponse() {}

  explicit DescribeAvailableDedicatedHostClassesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableDedicatedHostClassesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableDedicatedHostClassesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableDedicatedHostClassesResponse() = default;
};
class DescribeAvailableDedicatedHostZonesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};

  DescribeAvailableDedicatedHostZonesRequest() {}

  explicit DescribeAvailableDedicatedHostZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeAvailableDedicatedHostZonesRequest() = default;
};
class DescribeAvailableDedicatedHostZonesResponseBodyZonesDedicatedHostZones : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> zoneId{};

  DescribeAvailableDedicatedHostZonesResponseBodyZonesDedicatedHostZones() {}

  explicit DescribeAvailableDedicatedHostZonesResponseBodyZonesDedicatedHostZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeAvailableDedicatedHostZonesResponseBodyZonesDedicatedHostZones() = default;
};
class DescribeAvailableDedicatedHostZonesResponseBodyZones : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableDedicatedHostZonesResponseBodyZonesDedicatedHostZones>> dedicatedHostZones{};

  DescribeAvailableDedicatedHostZonesResponseBodyZones() {}

  explicit DescribeAvailableDedicatedHostZonesResponseBodyZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostZones) {
      vector<boost::any> temp1;
      for(auto item1:*dedicatedHostZones){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicatedHostZones"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostZones") != m.end() && !m["DedicatedHostZones"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicatedHostZones"].type()) {
        vector<DescribeAvailableDedicatedHostZonesResponseBodyZonesDedicatedHostZones> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicatedHostZones"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableDedicatedHostZonesResponseBodyZonesDedicatedHostZones model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicatedHostZones = make_shared<vector<DescribeAvailableDedicatedHostZonesResponseBodyZonesDedicatedHostZones>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableDedicatedHostZonesResponseBodyZones() = default;
};
class DescribeAvailableDedicatedHostZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAvailableDedicatedHostZonesResponseBodyZones> zones{};

  DescribeAvailableDedicatedHostZonesResponseBody() {}

  explicit DescribeAvailableDedicatedHostZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (zones) {
      res["Zones"] = zones ? boost::any(zones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      if (typeid(map<string, boost::any>) == m["Zones"].type()) {
        DescribeAvailableDedicatedHostZonesResponseBodyZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Zones"]));
        zones = make_shared<DescribeAvailableDedicatedHostZonesResponseBodyZones>(model1);
      }
    }
  }


  virtual ~DescribeAvailableDedicatedHostZonesResponseBody() = default;
};
class DescribeAvailableDedicatedHostZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAvailableDedicatedHostZonesResponseBody> body{};

  DescribeAvailableDedicatedHostZonesResponse() {}

  explicit DescribeAvailableDedicatedHostZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableDedicatedHostZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableDedicatedHostZonesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableDedicatedHostZonesResponse() = default;
};
class DescribeAvailableMetricsRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceName{};

  DescribeAvailableMetricsRequest() {}

  explicit DescribeAvailableMetricsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
  }


  virtual ~DescribeAvailableMetricsRequest() = default;
};
class DescribeAvailableMetricsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<string> groupKey{};
  shared_ptr<long> sortRule{};
  shared_ptr<string> description{};
  shared_ptr<string> unit{};
  shared_ptr<string> metricsKey{};
  shared_ptr<string> groupKeyType{};
  shared_ptr<string> metricsKeyAlias{};
  shared_ptr<string> method{};
  shared_ptr<string> dimension{};

  DescribeAvailableMetricsResponseBodyItems() {}

  explicit DescribeAvailableMetricsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupKey) {
      res["GroupKey"] = boost::any(*groupKey);
    }
    if (sortRule) {
      res["SortRule"] = boost::any(*sortRule);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (metricsKey) {
      res["MetricsKey"] = boost::any(*metricsKey);
    }
    if (groupKeyType) {
      res["GroupKeyType"] = boost::any(*groupKeyType);
    }
    if (metricsKeyAlias) {
      res["MetricsKeyAlias"] = boost::any(*metricsKeyAlias);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupKey") != m.end() && !m["GroupKey"].empty()) {
      groupKey = make_shared<string>(boost::any_cast<string>(m["GroupKey"]));
    }
    if (m.find("SortRule") != m.end() && !m["SortRule"].empty()) {
      sortRule = make_shared<long>(boost::any_cast<long>(m["SortRule"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("MetricsKey") != m.end() && !m["MetricsKey"].empty()) {
      metricsKey = make_shared<string>(boost::any_cast<string>(m["MetricsKey"]));
    }
    if (m.find("GroupKeyType") != m.end() && !m["GroupKeyType"].empty()) {
      groupKeyType = make_shared<string>(boost::any_cast<string>(m["GroupKeyType"]));
    }
    if (m.find("MetricsKeyAlias") != m.end() && !m["MetricsKeyAlias"].empty()) {
      metricsKeyAlias = make_shared<string>(boost::any_cast<string>(m["MetricsKeyAlias"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
  }


  virtual ~DescribeAvailableMetricsResponseBodyItems() = default;
};
class DescribeAvailableMetricsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAvailableMetricsResponseBodyItems>> items{};

  DescribeAvailableMetricsResponseBody() {}

  explicit DescribeAvailableMetricsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<DescribeAvailableMetricsResponseBodyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableMetricsResponseBodyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<DescribeAvailableMetricsResponseBodyItems>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableMetricsResponseBody() = default;
};
class DescribeAvailableMetricsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAvailableMetricsResponseBody> body{};

  DescribeAvailableMetricsResponse() {}

  explicit DescribeAvailableMetricsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableMetricsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableMetricsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableMetricsResponse() = default;
};
class DescribeAvailableRecoveryTimeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> crossBackupId{};
  shared_ptr<string> regionId{};

  DescribeAvailableRecoveryTimeRequest() {}

  explicit DescribeAvailableRecoveryTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (crossBackupId) {
      res["CrossBackupId"] = boost::any(*crossBackupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("CrossBackupId") != m.end() && !m["CrossBackupId"].empty()) {
      crossBackupId = make_shared<long>(boost::any_cast<long>(m["CrossBackupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeAvailableRecoveryTimeRequest() = default;
};
class DescribeAvailableRecoveryTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> recoveryEndTime{};
  shared_ptr<string> requestId{};
  shared_ptr<long> crossBackupId{};
  shared_ptr<string> recoveryBeginTime{};
  shared_ptr<string> regionId{};

  DescribeAvailableRecoveryTimeResponseBody() {}

  explicit DescribeAvailableRecoveryTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recoveryEndTime) {
      res["RecoveryEndTime"] = boost::any(*recoveryEndTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (crossBackupId) {
      res["CrossBackupId"] = boost::any(*crossBackupId);
    }
    if (recoveryBeginTime) {
      res["RecoveryBeginTime"] = boost::any(*recoveryBeginTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecoveryEndTime") != m.end() && !m["RecoveryEndTime"].empty()) {
      recoveryEndTime = make_shared<string>(boost::any_cast<string>(m["RecoveryEndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CrossBackupId") != m.end() && !m["CrossBackupId"].empty()) {
      crossBackupId = make_shared<long>(boost::any_cast<long>(m["CrossBackupId"]));
    }
    if (m.find("RecoveryBeginTime") != m.end() && !m["RecoveryBeginTime"].empty()) {
      recoveryBeginTime = make_shared<string>(boost::any_cast<string>(m["RecoveryBeginTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeAvailableRecoveryTimeResponseBody() = default;
};
class DescribeAvailableRecoveryTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAvailableRecoveryTimeResponseBody> body{};

  DescribeAvailableRecoveryTimeResponse() {}

  explicit DescribeAvailableRecoveryTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableRecoveryTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableRecoveryTimeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableRecoveryTimeResponse() = default;
};
class DescribeAvailableZonesRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> engine{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> dispenseMode{};
  shared_ptr<string> DBInstanceName{};
  shared_ptr<string> category{};

  DescribeAvailableZonesRequest() {}

  explicit DescribeAvailableZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (dispenseMode) {
      res["DispenseMode"] = boost::any(*dispenseMode);
    }
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("DispenseMode") != m.end() && !m["DispenseMode"].empty()) {
      dispenseMode = make_shared<string>(boost::any_cast<string>(m["DispenseMode"]));
    }
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
  }


  virtual ~DescribeAvailableZonesRequest() = default;
};
class DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes : public Darabonba::Model {
public:
  shared_ptr<string> storageType{};

  DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes() {}

  explicit DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes() = default;
};
class DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<vector<DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes>> supportedStorageTypes{};

  DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys() {}

  explicit DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (supportedStorageTypes) {
      vector<boost::any> temp1;
      for(auto item1:*supportedStorageTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportedStorageTypes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("SupportedStorageTypes") != m.end() && !m["SupportedStorageTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportedStorageTypes"].type()) {
        vector<DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportedStorageTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportedStorageTypes = make_shared<vector<DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys() = default;
};
class DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions : public Darabonba::Model {
public:
  shared_ptr<string> version{};
  shared_ptr<vector<DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys>> supportedCategorys{};

  DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions() {}

  explicit DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (supportedCategorys) {
      vector<boost::any> temp1;
      for(auto item1:*supportedCategorys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportedCategorys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("SupportedCategorys") != m.end() && !m["SupportedCategorys"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportedCategorys"].type()) {
        vector<DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportedCategorys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportedCategorys = make_shared<vector<DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions() = default;
};
class DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines : public Darabonba::Model {
public:
  shared_ptr<string> engine{};
  shared_ptr<vector<DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions>> supportedEngineVersions{};

  DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines() {}

  explicit DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (supportedEngineVersions) {
      vector<boost::any> temp1;
      for(auto item1:*supportedEngineVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportedEngineVersions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("SupportedEngineVersions") != m.end() && !m["SupportedEngineVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportedEngineVersions"].type()) {
        vector<DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportedEngineVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportedEngineVersions = make_shared<vector<DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines() = default;
};
class DescribeAvailableZonesResponseBodyAvailableZones : public Darabonba::Model {
public:
  shared_ptr<string> zoneId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines>> supportedEngines{};

  DescribeAvailableZonesResponseBodyAvailableZones() {}

  explicit DescribeAvailableZonesResponseBodyAvailableZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (supportedEngines) {
      vector<boost::any> temp1;
      for(auto item1:*supportedEngines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportedEngines"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SupportedEngines") != m.end() && !m["SupportedEngines"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportedEngines"].type()) {
        vector<DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportedEngines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportedEngines = make_shared<vector<DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableZonesResponseBodyAvailableZones() = default;
};
class DescribeAvailableZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAvailableZonesResponseBodyAvailableZones>> availableZones{};

  DescribeAvailableZonesResponseBody() {}

  explicit DescribeAvailableZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (availableZones) {
      vector<boost::any> temp1;
      for(auto item1:*availableZones){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableZones"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AvailableZones") != m.end() && !m["AvailableZones"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableZones"].type()) {
        vector<DescribeAvailableZonesResponseBodyAvailableZones> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableZones"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableZonesResponseBodyAvailableZones model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableZones = make_shared<vector<DescribeAvailableZonesResponseBodyAvailableZones>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableZonesResponseBody() = default;
};
class DescribeAvailableZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAvailableZonesResponseBody> body{};

  DescribeAvailableZonesResponse() {}

  explicit DescribeAvailableZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableZonesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableZonesResponse() = default;
};
class DescribeBackupDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> backupId{};

  DescribeBackupDatabaseRequest() {}

  explicit DescribeBackupDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
  }


  virtual ~DescribeBackupDatabaseRequest() = default;
};
class DescribeBackupDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> databaseNames{};
  shared_ptr<string> requestId{};

  DescribeBackupDatabaseResponseBody() {}

  explicit DescribeBackupDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseNames) {
      res["DatabaseNames"] = boost::any(*databaseNames);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseNames") != m.end() && !m["DatabaseNames"].empty()) {
      databaseNames = make_shared<string>(boost::any_cast<string>(m["DatabaseNames"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBackupDatabaseResponseBody() = default;
};
class DescribeBackupDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBackupDatabaseResponseBody> body{};

  DescribeBackupDatabaseResponse() {}

  explicit DescribeBackupDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupDatabaseResponse() = default;
};
class DescribeBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> backupPolicyMode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> compressType{};
  shared_ptr<string> releasedKeepPolicy{};

  DescribeBackupPolicyRequest() {}

  explicit DescribeBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (backupPolicyMode) {
      res["BackupPolicyMode"] = boost::any(*backupPolicyMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (compressType) {
      res["CompressType"] = boost::any(*compressType);
    }
    if (releasedKeepPolicy) {
      res["ReleasedKeepPolicy"] = boost::any(*releasedKeepPolicy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("BackupPolicyMode") != m.end() && !m["BackupPolicyMode"].empty()) {
      backupPolicyMode = make_shared<string>(boost::any_cast<string>(m["BackupPolicyMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("CompressType") != m.end() && !m["CompressType"].empty()) {
      compressType = make_shared<string>(boost::any_cast<string>(m["CompressType"]));
    }
    if (m.find("ReleasedKeepPolicy") != m.end() && !m["ReleasedKeepPolicy"].empty()) {
      releasedKeepPolicy = make_shared<string>(boost::any_cast<string>(m["ReleasedKeepPolicy"]));
    }
  }


  virtual ~DescribeBackupPolicyRequest() = default;
};
class DescribeBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> logBackupRetentionPeriod{};
  shared_ptr<string> archiveBackupKeepPolicy{};
  shared_ptr<string> archiveBackupKeepCount{};
  shared_ptr<long> localLogRetentionHours{};
  shared_ptr<long> backupRetentionPeriod{};
  shared_ptr<string> requestId{};
  shared_ptr<string> preferredBackupPeriod{};
  shared_ptr<string> compressType{};
  shared_ptr<long> supportReleasedKeep{};
  shared_ptr<string> localLogRetentionSpace{};
  shared_ptr<long> supportVolumeShadowCopy{};
  shared_ptr<string> backupMethod{};
  shared_ptr<string> logBackupFrequency{};
  shared_ptr<string> preferredNextBackupTime{};
  shared_ptr<string> highSpaceUsageProtection{};
  shared_ptr<string> archiveBackupRetentionPeriod{};
  shared_ptr<string> backupInterval{};
  shared_ptr<string> releasedKeepPolicy{};
  shared_ptr<string> preferredBackupTime{};
  shared_ptr<long> logBackupLocalRetentionNumber{};
  shared_ptr<string> category{};
  shared_ptr<string> enableBackupLog{};
  shared_ptr<string> backupLog{};

  DescribeBackupPolicyResponseBody() {}

  explicit DescribeBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logBackupRetentionPeriod) {
      res["LogBackupRetentionPeriod"] = boost::any(*logBackupRetentionPeriod);
    }
    if (archiveBackupKeepPolicy) {
      res["ArchiveBackupKeepPolicy"] = boost::any(*archiveBackupKeepPolicy);
    }
    if (archiveBackupKeepCount) {
      res["ArchiveBackupKeepCount"] = boost::any(*archiveBackupKeepCount);
    }
    if (localLogRetentionHours) {
      res["LocalLogRetentionHours"] = boost::any(*localLogRetentionHours);
    }
    if (backupRetentionPeriod) {
      res["BackupRetentionPeriod"] = boost::any(*backupRetentionPeriod);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (preferredBackupPeriod) {
      res["PreferredBackupPeriod"] = boost::any(*preferredBackupPeriod);
    }
    if (compressType) {
      res["CompressType"] = boost::any(*compressType);
    }
    if (supportReleasedKeep) {
      res["SupportReleasedKeep"] = boost::any(*supportReleasedKeep);
    }
    if (localLogRetentionSpace) {
      res["LocalLogRetentionSpace"] = boost::any(*localLogRetentionSpace);
    }
    if (supportVolumeShadowCopy) {
      res["SupportVolumeShadowCopy"] = boost::any(*supportVolumeShadowCopy);
    }
    if (backupMethod) {
      res["BackupMethod"] = boost::any(*backupMethod);
    }
    if (logBackupFrequency) {
      res["LogBackupFrequency"] = boost::any(*logBackupFrequency);
    }
    if (preferredNextBackupTime) {
      res["PreferredNextBackupTime"] = boost::any(*preferredNextBackupTime);
    }
    if (highSpaceUsageProtection) {
      res["HighSpaceUsageProtection"] = boost::any(*highSpaceUsageProtection);
    }
    if (archiveBackupRetentionPeriod) {
      res["ArchiveBackupRetentionPeriod"] = boost::any(*archiveBackupRetentionPeriod);
    }
    if (backupInterval) {
      res["BackupInterval"] = boost::any(*backupInterval);
    }
    if (releasedKeepPolicy) {
      res["ReleasedKeepPolicy"] = boost::any(*releasedKeepPolicy);
    }
    if (preferredBackupTime) {
      res["PreferredBackupTime"] = boost::any(*preferredBackupTime);
    }
    if (logBackupLocalRetentionNumber) {
      res["LogBackupLocalRetentionNumber"] = boost::any(*logBackupLocalRetentionNumber);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (enableBackupLog) {
      res["EnableBackupLog"] = boost::any(*enableBackupLog);
    }
    if (backupLog) {
      res["BackupLog"] = boost::any(*backupLog);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogBackupRetentionPeriod") != m.end() && !m["LogBackupRetentionPeriod"].empty()) {
      logBackupRetentionPeriod = make_shared<long>(boost::any_cast<long>(m["LogBackupRetentionPeriod"]));
    }
    if (m.find("ArchiveBackupKeepPolicy") != m.end() && !m["ArchiveBackupKeepPolicy"].empty()) {
      archiveBackupKeepPolicy = make_shared<string>(boost::any_cast<string>(m["ArchiveBackupKeepPolicy"]));
    }
    if (m.find("ArchiveBackupKeepCount") != m.end() && !m["ArchiveBackupKeepCount"].empty()) {
      archiveBackupKeepCount = make_shared<string>(boost::any_cast<string>(m["ArchiveBackupKeepCount"]));
    }
    if (m.find("LocalLogRetentionHours") != m.end() && !m["LocalLogRetentionHours"].empty()) {
      localLogRetentionHours = make_shared<long>(boost::any_cast<long>(m["LocalLogRetentionHours"]));
    }
    if (m.find("BackupRetentionPeriod") != m.end() && !m["BackupRetentionPeriod"].empty()) {
      backupRetentionPeriod = make_shared<long>(boost::any_cast<long>(m["BackupRetentionPeriod"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PreferredBackupPeriod") != m.end() && !m["PreferredBackupPeriod"].empty()) {
      preferredBackupPeriod = make_shared<string>(boost::any_cast<string>(m["PreferredBackupPeriod"]));
    }
    if (m.find("CompressType") != m.end() && !m["CompressType"].empty()) {
      compressType = make_shared<string>(boost::any_cast<string>(m["CompressType"]));
    }
    if (m.find("SupportReleasedKeep") != m.end() && !m["SupportReleasedKeep"].empty()) {
      supportReleasedKeep = make_shared<long>(boost::any_cast<long>(m["SupportReleasedKeep"]));
    }
    if (m.find("LocalLogRetentionSpace") != m.end() && !m["LocalLogRetentionSpace"].empty()) {
      localLogRetentionSpace = make_shared<string>(boost::any_cast<string>(m["LocalLogRetentionSpace"]));
    }
    if (m.find("SupportVolumeShadowCopy") != m.end() && !m["SupportVolumeShadowCopy"].empty()) {
      supportVolumeShadowCopy = make_shared<long>(boost::any_cast<long>(m["SupportVolumeShadowCopy"]));
    }
    if (m.find("BackupMethod") != m.end() && !m["BackupMethod"].empty()) {
      backupMethod = make_shared<string>(boost::any_cast<string>(m["BackupMethod"]));
    }
    if (m.find("LogBackupFrequency") != m.end() && !m["LogBackupFrequency"].empty()) {
      logBackupFrequency = make_shared<string>(boost::any_cast<string>(m["LogBackupFrequency"]));
    }
    if (m.find("PreferredNextBackupTime") != m.end() && !m["PreferredNextBackupTime"].empty()) {
      preferredNextBackupTime = make_shared<string>(boost::any_cast<string>(m["PreferredNextBackupTime"]));
    }
    if (m.find("HighSpaceUsageProtection") != m.end() && !m["HighSpaceUsageProtection"].empty()) {
      highSpaceUsageProtection = make_shared<string>(boost::any_cast<string>(m["HighSpaceUsageProtection"]));
    }
    if (m.find("ArchiveBackupRetentionPeriod") != m.end() && !m["ArchiveBackupRetentionPeriod"].empty()) {
      archiveBackupRetentionPeriod = make_shared<string>(boost::any_cast<string>(m["ArchiveBackupRetentionPeriod"]));
    }
    if (m.find("BackupInterval") != m.end() && !m["BackupInterval"].empty()) {
      backupInterval = make_shared<string>(boost::any_cast<string>(m["BackupInterval"]));
    }
    if (m.find("ReleasedKeepPolicy") != m.end() && !m["ReleasedKeepPolicy"].empty()) {
      releasedKeepPolicy = make_shared<string>(boost::any_cast<string>(m["ReleasedKeepPolicy"]));
    }
    if (m.find("PreferredBackupTime") != m.end() && !m["PreferredBackupTime"].empty()) {
      preferredBackupTime = make_shared<string>(boost::any_cast<string>(m["PreferredBackupTime"]));
    }
    if (m.find("LogBackupLocalRetentionNumber") != m.end() && !m["LogBackupLocalRetentionNumber"].empty()) {
      logBackupLocalRetentionNumber = make_shared<long>(boost::any_cast<long>(m["LogBackupLocalRetentionNumber"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("EnableBackupLog") != m.end() && !m["EnableBackupLog"].empty()) {
      enableBackupLog = make_shared<string>(boost::any_cast<string>(m["EnableBackupLog"]));
    }
    if (m.find("BackupLog") != m.end() && !m["BackupLog"].empty()) {
      backupLog = make_shared<string>(boost::any_cast<string>(m["BackupLog"]));
    }
  }


  virtual ~DescribeBackupPolicyResponseBody() = default;
};
class DescribeBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBackupPolicyResponseBody> body{};

  DescribeBackupPolicyResponse() {}

  explicit DescribeBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupPolicyResponse() = default;
};
class DescribeBackupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> backupId{};
  shared_ptr<string> backupStatus{};
  shared_ptr<string> backupMode{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeBackupsRequest() {}

  explicit DescribeBackupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (backupStatus) {
      res["BackupStatus"] = boost::any(*backupStatus);
    }
    if (backupMode) {
      res["BackupMode"] = boost::any(*backupMode);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("BackupStatus") != m.end() && !m["BackupStatus"].empty()) {
      backupStatus = make_shared<string>(boost::any_cast<string>(m["BackupStatus"]));
    }
    if (m.find("BackupMode") != m.end() && !m["BackupMode"].empty()) {
      backupMode = make_shared<string>(boost::any_cast<string>(m["BackupMode"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeBackupsRequest() = default;
};
class DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB : public Darabonba::Model {
public:
  shared_ptr<string> intranetDownloadLink{};
  shared_ptr<string> dataBase{};
  shared_ptr<string> downloadLink{};

  DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB() {}

  explicit DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (intranetDownloadLink) {
      res["IntranetDownloadLink"] = boost::any(*intranetDownloadLink);
    }
    if (dataBase) {
      res["DataBase"] = boost::any(*dataBase);
    }
    if (downloadLink) {
      res["DownloadLink"] = boost::any(*downloadLink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntranetDownloadLink") != m.end() && !m["IntranetDownloadLink"].empty()) {
      intranetDownloadLink = make_shared<string>(boost::any_cast<string>(m["IntranetDownloadLink"]));
    }
    if (m.find("DataBase") != m.end() && !m["DataBase"].empty()) {
      dataBase = make_shared<string>(boost::any_cast<string>(m["DataBase"]));
    }
    if (m.find("DownloadLink") != m.end() && !m["DownloadLink"].empty()) {
      downloadLink = make_shared<string>(boost::any_cast<string>(m["DownloadLink"]));
    }
  }


  virtual ~DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB() = default;
};
class DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB>> backupDownloadLinkByDB{};

  DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB() {}

  explicit DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupDownloadLinkByDB) {
      vector<boost::any> temp1;
      for(auto item1:*backupDownloadLinkByDB){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackupDownloadLinkByDB"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupDownloadLinkByDB") != m.end() && !m["BackupDownloadLinkByDB"].empty()) {
      if (typeid(vector<boost::any>) == m["BackupDownloadLinkByDB"].type()) {
        vector<DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackupDownloadLinkByDB"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backupDownloadLinkByDB = make_shared<vector<DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB>>(expect1);
      }
    }
  }


  virtual ~DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB() = default;
};
class DescribeBackupsResponseBodyItemsBackup : public Darabonba::Model {
public:
  shared_ptr<string> storageClass{};
  shared_ptr<string> encryption{};
  shared_ptr<string> backupStatus{};
  shared_ptr<string> storeStatus{};
  shared_ptr<long> consistentTime{};
  shared_ptr<string> backupType{};
  shared_ptr<string> copyOnlyBackup{};
  shared_ptr<string> backupEndTime{};
  shared_ptr<string> metaStatus{};
  shared_ptr<string> backupInitiator{};
  shared_ptr<string> backupIntranetDownloadURL{};
  shared_ptr<string> backupMethod{};
  shared_ptr<string> backupStartTime{};
  shared_ptr<string> backupDownloadURL{};
  shared_ptr<long> isAvail{};
  shared_ptr<string> backupId{};
  shared_ptr<string> hostInstanceID{};
  shared_ptr<long> backupSize{};
  shared_ptr<string> backupMode{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB> backupDownloadLinkByDB{};

  DescribeBackupsResponseBodyItemsBackup() {}

  explicit DescribeBackupsResponseBodyItemsBackup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (storageClass) {
      res["StorageClass"] = boost::any(*storageClass);
    }
    if (encryption) {
      res["Encryption"] = boost::any(*encryption);
    }
    if (backupStatus) {
      res["BackupStatus"] = boost::any(*backupStatus);
    }
    if (storeStatus) {
      res["StoreStatus"] = boost::any(*storeStatus);
    }
    if (consistentTime) {
      res["ConsistentTime"] = boost::any(*consistentTime);
    }
    if (backupType) {
      res["BackupType"] = boost::any(*backupType);
    }
    if (copyOnlyBackup) {
      res["CopyOnlyBackup"] = boost::any(*copyOnlyBackup);
    }
    if (backupEndTime) {
      res["BackupEndTime"] = boost::any(*backupEndTime);
    }
    if (metaStatus) {
      res["MetaStatus"] = boost::any(*metaStatus);
    }
    if (backupInitiator) {
      res["BackupInitiator"] = boost::any(*backupInitiator);
    }
    if (backupIntranetDownloadURL) {
      res["BackupIntranetDownloadURL"] = boost::any(*backupIntranetDownloadURL);
    }
    if (backupMethod) {
      res["BackupMethod"] = boost::any(*backupMethod);
    }
    if (backupStartTime) {
      res["BackupStartTime"] = boost::any(*backupStartTime);
    }
    if (backupDownloadURL) {
      res["BackupDownloadURL"] = boost::any(*backupDownloadURL);
    }
    if (isAvail) {
      res["IsAvail"] = boost::any(*isAvail);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (hostInstanceID) {
      res["HostInstanceID"] = boost::any(*hostInstanceID);
    }
    if (backupSize) {
      res["BackupSize"] = boost::any(*backupSize);
    }
    if (backupMode) {
      res["BackupMode"] = boost::any(*backupMode);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (backupDownloadLinkByDB) {
      res["BackupDownloadLinkByDB"] = backupDownloadLinkByDB ? boost::any(backupDownloadLinkByDB->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StorageClass") != m.end() && !m["StorageClass"].empty()) {
      storageClass = make_shared<string>(boost::any_cast<string>(m["StorageClass"]));
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      encryption = make_shared<string>(boost::any_cast<string>(m["Encryption"]));
    }
    if (m.find("BackupStatus") != m.end() && !m["BackupStatus"].empty()) {
      backupStatus = make_shared<string>(boost::any_cast<string>(m["BackupStatus"]));
    }
    if (m.find("StoreStatus") != m.end() && !m["StoreStatus"].empty()) {
      storeStatus = make_shared<string>(boost::any_cast<string>(m["StoreStatus"]));
    }
    if (m.find("ConsistentTime") != m.end() && !m["ConsistentTime"].empty()) {
      consistentTime = make_shared<long>(boost::any_cast<long>(m["ConsistentTime"]));
    }
    if (m.find("BackupType") != m.end() && !m["BackupType"].empty()) {
      backupType = make_shared<string>(boost::any_cast<string>(m["BackupType"]));
    }
    if (m.find("CopyOnlyBackup") != m.end() && !m["CopyOnlyBackup"].empty()) {
      copyOnlyBackup = make_shared<string>(boost::any_cast<string>(m["CopyOnlyBackup"]));
    }
    if (m.find("BackupEndTime") != m.end() && !m["BackupEndTime"].empty()) {
      backupEndTime = make_shared<string>(boost::any_cast<string>(m["BackupEndTime"]));
    }
    if (m.find("MetaStatus") != m.end() && !m["MetaStatus"].empty()) {
      metaStatus = make_shared<string>(boost::any_cast<string>(m["MetaStatus"]));
    }
    if (m.find("BackupInitiator") != m.end() && !m["BackupInitiator"].empty()) {
      backupInitiator = make_shared<string>(boost::any_cast<string>(m["BackupInitiator"]));
    }
    if (m.find("BackupIntranetDownloadURL") != m.end() && !m["BackupIntranetDownloadURL"].empty()) {
      backupIntranetDownloadURL = make_shared<string>(boost::any_cast<string>(m["BackupIntranetDownloadURL"]));
    }
    if (m.find("BackupMethod") != m.end() && !m["BackupMethod"].empty()) {
      backupMethod = make_shared<string>(boost::any_cast<string>(m["BackupMethod"]));
    }
    if (m.find("BackupStartTime") != m.end() && !m["BackupStartTime"].empty()) {
      backupStartTime = make_shared<string>(boost::any_cast<string>(m["BackupStartTime"]));
    }
    if (m.find("BackupDownloadURL") != m.end() && !m["BackupDownloadURL"].empty()) {
      backupDownloadURL = make_shared<string>(boost::any_cast<string>(m["BackupDownloadURL"]));
    }
    if (m.find("IsAvail") != m.end() && !m["IsAvail"].empty()) {
      isAvail = make_shared<long>(boost::any_cast<long>(m["IsAvail"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("HostInstanceID") != m.end() && !m["HostInstanceID"].empty()) {
      hostInstanceID = make_shared<string>(boost::any_cast<string>(m["HostInstanceID"]));
    }
    if (m.find("BackupSize") != m.end() && !m["BackupSize"].empty()) {
      backupSize = make_shared<long>(boost::any_cast<long>(m["BackupSize"]));
    }
    if (m.find("BackupMode") != m.end() && !m["BackupMode"].empty()) {
      backupMode = make_shared<string>(boost::any_cast<string>(m["BackupMode"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("BackupDownloadLinkByDB") != m.end() && !m["BackupDownloadLinkByDB"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackupDownloadLinkByDB"].type()) {
        DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackupDownloadLinkByDB"]));
        backupDownloadLinkByDB = make_shared<DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB>(model1);
      }
    }
  }


  virtual ~DescribeBackupsResponseBodyItemsBackup() = default;
};
class DescribeBackupsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBackupsResponseBodyItemsBackup>> backup{};

  DescribeBackupsResponseBodyItems() {}

  explicit DescribeBackupsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backup) {
      vector<boost::any> temp1;
      for(auto item1:*backup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Backup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backup") != m.end() && !m["Backup"].empty()) {
      if (typeid(vector<boost::any>) == m["Backup"].type()) {
        vector<DescribeBackupsResponseBodyItemsBackup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Backup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackupsResponseBodyItemsBackup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backup = make_shared<vector<DescribeBackupsResponseBodyItemsBackup>>(expect1);
      }
    }
  }


  virtual ~DescribeBackupsResponseBodyItems() = default;
};
class DescribeBackupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalEcsSnapshotSize{};
  shared_ptr<string> pageRecordCount{};
  shared_ptr<string> totalRecordCount{};
  shared_ptr<string> pageNumber{};
  shared_ptr<DescribeBackupsResponseBodyItems> items{};

  DescribeBackupsResponseBody() {}

  explicit DescribeBackupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalEcsSnapshotSize) {
      res["TotalEcsSnapshotSize"] = boost::any(*totalEcsSnapshotSize);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalEcsSnapshotSize") != m.end() && !m["TotalEcsSnapshotSize"].empty()) {
      totalEcsSnapshotSize = make_shared<long>(boost::any_cast<long>(m["TotalEcsSnapshotSize"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<string>(boost::any_cast<string>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<string>(boost::any_cast<string>(m["TotalRecordCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeBackupsResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeBackupsResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeBackupsResponseBody() = default;
};
class DescribeBackupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBackupsResponseBody> body{};

  DescribeBackupsResponse() {}

  explicit DescribeBackupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupsResponse() = default;
};
class DescribeBackupTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> flag{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> backupJobId{};
  shared_ptr<string> backupMode{};
  shared_ptr<string> backupJobStatus{};

  DescribeBackupTasksRequest() {}

  explicit DescribeBackupTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (backupJobId) {
      res["BackupJobId"] = boost::any(*backupJobId);
    }
    if (backupMode) {
      res["BackupMode"] = boost::any(*backupMode);
    }
    if (backupJobStatus) {
      res["BackupJobStatus"] = boost::any(*backupJobStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<string>(boost::any_cast<string>(m["Flag"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("BackupJobId") != m.end() && !m["BackupJobId"].empty()) {
      backupJobId = make_shared<long>(boost::any_cast<long>(m["BackupJobId"]));
    }
    if (m.find("BackupMode") != m.end() && !m["BackupMode"].empty()) {
      backupMode = make_shared<string>(boost::any_cast<string>(m["BackupMode"]));
    }
    if (m.find("BackupJobStatus") != m.end() && !m["BackupJobStatus"].empty()) {
      backupJobStatus = make_shared<string>(boost::any_cast<string>(m["BackupJobStatus"]));
    }
  }


  virtual ~DescribeBackupTasksRequest() = default;
};
class DescribeBackupTasksResponseBodyItemsBackupJob : public Darabonba::Model {
public:
  shared_ptr<string> process{};
  shared_ptr<string> backupJobId{};
  shared_ptr<string> backupStatus{};
  shared_ptr<string> jobMode{};
  shared_ptr<string> backupProgressStatus{};
  shared_ptr<string> backupId{};
  shared_ptr<string> taskAction{};

  DescribeBackupTasksResponseBodyItemsBackupJob() {}

  explicit DescribeBackupTasksResponseBodyItemsBackupJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (backupJobId) {
      res["BackupJobId"] = boost::any(*backupJobId);
    }
    if (backupStatus) {
      res["BackupStatus"] = boost::any(*backupStatus);
    }
    if (jobMode) {
      res["JobMode"] = boost::any(*jobMode);
    }
    if (backupProgressStatus) {
      res["BackupProgressStatus"] = boost::any(*backupProgressStatus);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (taskAction) {
      res["TaskAction"] = boost::any(*taskAction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
    if (m.find("BackupJobId") != m.end() && !m["BackupJobId"].empty()) {
      backupJobId = make_shared<string>(boost::any_cast<string>(m["BackupJobId"]));
    }
    if (m.find("BackupStatus") != m.end() && !m["BackupStatus"].empty()) {
      backupStatus = make_shared<string>(boost::any_cast<string>(m["BackupStatus"]));
    }
    if (m.find("JobMode") != m.end() && !m["JobMode"].empty()) {
      jobMode = make_shared<string>(boost::any_cast<string>(m["JobMode"]));
    }
    if (m.find("BackupProgressStatus") != m.end() && !m["BackupProgressStatus"].empty()) {
      backupProgressStatus = make_shared<string>(boost::any_cast<string>(m["BackupProgressStatus"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("TaskAction") != m.end() && !m["TaskAction"].empty()) {
      taskAction = make_shared<string>(boost::any_cast<string>(m["TaskAction"]));
    }
  }


  virtual ~DescribeBackupTasksResponseBodyItemsBackupJob() = default;
};
class DescribeBackupTasksResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBackupTasksResponseBodyItemsBackupJob>> backupJob{};

  DescribeBackupTasksResponseBodyItems() {}

  explicit DescribeBackupTasksResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupJob) {
      vector<boost::any> temp1;
      for(auto item1:*backupJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackupJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupJob") != m.end() && !m["BackupJob"].empty()) {
      if (typeid(vector<boost::any>) == m["BackupJob"].type()) {
        vector<DescribeBackupTasksResponseBodyItemsBackupJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackupJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackupTasksResponseBodyItemsBackupJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backupJob = make_shared<vector<DescribeBackupTasksResponseBodyItemsBackupJob>>(expect1);
      }
    }
  }


  virtual ~DescribeBackupTasksResponseBodyItems() = default;
};
class DescribeBackupTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBackupTasksResponseBodyItems> items{};

  DescribeBackupTasksResponseBody() {}

  explicit DescribeBackupTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeBackupTasksResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeBackupTasksResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeBackupTasksResponseBody() = default;
};
class DescribeBackupTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBackupTasksResponseBody> body{};

  DescribeBackupTasksResponse() {}

  explicit DescribeBackupTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupTasksResponse() = default;
};
class DescribeBinlogFilesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> ownerAccount{};

  DescribeBinlogFilesRequest() {}

  explicit DescribeBinlogFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeBinlogFilesRequest() = default;
};
class DescribeBinlogFilesResponseBodyItemsBinLogFile : public Darabonba::Model {
public:
  shared_ptr<string> remoteStatus{};
  shared_ptr<string> intranetDownloadLink{};
  shared_ptr<string> logBeginTime{};
  shared_ptr<string> linkExpiredTime{};
  shared_ptr<string> downloadLink{};
  shared_ptr<string> logFileName{};
  shared_ptr<string> checksum{};
  shared_ptr<string> logEndTime{};
  shared_ptr<string> hostInstanceID{};
  shared_ptr<long> fileSize{};

  DescribeBinlogFilesResponseBodyItemsBinLogFile() {}

  explicit DescribeBinlogFilesResponseBodyItemsBinLogFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remoteStatus) {
      res["RemoteStatus"] = boost::any(*remoteStatus);
    }
    if (intranetDownloadLink) {
      res["IntranetDownloadLink"] = boost::any(*intranetDownloadLink);
    }
    if (logBeginTime) {
      res["LogBeginTime"] = boost::any(*logBeginTime);
    }
    if (linkExpiredTime) {
      res["LinkExpiredTime"] = boost::any(*linkExpiredTime);
    }
    if (downloadLink) {
      res["DownloadLink"] = boost::any(*downloadLink);
    }
    if (logFileName) {
      res["LogFileName"] = boost::any(*logFileName);
    }
    if (checksum) {
      res["Checksum"] = boost::any(*checksum);
    }
    if (logEndTime) {
      res["LogEndTime"] = boost::any(*logEndTime);
    }
    if (hostInstanceID) {
      res["HostInstanceID"] = boost::any(*hostInstanceID);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemoteStatus") != m.end() && !m["RemoteStatus"].empty()) {
      remoteStatus = make_shared<string>(boost::any_cast<string>(m["RemoteStatus"]));
    }
    if (m.find("IntranetDownloadLink") != m.end() && !m["IntranetDownloadLink"].empty()) {
      intranetDownloadLink = make_shared<string>(boost::any_cast<string>(m["IntranetDownloadLink"]));
    }
    if (m.find("LogBeginTime") != m.end() && !m["LogBeginTime"].empty()) {
      logBeginTime = make_shared<string>(boost::any_cast<string>(m["LogBeginTime"]));
    }
    if (m.find("LinkExpiredTime") != m.end() && !m["LinkExpiredTime"].empty()) {
      linkExpiredTime = make_shared<string>(boost::any_cast<string>(m["LinkExpiredTime"]));
    }
    if (m.find("DownloadLink") != m.end() && !m["DownloadLink"].empty()) {
      downloadLink = make_shared<string>(boost::any_cast<string>(m["DownloadLink"]));
    }
    if (m.find("LogFileName") != m.end() && !m["LogFileName"].empty()) {
      logFileName = make_shared<string>(boost::any_cast<string>(m["LogFileName"]));
    }
    if (m.find("Checksum") != m.end() && !m["Checksum"].empty()) {
      checksum = make_shared<string>(boost::any_cast<string>(m["Checksum"]));
    }
    if (m.find("LogEndTime") != m.end() && !m["LogEndTime"].empty()) {
      logEndTime = make_shared<string>(boost::any_cast<string>(m["LogEndTime"]));
    }
    if (m.find("HostInstanceID") != m.end() && !m["HostInstanceID"].empty()) {
      hostInstanceID = make_shared<string>(boost::any_cast<string>(m["HostInstanceID"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
  }


  virtual ~DescribeBinlogFilesResponseBodyItemsBinLogFile() = default;
};
class DescribeBinlogFilesResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBinlogFilesResponseBodyItemsBinLogFile>> binLogFile{};

  DescribeBinlogFilesResponseBodyItems() {}

  explicit DescribeBinlogFilesResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binLogFile) {
      vector<boost::any> temp1;
      for(auto item1:*binLogFile){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BinLogFile"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BinLogFile") != m.end() && !m["BinLogFile"].empty()) {
      if (typeid(vector<boost::any>) == m["BinLogFile"].type()) {
        vector<DescribeBinlogFilesResponseBodyItemsBinLogFile> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BinLogFile"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBinlogFilesResponseBodyItemsBinLogFile model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        binLogFile = make_shared<vector<DescribeBinlogFilesResponseBodyItemsBinLogFile>>(expect1);
      }
    }
  }


  virtual ~DescribeBinlogFilesResponseBodyItems() = default;
};
class DescribeBinlogFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalFileSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeBinlogFilesResponseBodyItems> items{};

  DescribeBinlogFilesResponseBody() {}

  explicit DescribeBinlogFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalFileSize) {
      res["TotalFileSize"] = boost::any(*totalFileSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalFileSize") != m.end() && !m["TotalFileSize"].empty()) {
      totalFileSize = make_shared<long>(boost::any_cast<long>(m["TotalFileSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeBinlogFilesResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeBinlogFilesResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeBinlogFilesResponseBody() = default;
};
class DescribeBinlogFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBinlogFilesResponseBody> body{};

  DescribeBinlogFilesResponse() {}

  explicit DescribeBinlogFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBinlogFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBinlogFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBinlogFilesResponse() = default;
};
class DescribeCharacterSetNameRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> engine{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ownerAccount{};

  DescribeCharacterSetNameRequest() {}

  explicit DescribeCharacterSetNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeCharacterSetNameRequest() = default;
};
class DescribeCharacterSetNameResponseBodyCharacterSetNameItems : public Darabonba::Model {
public:
  shared_ptr<vector<string>> characterSetName{};

  DescribeCharacterSetNameResponseBodyCharacterSetNameItems() {}

  explicit DescribeCharacterSetNameResponseBodyCharacterSetNameItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (characterSetName) {
      res["CharacterSetName"] = boost::any(*characterSetName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharacterSetName") != m.end() && !m["CharacterSetName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CharacterSetName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CharacterSetName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      characterSetName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCharacterSetNameResponseBodyCharacterSetNameItems() = default;
};
class DescribeCharacterSetNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> engine{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCharacterSetNameResponseBodyCharacterSetNameItems> characterSetNameItems{};

  DescribeCharacterSetNameResponseBody() {}

  explicit DescribeCharacterSetNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (characterSetNameItems) {
      res["CharacterSetNameItems"] = characterSetNameItems ? boost::any(characterSetNameItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CharacterSetNameItems") != m.end() && !m["CharacterSetNameItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["CharacterSetNameItems"].type()) {
        DescribeCharacterSetNameResponseBodyCharacterSetNameItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CharacterSetNameItems"]));
        characterSetNameItems = make_shared<DescribeCharacterSetNameResponseBodyCharacterSetNameItems>(model1);
      }
    }
  }


  virtual ~DescribeCharacterSetNameResponseBody() = default;
};
class DescribeCharacterSetNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCharacterSetNameResponseBody> body{};

  DescribeCharacterSetNameResponse() {}

  explicit DescribeCharacterSetNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCharacterSetNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCharacterSetNameResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCharacterSetNameResponse() = default;
};
class DescribeCollationTimeZonesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeCollationTimeZonesRequest() {}

  explicit DescribeCollationTimeZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeCollationTimeZonesRequest() = default;
};
class DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone : public Darabonba::Model {
public:
  shared_ptr<string> timeZone{};
  shared_ptr<string> standardTimeOffset{};
  shared_ptr<string> description{};

  DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone() {}

  explicit DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    if (standardTimeOffset) {
      res["StandardTimeOffset"] = boost::any(*standardTimeOffset);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
    if (m.find("StandardTimeOffset") != m.end() && !m["StandardTimeOffset"].empty()) {
      standardTimeOffset = make_shared<string>(boost::any_cast<string>(m["StandardTimeOffset"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone() = default;
};
class DescribeCollationTimeZonesResponseBodyCollationTimeZones : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone>> collationTimeZone{};

  DescribeCollationTimeZonesResponseBodyCollationTimeZones() {}

  explicit DescribeCollationTimeZonesResponseBodyCollationTimeZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collationTimeZone) {
      vector<boost::any> temp1;
      for(auto item1:*collationTimeZone){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CollationTimeZone"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CollationTimeZone") != m.end() && !m["CollationTimeZone"].empty()) {
      if (typeid(vector<boost::any>) == m["CollationTimeZone"].type()) {
        vector<DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CollationTimeZone"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        collationTimeZone = make_shared<vector<DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone>>(expect1);
      }
    }
  }


  virtual ~DescribeCollationTimeZonesResponseBodyCollationTimeZones() = default;
};
class DescribeCollationTimeZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCollationTimeZonesResponseBodyCollationTimeZones> collationTimeZones{};

  DescribeCollationTimeZonesResponseBody() {}

  explicit DescribeCollationTimeZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (collationTimeZones) {
      res["CollationTimeZones"] = collationTimeZones ? boost::any(collationTimeZones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CollationTimeZones") != m.end() && !m["CollationTimeZones"].empty()) {
      if (typeid(map<string, boost::any>) == m["CollationTimeZones"].type()) {
        DescribeCollationTimeZonesResponseBodyCollationTimeZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CollationTimeZones"]));
        collationTimeZones = make_shared<DescribeCollationTimeZonesResponseBodyCollationTimeZones>(model1);
      }
    }
  }


  virtual ~DescribeCollationTimeZonesResponseBody() = default;
};
class DescribeCollationTimeZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCollationTimeZonesResponseBody> body{};

  DescribeCollationTimeZonesResponse() {}

  explicit DescribeCollationTimeZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCollationTimeZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCollationTimeZonesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCollationTimeZonesResponse() = default;
};
class DescribeCrossBackupMetaListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> backupSetId{};
  shared_ptr<string> getDbName{};
  shared_ptr<string> pattern{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> pageIndex{};
  shared_ptr<string> region{};

  DescribeCrossBackupMetaListRequest() {}

  explicit DescribeCrossBackupMetaListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (backupSetId) {
      res["BackupSetId"] = boost::any(*backupSetId);
    }
    if (getDbName) {
      res["GetDbName"] = boost::any(*getDbName);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("BackupSetId") != m.end() && !m["BackupSetId"].empty()) {
      backupSetId = make_shared<string>(boost::any_cast<string>(m["BackupSetId"]));
    }
    if (m.find("GetDbName") != m.end() && !m["GetDbName"].empty()) {
      getDbName = make_shared<string>(boost::any_cast<string>(m["GetDbName"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<string>(boost::any_cast<string>(m["PageIndex"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~DescribeCrossBackupMetaListRequest() = default;
};
class DescribeCrossBackupMetaListResponseBodyItemsMeta : public Darabonba::Model {
public:
  shared_ptr<string> tables{};
  shared_ptr<string> database{};
  shared_ptr<string> size{};

  DescribeCrossBackupMetaListResponseBodyItemsMeta() {}

  explicit DescribeCrossBackupMetaListResponseBodyItemsMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tables) {
      res["Tables"] = boost::any(*tables);
    }
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      tables = make_shared<string>(boost::any_cast<string>(m["Tables"]));
    }
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
  }


  virtual ~DescribeCrossBackupMetaListResponseBodyItemsMeta() = default;
};
class DescribeCrossBackupMetaListResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCrossBackupMetaListResponseBodyItemsMeta>> meta{};

  DescribeCrossBackupMetaListResponseBodyItems() {}

  explicit DescribeCrossBackupMetaListResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (meta) {
      vector<boost::any> temp1;
      for(auto item1:*meta){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Meta"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Meta") != m.end() && !m["Meta"].empty()) {
      if (typeid(vector<boost::any>) == m["Meta"].type()) {
        vector<DescribeCrossBackupMetaListResponseBodyItemsMeta> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Meta"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCrossBackupMetaListResponseBodyItemsMeta model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        meta = make_shared<vector<DescribeCrossBackupMetaListResponseBodyItemsMeta>>(expect1);
      }
    }
  }


  virtual ~DescribeCrossBackupMetaListResponseBodyItems() = default;
};
class DescribeCrossBackupMetaListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceName{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeCrossBackupMetaListResponseBodyItems> items{};

  DescribeCrossBackupMetaListResponseBody() {}

  explicit DescribeCrossBackupMetaListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeCrossBackupMetaListResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeCrossBackupMetaListResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeCrossBackupMetaListResponseBody() = default;
};
class DescribeCrossBackupMetaListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCrossBackupMetaListResponseBody> body{};

  DescribeCrossBackupMetaListResponse() {}

  explicit DescribeCrossBackupMetaListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCrossBackupMetaListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCrossBackupMetaListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCrossBackupMetaListResponse() = default;
};
class DescribeCrossRegionBackupDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeCrossRegionBackupDBInstanceRequest() {}

  explicit DescribeCrossRegionBackupDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeCrossRegionBackupDBInstanceRequest() = default;
};
class DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> logBackupEnabledTime{};
  shared_ptr<string> backupEnabled{};
  shared_ptr<string> DBInstanceStatus{};
  shared_ptr<string> lockMode{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> logBackupEnabled{};
  shared_ptr<long> retentType{};
  shared_ptr<long> retention{};
  shared_ptr<string> crossBackupType{};
  shared_ptr<string> crossBackupRegion{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> engine{};
  shared_ptr<string> backupEnabledTime{};
  shared_ptr<string> DBInstanceDescription{};

  DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem() {}

  explicit DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logBackupEnabledTime) {
      res["LogBackupEnabledTime"] = boost::any(*logBackupEnabledTime);
    }
    if (backupEnabled) {
      res["BackupEnabled"] = boost::any(*backupEnabled);
    }
    if (DBInstanceStatus) {
      res["DBInstanceStatus"] = boost::any(*DBInstanceStatus);
    }
    if (lockMode) {
      res["LockMode"] = boost::any(*lockMode);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (logBackupEnabled) {
      res["LogBackupEnabled"] = boost::any(*logBackupEnabled);
    }
    if (retentType) {
      res["RetentType"] = boost::any(*retentType);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (crossBackupType) {
      res["CrossBackupType"] = boost::any(*crossBackupType);
    }
    if (crossBackupRegion) {
      res["CrossBackupRegion"] = boost::any(*crossBackupRegion);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (backupEnabledTime) {
      res["BackupEnabledTime"] = boost::any(*backupEnabledTime);
    }
    if (DBInstanceDescription) {
      res["DBInstanceDescription"] = boost::any(*DBInstanceDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogBackupEnabledTime") != m.end() && !m["LogBackupEnabledTime"].empty()) {
      logBackupEnabledTime = make_shared<string>(boost::any_cast<string>(m["LogBackupEnabledTime"]));
    }
    if (m.find("BackupEnabled") != m.end() && !m["BackupEnabled"].empty()) {
      backupEnabled = make_shared<string>(boost::any_cast<string>(m["BackupEnabled"]));
    }
    if (m.find("DBInstanceStatus") != m.end() && !m["DBInstanceStatus"].empty()) {
      DBInstanceStatus = make_shared<string>(boost::any_cast<string>(m["DBInstanceStatus"]));
    }
    if (m.find("LockMode") != m.end() && !m["LockMode"].empty()) {
      lockMode = make_shared<string>(boost::any_cast<string>(m["LockMode"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("LogBackupEnabled") != m.end() && !m["LogBackupEnabled"].empty()) {
      logBackupEnabled = make_shared<string>(boost::any_cast<string>(m["LogBackupEnabled"]));
    }
    if (m.find("RetentType") != m.end() && !m["RetentType"].empty()) {
      retentType = make_shared<long>(boost::any_cast<long>(m["RetentType"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("CrossBackupType") != m.end() && !m["CrossBackupType"].empty()) {
      crossBackupType = make_shared<string>(boost::any_cast<string>(m["CrossBackupType"]));
    }
    if (m.find("CrossBackupRegion") != m.end() && !m["CrossBackupRegion"].empty()) {
      crossBackupRegion = make_shared<string>(boost::any_cast<string>(m["CrossBackupRegion"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("BackupEnabledTime") != m.end() && !m["BackupEnabledTime"].empty()) {
      backupEnabledTime = make_shared<string>(boost::any_cast<string>(m["BackupEnabledTime"]));
    }
    if (m.find("DBInstanceDescription") != m.end() && !m["DBInstanceDescription"].empty()) {
      DBInstanceDescription = make_shared<string>(boost::any_cast<string>(m["DBInstanceDescription"]));
    }
  }


  virtual ~DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem() = default;
};
class DescribeCrossRegionBackupDBInstanceResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem>> item{};

  DescribeCrossRegionBackupDBInstanceResponseBodyItems() {}

  explicit DescribeCrossRegionBackupDBInstanceResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~DescribeCrossRegionBackupDBInstanceResponseBodyItems() = default;
};
class DescribeCrossRegionBackupDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalRecords{};
  shared_ptr<long> itemsNumbers{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeCrossRegionBackupDBInstanceResponseBodyItems> items{};

  DescribeCrossRegionBackupDBInstanceResponseBody() {}

  explicit DescribeCrossRegionBackupDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalRecords) {
      res["TotalRecords"] = boost::any(*totalRecords);
    }
    if (itemsNumbers) {
      res["ItemsNumbers"] = boost::any(*itemsNumbers);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalRecords") != m.end() && !m["TotalRecords"].empty()) {
      totalRecords = make_shared<long>(boost::any_cast<long>(m["TotalRecords"]));
    }
    if (m.find("ItemsNumbers") != m.end() && !m["ItemsNumbers"].empty()) {
      itemsNumbers = make_shared<long>(boost::any_cast<long>(m["ItemsNumbers"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeCrossRegionBackupDBInstanceResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeCrossRegionBackupDBInstanceResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeCrossRegionBackupDBInstanceResponseBody() = default;
};
class DescribeCrossRegionBackupDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCrossRegionBackupDBInstanceResponseBody> body{};

  DescribeCrossRegionBackupDBInstanceResponse() {}

  explicit DescribeCrossRegionBackupDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCrossRegionBackupDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCrossRegionBackupDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCrossRegionBackupDBInstanceResponse() = default;
};
class DescribeCrossRegionBackupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> crossBackupRegion{};
  shared_ptr<long> crossBackupId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> backupId{};

  DescribeCrossRegionBackupsRequest() {}

  explicit DescribeCrossRegionBackupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (crossBackupRegion) {
      res["CrossBackupRegion"] = boost::any(*crossBackupRegion);
    }
    if (crossBackupId) {
      res["CrossBackupId"] = boost::any(*crossBackupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("CrossBackupRegion") != m.end() && !m["CrossBackupRegion"].empty()) {
      crossBackupRegion = make_shared<string>(boost::any_cast<string>(m["CrossBackupRegion"]));
    }
    if (m.find("CrossBackupId") != m.end() && !m["CrossBackupId"].empty()) {
      crossBackupId = make_shared<long>(boost::any_cast<long>(m["CrossBackupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<long>(boost::any_cast<long>(m["BackupId"]));
    }
  }


  virtual ~DescribeCrossRegionBackupsRequest() = default;
};
class DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> restoreRegion{};

  DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions() {}

  explicit DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (restoreRegion) {
      res["RestoreRegion"] = boost::any(*restoreRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RestoreRegion") != m.end() && !m["RestoreRegion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RestoreRegion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RestoreRegion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      restoreRegion = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions() = default;
};
class DescribeCrossRegionBackupsResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> consistentTime{};
  shared_ptr<string> DBInstanceStorageType{};
  shared_ptr<long> crossBackupId{};
  shared_ptr<string> backupType{};
  shared_ptr<string> backupStartTime{};
  shared_ptr<string> crossBackupSetLocation{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> crossBackupDownloadLink{};
  shared_ptr<string> backupEndTime{};
  shared_ptr<string> engineVersion{};
  shared_ptr<long> backupSetStatus{};
  shared_ptr<string> crossBackupSetFile{};
  shared_ptr<long> backupSetScale{};
  shared_ptr<long> crossBackupSetSize{};
  shared_ptr<string> crossBackupRegion{};
  shared_ptr<string> category{};
  shared_ptr<string> engine{};
  shared_ptr<string> backupMethod{};
  shared_ptr<DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions> restoreRegions{};

  DescribeCrossRegionBackupsResponseBodyItemsItem() {}

  explicit DescribeCrossRegionBackupsResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consistentTime) {
      res["ConsistentTime"] = boost::any(*consistentTime);
    }
    if (DBInstanceStorageType) {
      res["DBInstanceStorageType"] = boost::any(*DBInstanceStorageType);
    }
    if (crossBackupId) {
      res["CrossBackupId"] = boost::any(*crossBackupId);
    }
    if (backupType) {
      res["BackupType"] = boost::any(*backupType);
    }
    if (backupStartTime) {
      res["BackupStartTime"] = boost::any(*backupStartTime);
    }
    if (crossBackupSetLocation) {
      res["CrossBackupSetLocation"] = boost::any(*crossBackupSetLocation);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (crossBackupDownloadLink) {
      res["CrossBackupDownloadLink"] = boost::any(*crossBackupDownloadLink);
    }
    if (backupEndTime) {
      res["BackupEndTime"] = boost::any(*backupEndTime);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (backupSetStatus) {
      res["BackupSetStatus"] = boost::any(*backupSetStatus);
    }
    if (crossBackupSetFile) {
      res["CrossBackupSetFile"] = boost::any(*crossBackupSetFile);
    }
    if (backupSetScale) {
      res["BackupSetScale"] = boost::any(*backupSetScale);
    }
    if (crossBackupSetSize) {
      res["CrossBackupSetSize"] = boost::any(*crossBackupSetSize);
    }
    if (crossBackupRegion) {
      res["CrossBackupRegion"] = boost::any(*crossBackupRegion);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (backupMethod) {
      res["BackupMethod"] = boost::any(*backupMethod);
    }
    if (restoreRegions) {
      res["RestoreRegions"] = restoreRegions ? boost::any(restoreRegions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsistentTime") != m.end() && !m["ConsistentTime"].empty()) {
      consistentTime = make_shared<string>(boost::any_cast<string>(m["ConsistentTime"]));
    }
    if (m.find("DBInstanceStorageType") != m.end() && !m["DBInstanceStorageType"].empty()) {
      DBInstanceStorageType = make_shared<string>(boost::any_cast<string>(m["DBInstanceStorageType"]));
    }
    if (m.find("CrossBackupId") != m.end() && !m["CrossBackupId"].empty()) {
      crossBackupId = make_shared<long>(boost::any_cast<long>(m["CrossBackupId"]));
    }
    if (m.find("BackupType") != m.end() && !m["BackupType"].empty()) {
      backupType = make_shared<string>(boost::any_cast<string>(m["BackupType"]));
    }
    if (m.find("BackupStartTime") != m.end() && !m["BackupStartTime"].empty()) {
      backupStartTime = make_shared<string>(boost::any_cast<string>(m["BackupStartTime"]));
    }
    if (m.find("CrossBackupSetLocation") != m.end() && !m["CrossBackupSetLocation"].empty()) {
      crossBackupSetLocation = make_shared<string>(boost::any_cast<string>(m["CrossBackupSetLocation"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("CrossBackupDownloadLink") != m.end() && !m["CrossBackupDownloadLink"].empty()) {
      crossBackupDownloadLink = make_shared<string>(boost::any_cast<string>(m["CrossBackupDownloadLink"]));
    }
    if (m.find("BackupEndTime") != m.end() && !m["BackupEndTime"].empty()) {
      backupEndTime = make_shared<string>(boost::any_cast<string>(m["BackupEndTime"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("BackupSetStatus") != m.end() && !m["BackupSetStatus"].empty()) {
      backupSetStatus = make_shared<long>(boost::any_cast<long>(m["BackupSetStatus"]));
    }
    if (m.find("CrossBackupSetFile") != m.end() && !m["CrossBackupSetFile"].empty()) {
      crossBackupSetFile = make_shared<string>(boost::any_cast<string>(m["CrossBackupSetFile"]));
    }
    if (m.find("BackupSetScale") != m.end() && !m["BackupSetScale"].empty()) {
      backupSetScale = make_shared<long>(boost::any_cast<long>(m["BackupSetScale"]));
    }
    if (m.find("CrossBackupSetSize") != m.end() && !m["CrossBackupSetSize"].empty()) {
      crossBackupSetSize = make_shared<long>(boost::any_cast<long>(m["CrossBackupSetSize"]));
    }
    if (m.find("CrossBackupRegion") != m.end() && !m["CrossBackupRegion"].empty()) {
      crossBackupRegion = make_shared<string>(boost::any_cast<string>(m["CrossBackupRegion"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("BackupMethod") != m.end() && !m["BackupMethod"].empty()) {
      backupMethod = make_shared<string>(boost::any_cast<string>(m["BackupMethod"]));
    }
    if (m.find("RestoreRegions") != m.end() && !m["RestoreRegions"].empty()) {
      if (typeid(map<string, boost::any>) == m["RestoreRegions"].type()) {
        DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RestoreRegions"]));
        restoreRegions = make_shared<DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions>(model1);
      }
    }
  }


  virtual ~DescribeCrossRegionBackupsResponseBodyItemsItem() = default;
};
class DescribeCrossRegionBackupsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCrossRegionBackupsResponseBodyItemsItem>> item{};

  DescribeCrossRegionBackupsResponseBodyItems() {}

  explicit DescribeCrossRegionBackupsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<DescribeCrossRegionBackupsResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCrossRegionBackupsResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<DescribeCrossRegionBackupsResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~DescribeCrossRegionBackupsResponseBodyItems() = default;
};
class DescribeCrossRegionBackupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeCrossRegionBackupsResponseBodyItems> items{};

  DescribeCrossRegionBackupsResponseBody() {}

  explicit DescribeCrossRegionBackupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeCrossRegionBackupsResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeCrossRegionBackupsResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeCrossRegionBackupsResponseBody() = default;
};
class DescribeCrossRegionBackupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCrossRegionBackupsResponseBody> body{};

  DescribeCrossRegionBackupsResponse() {}

  explicit DescribeCrossRegionBackupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCrossRegionBackupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCrossRegionBackupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCrossRegionBackupsResponse() = default;
};
class DescribeCrossRegionLogBackupFilesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> crossBackupRegion{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeCrossRegionLogBackupFilesRequest() {}

  explicit DescribeCrossRegionLogBackupFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (crossBackupRegion) {
      res["CrossBackupRegion"] = boost::any(*crossBackupRegion);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("CrossBackupRegion") != m.end() && !m["CrossBackupRegion"].empty()) {
      crossBackupRegion = make_shared<string>(boost::any_cast<string>(m["CrossBackupRegion"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeCrossRegionLogBackupFilesRequest() = default;
};
class DescribeCrossRegionLogBackupFilesResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> logBeginTime{};
  shared_ptr<string> linkExpiredTime{};
  shared_ptr<string> crossIntranetDownloadLink{};
  shared_ptr<string> logFileName{};
  shared_ptr<string> crossBackupRegion{};
  shared_ptr<string> crossDownloadLink{};
  shared_ptr<long> crossLogBackupSize{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> crossLogBackupId{};
  shared_ptr<string> logEndTime{};

  DescribeCrossRegionLogBackupFilesResponseBodyItemsItem() {}

  explicit DescribeCrossRegionLogBackupFilesResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logBeginTime) {
      res["LogBeginTime"] = boost::any(*logBeginTime);
    }
    if (linkExpiredTime) {
      res["LinkExpiredTime"] = boost::any(*linkExpiredTime);
    }
    if (crossIntranetDownloadLink) {
      res["CrossIntranetDownloadLink"] = boost::any(*crossIntranetDownloadLink);
    }
    if (logFileName) {
      res["LogFileName"] = boost::any(*logFileName);
    }
    if (crossBackupRegion) {
      res["CrossBackupRegion"] = boost::any(*crossBackupRegion);
    }
    if (crossDownloadLink) {
      res["CrossDownloadLink"] = boost::any(*crossDownloadLink);
    }
    if (crossLogBackupSize) {
      res["CrossLogBackupSize"] = boost::any(*crossLogBackupSize);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (crossLogBackupId) {
      res["CrossLogBackupId"] = boost::any(*crossLogBackupId);
    }
    if (logEndTime) {
      res["LogEndTime"] = boost::any(*logEndTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogBeginTime") != m.end() && !m["LogBeginTime"].empty()) {
      logBeginTime = make_shared<string>(boost::any_cast<string>(m["LogBeginTime"]));
    }
    if (m.find("LinkExpiredTime") != m.end() && !m["LinkExpiredTime"].empty()) {
      linkExpiredTime = make_shared<string>(boost::any_cast<string>(m["LinkExpiredTime"]));
    }
    if (m.find("CrossIntranetDownloadLink") != m.end() && !m["CrossIntranetDownloadLink"].empty()) {
      crossIntranetDownloadLink = make_shared<string>(boost::any_cast<string>(m["CrossIntranetDownloadLink"]));
    }
    if (m.find("LogFileName") != m.end() && !m["LogFileName"].empty()) {
      logFileName = make_shared<string>(boost::any_cast<string>(m["LogFileName"]));
    }
    if (m.find("CrossBackupRegion") != m.end() && !m["CrossBackupRegion"].empty()) {
      crossBackupRegion = make_shared<string>(boost::any_cast<string>(m["CrossBackupRegion"]));
    }
    if (m.find("CrossDownloadLink") != m.end() && !m["CrossDownloadLink"].empty()) {
      crossDownloadLink = make_shared<string>(boost::any_cast<string>(m["CrossDownloadLink"]));
    }
    if (m.find("CrossLogBackupSize") != m.end() && !m["CrossLogBackupSize"].empty()) {
      crossLogBackupSize = make_shared<long>(boost::any_cast<long>(m["CrossLogBackupSize"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("CrossLogBackupId") != m.end() && !m["CrossLogBackupId"].empty()) {
      crossLogBackupId = make_shared<long>(boost::any_cast<long>(m["CrossLogBackupId"]));
    }
    if (m.find("LogEndTime") != m.end() && !m["LogEndTime"].empty()) {
      logEndTime = make_shared<string>(boost::any_cast<string>(m["LogEndTime"]));
    }
  }


  virtual ~DescribeCrossRegionLogBackupFilesResponseBodyItemsItem() = default;
};
class DescribeCrossRegionLogBackupFilesResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCrossRegionLogBackupFilesResponseBodyItemsItem>> item{};

  DescribeCrossRegionLogBackupFilesResponseBodyItems() {}

  explicit DescribeCrossRegionLogBackupFilesResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<DescribeCrossRegionLogBackupFilesResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCrossRegionLogBackupFilesResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<DescribeCrossRegionLogBackupFilesResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~DescribeCrossRegionLogBackupFilesResponseBodyItems() = default;
};
class DescribeCrossRegionLogBackupFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeCrossRegionLogBackupFilesResponseBodyItems> items{};

  DescribeCrossRegionLogBackupFilesResponseBody() {}

  explicit DescribeCrossRegionLogBackupFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeCrossRegionLogBackupFilesResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeCrossRegionLogBackupFilesResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeCrossRegionLogBackupFilesResponseBody() = default;
};
class DescribeCrossRegionLogBackupFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCrossRegionLogBackupFilesResponseBody> body{};

  DescribeCrossRegionLogBackupFilesResponse() {}

  explicit DescribeCrossRegionLogBackupFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCrossRegionLogBackupFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCrossRegionLogBackupFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCrossRegionLogBackupFilesResponse() = default;
};
class DescribeDatabasesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBName{};
  shared_ptr<string> DBStatus{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeDatabasesRequest() {}

  explicit DescribeDatabasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (DBStatus) {
      res["DBStatus"] = boost::any(*DBStatus);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("DBStatus") != m.end() && !m["DBStatus"].empty()) {
      DBStatus = make_shared<string>(boost::any_cast<string>(m["DBStatus"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeDatabasesRequest() = default;
};
class DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> accountPrivilege{};
  shared_ptr<string> accountPrivilegeDetail{};

  DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo() {}

  explicit DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (accountPrivilege) {
      res["AccountPrivilege"] = boost::any(*accountPrivilege);
    }
    if (accountPrivilegeDetail) {
      res["AccountPrivilegeDetail"] = boost::any(*accountPrivilegeDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AccountPrivilege") != m.end() && !m["AccountPrivilege"].empty()) {
      accountPrivilege = make_shared<string>(boost::any_cast<string>(m["AccountPrivilege"]));
    }
    if (m.find("AccountPrivilegeDetail") != m.end() && !m["AccountPrivilegeDetail"].empty()) {
      accountPrivilegeDetail = make_shared<string>(boost::any_cast<string>(m["AccountPrivilegeDetail"]));
    }
  }


  virtual ~DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo() = default;
};
class DescribeDatabasesResponseBodyDatabasesDatabaseAccounts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo>> accountPrivilegeInfo{};

  DescribeDatabasesResponseBodyDatabasesDatabaseAccounts() {}

  explicit DescribeDatabasesResponseBodyDatabasesDatabaseAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountPrivilegeInfo) {
      vector<boost::any> temp1;
      for(auto item1:*accountPrivilegeInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccountPrivilegeInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountPrivilegeInfo") != m.end() && !m["AccountPrivilegeInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AccountPrivilegeInfo"].type()) {
        vector<DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccountPrivilegeInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accountPrivilegeInfo = make_shared<vector<DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDatabasesResponseBodyDatabasesDatabaseAccounts() = default;
};
class DescribeDatabasesResponseBodyDatabasesDatabase : public Darabonba::Model {
public:
  shared_ptr<string> DBDescription{};
  shared_ptr<string> DBStatus{};
  shared_ptr<string> DBName{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> engine{};
  shared_ptr<string> characterSetName{};
  shared_ptr<DescribeDatabasesResponseBodyDatabasesDatabaseAccounts> accounts{};

  DescribeDatabasesResponseBodyDatabasesDatabase() {}

  explicit DescribeDatabasesResponseBodyDatabasesDatabase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBDescription) {
      res["DBDescription"] = boost::any(*DBDescription);
    }
    if (DBStatus) {
      res["DBStatus"] = boost::any(*DBStatus);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (characterSetName) {
      res["CharacterSetName"] = boost::any(*characterSetName);
    }
    if (accounts) {
      res["Accounts"] = accounts ? boost::any(accounts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBDescription") != m.end() && !m["DBDescription"].empty()) {
      DBDescription = make_shared<string>(boost::any_cast<string>(m["DBDescription"]));
    }
    if (m.find("DBStatus") != m.end() && !m["DBStatus"].empty()) {
      DBStatus = make_shared<string>(boost::any_cast<string>(m["DBStatus"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("CharacterSetName") != m.end() && !m["CharacterSetName"].empty()) {
      characterSetName = make_shared<string>(boost::any_cast<string>(m["CharacterSetName"]));
    }
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Accounts"].type()) {
        DescribeDatabasesResponseBodyDatabasesDatabaseAccounts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Accounts"]));
        accounts = make_shared<DescribeDatabasesResponseBodyDatabasesDatabaseAccounts>(model1);
      }
    }
  }


  virtual ~DescribeDatabasesResponseBodyDatabasesDatabase() = default;
};
class DescribeDatabasesResponseBodyDatabases : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDatabasesResponseBodyDatabasesDatabase>> database{};

  DescribeDatabasesResponseBodyDatabases() {}

  explicit DescribeDatabasesResponseBodyDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      vector<boost::any> temp1;
      for(auto item1:*database){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Database"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      if (typeid(vector<boost::any>) == m["Database"].type()) {
        vector<DescribeDatabasesResponseBodyDatabasesDatabase> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Database"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDatabasesResponseBodyDatabasesDatabase model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        database = make_shared<vector<DescribeDatabasesResponseBodyDatabasesDatabase>>(expect1);
      }
    }
  }


  virtual ~DescribeDatabasesResponseBodyDatabases() = default;
};
class DescribeDatabasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDatabasesResponseBodyDatabases> databases{};

  DescribeDatabasesResponseBody() {}

  explicit DescribeDatabasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (databases) {
      res["Databases"] = databases ? boost::any(databases->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(map<string, boost::any>) == m["Databases"].type()) {
        DescribeDatabasesResponseBodyDatabases model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Databases"]));
        databases = make_shared<DescribeDatabasesResponseBodyDatabases>(model1);
      }
    }
  }


  virtual ~DescribeDatabasesResponseBody() = default;
};
class DescribeDatabasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDatabasesResponseBody> body{};

  DescribeDatabasesResponse() {}

  explicit DescribeDatabasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDatabasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDatabasesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDatabasesResponse() = default;
};
class DescribeDBInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> expired{};

  DescribeDBInstanceAttributeRequest() {}

  explicit DescribeDBInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<string>(boost::any_cast<string>(m["Expired"]));
    }
  }


  virtual ~DescribeDBInstanceAttributeRequest() = default;
};
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone : public Darabonba::Model {
public:
  shared_ptr<string> zoneId{};

  DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone() {}

  explicit DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone() = default;
};
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone>> slaveZone{};

  DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones() {}

  explicit DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slaveZone) {
      vector<boost::any> temp1;
      for(auto item1:*slaveZone){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SlaveZone"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlaveZone") != m.end() && !m["SlaveZone"].empty()) {
      if (typeid(vector<boost::any>) == m["SlaveZone"].type()) {
        vector<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SlaveZone"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slaveZone = make_shared<vector<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones() = default;
};
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};

  DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId() {}

  explicit DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId() = default;
};
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId>> readOnlyDBInstanceId{};

  DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds() {}

  explicit DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (readOnlyDBInstanceId) {
      vector<boost::any> temp1;
      for(auto item1:*readOnlyDBInstanceId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReadOnlyDBInstanceId"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReadOnlyDBInstanceId") != m.end() && !m["ReadOnlyDBInstanceId"].empty()) {
      if (typeid(vector<boost::any>) == m["ReadOnlyDBInstanceId"].type()) {
        vector<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReadOnlyDBInstanceId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        readOnlyDBInstanceId = make_shared<vector<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds() = default;
};
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> DBInstanceId{};

  DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds() {}

  explicit DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DBInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DBInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      DBInstanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds() = default;
};
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra : public Darabonba::Model {
public:
  shared_ptr<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds> DBInstanceIds{};

  DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra() {}

  explicit DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceIds) {
      res["DBInstanceIds"] = DBInstanceIds ? boost::any(DBInstanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceIds") != m.end() && !m["DBInstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DBInstanceIds"].type()) {
        DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DBInstanceIds"]));
        DBInstanceIds = make_shared<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra() = default;
};
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> incrementSourceDBInstanceId{};
  shared_ptr<string> maintainTime{};
  shared_ptr<string> payType{};
  shared_ptr<string> availabilityValue{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> connectionString{};
  shared_ptr<string> superPermissionMode{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> masterInstanceId{};
  shared_ptr<string> autoUpgradeMinorVersion{};
  shared_ptr<string> expireTime{};
  shared_ptr<long> accountMaxQuantity{};
  shared_ptr<string> masterZone{};
  shared_ptr<string> guardDBInstanceId{};
  shared_ptr<long> DBInstanceStorage{};
  shared_ptr<string> timeZone{};
  shared_ptr<string> latestKernelVersion{};
  shared_ptr<long> tipsLevel{};
  shared_ptr<string> zoneId{};
  shared_ptr<long> maxConnections{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> tempDBInstanceId{};
  shared_ptr<string> advancedFeatures{};
  shared_ptr<string> DBInstanceStorageType{};
  shared_ptr<long> DBInstanceMemory{};
  shared_ptr<string> consoleVersion{};
  shared_ptr<string> connectionMode{};
  shared_ptr<string> port{};
  shared_ptr<string> lockMode{};
  shared_ptr<string> generalGroupName{};
  shared_ptr<string> vpcCloudInstanceId{};
  shared_ptr<string> collation{};
  shared_ptr<long> maxIOPS{};
  shared_ptr<string> tips{};
  shared_ptr<string> securityIPMode{};
  shared_ptr<string> DBInstanceClassType{};
  shared_ptr<long> proxyType{};
  shared_ptr<string> currentKernelVersion{};
  shared_ptr<string> DBInstanceDescription{};
  shared_ptr<string> DBInstanceCPU{};
  shared_ptr<string> DBInstanceNetType{};
  shared_ptr<string> DBInstanceType{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> DBInstanceStatus{};
  shared_ptr<long> DBMaxQuantity{};
  shared_ptr<string> regionId{};
  shared_ptr<string> readonlyInstanceSQLDelayedTime{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> category{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<string> engine{};
  shared_ptr<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones> slaveZones{};
  shared_ptr<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds> readOnlyDBInstanceIds{};
  shared_ptr<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra> extra{};

  DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute() {}

  explicit DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (incrementSourceDBInstanceId) {
      res["IncrementSourceDBInstanceId"] = boost::any(*incrementSourceDBInstanceId);
    }
    if (maintainTime) {
      res["MaintainTime"] = boost::any(*maintainTime);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (availabilityValue) {
      res["AvailabilityValue"] = boost::any(*availabilityValue);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (connectionString) {
      res["ConnectionString"] = boost::any(*connectionString);
    }
    if (superPermissionMode) {
      res["SuperPermissionMode"] = boost::any(*superPermissionMode);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (masterInstanceId) {
      res["MasterInstanceId"] = boost::any(*masterInstanceId);
    }
    if (autoUpgradeMinorVersion) {
      res["AutoUpgradeMinorVersion"] = boost::any(*autoUpgradeMinorVersion);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (accountMaxQuantity) {
      res["AccountMaxQuantity"] = boost::any(*accountMaxQuantity);
    }
    if (masterZone) {
      res["MasterZone"] = boost::any(*masterZone);
    }
    if (guardDBInstanceId) {
      res["GuardDBInstanceId"] = boost::any(*guardDBInstanceId);
    }
    if (DBInstanceStorage) {
      res["DBInstanceStorage"] = boost::any(*DBInstanceStorage);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    if (latestKernelVersion) {
      res["LatestKernelVersion"] = boost::any(*latestKernelVersion);
    }
    if (tipsLevel) {
      res["TipsLevel"] = boost::any(*tipsLevel);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (maxConnections) {
      res["MaxConnections"] = boost::any(*maxConnections);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (tempDBInstanceId) {
      res["TempDBInstanceId"] = boost::any(*tempDBInstanceId);
    }
    if (advancedFeatures) {
      res["AdvancedFeatures"] = boost::any(*advancedFeatures);
    }
    if (DBInstanceStorageType) {
      res["DBInstanceStorageType"] = boost::any(*DBInstanceStorageType);
    }
    if (DBInstanceMemory) {
      res["DBInstanceMemory"] = boost::any(*DBInstanceMemory);
    }
    if (consoleVersion) {
      res["ConsoleVersion"] = boost::any(*consoleVersion);
    }
    if (connectionMode) {
      res["ConnectionMode"] = boost::any(*connectionMode);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (lockMode) {
      res["LockMode"] = boost::any(*lockMode);
    }
    if (generalGroupName) {
      res["GeneralGroupName"] = boost::any(*generalGroupName);
    }
    if (vpcCloudInstanceId) {
      res["VpcCloudInstanceId"] = boost::any(*vpcCloudInstanceId);
    }
    if (collation) {
      res["Collation"] = boost::any(*collation);
    }
    if (maxIOPS) {
      res["MaxIOPS"] = boost::any(*maxIOPS);
    }
    if (tips) {
      res["Tips"] = boost::any(*tips);
    }
    if (securityIPMode) {
      res["SecurityIPMode"] = boost::any(*securityIPMode);
    }
    if (DBInstanceClassType) {
      res["DBInstanceClassType"] = boost::any(*DBInstanceClassType);
    }
    if (proxyType) {
      res["ProxyType"] = boost::any(*proxyType);
    }
    if (currentKernelVersion) {
      res["CurrentKernelVersion"] = boost::any(*currentKernelVersion);
    }
    if (DBInstanceDescription) {
      res["DBInstanceDescription"] = boost::any(*DBInstanceDescription);
    }
    if (DBInstanceCPU) {
      res["DBInstanceCPU"] = boost::any(*DBInstanceCPU);
    }
    if (DBInstanceNetType) {
      res["DBInstanceNetType"] = boost::any(*DBInstanceNetType);
    }
    if (DBInstanceType) {
      res["DBInstanceType"] = boost::any(*DBInstanceType);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (DBInstanceStatus) {
      res["DBInstanceStatus"] = boost::any(*DBInstanceStatus);
    }
    if (DBMaxQuantity) {
      res["DBMaxQuantity"] = boost::any(*DBMaxQuantity);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (readonlyInstanceSQLDelayedTime) {
      res["ReadonlyInstanceSQLDelayedTime"] = boost::any(*readonlyInstanceSQLDelayedTime);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (slaveZones) {
      res["SlaveZones"] = slaveZones ? boost::any(slaveZones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readOnlyDBInstanceIds) {
      res["ReadOnlyDBInstanceIds"] = readOnlyDBInstanceIds ? boost::any(readOnlyDBInstanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["Extra"] = extra ? boost::any(extra->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IncrementSourceDBInstanceId") != m.end() && !m["IncrementSourceDBInstanceId"].empty()) {
      incrementSourceDBInstanceId = make_shared<string>(boost::any_cast<string>(m["IncrementSourceDBInstanceId"]));
    }
    if (m.find("MaintainTime") != m.end() && !m["MaintainTime"].empty()) {
      maintainTime = make_shared<string>(boost::any_cast<string>(m["MaintainTime"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("AvailabilityValue") != m.end() && !m["AvailabilityValue"].empty()) {
      availabilityValue = make_shared<string>(boost::any_cast<string>(m["AvailabilityValue"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("ConnectionString") != m.end() && !m["ConnectionString"].empty()) {
      connectionString = make_shared<string>(boost::any_cast<string>(m["ConnectionString"]));
    }
    if (m.find("SuperPermissionMode") != m.end() && !m["SuperPermissionMode"].empty()) {
      superPermissionMode = make_shared<string>(boost::any_cast<string>(m["SuperPermissionMode"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("MasterInstanceId") != m.end() && !m["MasterInstanceId"].empty()) {
      masterInstanceId = make_shared<string>(boost::any_cast<string>(m["MasterInstanceId"]));
    }
    if (m.find("AutoUpgradeMinorVersion") != m.end() && !m["AutoUpgradeMinorVersion"].empty()) {
      autoUpgradeMinorVersion = make_shared<string>(boost::any_cast<string>(m["AutoUpgradeMinorVersion"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("AccountMaxQuantity") != m.end() && !m["AccountMaxQuantity"].empty()) {
      accountMaxQuantity = make_shared<long>(boost::any_cast<long>(m["AccountMaxQuantity"]));
    }
    if (m.find("MasterZone") != m.end() && !m["MasterZone"].empty()) {
      masterZone = make_shared<string>(boost::any_cast<string>(m["MasterZone"]));
    }
    if (m.find("GuardDBInstanceId") != m.end() && !m["GuardDBInstanceId"].empty()) {
      guardDBInstanceId = make_shared<string>(boost::any_cast<string>(m["GuardDBInstanceId"]));
    }
    if (m.find("DBInstanceStorage") != m.end() && !m["DBInstanceStorage"].empty()) {
      DBInstanceStorage = make_shared<long>(boost::any_cast<long>(m["DBInstanceStorage"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
    if (m.find("LatestKernelVersion") != m.end() && !m["LatestKernelVersion"].empty()) {
      latestKernelVersion = make_shared<string>(boost::any_cast<string>(m["LatestKernelVersion"]));
    }
    if (m.find("TipsLevel") != m.end() && !m["TipsLevel"].empty()) {
      tipsLevel = make_shared<long>(boost::any_cast<long>(m["TipsLevel"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("MaxConnections") != m.end() && !m["MaxConnections"].empty()) {
      maxConnections = make_shared<long>(boost::any_cast<long>(m["MaxConnections"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("TempDBInstanceId") != m.end() && !m["TempDBInstanceId"].empty()) {
      tempDBInstanceId = make_shared<string>(boost::any_cast<string>(m["TempDBInstanceId"]));
    }
    if (m.find("AdvancedFeatures") != m.end() && !m["AdvancedFeatures"].empty()) {
      advancedFeatures = make_shared<string>(boost::any_cast<string>(m["AdvancedFeatures"]));
    }
    if (m.find("DBInstanceStorageType") != m.end() && !m["DBInstanceStorageType"].empty()) {
      DBInstanceStorageType = make_shared<string>(boost::any_cast<string>(m["DBInstanceStorageType"]));
    }
    if (m.find("DBInstanceMemory") != m.end() && !m["DBInstanceMemory"].empty()) {
      DBInstanceMemory = make_shared<long>(boost::any_cast<long>(m["DBInstanceMemory"]));
    }
    if (m.find("ConsoleVersion") != m.end() && !m["ConsoleVersion"].empty()) {
      consoleVersion = make_shared<string>(boost::any_cast<string>(m["ConsoleVersion"]));
    }
    if (m.find("ConnectionMode") != m.end() && !m["ConnectionMode"].empty()) {
      connectionMode = make_shared<string>(boost::any_cast<string>(m["ConnectionMode"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("LockMode") != m.end() && !m["LockMode"].empty()) {
      lockMode = make_shared<string>(boost::any_cast<string>(m["LockMode"]));
    }
    if (m.find("GeneralGroupName") != m.end() && !m["GeneralGroupName"].empty()) {
      generalGroupName = make_shared<string>(boost::any_cast<string>(m["GeneralGroupName"]));
    }
    if (m.find("VpcCloudInstanceId") != m.end() && !m["VpcCloudInstanceId"].empty()) {
      vpcCloudInstanceId = make_shared<string>(boost::any_cast<string>(m["VpcCloudInstanceId"]));
    }
    if (m.find("Collation") != m.end() && !m["Collation"].empty()) {
      collation = make_shared<string>(boost::any_cast<string>(m["Collation"]));
    }
    if (m.find("MaxIOPS") != m.end() && !m["MaxIOPS"].empty()) {
      maxIOPS = make_shared<long>(boost::any_cast<long>(m["MaxIOPS"]));
    }
    if (m.find("Tips") != m.end() && !m["Tips"].empty()) {
      tips = make_shared<string>(boost::any_cast<string>(m["Tips"]));
    }
    if (m.find("SecurityIPMode") != m.end() && !m["SecurityIPMode"].empty()) {
      securityIPMode = make_shared<string>(boost::any_cast<string>(m["SecurityIPMode"]));
    }
    if (m.find("DBInstanceClassType") != m.end() && !m["DBInstanceClassType"].empty()) {
      DBInstanceClassType = make_shared<string>(boost::any_cast<string>(m["DBInstanceClassType"]));
    }
    if (m.find("ProxyType") != m.end() && !m["ProxyType"].empty()) {
      proxyType = make_shared<long>(boost::any_cast<long>(m["ProxyType"]));
    }
    if (m.find("CurrentKernelVersion") != m.end() && !m["CurrentKernelVersion"].empty()) {
      currentKernelVersion = make_shared<string>(boost::any_cast<string>(m["CurrentKernelVersion"]));
    }
    if (m.find("DBInstanceDescription") != m.end() && !m["DBInstanceDescription"].empty()) {
      DBInstanceDescription = make_shared<string>(boost::any_cast<string>(m["DBInstanceDescription"]));
    }
    if (m.find("DBInstanceCPU") != m.end() && !m["DBInstanceCPU"].empty()) {
      DBInstanceCPU = make_shared<string>(boost::any_cast<string>(m["DBInstanceCPU"]));
    }
    if (m.find("DBInstanceNetType") != m.end() && !m["DBInstanceNetType"].empty()) {
      DBInstanceNetType = make_shared<string>(boost::any_cast<string>(m["DBInstanceNetType"]));
    }
    if (m.find("DBInstanceType") != m.end() && !m["DBInstanceType"].empty()) {
      DBInstanceType = make_shared<string>(boost::any_cast<string>(m["DBInstanceType"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("DBInstanceStatus") != m.end() && !m["DBInstanceStatus"].empty()) {
      DBInstanceStatus = make_shared<string>(boost::any_cast<string>(m["DBInstanceStatus"]));
    }
    if (m.find("DBMaxQuantity") != m.end() && !m["DBMaxQuantity"].empty()) {
      DBMaxQuantity = make_shared<long>(boost::any_cast<long>(m["DBMaxQuantity"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReadonlyInstanceSQLDelayedTime") != m.end() && !m["ReadonlyInstanceSQLDelayedTime"].empty()) {
      readonlyInstanceSQLDelayedTime = make_shared<string>(boost::any_cast<string>(m["ReadonlyInstanceSQLDelayedTime"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("SlaveZones") != m.end() && !m["SlaveZones"].empty()) {
      if (typeid(map<string, boost::any>) == m["SlaveZones"].type()) {
        DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SlaveZones"]));
        slaveZones = make_shared<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones>(model1);
      }
    }
    if (m.find("ReadOnlyDBInstanceIds") != m.end() && !m["ReadOnlyDBInstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadOnlyDBInstanceIds"].type()) {
        DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadOnlyDBInstanceIds"]));
        readOnlyDBInstanceIds = make_shared<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds>(model1);
      }
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      if (typeid(map<string, boost::any>) == m["Extra"].type()) {
        DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Extra"]));
        extra = make_shared<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute() = default;
};
class DescribeDBInstanceAttributeResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute>> DBInstanceAttribute{};

  DescribeDBInstanceAttributeResponseBodyItems() {}

  explicit DescribeDBInstanceAttributeResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstanceAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstanceAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceAttribute") != m.end() && !m["DBInstanceAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstanceAttribute"].type()) {
        vector<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstanceAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstanceAttribute = make_shared<vector<DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstanceAttributeResponseBodyItems() = default;
};
class DescribeDBInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDBInstanceAttributeResponseBodyItems> items{};

  DescribeDBInstanceAttributeResponseBody() {}

  explicit DescribeDBInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeDBInstanceAttributeResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeDBInstanceAttributeResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceAttributeResponseBody() = default;
};
class DescribeDBInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstanceAttributeResponseBody> body{};

  DescribeDBInstanceAttributeResponse() {}

  explicit DescribeDBInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceAttributeResponse() = default;
};
class DescribeDBInstanceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};

  DescribeDBInstanceDetailRequest() {}

  explicit DescribeDBInstanceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~DescribeDBInstanceDetailRequest() = default;
};
class DescribeDBInstanceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> activationState{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> licenseType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> regionId{};

  DescribeDBInstanceDetailResponseBody() {}

  explicit DescribeDBInstanceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activationState) {
      res["ActivationState"] = boost::any(*activationState);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (licenseType) {
      res["LicenseType"] = boost::any(*licenseType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivationState") != m.end() && !m["ActivationState"].empty()) {
      activationState = make_shared<string>(boost::any_cast<string>(m["ActivationState"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("LicenseType") != m.end() && !m["LicenseType"].empty()) {
      licenseType = make_shared<string>(boost::any_cast<string>(m["LicenseType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDBInstanceDetailResponseBody() = default;
};
class DescribeDBInstanceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstanceDetailResponseBody> body{};

  DescribeDBInstanceDetailResponse() {}

  explicit DescribeDBInstanceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstanceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstanceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceDetailResponse() = default;
};
class DescribeDBInstanceEncryptionKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> encryptionKey{};
  shared_ptr<string> targetRegionId{};

  DescribeDBInstanceEncryptionKeyRequest() {}

  explicit DescribeDBInstanceEncryptionKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (encryptionKey) {
      res["EncryptionKey"] = boost::any(*encryptionKey);
    }
    if (targetRegionId) {
      res["TargetRegionId"] = boost::any(*targetRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("EncryptionKey") != m.end() && !m["EncryptionKey"].empty()) {
      encryptionKey = make_shared<string>(boost::any_cast<string>(m["EncryptionKey"]));
    }
    if (m.find("TargetRegionId") != m.end() && !m["TargetRegionId"].empty()) {
      targetRegionId = make_shared<string>(boost::any_cast<string>(m["TargetRegionId"]));
    }
  }


  virtual ~DescribeDBInstanceEncryptionKeyRequest() = default;
};
class DescribeDBInstanceEncryptionKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deleteDate{};
  shared_ptr<string> requestId{};
  shared_ptr<string> description{};
  shared_ptr<string> origin{};
  shared_ptr<string> materialExpireTime{};
  shared_ptr<string> encryptionKeyStatus{};
  shared_ptr<string> keyUsage{};
  shared_ptr<string> encryptionKey{};
  shared_ptr<string> creator{};

  DescribeDBInstanceEncryptionKeyResponseBody() {}

  explicit DescribeDBInstanceEncryptionKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteDate) {
      res["DeleteDate"] = boost::any(*deleteDate);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (origin) {
      res["Origin"] = boost::any(*origin);
    }
    if (materialExpireTime) {
      res["MaterialExpireTime"] = boost::any(*materialExpireTime);
    }
    if (encryptionKeyStatus) {
      res["EncryptionKeyStatus"] = boost::any(*encryptionKeyStatus);
    }
    if (keyUsage) {
      res["KeyUsage"] = boost::any(*keyUsage);
    }
    if (encryptionKey) {
      res["EncryptionKey"] = boost::any(*encryptionKey);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteDate") != m.end() && !m["DeleteDate"].empty()) {
      deleteDate = make_shared<string>(boost::any_cast<string>(m["DeleteDate"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Origin") != m.end() && !m["Origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["Origin"]));
    }
    if (m.find("MaterialExpireTime") != m.end() && !m["MaterialExpireTime"].empty()) {
      materialExpireTime = make_shared<string>(boost::any_cast<string>(m["MaterialExpireTime"]));
    }
    if (m.find("EncryptionKeyStatus") != m.end() && !m["EncryptionKeyStatus"].empty()) {
      encryptionKeyStatus = make_shared<string>(boost::any_cast<string>(m["EncryptionKeyStatus"]));
    }
    if (m.find("KeyUsage") != m.end() && !m["KeyUsage"].empty()) {
      keyUsage = make_shared<string>(boost::any_cast<string>(m["KeyUsage"]));
    }
    if (m.find("EncryptionKey") != m.end() && !m["EncryptionKey"].empty()) {
      encryptionKey = make_shared<string>(boost::any_cast<string>(m["EncryptionKey"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
  }


  virtual ~DescribeDBInstanceEncryptionKeyResponseBody() = default;
};
class DescribeDBInstanceEncryptionKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstanceEncryptionKeyResponseBody> body{};

  DescribeDBInstanceEncryptionKeyResponse() {}

  explicit DescribeDBInstanceEncryptionKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstanceEncryptionKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstanceEncryptionKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceEncryptionKeyResponse() = default;
};
class DescribeDBInstanceHAConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> ownerAccount{};

  DescribeDBInstanceHAConfigRequest() {}

  explicit DescribeDBInstanceHAConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeDBInstanceHAConfigRequest() = default;
};
class DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo : public Darabonba::Model {
public:
  shared_ptr<string> logSyncTime{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> syncStatus{};
  shared_ptr<string> dataSyncTime{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> regionId{};

  DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo() {}

  explicit DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logSyncTime) {
      res["LogSyncTime"] = boost::any(*logSyncTime);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (syncStatus) {
      res["SyncStatus"] = boost::any(*syncStatus);
    }
    if (dataSyncTime) {
      res["DataSyncTime"] = boost::any(*dataSyncTime);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogSyncTime") != m.end() && !m["LogSyncTime"].empty()) {
      logSyncTime = make_shared<string>(boost::any_cast<string>(m["LogSyncTime"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("SyncStatus") != m.end() && !m["SyncStatus"].empty()) {
      syncStatus = make_shared<string>(boost::any_cast<string>(m["SyncStatus"]));
    }
    if (m.find("DataSyncTime") != m.end() && !m["DataSyncTime"].empty()) {
      dataSyncTime = make_shared<string>(boost::any_cast<string>(m["DataSyncTime"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo() = default;
};
class DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo>> nodeInfo{};

  DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos() {}

  explicit DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeInfo) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeInfo") != m.end() && !m["NodeInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInfo"].type()) {
        vector<DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInfo = make_shared<vector<DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos() = default;
};
class DescribeDBInstanceHAConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> HAMode{};
  shared_ptr<string> syncMode{};
  shared_ptr<DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos> hostInstanceInfos{};

  DescribeDBInstanceHAConfigResponseBody() {}

  explicit DescribeDBInstanceHAConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (HAMode) {
      res["HAMode"] = boost::any(*HAMode);
    }
    if (syncMode) {
      res["SyncMode"] = boost::any(*syncMode);
    }
    if (hostInstanceInfos) {
      res["HostInstanceInfos"] = hostInstanceInfos ? boost::any(hostInstanceInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HAMode") != m.end() && !m["HAMode"].empty()) {
      HAMode = make_shared<string>(boost::any_cast<string>(m["HAMode"]));
    }
    if (m.find("SyncMode") != m.end() && !m["SyncMode"].empty()) {
      syncMode = make_shared<string>(boost::any_cast<string>(m["SyncMode"]));
    }
    if (m.find("HostInstanceInfos") != m.end() && !m["HostInstanceInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostInstanceInfos"].type()) {
        DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostInstanceInfos"]));
        hostInstanceInfos = make_shared<DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceHAConfigResponseBody() = default;
};
class DescribeDBInstanceHAConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstanceHAConfigResponseBody> body{};

  DescribeDBInstanceHAConfigResponse() {}

  explicit DescribeDBInstanceHAConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstanceHAConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstanceHAConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceHAConfigResponse() = default;
};
class DescribeDBInstanceIPArrayListRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> whitelistNetworkType{};

  DescribeDBInstanceIPArrayListRequest() {}

  explicit DescribeDBInstanceIPArrayListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (whitelistNetworkType) {
      res["WhitelistNetworkType"] = boost::any(*whitelistNetworkType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("WhitelistNetworkType") != m.end() && !m["WhitelistNetworkType"].empty()) {
      whitelistNetworkType = make_shared<string>(boost::any_cast<string>(m["WhitelistNetworkType"]));
    }
  }


  virtual ~DescribeDBInstanceIPArrayListRequest() = default;
};
class DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceIPArrayAttribute{};
  shared_ptr<string> DBInstanceIPArrayName{};
  shared_ptr<string> securityIPType{};
  shared_ptr<string> securityIPList{};

  DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray() {}

  explicit DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceIPArrayAttribute) {
      res["DBInstanceIPArrayAttribute"] = boost::any(*DBInstanceIPArrayAttribute);
    }
    if (DBInstanceIPArrayName) {
      res["DBInstanceIPArrayName"] = boost::any(*DBInstanceIPArrayName);
    }
    if (securityIPType) {
      res["SecurityIPType"] = boost::any(*securityIPType);
    }
    if (securityIPList) {
      res["SecurityIPList"] = boost::any(*securityIPList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceIPArrayAttribute") != m.end() && !m["DBInstanceIPArrayAttribute"].empty()) {
      DBInstanceIPArrayAttribute = make_shared<string>(boost::any_cast<string>(m["DBInstanceIPArrayAttribute"]));
    }
    if (m.find("DBInstanceIPArrayName") != m.end() && !m["DBInstanceIPArrayName"].empty()) {
      DBInstanceIPArrayName = make_shared<string>(boost::any_cast<string>(m["DBInstanceIPArrayName"]));
    }
    if (m.find("SecurityIPType") != m.end() && !m["SecurityIPType"].empty()) {
      securityIPType = make_shared<string>(boost::any_cast<string>(m["SecurityIPType"]));
    }
    if (m.find("SecurityIPList") != m.end() && !m["SecurityIPList"].empty()) {
      securityIPList = make_shared<string>(boost::any_cast<string>(m["SecurityIPList"]));
    }
  }


  virtual ~DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray() = default;
};
class DescribeDBInstanceIPArrayListResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray>> DBInstanceIPArray{};

  DescribeDBInstanceIPArrayListResponseBodyItems() {}

  explicit DescribeDBInstanceIPArrayListResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceIPArray) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstanceIPArray){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstanceIPArray"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceIPArray") != m.end() && !m["DBInstanceIPArray"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstanceIPArray"].type()) {
        vector<DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstanceIPArray"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstanceIPArray = make_shared<vector<DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstanceIPArrayListResponseBodyItems() = default;
};
class DescribeDBInstanceIPArrayListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDBInstanceIPArrayListResponseBodyItems> items{};

  DescribeDBInstanceIPArrayListResponseBody() {}

  explicit DescribeDBInstanceIPArrayListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeDBInstanceIPArrayListResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeDBInstanceIPArrayListResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceIPArrayListResponseBody() = default;
};
class DescribeDBInstanceIPArrayListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstanceIPArrayListResponseBody> body{};

  DescribeDBInstanceIPArrayListResponse() {}

  explicit DescribeDBInstanceIPArrayListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstanceIPArrayListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstanceIPArrayListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceIPArrayListResponse() = default;
};
class DescribeDBInstanceIpHostnameRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> regionId{};

  DescribeDBInstanceIpHostnameRequest() {}

  explicit DescribeDBInstanceIpHostnameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDBInstanceIpHostnameRequest() = default;
};
class DescribeDBInstanceIpHostnameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> ipHostnameInfos{};

  DescribeDBInstanceIpHostnameResponseBody() {}

  explicit DescribeDBInstanceIpHostnameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ipHostnameInfos) {
      res["IpHostnameInfos"] = boost::any(*ipHostnameInfos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("IpHostnameInfos") != m.end() && !m["IpHostnameInfos"].empty()) {
      ipHostnameInfos = make_shared<string>(boost::any_cast<string>(m["IpHostnameInfos"]));
    }
  }


  virtual ~DescribeDBInstanceIpHostnameResponseBody() = default;
};
class DescribeDBInstanceIpHostnameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstanceIpHostnameResponseBody> body{};

  DescribeDBInstanceIpHostnameResponse() {}

  explicit DescribeDBInstanceIpHostnameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstanceIpHostnameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstanceIpHostnameResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceIpHostnameResponse() = default;
};
class DescribeDBInstanceMetricsRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceName{};

  DescribeDBInstanceMetricsRequest() {}

  explicit DescribeDBInstanceMetricsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
  }


  virtual ~DescribeDBInstanceMetricsRequest() = default;
};
class DescribeDBInstanceMetricsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<string> groupKey{};
  shared_ptr<long> sortRule{};
  shared_ptr<string> description{};
  shared_ptr<string> unit{};
  shared_ptr<string> metricsKey{};
  shared_ptr<string> groupKeyType{};
  shared_ptr<string> method{};
  shared_ptr<string> dimension{};
  shared_ptr<string> metricsKeyAlias{};

  DescribeDBInstanceMetricsResponseBodyItems() {}

  explicit DescribeDBInstanceMetricsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupKey) {
      res["GroupKey"] = boost::any(*groupKey);
    }
    if (sortRule) {
      res["SortRule"] = boost::any(*sortRule);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (metricsKey) {
      res["MetricsKey"] = boost::any(*metricsKey);
    }
    if (groupKeyType) {
      res["GroupKeyType"] = boost::any(*groupKeyType);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (metricsKeyAlias) {
      res["MetricsKeyAlias"] = boost::any(*metricsKeyAlias);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupKey") != m.end() && !m["GroupKey"].empty()) {
      groupKey = make_shared<string>(boost::any_cast<string>(m["GroupKey"]));
    }
    if (m.find("SortRule") != m.end() && !m["SortRule"].empty()) {
      sortRule = make_shared<long>(boost::any_cast<long>(m["SortRule"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("MetricsKey") != m.end() && !m["MetricsKey"].empty()) {
      metricsKey = make_shared<string>(boost::any_cast<string>(m["MetricsKey"]));
    }
    if (m.find("GroupKeyType") != m.end() && !m["GroupKeyType"].empty()) {
      groupKeyType = make_shared<string>(boost::any_cast<string>(m["GroupKeyType"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("MetricsKeyAlias") != m.end() && !m["MetricsKeyAlias"].empty()) {
      metricsKeyAlias = make_shared<string>(boost::any_cast<string>(m["MetricsKeyAlias"]));
    }
  }


  virtual ~DescribeDBInstanceMetricsResponseBodyItems() = default;
};
class DescribeDBInstanceMetricsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDBInstanceMetricsResponseBodyItems>> items{};

  DescribeDBInstanceMetricsResponseBody() {}

  explicit DescribeDBInstanceMetricsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<DescribeDBInstanceMetricsResponseBodyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstanceMetricsResponseBodyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<DescribeDBInstanceMetricsResponseBodyItems>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstanceMetricsResponseBody() = default;
};
class DescribeDBInstanceMetricsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstanceMetricsResponseBody> body{};

  DescribeDBInstanceMetricsResponse() {}

  explicit DescribeDBInstanceMetricsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstanceMetricsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstanceMetricsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceMetricsResponse() = default;
};
class DescribeDBInstanceMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> ownerAccount{};

  DescribeDBInstanceMonitorRequest() {}

  explicit DescribeDBInstanceMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeDBInstanceMonitorRequest() = default;
};
class DescribeDBInstanceMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> period{};
  shared_ptr<string> requestId{};

  DescribeDBInstanceMonitorResponseBody() {}

  explicit DescribeDBInstanceMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDBInstanceMonitorResponseBody() = default;
};
class DescribeDBInstanceMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstanceMonitorResponseBody> body{};

  DescribeDBInstanceMonitorResponse() {}

  explicit DescribeDBInstanceMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstanceMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstanceMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceMonitorResponse() = default;
};
class DescribeDBInstanceNetInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> flag{};
  shared_ptr<string> DBInstanceNetRWSplitType{};
  shared_ptr<string> ownerAccount{};

  DescribeDBInstanceNetInfoRequest() {}

  explicit DescribeDBInstanceNetInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (DBInstanceNetRWSplitType) {
      res["DBInstanceNetRWSplitType"] = boost::any(*DBInstanceNetRWSplitType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("DBInstanceNetRWSplitType") != m.end() && !m["DBInstanceNetRWSplitType"].empty()) {
      DBInstanceNetRWSplitType = make_shared<string>(boost::any_cast<string>(m["DBInstanceNetRWSplitType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeDBInstanceNetInfoRequest() = default;
};
class DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup : public Darabonba::Model {
public:
  shared_ptr<string> securityIPs{};
  shared_ptr<string> securityIPGroupName{};

  DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup() {}

  explicit DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityIPs) {
      res["SecurityIPs"] = boost::any(*securityIPs);
    }
    if (securityIPGroupName) {
      res["SecurityIPGroupName"] = boost::any(*securityIPGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityIPs") != m.end() && !m["SecurityIPs"].empty()) {
      securityIPs = make_shared<string>(boost::any_cast<string>(m["SecurityIPs"]));
    }
    if (m.find("SecurityIPGroupName") != m.end() && !m["SecurityIPGroupName"].empty()) {
      securityIPGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIPGroupName"]));
    }
  }


  virtual ~DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup() = default;
};
class DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup>> securityIPGroup{};

  DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups() {}

  explicit DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityIPGroup) {
      vector<boost::any> temp1;
      for(auto item1:*securityIPGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["securityIPGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("securityIPGroup") != m.end() && !m["securityIPGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["securityIPGroup"].type()) {
        vector<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["securityIPGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityIPGroup = make_shared<vector<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups() = default;
};
class DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight : public Darabonba::Model {
public:
  shared_ptr<string> availability{};
  shared_ptr<string> weight{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> role{};
  shared_ptr<string> DBInstanceType{};

  DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight() {}

  explicit DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availability) {
      res["Availability"] = boost::any(*availability);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (DBInstanceType) {
      res["DBInstanceType"] = boost::any(*DBInstanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Availability") != m.end() && !m["Availability"].empty()) {
      availability = make_shared<string>(boost::any_cast<string>(m["Availability"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("DBInstanceType") != m.end() && !m["DBInstanceType"].empty()) {
      DBInstanceType = make_shared<string>(boost::any_cast<string>(m["DBInstanceType"]));
    }
  }


  virtual ~DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight() = default;
};
class DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight>> DBInstanceWeight{};

  DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights() {}

  explicit DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceWeight) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstanceWeight){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstanceWeight"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceWeight") != m.end() && !m["DBInstanceWeight"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstanceWeight"].type()) {
        vector<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstanceWeight"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstanceWeight = make_shared<vector<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights() = default;
};
class DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo : public Darabonba::Model {
public:
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> connectionStringType{};
  shared_ptr<string> connectionString{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> upgradeable{};
  shared_ptr<string> maxDelayTime{};
  shared_ptr<string> IPType{};
  shared_ptr<string> port{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> distributionType{};
  shared_ptr<string> IPAddress{};
  shared_ptr<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups> securityIPGroups{};
  shared_ptr<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights> DBInstanceWeights{};

  DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo() {}

  explicit DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (connectionStringType) {
      res["ConnectionStringType"] = boost::any(*connectionStringType);
    }
    if (connectionString) {
      res["ConnectionString"] = boost::any(*connectionString);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (upgradeable) {
      res["Upgradeable"] = boost::any(*upgradeable);
    }
    if (maxDelayTime) {
      res["MaxDelayTime"] = boost::any(*maxDelayTime);
    }
    if (IPType) {
      res["IPType"] = boost::any(*IPType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (distributionType) {
      res["DistributionType"] = boost::any(*distributionType);
    }
    if (IPAddress) {
      res["IPAddress"] = boost::any(*IPAddress);
    }
    if (securityIPGroups) {
      res["SecurityIPGroups"] = securityIPGroups ? boost::any(securityIPGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (DBInstanceWeights) {
      res["DBInstanceWeights"] = DBInstanceWeights ? boost::any(DBInstanceWeights->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ConnectionStringType") != m.end() && !m["ConnectionStringType"].empty()) {
      connectionStringType = make_shared<string>(boost::any_cast<string>(m["ConnectionStringType"]));
    }
    if (m.find("ConnectionString") != m.end() && !m["ConnectionString"].empty()) {
      connectionString = make_shared<string>(boost::any_cast<string>(m["ConnectionString"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("Upgradeable") != m.end() && !m["Upgradeable"].empty()) {
      upgradeable = make_shared<string>(boost::any_cast<string>(m["Upgradeable"]));
    }
    if (m.find("MaxDelayTime") != m.end() && !m["MaxDelayTime"].empty()) {
      maxDelayTime = make_shared<string>(boost::any_cast<string>(m["MaxDelayTime"]));
    }
    if (m.find("IPType") != m.end() && !m["IPType"].empty()) {
      IPType = make_shared<string>(boost::any_cast<string>(m["IPType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("DistributionType") != m.end() && !m["DistributionType"].empty()) {
      distributionType = make_shared<string>(boost::any_cast<string>(m["DistributionType"]));
    }
    if (m.find("IPAddress") != m.end() && !m["IPAddress"].empty()) {
      IPAddress = make_shared<string>(boost::any_cast<string>(m["IPAddress"]));
    }
    if (m.find("SecurityIPGroups") != m.end() && !m["SecurityIPGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityIPGroups"].type()) {
        DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityIPGroups"]));
        securityIPGroups = make_shared<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups>(model1);
      }
    }
    if (m.find("DBInstanceWeights") != m.end() && !m["DBInstanceWeights"].empty()) {
      if (typeid(map<string, boost::any>) == m["DBInstanceWeights"].type()) {
        DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DBInstanceWeights"]));
        DBInstanceWeights = make_shared<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo() = default;
};
class DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo>> DBInstanceNetInfo{};

  DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos() {}

  explicit DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceNetInfo) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstanceNetInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstanceNetInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceNetInfo") != m.end() && !m["DBInstanceNetInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstanceNetInfo"].type()) {
        vector<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstanceNetInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstanceNetInfo = make_shared<vector<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos() = default;
};
class DescribeDBInstanceNetInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> securityIPMode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos> DBInstanceNetInfos{};

  DescribeDBInstanceNetInfoResponseBody() {}

  explicit DescribeDBInstanceNetInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityIPMode) {
      res["SecurityIPMode"] = boost::any(*securityIPMode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (DBInstanceNetInfos) {
      res["DBInstanceNetInfos"] = DBInstanceNetInfos ? boost::any(DBInstanceNetInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityIPMode") != m.end() && !m["SecurityIPMode"].empty()) {
      securityIPMode = make_shared<string>(boost::any_cast<string>(m["SecurityIPMode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("DBInstanceNetInfos") != m.end() && !m["DBInstanceNetInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DBInstanceNetInfos"].type()) {
        DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DBInstanceNetInfos"]));
        DBInstanceNetInfos = make_shared<DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceNetInfoResponseBody() = default;
};
class DescribeDBInstanceNetInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstanceNetInfoResponseBody> body{};

  DescribeDBInstanceNetInfoResponse() {}

  explicit DescribeDBInstanceNetInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstanceNetInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstanceNetInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceNetInfoResponse() = default;
};
class DescribeDBInstancePerformanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> key{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDBInstancePerformanceRequest() {}

  explicit DescribeDBInstancePerformanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDBInstancePerformanceRequest() = default;
};
class DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> value{};

  DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue() {}

  explicit DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue() = default;
};
class DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue>> performanceValue{};

  DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues() {}

  explicit DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (performanceValue) {
      vector<boost::any> temp1;
      for(auto item1:*performanceValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PerformanceValue"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerformanceValue") != m.end() && !m["PerformanceValue"].empty()) {
      if (typeid(vector<boost::any>) == m["PerformanceValue"].type()) {
        vector<DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PerformanceValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        performanceValue = make_shared<vector<DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues() = default;
};
class DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> valueFormat{};
  shared_ptr<string> unit{};
  shared_ptr<DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues> values{};

  DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey() {}

  explicit DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (valueFormat) {
      res["ValueFormat"] = boost::any(*valueFormat);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (values) {
      res["Values"] = values ? boost::any(values->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("ValueFormat") != m.end() && !m["ValueFormat"].empty()) {
      valueFormat = make_shared<string>(boost::any_cast<string>(m["ValueFormat"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      if (typeid(map<string, boost::any>) == m["Values"].type()) {
        DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Values"]));
        values = make_shared<DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey() = default;
};
class DescribeDBInstancePerformanceResponseBodyPerformanceKeys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey>> performanceKey{};

  DescribeDBInstancePerformanceResponseBodyPerformanceKeys() {}

  explicit DescribeDBInstancePerformanceResponseBodyPerformanceKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (performanceKey) {
      vector<boost::any> temp1;
      for(auto item1:*performanceKey){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PerformanceKey"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerformanceKey") != m.end() && !m["PerformanceKey"].empty()) {
      if (typeid(vector<boost::any>) == m["PerformanceKey"].type()) {
        vector<DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PerformanceKey"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        performanceKey = make_shared<vector<DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstancePerformanceResponseBodyPerformanceKeys() = default;
};
class DescribeDBInstancePerformanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> engine{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDBInstancePerformanceResponseBodyPerformanceKeys> performanceKeys{};

  DescribeDBInstancePerformanceResponseBody() {}

  explicit DescribeDBInstancePerformanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (performanceKeys) {
      res["PerformanceKeys"] = performanceKeys ? boost::any(performanceKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PerformanceKeys") != m.end() && !m["PerformanceKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["PerformanceKeys"].type()) {
        DescribeDBInstancePerformanceResponseBodyPerformanceKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PerformanceKeys"]));
        performanceKeys = make_shared<DescribeDBInstancePerformanceResponseBodyPerformanceKeys>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancePerformanceResponseBody() = default;
};
class DescribeDBInstancePerformanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstancePerformanceResponseBody> body{};

  DescribeDBInstancePerformanceResponse() {}

  explicit DescribeDBInstancePerformanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstancePerformanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstancePerformanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancePerformanceResponse() = default;
};
class DescribeDBInstanceProxyConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};

  DescribeDBInstanceProxyConfigurationRequest() {}

  explicit DescribeDBInstanceProxyConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~DescribeDBInstanceProxyConfigurationRequest() = default;
};
class DescribeDBInstanceProxyConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> persistentConnectionsConfiguration{};
  shared_ptr<string> attacksProtectionConfiguration{};
  shared_ptr<string> requestId{};
  shared_ptr<string> transparentSwitchConfiguration{};

  DescribeDBInstanceProxyConfigurationResponseBody() {}

  explicit DescribeDBInstanceProxyConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (persistentConnectionsConfiguration) {
      res["PersistentConnectionsConfiguration"] = boost::any(*persistentConnectionsConfiguration);
    }
    if (attacksProtectionConfiguration) {
      res["AttacksProtectionConfiguration"] = boost::any(*attacksProtectionConfiguration);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transparentSwitchConfiguration) {
      res["TransparentSwitchConfiguration"] = boost::any(*transparentSwitchConfiguration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PersistentConnectionsConfiguration") != m.end() && !m["PersistentConnectionsConfiguration"].empty()) {
      persistentConnectionsConfiguration = make_shared<string>(boost::any_cast<string>(m["PersistentConnectionsConfiguration"]));
    }
    if (m.find("AttacksProtectionConfiguration") != m.end() && !m["AttacksProtectionConfiguration"].empty()) {
      attacksProtectionConfiguration = make_shared<string>(boost::any_cast<string>(m["AttacksProtectionConfiguration"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TransparentSwitchConfiguration") != m.end() && !m["TransparentSwitchConfiguration"].empty()) {
      transparentSwitchConfiguration = make_shared<string>(boost::any_cast<string>(m["TransparentSwitchConfiguration"]));
    }
  }


  virtual ~DescribeDBInstanceProxyConfigurationResponseBody() = default;
};
class DescribeDBInstanceProxyConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstanceProxyConfigurationResponseBody> body{};

  DescribeDBInstanceProxyConfigurationResponse() {}

  explicit DescribeDBInstanceProxyConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstanceProxyConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstanceProxyConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceProxyConfigurationResponse() = default;
};
class DescribeDBInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> proxyId{};
  shared_ptr<string> engine{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> DBInstanceStatus{};
  shared_ptr<string> expired{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBInstanceType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> payType{};
  shared_ptr<string> connectionMode{};
  shared_ptr<string> tags{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<long> instanceLevel{};
  shared_ptr<string> connectionString{};

  DescribeDBInstancesRequest() {}

  explicit DescribeDBInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (proxyId) {
      res["proxyId"] = boost::any(*proxyId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (DBInstanceStatus) {
      res["DBInstanceStatus"] = boost::any(*DBInstanceStatus);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBInstanceType) {
      res["DBInstanceType"] = boost::any(*DBInstanceType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (connectionMode) {
      res["ConnectionMode"] = boost::any(*connectionMode);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (instanceLevel) {
      res["InstanceLevel"] = boost::any(*instanceLevel);
    }
    if (connectionString) {
      res["ConnectionString"] = boost::any(*connectionString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("proxyId") != m.end() && !m["proxyId"].empty()) {
      proxyId = make_shared<string>(boost::any_cast<string>(m["proxyId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("DBInstanceStatus") != m.end() && !m["DBInstanceStatus"].empty()) {
      DBInstanceStatus = make_shared<string>(boost::any_cast<string>(m["DBInstanceStatus"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<string>(boost::any_cast<string>(m["Expired"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBInstanceType") != m.end() && !m["DBInstanceType"].empty()) {
      DBInstanceType = make_shared<string>(boost::any_cast<string>(m["DBInstanceType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("ConnectionMode") != m.end() && !m["ConnectionMode"].empty()) {
      connectionMode = make_shared<string>(boost::any_cast<string>(m["ConnectionMode"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("InstanceLevel") != m.end() && !m["InstanceLevel"].empty()) {
      instanceLevel = make_shared<long>(boost::any_cast<long>(m["InstanceLevel"]));
    }
    if (m.find("ConnectionString") != m.end() && !m["ConnectionString"].empty()) {
      connectionString = make_shared<string>(boost::any_cast<string>(m["ConnectionString"]));
    }
  }


  virtual ~DescribeDBInstancesRequest() = default;
};
class DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};

  DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId() {}

  explicit DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId() = default;
};
class DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId>> readOnlyDBInstanceId{};

  DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds() {}

  explicit DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (readOnlyDBInstanceId) {
      vector<boost::any> temp1;
      for(auto item1:*readOnlyDBInstanceId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReadOnlyDBInstanceId"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReadOnlyDBInstanceId") != m.end() && !m["ReadOnlyDBInstanceId"].empty()) {
      if (typeid(vector<boost::any>) == m["ReadOnlyDBInstanceId"].type()) {
        vector<DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReadOnlyDBInstanceId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        readOnlyDBInstanceId = make_shared<vector<DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds() = default;
};
class DescribeDBInstancesResponseBodyItemsDBInstance : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> dedicatedHostIdForLog{};
  shared_ptr<string> createTime{};
  shared_ptr<string> payType{};
  shared_ptr<string> dedicatedHostNameForLog{};
  shared_ptr<bool> mutriORsignle{};
  shared_ptr<string> dedicatedHostGroupName{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> vpcName{};
  shared_ptr<string> dedicatedHostZoneIdForMaster{};
  shared_ptr<string> connectionString{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> masterInstanceId{};
  shared_ptr<string> autoUpgradeMinorVersion{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> destroyTime{};
  shared_ptr<string> guardDBInstanceId{};
  shared_ptr<string> dedicatedHostNameForMaster{};
  shared_ptr<string> zoneId{};
  shared_ptr<long> tipsLevel{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> dedicatedHostIdForMaster{};
  shared_ptr<string> tempDBInstanceId{};
  shared_ptr<string> DBInstanceStorageType{};
  shared_ptr<string> connectionMode{};
  shared_ptr<string> lockMode{};
  shared_ptr<string> generalGroupName{};
  shared_ptr<string> vpcCloudInstanceId{};
  shared_ptr<string> dedicatedHostZoneIdForSlave{};
  shared_ptr<string> tips{};
  shared_ptr<string> dedicatedHostZoneIdForLog{};
  shared_ptr<string> dedicatedHostNameForSlave{};
  shared_ptr<string> DBInstanceDescription{};
  shared_ptr<string> DBInstanceNetType{};
  shared_ptr<string> DBInstanceType{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> DBInstanceStatus{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> dedicatedHostIdForSlave{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> category{};
  shared_ptr<string> engine{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<long> switchWeight{};
  shared_ptr<DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds> readOnlyDBInstanceIds{};

  DescribeDBInstancesResponseBodyItemsDBInstance() {}

  explicit DescribeDBInstancesResponseBodyItemsDBInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (dedicatedHostIdForLog) {
      res["DedicatedHostIdForLog"] = boost::any(*dedicatedHostIdForLog);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (dedicatedHostNameForLog) {
      res["DedicatedHostNameForLog"] = boost::any(*dedicatedHostNameForLog);
    }
    if (mutriORsignle) {
      res["MutriORsignle"] = boost::any(*mutriORsignle);
    }
    if (dedicatedHostGroupName) {
      res["DedicatedHostGroupName"] = boost::any(*dedicatedHostGroupName);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (dedicatedHostZoneIdForMaster) {
      res["DedicatedHostZoneIdForMaster"] = boost::any(*dedicatedHostZoneIdForMaster);
    }
    if (connectionString) {
      res["ConnectionString"] = boost::any(*connectionString);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (masterInstanceId) {
      res["MasterInstanceId"] = boost::any(*masterInstanceId);
    }
    if (autoUpgradeMinorVersion) {
      res["AutoUpgradeMinorVersion"] = boost::any(*autoUpgradeMinorVersion);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (destroyTime) {
      res["DestroyTime"] = boost::any(*destroyTime);
    }
    if (guardDBInstanceId) {
      res["GuardDBInstanceId"] = boost::any(*guardDBInstanceId);
    }
    if (dedicatedHostNameForMaster) {
      res["DedicatedHostNameForMaster"] = boost::any(*dedicatedHostNameForMaster);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (tipsLevel) {
      res["TipsLevel"] = boost::any(*tipsLevel);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (dedicatedHostIdForMaster) {
      res["DedicatedHostIdForMaster"] = boost::any(*dedicatedHostIdForMaster);
    }
    if (tempDBInstanceId) {
      res["TempDBInstanceId"] = boost::any(*tempDBInstanceId);
    }
    if (DBInstanceStorageType) {
      res["DBInstanceStorageType"] = boost::any(*DBInstanceStorageType);
    }
    if (connectionMode) {
      res["ConnectionMode"] = boost::any(*connectionMode);
    }
    if (lockMode) {
      res["LockMode"] = boost::any(*lockMode);
    }
    if (generalGroupName) {
      res["GeneralGroupName"] = boost::any(*generalGroupName);
    }
    if (vpcCloudInstanceId) {
      res["VpcCloudInstanceId"] = boost::any(*vpcCloudInstanceId);
    }
    if (dedicatedHostZoneIdForSlave) {
      res["DedicatedHostZoneIdForSlave"] = boost::any(*dedicatedHostZoneIdForSlave);
    }
    if (tips) {
      res["Tips"] = boost::any(*tips);
    }
    if (dedicatedHostZoneIdForLog) {
      res["DedicatedHostZoneIdForLog"] = boost::any(*dedicatedHostZoneIdForLog);
    }
    if (dedicatedHostNameForSlave) {
      res["DedicatedHostNameForSlave"] = boost::any(*dedicatedHostNameForSlave);
    }
    if (DBInstanceDescription) {
      res["DBInstanceDescription"] = boost::any(*DBInstanceDescription);
    }
    if (DBInstanceNetType) {
      res["DBInstanceNetType"] = boost::any(*DBInstanceNetType);
    }
    if (DBInstanceType) {
      res["DBInstanceType"] = boost::any(*DBInstanceType);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (DBInstanceStatus) {
      res["DBInstanceStatus"] = boost::any(*DBInstanceStatus);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (dedicatedHostIdForSlave) {
      res["DedicatedHostIdForSlave"] = boost::any(*dedicatedHostIdForSlave);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (switchWeight) {
      res["SwitchWeight"] = boost::any(*switchWeight);
    }
    if (readOnlyDBInstanceIds) {
      res["ReadOnlyDBInstanceIds"] = readOnlyDBInstanceIds ? boost::any(readOnlyDBInstanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("DedicatedHostIdForLog") != m.end() && !m["DedicatedHostIdForLog"].empty()) {
      dedicatedHostIdForLog = make_shared<string>(boost::any_cast<string>(m["DedicatedHostIdForLog"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("DedicatedHostNameForLog") != m.end() && !m["DedicatedHostNameForLog"].empty()) {
      dedicatedHostNameForLog = make_shared<string>(boost::any_cast<string>(m["DedicatedHostNameForLog"]));
    }
    if (m.find("MutriORsignle") != m.end() && !m["MutriORsignle"].empty()) {
      mutriORsignle = make_shared<bool>(boost::any_cast<bool>(m["MutriORsignle"]));
    }
    if (m.find("DedicatedHostGroupName") != m.end() && !m["DedicatedHostGroupName"].empty()) {
      dedicatedHostGroupName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupName"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("DedicatedHostZoneIdForMaster") != m.end() && !m["DedicatedHostZoneIdForMaster"].empty()) {
      dedicatedHostZoneIdForMaster = make_shared<string>(boost::any_cast<string>(m["DedicatedHostZoneIdForMaster"]));
    }
    if (m.find("ConnectionString") != m.end() && !m["ConnectionString"].empty()) {
      connectionString = make_shared<string>(boost::any_cast<string>(m["ConnectionString"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("MasterInstanceId") != m.end() && !m["MasterInstanceId"].empty()) {
      masterInstanceId = make_shared<string>(boost::any_cast<string>(m["MasterInstanceId"]));
    }
    if (m.find("AutoUpgradeMinorVersion") != m.end() && !m["AutoUpgradeMinorVersion"].empty()) {
      autoUpgradeMinorVersion = make_shared<string>(boost::any_cast<string>(m["AutoUpgradeMinorVersion"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("DestroyTime") != m.end() && !m["DestroyTime"].empty()) {
      destroyTime = make_shared<string>(boost::any_cast<string>(m["DestroyTime"]));
    }
    if (m.find("GuardDBInstanceId") != m.end() && !m["GuardDBInstanceId"].empty()) {
      guardDBInstanceId = make_shared<string>(boost::any_cast<string>(m["GuardDBInstanceId"]));
    }
    if (m.find("DedicatedHostNameForMaster") != m.end() && !m["DedicatedHostNameForMaster"].empty()) {
      dedicatedHostNameForMaster = make_shared<string>(boost::any_cast<string>(m["DedicatedHostNameForMaster"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("TipsLevel") != m.end() && !m["TipsLevel"].empty()) {
      tipsLevel = make_shared<long>(boost::any_cast<long>(m["TipsLevel"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DedicatedHostIdForMaster") != m.end() && !m["DedicatedHostIdForMaster"].empty()) {
      dedicatedHostIdForMaster = make_shared<string>(boost::any_cast<string>(m["DedicatedHostIdForMaster"]));
    }
    if (m.find("TempDBInstanceId") != m.end() && !m["TempDBInstanceId"].empty()) {
      tempDBInstanceId = make_shared<string>(boost::any_cast<string>(m["TempDBInstanceId"]));
    }
    if (m.find("DBInstanceStorageType") != m.end() && !m["DBInstanceStorageType"].empty()) {
      DBInstanceStorageType = make_shared<string>(boost::any_cast<string>(m["DBInstanceStorageType"]));
    }
    if (m.find("ConnectionMode") != m.end() && !m["ConnectionMode"].empty()) {
      connectionMode = make_shared<string>(boost::any_cast<string>(m["ConnectionMode"]));
    }
    if (m.find("LockMode") != m.end() && !m["LockMode"].empty()) {
      lockMode = make_shared<string>(boost::any_cast<string>(m["LockMode"]));
    }
    if (m.find("GeneralGroupName") != m.end() && !m["GeneralGroupName"].empty()) {
      generalGroupName = make_shared<string>(boost::any_cast<string>(m["GeneralGroupName"]));
    }
    if (m.find("VpcCloudInstanceId") != m.end() && !m["VpcCloudInstanceId"].empty()) {
      vpcCloudInstanceId = make_shared<string>(boost::any_cast<string>(m["VpcCloudInstanceId"]));
    }
    if (m.find("DedicatedHostZoneIdForSlave") != m.end() && !m["DedicatedHostZoneIdForSlave"].empty()) {
      dedicatedHostZoneIdForSlave = make_shared<string>(boost::any_cast<string>(m["DedicatedHostZoneIdForSlave"]));
    }
    if (m.find("Tips") != m.end() && !m["Tips"].empty()) {
      tips = make_shared<string>(boost::any_cast<string>(m["Tips"]));
    }
    if (m.find("DedicatedHostZoneIdForLog") != m.end() && !m["DedicatedHostZoneIdForLog"].empty()) {
      dedicatedHostZoneIdForLog = make_shared<string>(boost::any_cast<string>(m["DedicatedHostZoneIdForLog"]));
    }
    if (m.find("DedicatedHostNameForSlave") != m.end() && !m["DedicatedHostNameForSlave"].empty()) {
      dedicatedHostNameForSlave = make_shared<string>(boost::any_cast<string>(m["DedicatedHostNameForSlave"]));
    }
    if (m.find("DBInstanceDescription") != m.end() && !m["DBInstanceDescription"].empty()) {
      DBInstanceDescription = make_shared<string>(boost::any_cast<string>(m["DBInstanceDescription"]));
    }
    if (m.find("DBInstanceNetType") != m.end() && !m["DBInstanceNetType"].empty()) {
      DBInstanceNetType = make_shared<string>(boost::any_cast<string>(m["DBInstanceNetType"]));
    }
    if (m.find("DBInstanceType") != m.end() && !m["DBInstanceType"].empty()) {
      DBInstanceType = make_shared<string>(boost::any_cast<string>(m["DBInstanceType"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("DBInstanceStatus") != m.end() && !m["DBInstanceStatus"].empty()) {
      DBInstanceStatus = make_shared<string>(boost::any_cast<string>(m["DBInstanceStatus"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("DedicatedHostIdForSlave") != m.end() && !m["DedicatedHostIdForSlave"].empty()) {
      dedicatedHostIdForSlave = make_shared<string>(boost::any_cast<string>(m["DedicatedHostIdForSlave"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("SwitchWeight") != m.end() && !m["SwitchWeight"].empty()) {
      switchWeight = make_shared<long>(boost::any_cast<long>(m["SwitchWeight"]));
    }
    if (m.find("ReadOnlyDBInstanceIds") != m.end() && !m["ReadOnlyDBInstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadOnlyDBInstanceIds"].type()) {
        DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadOnlyDBInstanceIds"]));
        readOnlyDBInstanceIds = make_shared<DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancesResponseBodyItemsDBInstance() = default;
};
class DescribeDBInstancesResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstancesResponseBodyItemsDBInstance>> DBInstance{};

  DescribeDBInstancesResponseBodyItems() {}

  explicit DescribeDBInstancesResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstance) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstance") != m.end() && !m["DBInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstance"].type()) {
        vector<DescribeDBInstancesResponseBodyItemsDBInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstancesResponseBodyItemsDBInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstance = make_shared<vector<DescribeDBInstancesResponseBodyItemsDBInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstancesResponseBodyItems() = default;
};
class DescribeDBInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeDBInstancesResponseBodyItems> items{};

  DescribeDBInstancesResponseBody() {}

  explicit DescribeDBInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeDBInstancesResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeDBInstancesResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancesResponseBody() = default;
};
class DescribeDBInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstancesResponseBody> body{};

  DescribeDBInstancesResponse() {}

  explicit DescribeDBInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancesResponse() = default;
};
class DescribeDBInstancesAsCsvRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> DBInstanceId{};

  DescribeDBInstancesAsCsvRequest() {}

  explicit DescribeDBInstancesAsCsvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~DescribeDBInstancesAsCsvRequest() = default;
};
class DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> tempDBInstanceId{};
  shared_ptr<string> supportUpgradeAccountType{};
  shared_ptr<string> incrementSourceDBInstanceId{};
  shared_ptr<long> DBInstanceMemory{};
  shared_ptr<string> maintainTime{};
  shared_ptr<string> payType{};
  shared_ptr<string> tags{};
  shared_ptr<string> availabilityValue{};
  shared_ptr<string> readDelayTime{};
  shared_ptr<string> connectionMode{};
  shared_ptr<string> port{};
  shared_ptr<string> accountType{};
  shared_ptr<string> lockMode{};
  shared_ptr<string> engineVersion{};
  shared_ptr<long> maxIOPS{};
  shared_ptr<string> connectionString{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> securityIPList{};
  shared_ptr<string> masterInstanceId{};
  shared_ptr<string> DBInstanceClassType{};
  shared_ptr<string> DBInstanceDescription{};
  shared_ptr<string> DBInstanceCPU{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> DBInstanceNetType{};
  shared_ptr<string> DBInstanceType{};
  shared_ptr<long> accountMaxQuantity{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> DBInstanceStatus{};
  shared_ptr<long> DBMaxQuantity{};
  shared_ptr<string> guardDBInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> DBInstanceStorage{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> category{};
  shared_ptr<long> maxConnections{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<string> engine{};

  DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute() {}

  explicit DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (tempDBInstanceId) {
      res["TempDBInstanceId"] = boost::any(*tempDBInstanceId);
    }
    if (supportUpgradeAccountType) {
      res["SupportUpgradeAccountType"] = boost::any(*supportUpgradeAccountType);
    }
    if (incrementSourceDBInstanceId) {
      res["IncrementSourceDBInstanceId"] = boost::any(*incrementSourceDBInstanceId);
    }
    if (DBInstanceMemory) {
      res["DBInstanceMemory"] = boost::any(*DBInstanceMemory);
    }
    if (maintainTime) {
      res["MaintainTime"] = boost::any(*maintainTime);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (availabilityValue) {
      res["AvailabilityValue"] = boost::any(*availabilityValue);
    }
    if (readDelayTime) {
      res["ReadDelayTime"] = boost::any(*readDelayTime);
    }
    if (connectionMode) {
      res["ConnectionMode"] = boost::any(*connectionMode);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (lockMode) {
      res["LockMode"] = boost::any(*lockMode);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (maxIOPS) {
      res["MaxIOPS"] = boost::any(*maxIOPS);
    }
    if (connectionString) {
      res["ConnectionString"] = boost::any(*connectionString);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (securityIPList) {
      res["SecurityIPList"] = boost::any(*securityIPList);
    }
    if (masterInstanceId) {
      res["MasterInstanceId"] = boost::any(*masterInstanceId);
    }
    if (DBInstanceClassType) {
      res["DBInstanceClassType"] = boost::any(*DBInstanceClassType);
    }
    if (DBInstanceDescription) {
      res["DBInstanceDescription"] = boost::any(*DBInstanceDescription);
    }
    if (DBInstanceCPU) {
      res["DBInstanceCPU"] = boost::any(*DBInstanceCPU);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (DBInstanceNetType) {
      res["DBInstanceNetType"] = boost::any(*DBInstanceNetType);
    }
    if (DBInstanceType) {
      res["DBInstanceType"] = boost::any(*DBInstanceType);
    }
    if (accountMaxQuantity) {
      res["AccountMaxQuantity"] = boost::any(*accountMaxQuantity);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (DBInstanceStatus) {
      res["DBInstanceStatus"] = boost::any(*DBInstanceStatus);
    }
    if (DBMaxQuantity) {
      res["DBMaxQuantity"] = boost::any(*DBMaxQuantity);
    }
    if (guardDBInstanceId) {
      res["GuardDBInstanceId"] = boost::any(*guardDBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (DBInstanceStorage) {
      res["DBInstanceStorage"] = boost::any(*DBInstanceStorage);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (maxConnections) {
      res["MaxConnections"] = boost::any(*maxConnections);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("TempDBInstanceId") != m.end() && !m["TempDBInstanceId"].empty()) {
      tempDBInstanceId = make_shared<string>(boost::any_cast<string>(m["TempDBInstanceId"]));
    }
    if (m.find("SupportUpgradeAccountType") != m.end() && !m["SupportUpgradeAccountType"].empty()) {
      supportUpgradeAccountType = make_shared<string>(boost::any_cast<string>(m["SupportUpgradeAccountType"]));
    }
    if (m.find("IncrementSourceDBInstanceId") != m.end() && !m["IncrementSourceDBInstanceId"].empty()) {
      incrementSourceDBInstanceId = make_shared<string>(boost::any_cast<string>(m["IncrementSourceDBInstanceId"]));
    }
    if (m.find("DBInstanceMemory") != m.end() && !m["DBInstanceMemory"].empty()) {
      DBInstanceMemory = make_shared<long>(boost::any_cast<long>(m["DBInstanceMemory"]));
    }
    if (m.find("MaintainTime") != m.end() && !m["MaintainTime"].empty()) {
      maintainTime = make_shared<string>(boost::any_cast<string>(m["MaintainTime"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("AvailabilityValue") != m.end() && !m["AvailabilityValue"].empty()) {
      availabilityValue = make_shared<string>(boost::any_cast<string>(m["AvailabilityValue"]));
    }
    if (m.find("ReadDelayTime") != m.end() && !m["ReadDelayTime"].empty()) {
      readDelayTime = make_shared<string>(boost::any_cast<string>(m["ReadDelayTime"]));
    }
    if (m.find("ConnectionMode") != m.end() && !m["ConnectionMode"].empty()) {
      connectionMode = make_shared<string>(boost::any_cast<string>(m["ConnectionMode"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("LockMode") != m.end() && !m["LockMode"].empty()) {
      lockMode = make_shared<string>(boost::any_cast<string>(m["LockMode"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("MaxIOPS") != m.end() && !m["MaxIOPS"].empty()) {
      maxIOPS = make_shared<long>(boost::any_cast<long>(m["MaxIOPS"]));
    }
    if (m.find("ConnectionString") != m.end() && !m["ConnectionString"].empty()) {
      connectionString = make_shared<string>(boost::any_cast<string>(m["ConnectionString"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("SecurityIPList") != m.end() && !m["SecurityIPList"].empty()) {
      securityIPList = make_shared<string>(boost::any_cast<string>(m["SecurityIPList"]));
    }
    if (m.find("MasterInstanceId") != m.end() && !m["MasterInstanceId"].empty()) {
      masterInstanceId = make_shared<string>(boost::any_cast<string>(m["MasterInstanceId"]));
    }
    if (m.find("DBInstanceClassType") != m.end() && !m["DBInstanceClassType"].empty()) {
      DBInstanceClassType = make_shared<string>(boost::any_cast<string>(m["DBInstanceClassType"]));
    }
    if (m.find("DBInstanceDescription") != m.end() && !m["DBInstanceDescription"].empty()) {
      DBInstanceDescription = make_shared<string>(boost::any_cast<string>(m["DBInstanceDescription"]));
    }
    if (m.find("DBInstanceCPU") != m.end() && !m["DBInstanceCPU"].empty()) {
      DBInstanceCPU = make_shared<string>(boost::any_cast<string>(m["DBInstanceCPU"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("DBInstanceNetType") != m.end() && !m["DBInstanceNetType"].empty()) {
      DBInstanceNetType = make_shared<string>(boost::any_cast<string>(m["DBInstanceNetType"]));
    }
    if (m.find("DBInstanceType") != m.end() && !m["DBInstanceType"].empty()) {
      DBInstanceType = make_shared<string>(boost::any_cast<string>(m["DBInstanceType"]));
    }
    if (m.find("AccountMaxQuantity") != m.end() && !m["AccountMaxQuantity"].empty()) {
      accountMaxQuantity = make_shared<long>(boost::any_cast<long>(m["AccountMaxQuantity"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("DBInstanceStatus") != m.end() && !m["DBInstanceStatus"].empty()) {
      DBInstanceStatus = make_shared<string>(boost::any_cast<string>(m["DBInstanceStatus"]));
    }
    if (m.find("DBMaxQuantity") != m.end() && !m["DBMaxQuantity"].empty()) {
      DBMaxQuantity = make_shared<long>(boost::any_cast<long>(m["DBMaxQuantity"]));
    }
    if (m.find("GuardDBInstanceId") != m.end() && !m["GuardDBInstanceId"].empty()) {
      guardDBInstanceId = make_shared<string>(boost::any_cast<string>(m["GuardDBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DBInstanceStorage") != m.end() && !m["DBInstanceStorage"].empty()) {
      DBInstanceStorage = make_shared<long>(boost::any_cast<long>(m["DBInstanceStorage"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("MaxConnections") != m.end() && !m["MaxConnections"].empty()) {
      maxConnections = make_shared<long>(boost::any_cast<long>(m["MaxConnections"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
  }


  virtual ~DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute() = default;
};
class DescribeDBInstancesAsCsvResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute>> DBInstanceAttribute{};

  DescribeDBInstancesAsCsvResponseBodyItems() {}

  explicit DescribeDBInstancesAsCsvResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstanceAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstanceAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceAttribute") != m.end() && !m["DBInstanceAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstanceAttribute"].type()) {
        vector<DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstanceAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstanceAttribute = make_shared<vector<DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstancesAsCsvResponseBodyItems() = default;
};
class DescribeDBInstancesAsCsvResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDBInstancesAsCsvResponseBodyItems> items{};

  DescribeDBInstancesAsCsvResponseBody() {}

  explicit DescribeDBInstancesAsCsvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeDBInstancesAsCsvResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeDBInstancesAsCsvResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancesAsCsvResponseBody() = default;
};
class DescribeDBInstancesAsCsvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstancesAsCsvResponseBody> body{};

  DescribeDBInstancesAsCsvResponse() {}

  explicit DescribeDBInstancesAsCsvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstancesAsCsvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstancesAsCsvResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancesAsCsvResponse() = default;
};
class DescribeDBInstancesByExpireTimeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> proxyId{};
  shared_ptr<long> expirePeriod{};
  shared_ptr<bool> expired{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> tags{};
  shared_ptr<string> ownerAccount{};

  DescribeDBInstancesByExpireTimeRequest() {}

  explicit DescribeDBInstancesByExpireTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (proxyId) {
      res["proxyId"] = boost::any(*proxyId);
    }
    if (expirePeriod) {
      res["ExpirePeriod"] = boost::any(*expirePeriod);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("proxyId") != m.end() && !m["proxyId"].empty()) {
      proxyId = make_shared<string>(boost::any_cast<string>(m["proxyId"]));
    }
    if (m.find("ExpirePeriod") != m.end() && !m["ExpirePeriod"].empty()) {
      expirePeriod = make_shared<long>(boost::any_cast<long>(m["ExpirePeriod"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeDBInstancesByExpireTimeRequest() = default;
};
class DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime : public Darabonba::Model {
public:
  shared_ptr<string> expireTime{};
  shared_ptr<string> payType{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBInstanceStatus{};
  shared_ptr<string> DBInstanceDescription{};
  shared_ptr<string> lockMode{};

  DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime() {}

  explicit DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBInstanceStatus) {
      res["DBInstanceStatus"] = boost::any(*DBInstanceStatus);
    }
    if (DBInstanceDescription) {
      res["DBInstanceDescription"] = boost::any(*DBInstanceDescription);
    }
    if (lockMode) {
      res["LockMode"] = boost::any(*lockMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBInstanceStatus") != m.end() && !m["DBInstanceStatus"].empty()) {
      DBInstanceStatus = make_shared<string>(boost::any_cast<string>(m["DBInstanceStatus"]));
    }
    if (m.find("DBInstanceDescription") != m.end() && !m["DBInstanceDescription"].empty()) {
      DBInstanceDescription = make_shared<string>(boost::any_cast<string>(m["DBInstanceDescription"]));
    }
    if (m.find("LockMode") != m.end() && !m["LockMode"].empty()) {
      lockMode = make_shared<string>(boost::any_cast<string>(m["LockMode"]));
    }
  }


  virtual ~DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime() = default;
};
class DescribeDBInstancesByExpireTimeResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime>> DBInstanceExpireTime{};

  DescribeDBInstancesByExpireTimeResponseBodyItems() {}

  explicit DescribeDBInstancesByExpireTimeResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceExpireTime) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstanceExpireTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstanceExpireTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceExpireTime") != m.end() && !m["DBInstanceExpireTime"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstanceExpireTime"].type()) {
        vector<DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstanceExpireTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstanceExpireTime = make_shared<vector<DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstancesByExpireTimeResponseBodyItems() = default;
};
class DescribeDBInstancesByExpireTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeDBInstancesByExpireTimeResponseBodyItems> items{};

  DescribeDBInstancesByExpireTimeResponseBody() {}

  explicit DescribeDBInstancesByExpireTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeDBInstancesByExpireTimeResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeDBInstancesByExpireTimeResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancesByExpireTimeResponseBody() = default;
};
class DescribeDBInstancesByExpireTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstancesByExpireTimeResponseBody> body{};

  DescribeDBInstancesByExpireTimeResponse() {}

  explicit DescribeDBInstancesByExpireTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstancesByExpireTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstancesByExpireTimeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancesByExpireTimeResponse() = default;
};
class DescribeDBInstancesByPerformanceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDBInstancesByPerformanceRequestTag() {}

  explicit DescribeDBInstancesByPerformanceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeDBInstancesByPerformanceRequestTag() = default;
};
class DescribeDBInstancesByPerformanceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstancesByPerformanceRequestTag>> tag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> proxyId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> sortMethod{};
  shared_ptr<string> sortKey{};
  shared_ptr<string> tags{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};

  DescribeDBInstancesByPerformanceRequest() {}

  explicit DescribeDBInstancesByPerformanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (proxyId) {
      res["proxyId"] = boost::any(*proxyId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (sortMethod) {
      res["SortMethod"] = boost::any(*sortMethod);
    }
    if (sortKey) {
      res["SortKey"] = boost::any(*sortKey);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDBInstancesByPerformanceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstancesByPerformanceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDBInstancesByPerformanceRequestTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("proxyId") != m.end() && !m["proxyId"].empty()) {
      proxyId = make_shared<string>(boost::any_cast<string>(m["proxyId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("SortMethod") != m.end() && !m["SortMethod"].empty()) {
      sortMethod = make_shared<string>(boost::any_cast<string>(m["SortMethod"]));
    }
    if (m.find("SortKey") != m.end() && !m["SortKey"].empty()) {
      sortKey = make_shared<string>(boost::any_cast<string>(m["SortKey"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDBInstancesByPerformanceRequest() = default;
};
class DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance : public Darabonba::Model {
public:
  shared_ptr<string> CPUUsage{};
  shared_ptr<string> sessionUsage{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBInstanceDescription{};
  shared_ptr<string> IOPSUsage{};
  shared_ptr<string> diskUsage{};

  DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance() {}

  explicit DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CPUUsage) {
      res["CPUUsage"] = boost::any(*CPUUsage);
    }
    if (sessionUsage) {
      res["SessionUsage"] = boost::any(*sessionUsage);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBInstanceDescription) {
      res["DBInstanceDescription"] = boost::any(*DBInstanceDescription);
    }
    if (IOPSUsage) {
      res["IOPSUsage"] = boost::any(*IOPSUsage);
    }
    if (diskUsage) {
      res["DiskUsage"] = boost::any(*diskUsage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CPUUsage") != m.end() && !m["CPUUsage"].empty()) {
      CPUUsage = make_shared<string>(boost::any_cast<string>(m["CPUUsage"]));
    }
    if (m.find("SessionUsage") != m.end() && !m["SessionUsage"].empty()) {
      sessionUsage = make_shared<string>(boost::any_cast<string>(m["SessionUsage"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBInstanceDescription") != m.end() && !m["DBInstanceDescription"].empty()) {
      DBInstanceDescription = make_shared<string>(boost::any_cast<string>(m["DBInstanceDescription"]));
    }
    if (m.find("IOPSUsage") != m.end() && !m["IOPSUsage"].empty()) {
      IOPSUsage = make_shared<string>(boost::any_cast<string>(m["IOPSUsage"]));
    }
    if (m.find("DiskUsage") != m.end() && !m["DiskUsage"].empty()) {
      diskUsage = make_shared<string>(boost::any_cast<string>(m["DiskUsage"]));
    }
  }


  virtual ~DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance() = default;
};
class DescribeDBInstancesByPerformanceResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance>> DBInstancePerformance{};

  DescribeDBInstancesByPerformanceResponseBodyItems() {}

  explicit DescribeDBInstancesByPerformanceResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstancePerformance) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstancePerformance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstancePerformance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstancePerformance") != m.end() && !m["DBInstancePerformance"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstancePerformance"].type()) {
        vector<DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstancePerformance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstancePerformance = make_shared<vector<DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstancesByPerformanceResponseBodyItems() = default;
};
class DescribeDBInstancesByPerformanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeDBInstancesByPerformanceResponseBodyItems> items{};

  DescribeDBInstancesByPerformanceResponseBody() {}

  explicit DescribeDBInstancesByPerformanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeDBInstancesByPerformanceResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeDBInstancesByPerformanceResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancesByPerformanceResponseBody() = default;
};
class DescribeDBInstancesByPerformanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstancesByPerformanceResponseBody> body{};

  DescribeDBInstancesByPerformanceResponse() {}

  explicit DescribeDBInstancesByPerformanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstancesByPerformanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstancesByPerformanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancesByPerformanceResponse() = default;
};
class DescribeDBInstancesForCloneRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> proxyId{};
  shared_ptr<string> engine{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> DBInstanceStatus{};
  shared_ptr<string> expired{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBInstanceType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> payType{};
  shared_ptr<string> connectionMode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> currentInstanceId{};

  DescribeDBInstancesForCloneRequest() {}

  explicit DescribeDBInstancesForCloneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (proxyId) {
      res["proxyId"] = boost::any(*proxyId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (DBInstanceStatus) {
      res["DBInstanceStatus"] = boost::any(*DBInstanceStatus);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBInstanceType) {
      res["DBInstanceType"] = boost::any(*DBInstanceType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (connectionMode) {
      res["ConnectionMode"] = boost::any(*connectionMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (currentInstanceId) {
      res["CurrentInstanceId"] = boost::any(*currentInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("proxyId") != m.end() && !m["proxyId"].empty()) {
      proxyId = make_shared<string>(boost::any_cast<string>(m["proxyId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DBInstanceStatus") != m.end() && !m["DBInstanceStatus"].empty()) {
      DBInstanceStatus = make_shared<string>(boost::any_cast<string>(m["DBInstanceStatus"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<string>(boost::any_cast<string>(m["Expired"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBInstanceType") != m.end() && !m["DBInstanceType"].empty()) {
      DBInstanceType = make_shared<string>(boost::any_cast<string>(m["DBInstanceType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("ConnectionMode") != m.end() && !m["ConnectionMode"].empty()) {
      connectionMode = make_shared<string>(boost::any_cast<string>(m["ConnectionMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("CurrentInstanceId") != m.end() && !m["CurrentInstanceId"].empty()) {
      currentInstanceId = make_shared<string>(boost::any_cast<string>(m["CurrentInstanceId"]));
    }
  }


  virtual ~DescribeDBInstancesForCloneRequest() = default;
};
class DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};

  DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId() {}

  explicit DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId() = default;
};
class DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId>> readOnlyDBInstanceId{};

  DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds() {}

  explicit DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (readOnlyDBInstanceId) {
      vector<boost::any> temp1;
      for(auto item1:*readOnlyDBInstanceId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReadOnlyDBInstanceId"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReadOnlyDBInstanceId") != m.end() && !m["ReadOnlyDBInstanceId"].empty()) {
      if (typeid(vector<boost::any>) == m["ReadOnlyDBInstanceId"].type()) {
        vector<DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReadOnlyDBInstanceId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        readOnlyDBInstanceId = make_shared<vector<DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds() = default;
};
class DescribeDBInstancesForCloneResponseBodyItemsDBInstance : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> replicateId{};
  shared_ptr<string> tempDBInstanceId{};
  shared_ptr<string> DBInstanceStorageType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> payType{};
  shared_ptr<bool> mutriORsignle{};
  shared_ptr<string> connectionMode{};
  shared_ptr<string> lockMode{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> vpcCloudInstanceId{};
  shared_ptr<long> insId{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> masterInstanceId{};
  shared_ptr<string> DBInstanceDescription{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> DBInstanceNetType{};
  shared_ptr<string> DBInstanceType{};
  shared_ptr<string> destroyTime{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> DBInstanceStatus{};
  shared_ptr<string> guardDBInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> category{};
  shared_ptr<string> engine{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds> readOnlyDBInstanceIds{};

  DescribeDBInstancesForCloneResponseBodyItemsDBInstance() {}

  explicit DescribeDBInstancesForCloneResponseBodyItemsDBInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (replicateId) {
      res["ReplicateId"] = boost::any(*replicateId);
    }
    if (tempDBInstanceId) {
      res["TempDBInstanceId"] = boost::any(*tempDBInstanceId);
    }
    if (DBInstanceStorageType) {
      res["DBInstanceStorageType"] = boost::any(*DBInstanceStorageType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (mutriORsignle) {
      res["MutriORsignle"] = boost::any(*mutriORsignle);
    }
    if (connectionMode) {
      res["ConnectionMode"] = boost::any(*connectionMode);
    }
    if (lockMode) {
      res["LockMode"] = boost::any(*lockMode);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (vpcCloudInstanceId) {
      res["VpcCloudInstanceId"] = boost::any(*vpcCloudInstanceId);
    }
    if (insId) {
      res["InsId"] = boost::any(*insId);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (masterInstanceId) {
      res["MasterInstanceId"] = boost::any(*masterInstanceId);
    }
    if (DBInstanceDescription) {
      res["DBInstanceDescription"] = boost::any(*DBInstanceDescription);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (DBInstanceNetType) {
      res["DBInstanceNetType"] = boost::any(*DBInstanceNetType);
    }
    if (DBInstanceType) {
      res["DBInstanceType"] = boost::any(*DBInstanceType);
    }
    if (destroyTime) {
      res["DestroyTime"] = boost::any(*destroyTime);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (DBInstanceStatus) {
      res["DBInstanceStatus"] = boost::any(*DBInstanceStatus);
    }
    if (guardDBInstanceId) {
      res["GuardDBInstanceId"] = boost::any(*guardDBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (readOnlyDBInstanceIds) {
      res["ReadOnlyDBInstanceIds"] = readOnlyDBInstanceIds ? boost::any(readOnlyDBInstanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ReplicateId") != m.end() && !m["ReplicateId"].empty()) {
      replicateId = make_shared<string>(boost::any_cast<string>(m["ReplicateId"]));
    }
    if (m.find("TempDBInstanceId") != m.end() && !m["TempDBInstanceId"].empty()) {
      tempDBInstanceId = make_shared<string>(boost::any_cast<string>(m["TempDBInstanceId"]));
    }
    if (m.find("DBInstanceStorageType") != m.end() && !m["DBInstanceStorageType"].empty()) {
      DBInstanceStorageType = make_shared<string>(boost::any_cast<string>(m["DBInstanceStorageType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("MutriORsignle") != m.end() && !m["MutriORsignle"].empty()) {
      mutriORsignle = make_shared<bool>(boost::any_cast<bool>(m["MutriORsignle"]));
    }
    if (m.find("ConnectionMode") != m.end() && !m["ConnectionMode"].empty()) {
      connectionMode = make_shared<string>(boost::any_cast<string>(m["ConnectionMode"]));
    }
    if (m.find("LockMode") != m.end() && !m["LockMode"].empty()) {
      lockMode = make_shared<string>(boost::any_cast<string>(m["LockMode"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("VpcCloudInstanceId") != m.end() && !m["VpcCloudInstanceId"].empty()) {
      vpcCloudInstanceId = make_shared<string>(boost::any_cast<string>(m["VpcCloudInstanceId"]));
    }
    if (m.find("InsId") != m.end() && !m["InsId"].empty()) {
      insId = make_shared<long>(boost::any_cast<long>(m["InsId"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("MasterInstanceId") != m.end() && !m["MasterInstanceId"].empty()) {
      masterInstanceId = make_shared<string>(boost::any_cast<string>(m["MasterInstanceId"]));
    }
    if (m.find("DBInstanceDescription") != m.end() && !m["DBInstanceDescription"].empty()) {
      DBInstanceDescription = make_shared<string>(boost::any_cast<string>(m["DBInstanceDescription"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("DBInstanceNetType") != m.end() && !m["DBInstanceNetType"].empty()) {
      DBInstanceNetType = make_shared<string>(boost::any_cast<string>(m["DBInstanceNetType"]));
    }
    if (m.find("DBInstanceType") != m.end() && !m["DBInstanceType"].empty()) {
      DBInstanceType = make_shared<string>(boost::any_cast<string>(m["DBInstanceType"]));
    }
    if (m.find("DestroyTime") != m.end() && !m["DestroyTime"].empty()) {
      destroyTime = make_shared<string>(boost::any_cast<string>(m["DestroyTime"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("DBInstanceStatus") != m.end() && !m["DBInstanceStatus"].empty()) {
      DBInstanceStatus = make_shared<string>(boost::any_cast<string>(m["DBInstanceStatus"]));
    }
    if (m.find("GuardDBInstanceId") != m.end() && !m["GuardDBInstanceId"].empty()) {
      guardDBInstanceId = make_shared<string>(boost::any_cast<string>(m["GuardDBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("ReadOnlyDBInstanceIds") != m.end() && !m["ReadOnlyDBInstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadOnlyDBInstanceIds"].type()) {
        DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadOnlyDBInstanceIds"]));
        readOnlyDBInstanceIds = make_shared<DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancesForCloneResponseBodyItemsDBInstance() = default;
};
class DescribeDBInstancesForCloneResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstancesForCloneResponseBodyItemsDBInstance>> DBInstance{};

  DescribeDBInstancesForCloneResponseBodyItems() {}

  explicit DescribeDBInstancesForCloneResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstance) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstance") != m.end() && !m["DBInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstance"].type()) {
        vector<DescribeDBInstancesForCloneResponseBodyItemsDBInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstancesForCloneResponseBodyItemsDBInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstance = make_shared<vector<DescribeDBInstancesForCloneResponseBodyItemsDBInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstancesForCloneResponseBodyItems() = default;
};
class DescribeDBInstancesForCloneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeDBInstancesForCloneResponseBodyItems> items{};

  DescribeDBInstancesForCloneResponseBody() {}

  explicit DescribeDBInstancesForCloneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeDBInstancesForCloneResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeDBInstancesForCloneResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancesForCloneResponseBody() = default;
};
class DescribeDBInstancesForCloneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstancesForCloneResponseBody> body{};

  DescribeDBInstancesForCloneResponse() {}

  explicit DescribeDBInstancesForCloneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstancesForCloneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstancesForCloneResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstancesForCloneResponse() = default;
};
class DescribeDBInstanceSSLRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> ownerAccount{};

  DescribeDBInstanceSSLRequest() {}

  explicit DescribeDBInstanceSSLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeDBInstanceSSLRequest() = default;
};
class DescribeDBInstanceSSLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> serverCert{};
  shared_ptr<string> clientCACertExpireTime{};
  shared_ptr<string> requireUpdateItem{};
  shared_ptr<string> serverCAUrl{};
  shared_ptr<string> requireUpdate{};
  shared_ptr<string> clientCertRevocationList{};
  shared_ptr<string> SSLExpireTime{};
  shared_ptr<string> CAType{};
  shared_ptr<string> SSLCreateTime{};
  shared_ptr<string> replicationACL{};
  shared_ptr<string> ACL{};
  shared_ptr<string> requestId{};
  shared_ptr<string> lastModifyStatus{};
  shared_ptr<string> SSLEnabled{};
  shared_ptr<string> connectionString{};
  shared_ptr<string> requireUpdateReason{};
  shared_ptr<string> clientCACert{};
  shared_ptr<string> serverKey{};
  shared_ptr<string> modifyStatusReason{};

  DescribeDBInstanceSSLResponseBody() {}

  explicit DescribeDBInstanceSSLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serverCert) {
      res["ServerCert"] = boost::any(*serverCert);
    }
    if (clientCACertExpireTime) {
      res["ClientCACertExpireTime"] = boost::any(*clientCACertExpireTime);
    }
    if (requireUpdateItem) {
      res["RequireUpdateItem"] = boost::any(*requireUpdateItem);
    }
    if (serverCAUrl) {
      res["ServerCAUrl"] = boost::any(*serverCAUrl);
    }
    if (requireUpdate) {
      res["RequireUpdate"] = boost::any(*requireUpdate);
    }
    if (clientCertRevocationList) {
      res["ClientCertRevocationList"] = boost::any(*clientCertRevocationList);
    }
    if (SSLExpireTime) {
      res["SSLExpireTime"] = boost::any(*SSLExpireTime);
    }
    if (CAType) {
      res["CAType"] = boost::any(*CAType);
    }
    if (SSLCreateTime) {
      res["SSLCreateTime"] = boost::any(*SSLCreateTime);
    }
    if (replicationACL) {
      res["ReplicationACL"] = boost::any(*replicationACL);
    }
    if (ACL) {
      res["ACL"] = boost::any(*ACL);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (lastModifyStatus) {
      res["LastModifyStatus"] = boost::any(*lastModifyStatus);
    }
    if (SSLEnabled) {
      res["SSLEnabled"] = boost::any(*SSLEnabled);
    }
    if (connectionString) {
      res["ConnectionString"] = boost::any(*connectionString);
    }
    if (requireUpdateReason) {
      res["RequireUpdateReason"] = boost::any(*requireUpdateReason);
    }
    if (clientCACert) {
      res["ClientCACert"] = boost::any(*clientCACert);
    }
    if (serverKey) {
      res["ServerKey"] = boost::any(*serverKey);
    }
    if (modifyStatusReason) {
      res["ModifyStatusReason"] = boost::any(*modifyStatusReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServerCert") != m.end() && !m["ServerCert"].empty()) {
      serverCert = make_shared<string>(boost::any_cast<string>(m["ServerCert"]));
    }
    if (m.find("ClientCACertExpireTime") != m.end() && !m["ClientCACertExpireTime"].empty()) {
      clientCACertExpireTime = make_shared<string>(boost::any_cast<string>(m["ClientCACertExpireTime"]));
    }
    if (m.find("RequireUpdateItem") != m.end() && !m["RequireUpdateItem"].empty()) {
      requireUpdateItem = make_shared<string>(boost::any_cast<string>(m["RequireUpdateItem"]));
    }
    if (m.find("ServerCAUrl") != m.end() && !m["ServerCAUrl"].empty()) {
      serverCAUrl = make_shared<string>(boost::any_cast<string>(m["ServerCAUrl"]));
    }
    if (m.find("RequireUpdate") != m.end() && !m["RequireUpdate"].empty()) {
      requireUpdate = make_shared<string>(boost::any_cast<string>(m["RequireUpdate"]));
    }
    if (m.find("ClientCertRevocationList") != m.end() && !m["ClientCertRevocationList"].empty()) {
      clientCertRevocationList = make_shared<string>(boost::any_cast<string>(m["ClientCertRevocationList"]));
    }
    if (m.find("SSLExpireTime") != m.end() && !m["SSLExpireTime"].empty()) {
      SSLExpireTime = make_shared<string>(boost::any_cast<string>(m["SSLExpireTime"]));
    }
    if (m.find("CAType") != m.end() && !m["CAType"].empty()) {
      CAType = make_shared<string>(boost::any_cast<string>(m["CAType"]));
    }
    if (m.find("SSLCreateTime") != m.end() && !m["SSLCreateTime"].empty()) {
      SSLCreateTime = make_shared<string>(boost::any_cast<string>(m["SSLCreateTime"]));
    }
    if (m.find("ReplicationACL") != m.end() && !m["ReplicationACL"].empty()) {
      replicationACL = make_shared<string>(boost::any_cast<string>(m["ReplicationACL"]));
    }
    if (m.find("ACL") != m.end() && !m["ACL"].empty()) {
      ACL = make_shared<string>(boost::any_cast<string>(m["ACL"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("LastModifyStatus") != m.end() && !m["LastModifyStatus"].empty()) {
      lastModifyStatus = make_shared<string>(boost::any_cast<string>(m["LastModifyStatus"]));
    }
    if (m.find("SSLEnabled") != m.end() && !m["SSLEnabled"].empty()) {
      SSLEnabled = make_shared<string>(boost::any_cast<string>(m["SSLEnabled"]));
    }
    if (m.find("ConnectionString") != m.end() && !m["ConnectionString"].empty()) {
      connectionString = make_shared<string>(boost::any_cast<string>(m["ConnectionString"]));
    }
    if (m.find("RequireUpdateReason") != m.end() && !m["RequireUpdateReason"].empty()) {
      requireUpdateReason = make_shared<string>(boost::any_cast<string>(m["RequireUpdateReason"]));
    }
    if (m.find("ClientCACert") != m.end() && !m["ClientCACert"].empty()) {
      clientCACert = make_shared<string>(boost::any_cast<string>(m["ClientCACert"]));
    }
    if (m.find("ServerKey") != m.end() && !m["ServerKey"].empty()) {
      serverKey = make_shared<string>(boost::any_cast<string>(m["ServerKey"]));
    }
    if (m.find("ModifyStatusReason") != m.end() && !m["ModifyStatusReason"].empty()) {
      modifyStatusReason = make_shared<string>(boost::any_cast<string>(m["ModifyStatusReason"]));
    }
  }


  virtual ~DescribeDBInstanceSSLResponseBody() = default;
};
class DescribeDBInstanceSSLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstanceSSLResponseBody> body{};

  DescribeDBInstanceSSLResponse() {}

  explicit DescribeDBInstanceSSLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstanceSSLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstanceSSLResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceSSLResponse() = default;
};
class DescribeDBInstanceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> addressIP{};
  shared_ptr<string> addressPort{};

  DescribeDBInstanceStatusRequest() {}

  explicit DescribeDBInstanceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (addressIP) {
      res["AddressIP"] = boost::any(*addressIP);
    }
    if (addressPort) {
      res["AddressPort"] = boost::any(*addressPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AddressIP") != m.end() && !m["AddressIP"].empty()) {
      addressIP = make_shared<string>(boost::any_cast<string>(m["AddressIP"]));
    }
    if (m.find("AddressPort") != m.end() && !m["AddressPort"].empty()) {
      addressPort = make_shared<string>(boost::any_cast<string>(m["AddressPort"]));
    }
  }


  virtual ~DescribeDBInstanceStatusRequest() = default;
};
class DescribeDBInstanceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> DBInstanceCpuCores{};
  shared_ptr<long> taskStatus{};
  shared_ptr<long> DBInstanceId{};
  shared_ptr<long> DBInstanceStatus{};
  shared_ptr<string> DBInstanceUseType{};

  DescribeDBInstanceStatusResponseBody() {}

  explicit DescribeDBInstanceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (DBInstanceCpuCores) {
      res["DBInstanceCpuCores"] = boost::any(*DBInstanceCpuCores);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBInstanceStatus) {
      res["DBInstanceStatus"] = boost::any(*DBInstanceStatus);
    }
    if (DBInstanceUseType) {
      res["DBInstanceUseType"] = boost::any(*DBInstanceUseType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DBInstanceCpuCores") != m.end() && !m["DBInstanceCpuCores"].empty()) {
      DBInstanceCpuCores = make_shared<string>(boost::any_cast<string>(m["DBInstanceCpuCores"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<long>(boost::any_cast<long>(m["DBInstanceId"]));
    }
    if (m.find("DBInstanceStatus") != m.end() && !m["DBInstanceStatus"].empty()) {
      DBInstanceStatus = make_shared<long>(boost::any_cast<long>(m["DBInstanceStatus"]));
    }
    if (m.find("DBInstanceUseType") != m.end() && !m["DBInstanceUseType"].empty()) {
      DBInstanceUseType = make_shared<string>(boost::any_cast<string>(m["DBInstanceUseType"]));
    }
  }


  virtual ~DescribeDBInstanceStatusResponseBody() = default;
};
class DescribeDBInstanceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstanceStatusResponseBody> body{};

  DescribeDBInstanceStatusResponse() {}

  explicit DescribeDBInstanceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstanceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstanceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceStatusResponse() = default;
};
class DescribeDBInstanceTDERequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> ownerAccount{};

  DescribeDBInstanceTDERequest() {}

  explicit DescribeDBInstanceTDERequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeDBInstanceTDERequest() = default;
};
class DescribeDBInstanceTDEResponseBodyDatabasesDatabase : public Darabonba::Model {
public:
  shared_ptr<string> DBName{};
  shared_ptr<string> TDEStatus{};

  DescribeDBInstanceTDEResponseBodyDatabasesDatabase() {}

  explicit DescribeDBInstanceTDEResponseBodyDatabasesDatabase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (TDEStatus) {
      res["TDEStatus"] = boost::any(*TDEStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("TDEStatus") != m.end() && !m["TDEStatus"].empty()) {
      TDEStatus = make_shared<string>(boost::any_cast<string>(m["TDEStatus"]));
    }
  }


  virtual ~DescribeDBInstanceTDEResponseBodyDatabasesDatabase() = default;
};
class DescribeDBInstanceTDEResponseBodyDatabases : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBInstanceTDEResponseBodyDatabasesDatabase>> database{};

  DescribeDBInstanceTDEResponseBodyDatabases() {}

  explicit DescribeDBInstanceTDEResponseBodyDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      vector<boost::any> temp1;
      for(auto item1:*database){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Database"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      if (typeid(vector<boost::any>) == m["Database"].type()) {
        vector<DescribeDBInstanceTDEResponseBodyDatabasesDatabase> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Database"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBInstanceTDEResponseBodyDatabasesDatabase model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        database = make_shared<vector<DescribeDBInstanceTDEResponseBodyDatabasesDatabase>>(expect1);
      }
    }
  }


  virtual ~DescribeDBInstanceTDEResponseBodyDatabases() = default;
};
class DescribeDBInstanceTDEResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> TDEStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDBInstanceTDEResponseBodyDatabases> databases{};

  DescribeDBInstanceTDEResponseBody() {}

  explicit DescribeDBInstanceTDEResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TDEStatus) {
      res["TDEStatus"] = boost::any(*TDEStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (databases) {
      res["Databases"] = databases ? boost::any(databases->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TDEStatus") != m.end() && !m["TDEStatus"].empty()) {
      TDEStatus = make_shared<string>(boost::any_cast<string>(m["TDEStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(map<string, boost::any>) == m["Databases"].type()) {
        DescribeDBInstanceTDEResponseBodyDatabases model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Databases"]));
        databases = make_shared<DescribeDBInstanceTDEResponseBodyDatabases>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceTDEResponseBody() = default;
};
class DescribeDBInstanceTDEResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBInstanceTDEResponseBody> body{};

  DescribeDBInstanceTDEResponse() {}

  explicit DescribeDBInstanceTDEResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBInstanceTDEResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBInstanceTDEResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBInstanceTDEResponse() = default;
};
class DescribeDBProxyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> regionId{};

  DescribeDBProxyRequest() {}

  explicit DescribeDBProxyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDBProxyRequest() = default;
};
class DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems : public Darabonba::Model {
public:
  shared_ptr<string> DBProxyConnectStringNetWorkType{};
  shared_ptr<string> DBProxyConnectStringNetType{};
  shared_ptr<string> DBProxyVpcInstanceId{};
  shared_ptr<string> DBProxyEndpointName{};
  shared_ptr<string> DBProxyEndpointId{};
  shared_ptr<string> DBProxyConnectStringPort{};
  shared_ptr<string> DBProxyConnectString{};

  DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems() {}

  explicit DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBProxyConnectStringNetWorkType) {
      res["DBProxyConnectStringNetWorkType"] = boost::any(*DBProxyConnectStringNetWorkType);
    }
    if (DBProxyConnectStringNetType) {
      res["DBProxyConnectStringNetType"] = boost::any(*DBProxyConnectStringNetType);
    }
    if (DBProxyVpcInstanceId) {
      res["DBProxyVpcInstanceId"] = boost::any(*DBProxyVpcInstanceId);
    }
    if (DBProxyEndpointName) {
      res["DBProxyEndpointName"] = boost::any(*DBProxyEndpointName);
    }
    if (DBProxyEndpointId) {
      res["DBProxyEndpointId"] = boost::any(*DBProxyEndpointId);
    }
    if (DBProxyConnectStringPort) {
      res["DBProxyConnectStringPort"] = boost::any(*DBProxyConnectStringPort);
    }
    if (DBProxyConnectString) {
      res["DBProxyConnectString"] = boost::any(*DBProxyConnectString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBProxyConnectStringNetWorkType") != m.end() && !m["DBProxyConnectStringNetWorkType"].empty()) {
      DBProxyConnectStringNetWorkType = make_shared<string>(boost::any_cast<string>(m["DBProxyConnectStringNetWorkType"]));
    }
    if (m.find("DBProxyConnectStringNetType") != m.end() && !m["DBProxyConnectStringNetType"].empty()) {
      DBProxyConnectStringNetType = make_shared<string>(boost::any_cast<string>(m["DBProxyConnectStringNetType"]));
    }
    if (m.find("DBProxyVpcInstanceId") != m.end() && !m["DBProxyVpcInstanceId"].empty()) {
      DBProxyVpcInstanceId = make_shared<string>(boost::any_cast<string>(m["DBProxyVpcInstanceId"]));
    }
    if (m.find("DBProxyEndpointName") != m.end() && !m["DBProxyEndpointName"].empty()) {
      DBProxyEndpointName = make_shared<string>(boost::any_cast<string>(m["DBProxyEndpointName"]));
    }
    if (m.find("DBProxyEndpointId") != m.end() && !m["DBProxyEndpointId"].empty()) {
      DBProxyEndpointId = make_shared<string>(boost::any_cast<string>(m["DBProxyEndpointId"]));
    }
    if (m.find("DBProxyConnectStringPort") != m.end() && !m["DBProxyConnectStringPort"].empty()) {
      DBProxyConnectStringPort = make_shared<string>(boost::any_cast<string>(m["DBProxyConnectStringPort"]));
    }
    if (m.find("DBProxyConnectString") != m.end() && !m["DBProxyConnectString"].empty()) {
      DBProxyConnectString = make_shared<string>(boost::any_cast<string>(m["DBProxyConnectString"]));
    }
  }


  virtual ~DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems() = default;
};
class DescribeDBProxyResponseBodyDBProxyConnectStringItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems>> DBProxyConnectStringItems{};

  DescribeDBProxyResponseBodyDBProxyConnectStringItems() {}

  explicit DescribeDBProxyResponseBodyDBProxyConnectStringItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBProxyConnectStringItems) {
      vector<boost::any> temp1;
      for(auto item1:*DBProxyConnectStringItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBProxyConnectStringItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBProxyConnectStringItems") != m.end() && !m["DBProxyConnectStringItems"].empty()) {
      if (typeid(vector<boost::any>) == m["DBProxyConnectStringItems"].type()) {
        vector<DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBProxyConnectStringItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBProxyConnectStringItems = make_shared<vector<DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems>>(expect1);
      }
    }
  }


  virtual ~DescribeDBProxyResponseBodyDBProxyConnectStringItems() = default;
};
class DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems : public Darabonba::Model {
public:
  shared_ptr<string> dbProxyEndpointAliases{};
  shared_ptr<string> dbProxyEndpointName{};
  shared_ptr<string> dbProxyEndpointType{};
  shared_ptr<string> dbProxyReadWriteMode{};

  DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems() {}

  explicit DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbProxyEndpointAliases) {
      res["DbProxyEndpointAliases"] = boost::any(*dbProxyEndpointAliases);
    }
    if (dbProxyEndpointName) {
      res["DbProxyEndpointName"] = boost::any(*dbProxyEndpointName);
    }
    if (dbProxyEndpointType) {
      res["DbProxyEndpointType"] = boost::any(*dbProxyEndpointType);
    }
    if (dbProxyReadWriteMode) {
      res["DbProxyReadWriteMode"] = boost::any(*dbProxyReadWriteMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbProxyEndpointAliases") != m.end() && !m["DbProxyEndpointAliases"].empty()) {
      dbProxyEndpointAliases = make_shared<string>(boost::any_cast<string>(m["DbProxyEndpointAliases"]));
    }
    if (m.find("DbProxyEndpointName") != m.end() && !m["DbProxyEndpointName"].empty()) {
      dbProxyEndpointName = make_shared<string>(boost::any_cast<string>(m["DbProxyEndpointName"]));
    }
    if (m.find("DbProxyEndpointType") != m.end() && !m["DbProxyEndpointType"].empty()) {
      dbProxyEndpointType = make_shared<string>(boost::any_cast<string>(m["DbProxyEndpointType"]));
    }
    if (m.find("DbProxyReadWriteMode") != m.end() && !m["DbProxyReadWriteMode"].empty()) {
      dbProxyReadWriteMode = make_shared<string>(boost::any_cast<string>(m["DbProxyReadWriteMode"]));
    }
  }


  virtual ~DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems() = default;
};
class DescribeDBProxyResponseBodyDbProxyEndpointItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems>> dbProxyEndpointItems{};

  DescribeDBProxyResponseBodyDbProxyEndpointItems() {}

  explicit DescribeDBProxyResponseBodyDbProxyEndpointItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbProxyEndpointItems) {
      vector<boost::any> temp1;
      for(auto item1:*dbProxyEndpointItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DbProxyEndpointItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbProxyEndpointItems") != m.end() && !m["DbProxyEndpointItems"].empty()) {
      if (typeid(vector<boost::any>) == m["DbProxyEndpointItems"].type()) {
        vector<DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DbProxyEndpointItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dbProxyEndpointItems = make_shared<vector<DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems>>(expect1);
      }
    }
  }


  virtual ~DescribeDBProxyResponseBodyDbProxyEndpointItems() = default;
};
class DescribeDBProxyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBProxyInstanceLatestMinorVersion{};
  shared_ptr<string> requestId{};
  shared_ptr<string> DBProxyInstanceCurrentMinorVersion{};
  shared_ptr<long> DBProxyInstanceNum{};
  shared_ptr<string> DBProxyInstanceType{};
  shared_ptr<string> DBProxyInstanceStatus{};
  shared_ptr<string> DBProxyServiceStatus{};
  shared_ptr<string> DBProxyInstanceName{};
  shared_ptr<DescribeDBProxyResponseBodyDBProxyConnectStringItems> DBProxyConnectStringItems{};
  shared_ptr<DescribeDBProxyResponseBodyDbProxyEndpointItems> dbProxyEndpointItems{};

  DescribeDBProxyResponseBody() {}

  explicit DescribeDBProxyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBProxyInstanceLatestMinorVersion) {
      res["DBProxyInstanceLatestMinorVersion"] = boost::any(*DBProxyInstanceLatestMinorVersion);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (DBProxyInstanceCurrentMinorVersion) {
      res["DBProxyInstanceCurrentMinorVersion"] = boost::any(*DBProxyInstanceCurrentMinorVersion);
    }
    if (DBProxyInstanceNum) {
      res["DBProxyInstanceNum"] = boost::any(*DBProxyInstanceNum);
    }
    if (DBProxyInstanceType) {
      res["DBProxyInstanceType"] = boost::any(*DBProxyInstanceType);
    }
    if (DBProxyInstanceStatus) {
      res["DBProxyInstanceStatus"] = boost::any(*DBProxyInstanceStatus);
    }
    if (DBProxyServiceStatus) {
      res["DBProxyServiceStatus"] = boost::any(*DBProxyServiceStatus);
    }
    if (DBProxyInstanceName) {
      res["DBProxyInstanceName"] = boost::any(*DBProxyInstanceName);
    }
    if (DBProxyConnectStringItems) {
      res["DBProxyConnectStringItems"] = DBProxyConnectStringItems ? boost::any(DBProxyConnectStringItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dbProxyEndpointItems) {
      res["DbProxyEndpointItems"] = dbProxyEndpointItems ? boost::any(dbProxyEndpointItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBProxyInstanceLatestMinorVersion") != m.end() && !m["DBProxyInstanceLatestMinorVersion"].empty()) {
      DBProxyInstanceLatestMinorVersion = make_shared<string>(boost::any_cast<string>(m["DBProxyInstanceLatestMinorVersion"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DBProxyInstanceCurrentMinorVersion") != m.end() && !m["DBProxyInstanceCurrentMinorVersion"].empty()) {
      DBProxyInstanceCurrentMinorVersion = make_shared<string>(boost::any_cast<string>(m["DBProxyInstanceCurrentMinorVersion"]));
    }
    if (m.find("DBProxyInstanceNum") != m.end() && !m["DBProxyInstanceNum"].empty()) {
      DBProxyInstanceNum = make_shared<long>(boost::any_cast<long>(m["DBProxyInstanceNum"]));
    }
    if (m.find("DBProxyInstanceType") != m.end() && !m["DBProxyInstanceType"].empty()) {
      DBProxyInstanceType = make_shared<string>(boost::any_cast<string>(m["DBProxyInstanceType"]));
    }
    if (m.find("DBProxyInstanceStatus") != m.end() && !m["DBProxyInstanceStatus"].empty()) {
      DBProxyInstanceStatus = make_shared<string>(boost::any_cast<string>(m["DBProxyInstanceStatus"]));
    }
    if (m.find("DBProxyServiceStatus") != m.end() && !m["DBProxyServiceStatus"].empty()) {
      DBProxyServiceStatus = make_shared<string>(boost::any_cast<string>(m["DBProxyServiceStatus"]));
    }
    if (m.find("DBProxyInstanceName") != m.end() && !m["DBProxyInstanceName"].empty()) {
      DBProxyInstanceName = make_shared<string>(boost::any_cast<string>(m["DBProxyInstanceName"]));
    }
    if (m.find("DBProxyConnectStringItems") != m.end() && !m["DBProxyConnectStringItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["DBProxyConnectStringItems"].type()) {
        DescribeDBProxyResponseBodyDBProxyConnectStringItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DBProxyConnectStringItems"]));
        DBProxyConnectStringItems = make_shared<DescribeDBProxyResponseBodyDBProxyConnectStringItems>(model1);
      }
    }
    if (m.find("DbProxyEndpointItems") != m.end() && !m["DbProxyEndpointItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["DbProxyEndpointItems"].type()) {
        DescribeDBProxyResponseBodyDbProxyEndpointItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DbProxyEndpointItems"]));
        dbProxyEndpointItems = make_shared<DescribeDBProxyResponseBodyDbProxyEndpointItems>(model1);
      }
    }
  }


  virtual ~DescribeDBProxyResponseBody() = default;
};
class DescribeDBProxyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBProxyResponseBody> body{};

  DescribeDBProxyResponse() {}

  explicit DescribeDBProxyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBProxyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBProxyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBProxyResponse() = default;
};
class DescribeDBProxyEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBProxyEndpointId{};
  shared_ptr<string> DBProxyConnectString{};
  shared_ptr<string> regionId{};

  DescribeDBProxyEndpointRequest() {}

  explicit DescribeDBProxyEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBProxyEndpointId) {
      res["DBProxyEndpointId"] = boost::any(*DBProxyEndpointId);
    }
    if (DBProxyConnectString) {
      res["DBProxyConnectString"] = boost::any(*DBProxyConnectString);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBProxyEndpointId") != m.end() && !m["DBProxyEndpointId"].empty()) {
      DBProxyEndpointId = make_shared<string>(boost::any_cast<string>(m["DBProxyEndpointId"]));
    }
    if (m.find("DBProxyConnectString") != m.end() && !m["DBProxyConnectString"].empty()) {
      DBProxyConnectString = make_shared<string>(boost::any_cast<string>(m["DBProxyConnectString"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDBProxyEndpointRequest() = default;
};
class DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems : public Darabonba::Model {
public:
  shared_ptr<string> dbProxyEndpointPort{};
  shared_ptr<string> dbProxyEndpointConnectString{};
  shared_ptr<string> dbProxyEndpointNetType{};

  DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems() {}

  explicit DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbProxyEndpointPort) {
      res["DbProxyEndpointPort"] = boost::any(*dbProxyEndpointPort);
    }
    if (dbProxyEndpointConnectString) {
      res["DbProxyEndpointConnectString"] = boost::any(*dbProxyEndpointConnectString);
    }
    if (dbProxyEndpointNetType) {
      res["DbProxyEndpointNetType"] = boost::any(*dbProxyEndpointNetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbProxyEndpointPort") != m.end() && !m["DbProxyEndpointPort"].empty()) {
      dbProxyEndpointPort = make_shared<string>(boost::any_cast<string>(m["DbProxyEndpointPort"]));
    }
    if (m.find("DbProxyEndpointConnectString") != m.end() && !m["DbProxyEndpointConnectString"].empty()) {
      dbProxyEndpointConnectString = make_shared<string>(boost::any_cast<string>(m["DbProxyEndpointConnectString"]));
    }
    if (m.find("DbProxyEndpointNetType") != m.end() && !m["DbProxyEndpointNetType"].empty()) {
      dbProxyEndpointNetType = make_shared<string>(boost::any_cast<string>(m["DbProxyEndpointNetType"]));
    }
  }


  virtual ~DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems() = default;
};
class DescribeDBProxyEndpointResponseBodyEndpointConnectItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems>> endpointConnectItems{};

  DescribeDBProxyEndpointResponseBodyEndpointConnectItems() {}

  explicit DescribeDBProxyEndpointResponseBodyEndpointConnectItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointConnectItems) {
      vector<boost::any> temp1;
      for(auto item1:*endpointConnectItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointConnectItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointConnectItems") != m.end() && !m["EndpointConnectItems"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointConnectItems"].type()) {
        vector<DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointConnectItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointConnectItems = make_shared<vector<DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems>>(expect1);
      }
    }
  }


  virtual ~DescribeDBProxyEndpointResponseBodyEndpointConnectItems() = default;
};
class DescribeDBProxyEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBProxyConnectStringNetType{};
  shared_ptr<string> DBProxyFeatures{};
  shared_ptr<string> requestId{};
  shared_ptr<string> readOnlyInstanceWeight{};
  shared_ptr<string> readOnlyInstanceDistributionType{};
  shared_ptr<string> readOnlyInstanceMaxDelayTime{};
  shared_ptr<string> dbProxyEndpointReadWriteMode{};
  shared_ptr<string> dbProxyEndpointAliases{};
  shared_ptr<string> DBProxyEndpointId{};
  shared_ptr<string> DBProxyConnectStringPort{};
  shared_ptr<string> DBProxyConnectString{};
  shared_ptr<DescribeDBProxyEndpointResponseBodyEndpointConnectItems> endpointConnectItems{};

  DescribeDBProxyEndpointResponseBody() {}

  explicit DescribeDBProxyEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBProxyConnectStringNetType) {
      res["DBProxyConnectStringNetType"] = boost::any(*DBProxyConnectStringNetType);
    }
    if (DBProxyFeatures) {
      res["DBProxyFeatures"] = boost::any(*DBProxyFeatures);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (readOnlyInstanceWeight) {
      res["ReadOnlyInstanceWeight"] = boost::any(*readOnlyInstanceWeight);
    }
    if (readOnlyInstanceDistributionType) {
      res["ReadOnlyInstanceDistributionType"] = boost::any(*readOnlyInstanceDistributionType);
    }
    if (readOnlyInstanceMaxDelayTime) {
      res["ReadOnlyInstanceMaxDelayTime"] = boost::any(*readOnlyInstanceMaxDelayTime);
    }
    if (dbProxyEndpointReadWriteMode) {
      res["DbProxyEndpointReadWriteMode"] = boost::any(*dbProxyEndpointReadWriteMode);
    }
    if (dbProxyEndpointAliases) {
      res["DbProxyEndpointAliases"] = boost::any(*dbProxyEndpointAliases);
    }
    if (DBProxyEndpointId) {
      res["DBProxyEndpointId"] = boost::any(*DBProxyEndpointId);
    }
    if (DBProxyConnectStringPort) {
      res["DBProxyConnectStringPort"] = boost::any(*DBProxyConnectStringPort);
    }
    if (DBProxyConnectString) {
      res["DBProxyConnectString"] = boost::any(*DBProxyConnectString);
    }
    if (endpointConnectItems) {
      res["EndpointConnectItems"] = endpointConnectItems ? boost::any(endpointConnectItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBProxyConnectStringNetType") != m.end() && !m["DBProxyConnectStringNetType"].empty()) {
      DBProxyConnectStringNetType = make_shared<string>(boost::any_cast<string>(m["DBProxyConnectStringNetType"]));
    }
    if (m.find("DBProxyFeatures") != m.end() && !m["DBProxyFeatures"].empty()) {
      DBProxyFeatures = make_shared<string>(boost::any_cast<string>(m["DBProxyFeatures"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReadOnlyInstanceWeight") != m.end() && !m["ReadOnlyInstanceWeight"].empty()) {
      readOnlyInstanceWeight = make_shared<string>(boost::any_cast<string>(m["ReadOnlyInstanceWeight"]));
    }
    if (m.find("ReadOnlyInstanceDistributionType") != m.end() && !m["ReadOnlyInstanceDistributionType"].empty()) {
      readOnlyInstanceDistributionType = make_shared<string>(boost::any_cast<string>(m["ReadOnlyInstanceDistributionType"]));
    }
    if (m.find("ReadOnlyInstanceMaxDelayTime") != m.end() && !m["ReadOnlyInstanceMaxDelayTime"].empty()) {
      readOnlyInstanceMaxDelayTime = make_shared<string>(boost::any_cast<string>(m["ReadOnlyInstanceMaxDelayTime"]));
    }
    if (m.find("DbProxyEndpointReadWriteMode") != m.end() && !m["DbProxyEndpointReadWriteMode"].empty()) {
      dbProxyEndpointReadWriteMode = make_shared<string>(boost::any_cast<string>(m["DbProxyEndpointReadWriteMode"]));
    }
    if (m.find("DbProxyEndpointAliases") != m.end() && !m["DbProxyEndpointAliases"].empty()) {
      dbProxyEndpointAliases = make_shared<string>(boost::any_cast<string>(m["DbProxyEndpointAliases"]));
    }
    if (m.find("DBProxyEndpointId") != m.end() && !m["DBProxyEndpointId"].empty()) {
      DBProxyEndpointId = make_shared<string>(boost::any_cast<string>(m["DBProxyEndpointId"]));
    }
    if (m.find("DBProxyConnectStringPort") != m.end() && !m["DBProxyConnectStringPort"].empty()) {
      DBProxyConnectStringPort = make_shared<string>(boost::any_cast<string>(m["DBProxyConnectStringPort"]));
    }
    if (m.find("DBProxyConnectString") != m.end() && !m["DBProxyConnectString"].empty()) {
      DBProxyConnectString = make_shared<string>(boost::any_cast<string>(m["DBProxyConnectString"]));
    }
    if (m.find("EndpointConnectItems") != m.end() && !m["EndpointConnectItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["EndpointConnectItems"].type()) {
        DescribeDBProxyEndpointResponseBodyEndpointConnectItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EndpointConnectItems"]));
        endpointConnectItems = make_shared<DescribeDBProxyEndpointResponseBodyEndpointConnectItems>(model1);
      }
    }
  }


  virtual ~DescribeDBProxyEndpointResponseBody() = default;
};
class DescribeDBProxyEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBProxyEndpointResponseBody> body{};

  DescribeDBProxyEndpointResponse() {}

  explicit DescribeDBProxyEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBProxyEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBProxyEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBProxyEndpointResponse() = default;
};
class DescribeDBProxyPerformanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBProxyInstanceType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> metricsName{};

  DescribeDBProxyPerformanceRequest() {}

  explicit DescribeDBProxyPerformanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBProxyInstanceType) {
      res["DBProxyInstanceType"] = boost::any(*DBProxyInstanceType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (metricsName) {
      res["MetricsName"] = boost::any(*metricsName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBProxyInstanceType") != m.end() && !m["DBProxyInstanceType"].empty()) {
      DBProxyInstanceType = make_shared<string>(boost::any_cast<string>(m["DBProxyInstanceType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("MetricsName") != m.end() && !m["MetricsName"].empty()) {
      metricsName = make_shared<string>(boost::any_cast<string>(m["MetricsName"]));
    }
  }


  virtual ~DescribeDBProxyPerformanceRequest() = default;
};
class DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> value{};

  DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue() {}

  explicit DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue() = default;
};
class DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue>> performanceValue{};

  DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues() {}

  explicit DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (performanceValue) {
      vector<boost::any> temp1;
      for(auto item1:*performanceValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PerformanceValue"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerformanceValue") != m.end() && !m["PerformanceValue"].empty()) {
      if (typeid(vector<boost::any>) == m["PerformanceValue"].type()) {
        vector<DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PerformanceValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        performanceValue = make_shared<vector<DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue>>(expect1);
      }
    }
  }


  virtual ~DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues() = default;
};
class DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey : public Darabonba::Model {
public:
  shared_ptr<string> valueFormat{};
  shared_ptr<string> key{};
  shared_ptr<DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues> values{};

  DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey() {}

  explicit DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (valueFormat) {
      res["ValueFormat"] = boost::any(*valueFormat);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (values) {
      res["Values"] = values ? boost::any(values->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ValueFormat") != m.end() && !m["ValueFormat"].empty()) {
      valueFormat = make_shared<string>(boost::any_cast<string>(m["ValueFormat"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      if (typeid(map<string, boost::any>) == m["Values"].type()) {
        DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Values"]));
        values = make_shared<DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues>(model1);
      }
    }
  }


  virtual ~DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey() = default;
};
class DescribeDBProxyPerformanceResponseBodyPerformanceKeys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey>> performanceKey{};

  DescribeDBProxyPerformanceResponseBodyPerformanceKeys() {}

  explicit DescribeDBProxyPerformanceResponseBodyPerformanceKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (performanceKey) {
      vector<boost::any> temp1;
      for(auto item1:*performanceKey){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PerformanceKey"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerformanceKey") != m.end() && !m["PerformanceKey"].empty()) {
      if (typeid(vector<boost::any>) == m["PerformanceKey"].type()) {
        vector<DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PerformanceKey"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        performanceKey = make_shared<vector<DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey>>(expect1);
      }
    }
  }


  virtual ~DescribeDBProxyPerformanceResponseBodyPerformanceKeys() = default;
};
class DescribeDBProxyPerformanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDBProxyPerformanceResponseBodyPerformanceKeys> performanceKeys{};

  DescribeDBProxyPerformanceResponseBody() {}

  explicit DescribeDBProxyPerformanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (performanceKeys) {
      res["PerformanceKeys"] = performanceKeys ? boost::any(performanceKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PerformanceKeys") != m.end() && !m["PerformanceKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["PerformanceKeys"].type()) {
        DescribeDBProxyPerformanceResponseBodyPerformanceKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PerformanceKeys"]));
        performanceKeys = make_shared<DescribeDBProxyPerformanceResponseBodyPerformanceKeys>(model1);
      }
    }
  }


  virtual ~DescribeDBProxyPerformanceResponseBody() = default;
};
class DescribeDBProxyPerformanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDBProxyPerformanceResponseBody> body{};

  DescribeDBProxyPerformanceResponse() {}

  explicit DescribeDBProxyPerformanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDBProxyPerformanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDBProxyPerformanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDBProxyPerformanceResponse() = default;
};
class DescribeDedicatedHostAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> dedicatedHostGroupId{};

  DescribeDedicatedHostAttributeRequest() {}

  explicit DescribeDedicatedHostAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
  }


  virtual ~DescribeDedicatedHostAttributeRequest() = default;
};
class DescribeDedicatedHostAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> CPUAllocationRatio{};
  shared_ptr<string> diskAllocationRatio{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<long> instanceNumber{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> autoRenew{};
  shared_ptr<string> imageCategory{};
  shared_ptr<long> hostStorage{};
  shared_ptr<long> instanceNumberSlave{};
  shared_ptr<string> openPermission{};
  shared_ptr<string> hostType{};
  shared_ptr<string> expiredTime{};
  shared_ptr<long> hostMem{};
  shared_ptr<string> memoryUsed{};
  shared_ptr<string> hostStatus{};
  shared_ptr<string> cpuUsed{};
  shared_ptr<string> hostName{};
  shared_ptr<long> instanceNumberROSlave{};
  shared_ptr<string> allocationStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<string> memAllocationRatio{};
  shared_ptr<string> zoneId{};
  shared_ptr<long> instanceNumberROMaster{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<long> instanceNumberMaster{};
  shared_ptr<string> storageUsed{};
  shared_ptr<string> hostClass{};
  shared_ptr<long> hostCPU{};
  shared_ptr<string> regionId{};
  shared_ptr<string> IPAddress{};
  shared_ptr<string> accountName{};

  DescribeDedicatedHostAttributeResponseBody() {}

  explicit DescribeDedicatedHostAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CPUAllocationRatio) {
      res["CPUAllocationRatio"] = boost::any(*CPUAllocationRatio);
    }
    if (diskAllocationRatio) {
      res["DiskAllocationRatio"] = boost::any(*diskAllocationRatio);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (instanceNumber) {
      res["InstanceNumber"] = boost::any(*instanceNumber);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (imageCategory) {
      res["ImageCategory"] = boost::any(*imageCategory);
    }
    if (hostStorage) {
      res["HostStorage"] = boost::any(*hostStorage);
    }
    if (instanceNumberSlave) {
      res["InstanceNumberSlave"] = boost::any(*instanceNumberSlave);
    }
    if (openPermission) {
      res["OpenPermission"] = boost::any(*openPermission);
    }
    if (hostType) {
      res["HostType"] = boost::any(*hostType);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (hostMem) {
      res["HostMem"] = boost::any(*hostMem);
    }
    if (memoryUsed) {
      res["MemoryUsed"] = boost::any(*memoryUsed);
    }
    if (hostStatus) {
      res["HostStatus"] = boost::any(*hostStatus);
    }
    if (cpuUsed) {
      res["CpuUsed"] = boost::any(*cpuUsed);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceNumberROSlave) {
      res["InstanceNumberROSlave"] = boost::any(*instanceNumberROSlave);
    }
    if (allocationStatus) {
      res["AllocationStatus"] = boost::any(*allocationStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (memAllocationRatio) {
      res["MemAllocationRatio"] = boost::any(*memAllocationRatio);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (instanceNumberROMaster) {
      res["InstanceNumberROMaster"] = boost::any(*instanceNumberROMaster);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (instanceNumberMaster) {
      res["InstanceNumberMaster"] = boost::any(*instanceNumberMaster);
    }
    if (storageUsed) {
      res["StorageUsed"] = boost::any(*storageUsed);
    }
    if (hostClass) {
      res["HostClass"] = boost::any(*hostClass);
    }
    if (hostCPU) {
      res["HostCPU"] = boost::any(*hostCPU);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (IPAddress) {
      res["IPAddress"] = boost::any(*IPAddress);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CPUAllocationRatio") != m.end() && !m["CPUAllocationRatio"].empty()) {
      CPUAllocationRatio = make_shared<string>(boost::any_cast<string>(m["CPUAllocationRatio"]));
    }
    if (m.find("DiskAllocationRatio") != m.end() && !m["DiskAllocationRatio"].empty()) {
      diskAllocationRatio = make_shared<string>(boost::any_cast<string>(m["DiskAllocationRatio"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("InstanceNumber") != m.end() && !m["InstanceNumber"].empty()) {
      instanceNumber = make_shared<long>(boost::any_cast<long>(m["InstanceNumber"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<string>(boost::any_cast<string>(m["AutoRenew"]));
    }
    if (m.find("ImageCategory") != m.end() && !m["ImageCategory"].empty()) {
      imageCategory = make_shared<string>(boost::any_cast<string>(m["ImageCategory"]));
    }
    if (m.find("HostStorage") != m.end() && !m["HostStorage"].empty()) {
      hostStorage = make_shared<long>(boost::any_cast<long>(m["HostStorage"]));
    }
    if (m.find("InstanceNumberSlave") != m.end() && !m["InstanceNumberSlave"].empty()) {
      instanceNumberSlave = make_shared<long>(boost::any_cast<long>(m["InstanceNumberSlave"]));
    }
    if (m.find("OpenPermission") != m.end() && !m["OpenPermission"].empty()) {
      openPermission = make_shared<string>(boost::any_cast<string>(m["OpenPermission"]));
    }
    if (m.find("HostType") != m.end() && !m["HostType"].empty()) {
      hostType = make_shared<string>(boost::any_cast<string>(m["HostType"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("HostMem") != m.end() && !m["HostMem"].empty()) {
      hostMem = make_shared<long>(boost::any_cast<long>(m["HostMem"]));
    }
    if (m.find("MemoryUsed") != m.end() && !m["MemoryUsed"].empty()) {
      memoryUsed = make_shared<string>(boost::any_cast<string>(m["MemoryUsed"]));
    }
    if (m.find("HostStatus") != m.end() && !m["HostStatus"].empty()) {
      hostStatus = make_shared<string>(boost::any_cast<string>(m["HostStatus"]));
    }
    if (m.find("CpuUsed") != m.end() && !m["CpuUsed"].empty()) {
      cpuUsed = make_shared<string>(boost::any_cast<string>(m["CpuUsed"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceNumberROSlave") != m.end() && !m["InstanceNumberROSlave"].empty()) {
      instanceNumberROSlave = make_shared<long>(boost::any_cast<long>(m["InstanceNumberROSlave"]));
    }
    if (m.find("AllocationStatus") != m.end() && !m["AllocationStatus"].empty()) {
      allocationStatus = make_shared<string>(boost::any_cast<string>(m["AllocationStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MemAllocationRatio") != m.end() && !m["MemAllocationRatio"].empty()) {
      memAllocationRatio = make_shared<string>(boost::any_cast<string>(m["MemAllocationRatio"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("InstanceNumberROMaster") != m.end() && !m["InstanceNumberROMaster"].empty()) {
      instanceNumberROMaster = make_shared<long>(boost::any_cast<long>(m["InstanceNumberROMaster"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("InstanceNumberMaster") != m.end() && !m["InstanceNumberMaster"].empty()) {
      instanceNumberMaster = make_shared<long>(boost::any_cast<long>(m["InstanceNumberMaster"]));
    }
    if (m.find("StorageUsed") != m.end() && !m["StorageUsed"].empty()) {
      storageUsed = make_shared<string>(boost::any_cast<string>(m["StorageUsed"]));
    }
    if (m.find("HostClass") != m.end() && !m["HostClass"].empty()) {
      hostClass = make_shared<string>(boost::any_cast<string>(m["HostClass"]));
    }
    if (m.find("HostCPU") != m.end() && !m["HostCPU"].empty()) {
      hostCPU = make_shared<long>(boost::any_cast<long>(m["HostCPU"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("IPAddress") != m.end() && !m["IPAddress"].empty()) {
      IPAddress = make_shared<string>(boost::any_cast<string>(m["IPAddress"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
  }


  virtual ~DescribeDedicatedHostAttributeResponseBody() = default;
};
class DescribeDedicatedHostAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDedicatedHostAttributeResponseBody> body{};

  DescribeDedicatedHostAttributeResponse() {}

  explicit DescribeDedicatedHostAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedHostAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedHostAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostAttributeResponse() = default;
};
class DescribeDedicatedHostGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> imageCategory{};

  DescribeDedicatedHostGroupsRequest() {}

  explicit DescribeDedicatedHostGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (imageCategory) {
      res["ImageCategory"] = boost::any(*imageCategory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("ImageCategory") != m.end() && !m["ImageCategory"].empty()) {
      imageCategory = make_shared<string>(boost::any_cast<string>(m["ImageCategory"]));
    }
  }


  virtual ~DescribeDedicatedHostGroupsRequest() = default;
};
class DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> zoneIDList{};

  DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList() {}

  explicit DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneIDList) {
      res["ZoneIDList"] = boost::any(*zoneIDList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZoneIDList") != m.end() && !m["ZoneIDList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ZoneIDList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ZoneIDList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zoneIDList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList() = default;
};
class DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups : public Darabonba::Model {
public:
  shared_ptr<double> diskAllocateRation{};
  shared_ptr<string> createTime{};
  shared_ptr<map<string, boost::any>> dedicatedHostCountGroupByHostType{};
  shared_ptr<string> text{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<double> diskUtility{};
  shared_ptr<double> memUsedAmount{};
  shared_ptr<double> memAllocatedAmount{};
  shared_ptr<long> cpuAllocationRatio{};
  shared_ptr<long> memAllocationRatio{};
  shared_ptr<double> memUtility{};
  shared_ptr<double> memAllocateRation{};
  shared_ptr<double> cpuAllocatedAmount{};
  shared_ptr<string> dedicatedHostGroupDesc{};
  shared_ptr<double> cpuAllocateRation{};
  shared_ptr<long> instanceNumber{};
  shared_ptr<string> openPermission{};
  shared_ptr<string> VPCId{};
  shared_ptr<double> diskAllocatedAmount{};
  shared_ptr<long> hostNumber{};
  shared_ptr<double> diskUsedAmount{};
  shared_ptr<string> allocationPolicy{};
  shared_ptr<string> engine{};
  shared_ptr<long> diskAllocationRatio{};
  shared_ptr<string> bastionInstanceId{};
  shared_ptr<string> hostReplacePolicy{};
  shared_ptr<DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList> zoneIDList{};

  DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups() {}

  explicit DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskAllocateRation) {
      res["DiskAllocateRation"] = boost::any(*diskAllocateRation);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dedicatedHostCountGroupByHostType) {
      res["DedicatedHostCountGroupByHostType"] = boost::any(*dedicatedHostCountGroupByHostType);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (diskUtility) {
      res["DiskUtility"] = boost::any(*diskUtility);
    }
    if (memUsedAmount) {
      res["MemUsedAmount"] = boost::any(*memUsedAmount);
    }
    if (memAllocatedAmount) {
      res["MemAllocatedAmount"] = boost::any(*memAllocatedAmount);
    }
    if (cpuAllocationRatio) {
      res["CpuAllocationRatio"] = boost::any(*cpuAllocationRatio);
    }
    if (memAllocationRatio) {
      res["MemAllocationRatio"] = boost::any(*memAllocationRatio);
    }
    if (memUtility) {
      res["MemUtility"] = boost::any(*memUtility);
    }
    if (memAllocateRation) {
      res["MemAllocateRation"] = boost::any(*memAllocateRation);
    }
    if (cpuAllocatedAmount) {
      res["CpuAllocatedAmount"] = boost::any(*cpuAllocatedAmount);
    }
    if (dedicatedHostGroupDesc) {
      res["DedicatedHostGroupDesc"] = boost::any(*dedicatedHostGroupDesc);
    }
    if (cpuAllocateRation) {
      res["CpuAllocateRation"] = boost::any(*cpuAllocateRation);
    }
    if (instanceNumber) {
      res["InstanceNumber"] = boost::any(*instanceNumber);
    }
    if (openPermission) {
      res["OpenPermission"] = boost::any(*openPermission);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (diskAllocatedAmount) {
      res["DiskAllocatedAmount"] = boost::any(*diskAllocatedAmount);
    }
    if (hostNumber) {
      res["HostNumber"] = boost::any(*hostNumber);
    }
    if (diskUsedAmount) {
      res["DiskUsedAmount"] = boost::any(*diskUsedAmount);
    }
    if (allocationPolicy) {
      res["AllocationPolicy"] = boost::any(*allocationPolicy);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (diskAllocationRatio) {
      res["DiskAllocationRatio"] = boost::any(*diskAllocationRatio);
    }
    if (bastionInstanceId) {
      res["BastionInstanceId"] = boost::any(*bastionInstanceId);
    }
    if (hostReplacePolicy) {
      res["HostReplacePolicy"] = boost::any(*hostReplacePolicy);
    }
    if (zoneIDList) {
      res["ZoneIDList"] = zoneIDList ? boost::any(zoneIDList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskAllocateRation") != m.end() && !m["DiskAllocateRation"].empty()) {
      diskAllocateRation = make_shared<double>(boost::any_cast<double>(m["DiskAllocateRation"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DedicatedHostCountGroupByHostType") != m.end() && !m["DedicatedHostCountGroupByHostType"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["DedicatedHostCountGroupByHostType"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      dedicatedHostCountGroupByHostType = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("DiskUtility") != m.end() && !m["DiskUtility"].empty()) {
      diskUtility = make_shared<double>(boost::any_cast<double>(m["DiskUtility"]));
    }
    if (m.find("MemUsedAmount") != m.end() && !m["MemUsedAmount"].empty()) {
      memUsedAmount = make_shared<double>(boost::any_cast<double>(m["MemUsedAmount"]));
    }
    if (m.find("MemAllocatedAmount") != m.end() && !m["MemAllocatedAmount"].empty()) {
      memAllocatedAmount = make_shared<double>(boost::any_cast<double>(m["MemAllocatedAmount"]));
    }
    if (m.find("CpuAllocationRatio") != m.end() && !m["CpuAllocationRatio"].empty()) {
      cpuAllocationRatio = make_shared<long>(boost::any_cast<long>(m["CpuAllocationRatio"]));
    }
    if (m.find("MemAllocationRatio") != m.end() && !m["MemAllocationRatio"].empty()) {
      memAllocationRatio = make_shared<long>(boost::any_cast<long>(m["MemAllocationRatio"]));
    }
    if (m.find("MemUtility") != m.end() && !m["MemUtility"].empty()) {
      memUtility = make_shared<double>(boost::any_cast<double>(m["MemUtility"]));
    }
    if (m.find("MemAllocateRation") != m.end() && !m["MemAllocateRation"].empty()) {
      memAllocateRation = make_shared<double>(boost::any_cast<double>(m["MemAllocateRation"]));
    }
    if (m.find("CpuAllocatedAmount") != m.end() && !m["CpuAllocatedAmount"].empty()) {
      cpuAllocatedAmount = make_shared<double>(boost::any_cast<double>(m["CpuAllocatedAmount"]));
    }
    if (m.find("DedicatedHostGroupDesc") != m.end() && !m["DedicatedHostGroupDesc"].empty()) {
      dedicatedHostGroupDesc = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupDesc"]));
    }
    if (m.find("CpuAllocateRation") != m.end() && !m["CpuAllocateRation"].empty()) {
      cpuAllocateRation = make_shared<double>(boost::any_cast<double>(m["CpuAllocateRation"]));
    }
    if (m.find("InstanceNumber") != m.end() && !m["InstanceNumber"].empty()) {
      instanceNumber = make_shared<long>(boost::any_cast<long>(m["InstanceNumber"]));
    }
    if (m.find("OpenPermission") != m.end() && !m["OpenPermission"].empty()) {
      openPermission = make_shared<string>(boost::any_cast<string>(m["OpenPermission"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("DiskAllocatedAmount") != m.end() && !m["DiskAllocatedAmount"].empty()) {
      diskAllocatedAmount = make_shared<double>(boost::any_cast<double>(m["DiskAllocatedAmount"]));
    }
    if (m.find("HostNumber") != m.end() && !m["HostNumber"].empty()) {
      hostNumber = make_shared<long>(boost::any_cast<long>(m["HostNumber"]));
    }
    if (m.find("DiskUsedAmount") != m.end() && !m["DiskUsedAmount"].empty()) {
      diskUsedAmount = make_shared<double>(boost::any_cast<double>(m["DiskUsedAmount"]));
    }
    if (m.find("AllocationPolicy") != m.end() && !m["AllocationPolicy"].empty()) {
      allocationPolicy = make_shared<string>(boost::any_cast<string>(m["AllocationPolicy"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("DiskAllocationRatio") != m.end() && !m["DiskAllocationRatio"].empty()) {
      diskAllocationRatio = make_shared<long>(boost::any_cast<long>(m["DiskAllocationRatio"]));
    }
    if (m.find("BastionInstanceId") != m.end() && !m["BastionInstanceId"].empty()) {
      bastionInstanceId = make_shared<string>(boost::any_cast<string>(m["BastionInstanceId"]));
    }
    if (m.find("HostReplacePolicy") != m.end() && !m["HostReplacePolicy"].empty()) {
      hostReplacePolicy = make_shared<string>(boost::any_cast<string>(m["HostReplacePolicy"]));
    }
    if (m.find("ZoneIDList") != m.end() && !m["ZoneIDList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ZoneIDList"].type()) {
        DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ZoneIDList"]));
        zoneIDList = make_shared<DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups() = default;
};
class DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups>> dedicatedHostGroups{};

  DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups() {}

  explicit DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostGroups) {
      vector<boost::any> temp1;
      for(auto item1:*dedicatedHostGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicatedHostGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostGroups") != m.end() && !m["DedicatedHostGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicatedHostGroups"].type()) {
        vector<DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicatedHostGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicatedHostGroups = make_shared<vector<DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups() = default;
};
class DescribeDedicatedHostGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups> dedicatedHostGroups{};

  DescribeDedicatedHostGroupsResponseBody() {}

  explicit DescribeDedicatedHostGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dedicatedHostGroups) {
      res["DedicatedHostGroups"] = dedicatedHostGroups ? boost::any(dedicatedHostGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DedicatedHostGroups") != m.end() && !m["DedicatedHostGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHostGroups"].type()) {
        DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHostGroups"]));
        dedicatedHostGroups = make_shared<DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostGroupsResponseBody() = default;
};
class DescribeDedicatedHostGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDedicatedHostGroupsResponseBody> body{};

  DescribeDedicatedHostGroupsResponse() {}

  explicit DescribeDedicatedHostGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedHostGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedHostGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostGroupsResponse() = default;
};
class DescribeDedicatedHostImageCategoriesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> hostGroup{};

  DescribeDedicatedHostImageCategoriesRequest() {}

  explicit DescribeDedicatedHostImageCategoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (hostGroup) {
      res["HostGroup"] = boost::any(*hostGroup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      hostGroup = make_shared<string>(boost::any_cast<string>(m["HostGroup"]));
    }
  }


  virtual ~DescribeDedicatedHostImageCategoriesRequest() = default;
};
class DescribeDedicatedHostImageCategoriesResponseBodyImagesImages : public Darabonba::Model {
public:
  shared_ptr<string> imageCode{};
  shared_ptr<string> imageName{};

  DescribeDedicatedHostImageCategoriesResponseBodyImagesImages() {}

  explicit DescribeDedicatedHostImageCategoriesResponseBodyImagesImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageCode) {
      res["ImageCode"] = boost::any(*imageCode);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageCode") != m.end() && !m["ImageCode"].empty()) {
      imageCode = make_shared<string>(boost::any_cast<string>(m["ImageCode"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
  }


  virtual ~DescribeDedicatedHostImageCategoriesResponseBodyImagesImages() = default;
};
class DescribeDedicatedHostImageCategoriesResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostImageCategoriesResponseBodyImagesImages>> images{};

  DescribeDedicatedHostImageCategoriesResponseBodyImages() {}

  explicit DescribeDedicatedHostImageCategoriesResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      vector<boost::any> temp1;
      for(auto item1:*images){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Images"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(vector<boost::any>) == m["Images"].type()) {
        vector<DescribeDedicatedHostImageCategoriesResponseBodyImagesImages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Images"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostImageCategoriesResponseBodyImagesImages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        images = make_shared<vector<DescribeDedicatedHostImageCategoriesResponseBodyImagesImages>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostImageCategoriesResponseBodyImages() = default;
};
class DescribeDedicatedHostImageCategoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDedicatedHostImageCategoriesResponseBodyImages> images{};

  DescribeDedicatedHostImageCategoriesResponseBody() {}

  explicit DescribeDedicatedHostImageCategoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeDedicatedHostImageCategoriesResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeDedicatedHostImageCategoriesResponseBodyImages>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostImageCategoriesResponseBody() = default;
};
class DescribeDedicatedHostImageCategoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDedicatedHostImageCategoriesResponseBody> body{};

  DescribeDedicatedHostImageCategoriesResponse() {}

  explicit DescribeDedicatedHostImageCategoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedHostImageCategoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedHostImageCategoriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostImageCategoriesResponse() = default;
};
class DescribeDedicatedHostsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<long> orderId{};
  shared_ptr<string> hostType{};
  shared_ptr<string> hostStatus{};
  shared_ptr<string> allocationStatus{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> dedicatedHostId{};

  DescribeDedicatedHostsRequest() {}

  explicit DescribeDedicatedHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (hostType) {
      res["HostType"] = boost::any(*hostType);
    }
    if (hostStatus) {
      res["HostStatus"] = boost::any(*hostStatus);
    }
    if (allocationStatus) {
      res["AllocationStatus"] = boost::any(*allocationStatus);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("HostType") != m.end() && !m["HostType"].empty()) {
      hostType = make_shared<string>(boost::any_cast<string>(m["HostType"]));
    }
    if (m.find("HostStatus") != m.end() && !m["HostStatus"].empty()) {
      hostStatus = make_shared<string>(boost::any_cast<string>(m["HostStatus"]));
    }
    if (m.find("AllocationStatus") != m.end() && !m["AllocationStatus"].empty()) {
      allocationStatus = make_shared<string>(boost::any_cast<string>(m["AllocationStatus"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
  }


  virtual ~DescribeDedicatedHostsRequest() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts : public Darabonba::Model {
public:
  shared_ptr<string> hostType{};
  shared_ptr<string> hostStorage{};
  shared_ptr<string> memoryUsed{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> allocationStatus{};
  shared_ptr<string> storageUsed{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> memAllocationRatio{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> IPAddress{};
  shared_ptr<string> hostStatus{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hostCPU{};
  shared_ptr<string> instanceNumber{};
  shared_ptr<string> openPermission{};
  shared_ptr<string> cpuUsed{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> hostClass{};
  shared_ptr<string> endTime{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> CPUAllocationRatio{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> imageCategory{};
  shared_ptr<string> engine{};
  shared_ptr<string> diskAllocationRatio{};
  shared_ptr<string> hostMem{};
  shared_ptr<string> bastionInstanceId{};
  shared_ptr<string> accountName{};

  DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostType) {
      res["HostType"] = boost::any(*hostType);
    }
    if (hostStorage) {
      res["HostStorage"] = boost::any(*hostStorage);
    }
    if (memoryUsed) {
      res["MemoryUsed"] = boost::any(*memoryUsed);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (allocationStatus) {
      res["AllocationStatus"] = boost::any(*allocationStatus);
    }
    if (storageUsed) {
      res["StorageUsed"] = boost::any(*storageUsed);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (memAllocationRatio) {
      res["MemAllocationRatio"] = boost::any(*memAllocationRatio);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (IPAddress) {
      res["IPAddress"] = boost::any(*IPAddress);
    }
    if (hostStatus) {
      res["HostStatus"] = boost::any(*hostStatus);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hostCPU) {
      res["HostCPU"] = boost::any(*hostCPU);
    }
    if (instanceNumber) {
      res["InstanceNumber"] = boost::any(*instanceNumber);
    }
    if (openPermission) {
      res["OpenPermission"] = boost::any(*openPermission);
    }
    if (cpuUsed) {
      res["CpuUsed"] = boost::any(*cpuUsed);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (hostClass) {
      res["HostClass"] = boost::any(*hostClass);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (CPUAllocationRatio) {
      res["CPUAllocationRatio"] = boost::any(*CPUAllocationRatio);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (imageCategory) {
      res["ImageCategory"] = boost::any(*imageCategory);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (diskAllocationRatio) {
      res["DiskAllocationRatio"] = boost::any(*diskAllocationRatio);
    }
    if (hostMem) {
      res["HostMem"] = boost::any(*hostMem);
    }
    if (bastionInstanceId) {
      res["BastionInstanceId"] = boost::any(*bastionInstanceId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostType") != m.end() && !m["HostType"].empty()) {
      hostType = make_shared<string>(boost::any_cast<string>(m["HostType"]));
    }
    if (m.find("HostStorage") != m.end() && !m["HostStorage"].empty()) {
      hostStorage = make_shared<string>(boost::any_cast<string>(m["HostStorage"]));
    }
    if (m.find("MemoryUsed") != m.end() && !m["MemoryUsed"].empty()) {
      memoryUsed = make_shared<string>(boost::any_cast<string>(m["MemoryUsed"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("AllocationStatus") != m.end() && !m["AllocationStatus"].empty()) {
      allocationStatus = make_shared<string>(boost::any_cast<string>(m["AllocationStatus"]));
    }
    if (m.find("StorageUsed") != m.end() && !m["StorageUsed"].empty()) {
      storageUsed = make_shared<string>(boost::any_cast<string>(m["StorageUsed"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("MemAllocationRatio") != m.end() && !m["MemAllocationRatio"].empty()) {
      memAllocationRatio = make_shared<string>(boost::any_cast<string>(m["MemAllocationRatio"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("IPAddress") != m.end() && !m["IPAddress"].empty()) {
      IPAddress = make_shared<string>(boost::any_cast<string>(m["IPAddress"]));
    }
    if (m.find("HostStatus") != m.end() && !m["HostStatus"].empty()) {
      hostStatus = make_shared<string>(boost::any_cast<string>(m["HostStatus"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HostCPU") != m.end() && !m["HostCPU"].empty()) {
      hostCPU = make_shared<string>(boost::any_cast<string>(m["HostCPU"]));
    }
    if (m.find("InstanceNumber") != m.end() && !m["InstanceNumber"].empty()) {
      instanceNumber = make_shared<string>(boost::any_cast<string>(m["InstanceNumber"]));
    }
    if (m.find("OpenPermission") != m.end() && !m["OpenPermission"].empty()) {
      openPermission = make_shared<string>(boost::any_cast<string>(m["OpenPermission"]));
    }
    if (m.find("CpuUsed") != m.end() && !m["CpuUsed"].empty()) {
      cpuUsed = make_shared<string>(boost::any_cast<string>(m["CpuUsed"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("HostClass") != m.end() && !m["HostClass"].empty()) {
      hostClass = make_shared<string>(boost::any_cast<string>(m["HostClass"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("CPUAllocationRatio") != m.end() && !m["CPUAllocationRatio"].empty()) {
      CPUAllocationRatio = make_shared<string>(boost::any_cast<string>(m["CPUAllocationRatio"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ImageCategory") != m.end() && !m["ImageCategory"].empty()) {
      imageCategory = make_shared<string>(boost::any_cast<string>(m["ImageCategory"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("DiskAllocationRatio") != m.end() && !m["DiskAllocationRatio"].empty()) {
      diskAllocationRatio = make_shared<string>(boost::any_cast<string>(m["DiskAllocationRatio"]));
    }
    if (m.find("HostMem") != m.end() && !m["HostMem"].empty()) {
      hostMem = make_shared<string>(boost::any_cast<string>(m["HostMem"]));
    }
    if (m.find("BastionInstanceId") != m.end() && !m["BastionInstanceId"].empty()) {
      bastionInstanceId = make_shared<string>(boost::any_cast<string>(m["BastionInstanceId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts() = default;
};
class DescribeDedicatedHostsResponseBodyDedicatedHosts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts>> dedicatedHosts{};

  DescribeDedicatedHostsResponseBodyDedicatedHosts() {}

  explicit DescribeDedicatedHostsResponseBodyDedicatedHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHosts) {
      vector<boost::any> temp1;
      for(auto item1:*dedicatedHosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicatedHosts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHosts") != m.end() && !m["DedicatedHosts"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicatedHosts"].type()) {
        vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicatedHosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicatedHosts = make_shared<vector<DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts>>(expect1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponseBodyDedicatedHosts() = default;
};
class DescribeDedicatedHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDedicatedHostsResponseBodyDedicatedHosts> dedicatedHosts{};

  DescribeDedicatedHostsResponseBody() {}

  explicit DescribeDedicatedHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dedicatedHosts) {
      res["DedicatedHosts"] = dedicatedHosts ? boost::any(dedicatedHosts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DedicatedHosts") != m.end() && !m["DedicatedHosts"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedHosts"].type()) {
        DescribeDedicatedHostsResponseBodyDedicatedHosts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedHosts"]));
        dedicatedHosts = make_shared<DescribeDedicatedHostsResponseBodyDedicatedHosts>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponseBody() = default;
};
class DescribeDedicatedHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDedicatedHostsResponseBody> body{};

  DescribeDedicatedHostsResponse() {}

  explicit DescribeDedicatedHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedHostsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedHostsResponse() = default;
};
class DescribeDetachedBackupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> backupId{};
  shared_ptr<string> backupStatus{};
  shared_ptr<string> backupMode{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> region{};

  DescribeDetachedBackupsRequest() {}

  explicit DescribeDetachedBackupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (backupStatus) {
      res["BackupStatus"] = boost::any(*backupStatus);
    }
    if (backupMode) {
      res["BackupMode"] = boost::any(*backupMode);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("BackupStatus") != m.end() && !m["BackupStatus"].empty()) {
      backupStatus = make_shared<string>(boost::any_cast<string>(m["BackupStatus"]));
    }
    if (m.find("BackupMode") != m.end() && !m["BackupMode"].empty()) {
      backupMode = make_shared<string>(boost::any_cast<string>(m["BackupMode"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~DescribeDetachedBackupsRequest() = default;
};
class DescribeDetachedBackupsResponseBodyItemsBackup : public Darabonba::Model {
public:
  shared_ptr<long> consistentTime{};
  shared_ptr<string> storeStatus{};
  shared_ptr<string> backupStatus{};
  shared_ptr<string> backupType{};
  shared_ptr<string> backupStartTime{};
  shared_ptr<string> backupDownloadURL{};
  shared_ptr<long> isAvail{};
  shared_ptr<string> metaStatus{};
  shared_ptr<string> backupEndTime{};
  shared_ptr<string> backupId{};
  shared_ptr<string> hostInstanceID{};
  shared_ptr<string> backupIntranetDownloadURL{};
  shared_ptr<long> backupSize{};
  shared_ptr<string> backupMode{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> backupMethod{};

  DescribeDetachedBackupsResponseBodyItemsBackup() {}

  explicit DescribeDetachedBackupsResponseBodyItemsBackup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consistentTime) {
      res["ConsistentTime"] = boost::any(*consistentTime);
    }
    if (storeStatus) {
      res["StoreStatus"] = boost::any(*storeStatus);
    }
    if (backupStatus) {
      res["BackupStatus"] = boost::any(*backupStatus);
    }
    if (backupType) {
      res["BackupType"] = boost::any(*backupType);
    }
    if (backupStartTime) {
      res["BackupStartTime"] = boost::any(*backupStartTime);
    }
    if (backupDownloadURL) {
      res["BackupDownloadURL"] = boost::any(*backupDownloadURL);
    }
    if (isAvail) {
      res["IsAvail"] = boost::any(*isAvail);
    }
    if (metaStatus) {
      res["MetaStatus"] = boost::any(*metaStatus);
    }
    if (backupEndTime) {
      res["BackupEndTime"] = boost::any(*backupEndTime);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (hostInstanceID) {
      res["HostInstanceID"] = boost::any(*hostInstanceID);
    }
    if (backupIntranetDownloadURL) {
      res["BackupIntranetDownloadURL"] = boost::any(*backupIntranetDownloadURL);
    }
    if (backupSize) {
      res["BackupSize"] = boost::any(*backupSize);
    }
    if (backupMode) {
      res["BackupMode"] = boost::any(*backupMode);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (backupMethod) {
      res["BackupMethod"] = boost::any(*backupMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsistentTime") != m.end() && !m["ConsistentTime"].empty()) {
      consistentTime = make_shared<long>(boost::any_cast<long>(m["ConsistentTime"]));
    }
    if (m.find("StoreStatus") != m.end() && !m["StoreStatus"].empty()) {
      storeStatus = make_shared<string>(boost::any_cast<string>(m["StoreStatus"]));
    }
    if (m.find("BackupStatus") != m.end() && !m["BackupStatus"].empty()) {
      backupStatus = make_shared<string>(boost::any_cast<string>(m["BackupStatus"]));
    }
    if (m.find("BackupType") != m.end() && !m["BackupType"].empty()) {
      backupType = make_shared<string>(boost::any_cast<string>(m["BackupType"]));
    }
    if (m.find("BackupStartTime") != m.end() && !m["BackupStartTime"].empty()) {
      backupStartTime = make_shared<string>(boost::any_cast<string>(m["BackupStartTime"]));
    }
    if (m.find("BackupDownloadURL") != m.end() && !m["BackupDownloadURL"].empty()) {
      backupDownloadURL = make_shared<string>(boost::any_cast<string>(m["BackupDownloadURL"]));
    }
    if (m.find("IsAvail") != m.end() && !m["IsAvail"].empty()) {
      isAvail = make_shared<long>(boost::any_cast<long>(m["IsAvail"]));
    }
    if (m.find("MetaStatus") != m.end() && !m["MetaStatus"].empty()) {
      metaStatus = make_shared<string>(boost::any_cast<string>(m["MetaStatus"]));
    }
    if (m.find("BackupEndTime") != m.end() && !m["BackupEndTime"].empty()) {
      backupEndTime = make_shared<string>(boost::any_cast<string>(m["BackupEndTime"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("HostInstanceID") != m.end() && !m["HostInstanceID"].empty()) {
      hostInstanceID = make_shared<string>(boost::any_cast<string>(m["HostInstanceID"]));
    }
    if (m.find("BackupIntranetDownloadURL") != m.end() && !m["BackupIntranetDownloadURL"].empty()) {
      backupIntranetDownloadURL = make_shared<string>(boost::any_cast<string>(m["BackupIntranetDownloadURL"]));
    }
    if (m.find("BackupSize") != m.end() && !m["BackupSize"].empty()) {
      backupSize = make_shared<long>(boost::any_cast<long>(m["BackupSize"]));
    }
    if (m.find("BackupMode") != m.end() && !m["BackupMode"].empty()) {
      backupMode = make_shared<string>(boost::any_cast<string>(m["BackupMode"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("BackupMethod") != m.end() && !m["BackupMethod"].empty()) {
      backupMethod = make_shared<string>(boost::any_cast<string>(m["BackupMethod"]));
    }
  }


  virtual ~DescribeDetachedBackupsResponseBodyItemsBackup() = default;
};
class DescribeDetachedBackupsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDetachedBackupsResponseBodyItemsBackup>> backup{};

  DescribeDetachedBackupsResponseBodyItems() {}

  explicit DescribeDetachedBackupsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backup) {
      vector<boost::any> temp1;
      for(auto item1:*backup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Backup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backup") != m.end() && !m["Backup"].empty()) {
      if (typeid(vector<boost::any>) == m["Backup"].type()) {
        vector<DescribeDetachedBackupsResponseBodyItemsBackup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Backup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDetachedBackupsResponseBodyItemsBackup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backup = make_shared<vector<DescribeDetachedBackupsResponseBodyItemsBackup>>(expect1);
      }
    }
  }


  virtual ~DescribeDetachedBackupsResponseBodyItems() = default;
};
class DescribeDetachedBackupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<string> pageRecordCount{};
  shared_ptr<string> totalRecordCount{};
  shared_ptr<DescribeDetachedBackupsResponseBodyItems> items{};

  DescribeDetachedBackupsResponseBody() {}

  explicit DescribeDetachedBackupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<string>(boost::any_cast<string>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<string>(boost::any_cast<string>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeDetachedBackupsResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeDetachedBackupsResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeDetachedBackupsResponseBody() = default;
};
class DescribeDetachedBackupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDetachedBackupsResponseBody> body{};

  DescribeDetachedBackupsResponse() {}

  explicit DescribeDetachedBackupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDetachedBackupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDetachedBackupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDetachedBackupsResponse() = default;
};
class DescribeDiagnosticReportListRequest : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};

  DescribeDiagnosticReportListRequest() {}

  explicit DescribeDiagnosticReportListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~DescribeDiagnosticReportListRequest() = default;
};
class DescribeDiagnosticReportListResponseBodyReportList : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> diagnosticTime{};
  shared_ptr<string> startTime{};
  shared_ptr<long> score{};
  shared_ptr<string> downloadURL{};

  DescribeDiagnosticReportListResponseBodyReportList() {}

  explicit DescribeDiagnosticReportListResponseBodyReportList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (diagnosticTime) {
      res["DiagnosticTime"] = boost::any(*diagnosticTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (downloadURL) {
      res["DownloadURL"] = boost::any(*downloadURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("DiagnosticTime") != m.end() && !m["DiagnosticTime"].empty()) {
      diagnosticTime = make_shared<string>(boost::any_cast<string>(m["DiagnosticTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<long>(boost::any_cast<long>(m["Score"]));
    }
    if (m.find("DownloadURL") != m.end() && !m["DownloadURL"].empty()) {
      downloadURL = make_shared<string>(boost::any_cast<string>(m["DownloadURL"]));
    }
  }


  virtual ~DescribeDiagnosticReportListResponseBodyReportList() = default;
};
class DescribeDiagnosticReportListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDiagnosticReportListResponseBodyReportList>> reportList{};

  DescribeDiagnosticReportListResponseBody() {}

  explicit DescribeDiagnosticReportListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reportList) {
      vector<boost::any> temp1;
      for(auto item1:*reportList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReportList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReportList") != m.end() && !m["ReportList"].empty()) {
      if (typeid(vector<boost::any>) == m["ReportList"].type()) {
        vector<DescribeDiagnosticReportListResponseBodyReportList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReportList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnosticReportListResponseBodyReportList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reportList = make_shared<vector<DescribeDiagnosticReportListResponseBodyReportList>>(expect1);
      }
    }
  }


  virtual ~DescribeDiagnosticReportListResponseBody() = default;
};
class DescribeDiagnosticReportListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDiagnosticReportListResponseBody> body{};

  DescribeDiagnosticReportListResponse() {}

  explicit DescribeDiagnosticReportListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDiagnosticReportListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDiagnosticReportListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDiagnosticReportListResponse() = default;
};
class DescribeDownloadLinkDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<long> backupSetId{};
  shared_ptr<long> maxRecordsPerPage{};
  shared_ptr<long> pageNumbers{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dataBaseName{};

  DescribeDownloadLinkDetailsRequest() {}

  explicit DescribeDownloadLinkDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupSetId) {
      res["BackupSetId"] = boost::any(*backupSetId);
    }
    if (maxRecordsPerPage) {
      res["MaxRecordsPerPage"] = boost::any(*maxRecordsPerPage);
    }
    if (pageNumbers) {
      res["PageNumbers"] = boost::any(*pageNumbers);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dataBaseName) {
      res["DataBaseName"] = boost::any(*dataBaseName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupSetId") != m.end() && !m["BackupSetId"].empty()) {
      backupSetId = make_shared<long>(boost::any_cast<long>(m["BackupSetId"]));
    }
    if (m.find("MaxRecordsPerPage") != m.end() && !m["MaxRecordsPerPage"].empty()) {
      maxRecordsPerPage = make_shared<long>(boost::any_cast<long>(m["MaxRecordsPerPage"]));
    }
    if (m.find("PageNumbers") != m.end() && !m["PageNumbers"].empty()) {
      pageNumbers = make_shared<long>(boost::any_cast<long>(m["PageNumbers"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DataBaseName") != m.end() && !m["DataBaseName"].empty()) {
      dataBaseName = make_shared<string>(boost::any_cast<string>(m["DataBaseName"]));
    }
  }


  virtual ~DescribeDownloadLinkDetailsRequest() = default;
};
class DescribeDownloadLinkDetailsResponseBodyDataBackupDownloadLinkByDB : public Darabonba::Model {
public:
  shared_ptr<string> dataBase{};
  shared_ptr<string> downloadLink{};
  shared_ptr<string> intranetDownloadLink{};

  DescribeDownloadLinkDetailsResponseBodyDataBackupDownloadLinkByDB() {}

  explicit DescribeDownloadLinkDetailsResponseBodyDataBackupDownloadLinkByDB(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataBase) {
      res["DataBase"] = boost::any(*dataBase);
    }
    if (downloadLink) {
      res["DownloadLink"] = boost::any(*downloadLink);
    }
    if (intranetDownloadLink) {
      res["IntranetDownloadLink"] = boost::any(*intranetDownloadLink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataBase") != m.end() && !m["DataBase"].empty()) {
      dataBase = make_shared<string>(boost::any_cast<string>(m["DataBase"]));
    }
    if (m.find("DownloadLink") != m.end() && !m["DownloadLink"].empty()) {
      downloadLink = make_shared<string>(boost::any_cast<string>(m["DownloadLink"]));
    }
    if (m.find("IntranetDownloadLink") != m.end() && !m["IntranetDownloadLink"].empty()) {
      intranetDownloadLink = make_shared<string>(boost::any_cast<string>(m["IntranetDownloadLink"]));
    }
  }


  virtual ~DescribeDownloadLinkDetailsResponseBodyDataBackupDownloadLinkByDB() = default;
};
class DescribeDownloadLinkDetailsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDownloadLinkDetailsResponseBodyDataBackupDownloadLinkByDB>> backupDownloadLinkByDB{};
  shared_ptr<long> maxRecordsPerPage{};
  shared_ptr<long> pageNumbers{};
  shared_ptr<long> totalRecords{};
  shared_ptr<string> backupStartTime{};
  shared_ptr<string> backupEndTime{};
  shared_ptr<string> backupType{};
  shared_ptr<string> backupMethod{};
  shared_ptr<string> backupStatus{};
  shared_ptr<long> hostInstanceId{};

  DescribeDownloadLinkDetailsResponseBodyData() {}

  explicit DescribeDownloadLinkDetailsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupDownloadLinkByDB) {
      vector<boost::any> temp1;
      for(auto item1:*backupDownloadLinkByDB){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackupDownloadLinkByDB"] = boost::any(temp1);
    }
    if (maxRecordsPerPage) {
      res["MaxRecordsPerPage"] = boost::any(*maxRecordsPerPage);
    }
    if (pageNumbers) {
      res["PageNumbers"] = boost::any(*pageNumbers);
    }
    if (totalRecords) {
      res["TotalRecords"] = boost::any(*totalRecords);
    }
    if (backupStartTime) {
      res["BackupStartTime"] = boost::any(*backupStartTime);
    }
    if (backupEndTime) {
      res["BackupEndTime"] = boost::any(*backupEndTime);
    }
    if (backupType) {
      res["BackupType"] = boost::any(*backupType);
    }
    if (backupMethod) {
      res["BackupMethod"] = boost::any(*backupMethod);
    }
    if (backupStatus) {
      res["BackupStatus"] = boost::any(*backupStatus);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupDownloadLinkByDB") != m.end() && !m["BackupDownloadLinkByDB"].empty()) {
      if (typeid(vector<boost::any>) == m["BackupDownloadLinkByDB"].type()) {
        vector<DescribeDownloadLinkDetailsResponseBodyDataBackupDownloadLinkByDB> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackupDownloadLinkByDB"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDownloadLinkDetailsResponseBodyDataBackupDownloadLinkByDB model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backupDownloadLinkByDB = make_shared<vector<DescribeDownloadLinkDetailsResponseBodyDataBackupDownloadLinkByDB>>(expect1);
      }
    }
    if (m.find("MaxRecordsPerPage") != m.end() && !m["MaxRecordsPerPage"].empty()) {
      maxRecordsPerPage = make_shared<long>(boost::any_cast<long>(m["MaxRecordsPerPage"]));
    }
    if (m.find("PageNumbers") != m.end() && !m["PageNumbers"].empty()) {
      pageNumbers = make_shared<long>(boost::any_cast<long>(m["PageNumbers"]));
    }
    if (m.find("TotalRecords") != m.end() && !m["TotalRecords"].empty()) {
      totalRecords = make_shared<long>(boost::any_cast<long>(m["TotalRecords"]));
    }
    if (m.find("BackupStartTime") != m.end() && !m["BackupStartTime"].empty()) {
      backupStartTime = make_shared<string>(boost::any_cast<string>(m["BackupStartTime"]));
    }
    if (m.find("BackupEndTime") != m.end() && !m["BackupEndTime"].empty()) {
      backupEndTime = make_shared<string>(boost::any_cast<string>(m["BackupEndTime"]));
    }
    if (m.find("BackupType") != m.end() && !m["BackupType"].empty()) {
      backupType = make_shared<string>(boost::any_cast<string>(m["BackupType"]));
    }
    if (m.find("BackupMethod") != m.end() && !m["BackupMethod"].empty()) {
      backupMethod = make_shared<string>(boost::any_cast<string>(m["BackupMethod"]));
    }
    if (m.find("BackupStatus") != m.end() && !m["BackupStatus"].empty()) {
      backupStatus = make_shared<string>(boost::any_cast<string>(m["BackupStatus"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<long>(boost::any_cast<long>(m["HostInstanceId"]));
    }
  }


  virtual ~DescribeDownloadLinkDetailsResponseBodyData() = default;
};
class DescribeDownloadLinkDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<DescribeDownloadLinkDetailsResponseBodyData> data{};
  shared_ptr<long> code{};

  DescribeDownloadLinkDetailsResponseBody() {}

  explicit DescribeDownloadLinkDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDownloadLinkDetailsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDownloadLinkDetailsResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~DescribeDownloadLinkDetailsResponseBody() = default;
};
class DescribeDownloadLinkDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDownloadLinkDetailsResponseBody> body{};

  DescribeDownloadLinkDetailsResponse() {}

  explicit DescribeDownloadLinkDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDownloadLinkDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDownloadLinkDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDownloadLinkDetailsResponse() = default;
};
class DescribeDTCSecurityIpHostsForSQLServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> regionId{};

  DescribeDTCSecurityIpHostsForSQLServerRequest() {}

  explicit DescribeDTCSecurityIpHostsForSQLServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDTCSecurityIpHostsForSQLServerRequest() = default;
};
class DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups : public Darabonba::Model {
public:
  shared_ptr<string> securityIpHosts{};
  shared_ptr<string> whitelistGroupName{};

  DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups() {}

  explicit DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityIpHosts) {
      res["SecurityIpHosts"] = boost::any(*securityIpHosts);
    }
    if (whitelistGroupName) {
      res["WhitelistGroupName"] = boost::any(*whitelistGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityIpHosts") != m.end() && !m["SecurityIpHosts"].empty()) {
      securityIpHosts = make_shared<string>(boost::any_cast<string>(m["SecurityIpHosts"]));
    }
    if (m.find("WhitelistGroupName") != m.end() && !m["WhitelistGroupName"].empty()) {
      whitelistGroupName = make_shared<string>(boost::any_cast<string>(m["WhitelistGroupName"]));
    }
  }


  virtual ~DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups() = default;
};
class DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups>> whiteListGroups{};

  DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems() {}

  explicit DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (whiteListGroups) {
      vector<boost::any> temp1;
      for(auto item1:*whiteListGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WhiteListGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WhiteListGroups") != m.end() && !m["WhiteListGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["WhiteListGroups"].type()) {
        vector<DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WhiteListGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        whiteListGroups = make_shared<vector<DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups>>(expect1);
      }
    }
  }


  virtual ~DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems() = default;
};
class DescribeDTCSecurityIpHostsForSQLServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> ipHostPairNum{};
  shared_ptr<DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems> items{};

  DescribeDTCSecurityIpHostsForSQLServerResponseBody() {}

  explicit DescribeDTCSecurityIpHostsForSQLServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ipHostPairNum) {
      res["IpHostPairNum"] = boost::any(*ipHostPairNum);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("IpHostPairNum") != m.end() && !m["IpHostPairNum"].empty()) {
      ipHostPairNum = make_shared<string>(boost::any_cast<string>(m["IpHostPairNum"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeDTCSecurityIpHostsForSQLServerResponseBody() = default;
};
class DescribeDTCSecurityIpHostsForSQLServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDTCSecurityIpHostsForSQLServerResponseBody> body{};

  DescribeDTCSecurityIpHostsForSQLServerResponse() {}

  explicit DescribeDTCSecurityIpHostsForSQLServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDTCSecurityIpHostsForSQLServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDTCSecurityIpHostsForSQLServerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDTCSecurityIpHostsForSQLServerResponse() = default;
};
class DescribeErrorLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> ownerAccount{};

  DescribeErrorLogsRequest() {}

  explicit DescribeErrorLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeErrorLogsRequest() = default;
};
class DescribeErrorLogsResponseBodyItemsErrorLog : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> errorInfo{};

  DescribeErrorLogsResponseBodyItemsErrorLog() {}

  explicit DescribeErrorLogsResponseBodyItemsErrorLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (errorInfo) {
      res["ErrorInfo"] = boost::any(*errorInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ErrorInfo") != m.end() && !m["ErrorInfo"].empty()) {
      errorInfo = make_shared<string>(boost::any_cast<string>(m["ErrorInfo"]));
    }
  }


  virtual ~DescribeErrorLogsResponseBodyItemsErrorLog() = default;
};
class DescribeErrorLogsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeErrorLogsResponseBodyItemsErrorLog>> errorLog{};

  DescribeErrorLogsResponseBodyItems() {}

  explicit DescribeErrorLogsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorLog) {
      vector<boost::any> temp1;
      for(auto item1:*errorLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorLog"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorLog") != m.end() && !m["ErrorLog"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorLog"].type()) {
        vector<DescribeErrorLogsResponseBodyItemsErrorLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeErrorLogsResponseBodyItemsErrorLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorLog = make_shared<vector<DescribeErrorLogsResponseBodyItemsErrorLog>>(expect1);
      }
    }
  }


  virtual ~DescribeErrorLogsResponseBodyItems() = default;
};
class DescribeErrorLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeErrorLogsResponseBodyItems> items{};

  DescribeErrorLogsResponseBody() {}

  explicit DescribeErrorLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeErrorLogsResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeErrorLogsResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeErrorLogsResponseBody() = default;
};
class DescribeErrorLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeErrorLogsResponseBody> body{};

  DescribeErrorLogsResponse() {}

  explicit DescribeErrorLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeErrorLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeErrorLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeErrorLogsResponse() = default;
};
class DescribeEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeEventsRequest() {}

  explicit DescribeEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeEventsRequest() = default;
};
class DescribeEventsResponseBodyEventItemsEventItems : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<string> eventTime{};
  shared_ptr<string> eventUserType{};
  shared_ptr<string> eventRecordTime{};
  shared_ptr<long> callerUid{};
  shared_ptr<string> regionId{};
  shared_ptr<long> eventId{};
  shared_ptr<string> eventType{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> eventPayload{};
  shared_ptr<string> eventReason{};
  shared_ptr<string> resourceName{};

  DescribeEventsResponseBodyEventItemsEventItems() {}

  explicit DescribeEventsResponseBodyEventItemsEventItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    if (eventUserType) {
      res["EventUserType"] = boost::any(*eventUserType);
    }
    if (eventRecordTime) {
      res["EventRecordTime"] = boost::any(*eventRecordTime);
    }
    if (callerUid) {
      res["CallerUid"] = boost::any(*callerUid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (eventPayload) {
      res["EventPayload"] = boost::any(*eventPayload);
    }
    if (eventReason) {
      res["EventReason"] = boost::any(*eventReason);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<string>(boost::any_cast<string>(m["EventTime"]));
    }
    if (m.find("EventUserType") != m.end() && !m["EventUserType"].empty()) {
      eventUserType = make_shared<string>(boost::any_cast<string>(m["EventUserType"]));
    }
    if (m.find("EventRecordTime") != m.end() && !m["EventRecordTime"].empty()) {
      eventRecordTime = make_shared<string>(boost::any_cast<string>(m["EventRecordTime"]));
    }
    if (m.find("CallerUid") != m.end() && !m["CallerUid"].empty()) {
      callerUid = make_shared<long>(boost::any_cast<long>(m["CallerUid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<long>(boost::any_cast<long>(m["EventId"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("EventPayload") != m.end() && !m["EventPayload"].empty()) {
      eventPayload = make_shared<string>(boost::any_cast<string>(m["EventPayload"]));
    }
    if (m.find("EventReason") != m.end() && !m["EventReason"].empty()) {
      eventReason = make_shared<string>(boost::any_cast<string>(m["EventReason"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
  }


  virtual ~DescribeEventsResponseBodyEventItemsEventItems() = default;
};
class DescribeEventsResponseBodyEventItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventsResponseBodyEventItemsEventItems>> eventItems{};

  DescribeEventsResponseBodyEventItems() {}

  explicit DescribeEventsResponseBodyEventItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventItems) {
      vector<boost::any> temp1;
      for(auto item1:*eventItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventItems") != m.end() && !m["EventItems"].empty()) {
      if (typeid(vector<boost::any>) == m["EventItems"].type()) {
        vector<DescribeEventsResponseBodyEventItemsEventItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventsResponseBodyEventItemsEventItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventItems = make_shared<vector<DescribeEventsResponseBodyEventItemsEventItems>>(expect1);
      }
    }
  }


  virtual ~DescribeEventsResponseBodyEventItems() = default;
};
class DescribeEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeEventsResponseBodyEventItems> eventItems{};

  DescribeEventsResponseBody() {}

  explicit DescribeEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (eventItems) {
      res["EventItems"] = eventItems ? boost::any(eventItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("EventItems") != m.end() && !m["EventItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventItems"].type()) {
        DescribeEventsResponseBodyEventItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventItems"]));
        eventItems = make_shared<DescribeEventsResponseBodyEventItems>(model1);
      }
    }
  }


  virtual ~DescribeEventsResponseBody() = default;
};
class DescribeEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEventsResponseBody> body{};

  DescribeEventsResponse() {}

  explicit DescribeEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventsResponse() = default;
};
class DescribeHADiagnoseConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> regionId{};

  DescribeHADiagnoseConfigRequest() {}

  explicit DescribeHADiagnoseConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeHADiagnoseConfigRequest() = default;
};
class DescribeHADiagnoseConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> tcpConnectionType{};
  shared_ptr<string> requestId{};

  DescribeHADiagnoseConfigResponseBody() {}

  explicit DescribeHADiagnoseConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tcpConnectionType) {
      res["TcpConnectionType"] = boost::any(*tcpConnectionType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TcpConnectionType") != m.end() && !m["TcpConnectionType"].empty()) {
      tcpConnectionType = make_shared<string>(boost::any_cast<string>(m["TcpConnectionType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeHADiagnoseConfigResponseBody() = default;
};
class DescribeHADiagnoseConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeHADiagnoseConfigResponseBody> body{};

  DescribeHADiagnoseConfigResponse() {}

  explicit DescribeHADiagnoseConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHADiagnoseConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHADiagnoseConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHADiagnoseConfigResponse() = default;
};
class DescribeHASwitchConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> regionId{};

  DescribeHASwitchConfigRequest() {}

  explicit DescribeHASwitchConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeHASwitchConfigRequest() = default;
};
class DescribeHASwitchConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> manualHATime{};
  shared_ptr<string> HAConfig{};

  DescribeHASwitchConfigResponseBody() {}

  explicit DescribeHASwitchConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (manualHATime) {
      res["ManualHATime"] = boost::any(*manualHATime);
    }
    if (HAConfig) {
      res["HAConfig"] = boost::any(*HAConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ManualHATime") != m.end() && !m["ManualHATime"].empty()) {
      manualHATime = make_shared<string>(boost::any_cast<string>(m["ManualHATime"]));
    }
    if (m.find("HAConfig") != m.end() && !m["HAConfig"].empty()) {
      HAConfig = make_shared<string>(boost::any_cast<string>(m["HAConfig"]));
    }
  }


  virtual ~DescribeHASwitchConfigResponseBody() = default;
};
class DescribeHASwitchConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeHASwitchConfigResponseBody> body{};

  DescribeHASwitchConfigResponse() {}

  explicit DescribeHASwitchConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHASwitchConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHASwitchConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHASwitchConfigResponse() = default;
};
class DescribeInstanceAutoRenewalAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> proxyId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> ownerAccount{};

  DescribeInstanceAutoRenewalAttributeRequest() {}

  explicit DescribeInstanceAutoRenewalAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (proxyId) {
      res["proxyId"] = boost::any(*proxyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("proxyId") != m.end() && !m["proxyId"].empty()) {
      proxyId = make_shared<string>(boost::any_cast<string>(m["proxyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeInstanceAutoRenewalAttributeRequest() = default;
};
class DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> duration{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> autoRenew{};
  shared_ptr<string> regionId{};

  DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem() {}

  explicit DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<string>(boost::any_cast<string>(m["AutoRenew"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem() = default;
};
class DescribeInstanceAutoRenewalAttributeResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem>> item{};

  DescribeInstanceAutoRenewalAttributeResponseBodyItems() {}

  explicit DescribeInstanceAutoRenewalAttributeResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceAutoRenewalAttributeResponseBodyItems() = default;
};
class DescribeInstanceAutoRenewalAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeInstanceAutoRenewalAttributeResponseBodyItems> items{};

  DescribeInstanceAutoRenewalAttributeResponseBody() {}

  explicit DescribeInstanceAutoRenewalAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeInstanceAutoRenewalAttributeResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeInstanceAutoRenewalAttributeResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAutoRenewalAttributeResponseBody() = default;
};
class DescribeInstanceAutoRenewalAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceAutoRenewalAttributeResponseBody> body{};

  DescribeInstanceAutoRenewalAttributeResponse() {}

  explicit DescribeInstanceAutoRenewalAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceAutoRenewalAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceAutoRenewalAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAutoRenewalAttributeResponse() = default;
};
class DescribeInstanceCrossBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> regionId{};

  DescribeInstanceCrossBackupPolicyRequest() {}

  explicit DescribeInstanceCrossBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeInstanceCrossBackupPolicyRequest() = default;
};
class DescribeInstanceCrossBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> logBackupEnabledTime{};
  shared_ptr<string> backupEnabled{};
  shared_ptr<string> DBInstanceStatus{};
  shared_ptr<string> lockMode{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> regionId{};
  shared_ptr<string> logBackupEnabled{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retentType{};
  shared_ptr<long> retention{};
  shared_ptr<string> crossBackupType{};
  shared_ptr<string> crossBackupRegion{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> engine{};
  shared_ptr<string> backupEnabledTime{};
  shared_ptr<string> DBInstanceDescription{};

  DescribeInstanceCrossBackupPolicyResponseBody() {}

  explicit DescribeInstanceCrossBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logBackupEnabledTime) {
      res["LogBackupEnabledTime"] = boost::any(*logBackupEnabledTime);
    }
    if (backupEnabled) {
      res["BackupEnabled"] = boost::any(*backupEnabled);
    }
    if (DBInstanceStatus) {
      res["DBInstanceStatus"] = boost::any(*DBInstanceStatus);
    }
    if (lockMode) {
      res["LockMode"] = boost::any(*lockMode);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (logBackupEnabled) {
      res["LogBackupEnabled"] = boost::any(*logBackupEnabled);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retentType) {
      res["RetentType"] = boost::any(*retentType);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (crossBackupType) {
      res["CrossBackupType"] = boost::any(*crossBackupType);
    }
    if (crossBackupRegion) {
      res["CrossBackupRegion"] = boost::any(*crossBackupRegion);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (backupEnabledTime) {
      res["BackupEnabledTime"] = boost::any(*backupEnabledTime);
    }
    if (DBInstanceDescription) {
      res["DBInstanceDescription"] = boost::any(*DBInstanceDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogBackupEnabledTime") != m.end() && !m["LogBackupEnabledTime"].empty()) {
      logBackupEnabledTime = make_shared<string>(boost::any_cast<string>(m["LogBackupEnabledTime"]));
    }
    if (m.find("BackupEnabled") != m.end() && !m["BackupEnabled"].empty()) {
      backupEnabled = make_shared<string>(boost::any_cast<string>(m["BackupEnabled"]));
    }
    if (m.find("DBInstanceStatus") != m.end() && !m["DBInstanceStatus"].empty()) {
      DBInstanceStatus = make_shared<string>(boost::any_cast<string>(m["DBInstanceStatus"]));
    }
    if (m.find("LockMode") != m.end() && !m["LockMode"].empty()) {
      lockMode = make_shared<string>(boost::any_cast<string>(m["LockMode"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("LogBackupEnabled") != m.end() && !m["LogBackupEnabled"].empty()) {
      logBackupEnabled = make_shared<string>(boost::any_cast<string>(m["LogBackupEnabled"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetentType") != m.end() && !m["RetentType"].empty()) {
      retentType = make_shared<long>(boost::any_cast<long>(m["RetentType"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("CrossBackupType") != m.end() && !m["CrossBackupType"].empty()) {
      crossBackupType = make_shared<string>(boost::any_cast<string>(m["CrossBackupType"]));
    }
    if (m.find("CrossBackupRegion") != m.end() && !m["CrossBackupRegion"].empty()) {
      crossBackupRegion = make_shared<string>(boost::any_cast<string>(m["CrossBackupRegion"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("BackupEnabledTime") != m.end() && !m["BackupEnabledTime"].empty()) {
      backupEnabledTime = make_shared<string>(boost::any_cast<string>(m["BackupEnabledTime"]));
    }
    if (m.find("DBInstanceDescription") != m.end() && !m["DBInstanceDescription"].empty()) {
      DBInstanceDescription = make_shared<string>(boost::any_cast<string>(m["DBInstanceDescription"]));
    }
  }


  virtual ~DescribeInstanceCrossBackupPolicyResponseBody() = default;
};
class DescribeInstanceCrossBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceCrossBackupPolicyResponseBody> body{};

  DescribeInstanceCrossBackupPolicyResponse() {}

  explicit DescribeInstanceCrossBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceCrossBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceCrossBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceCrossBackupPolicyResponse() = default;
};
class DescribeInstanceKeywordsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> key{};
  shared_ptr<string> ownerAccount{};

  DescribeInstanceKeywordsRequest() {}

  explicit DescribeInstanceKeywordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeInstanceKeywordsRequest() = default;
};
class DescribeInstanceKeywordsResponseBodyWords : public Darabonba::Model {
public:
  shared_ptr<vector<string>> word{};

  DescribeInstanceKeywordsResponseBodyWords() {}

  explicit DescribeInstanceKeywordsResponseBodyWords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (word) {
      res["word"] = boost::any(*word);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("word") != m.end() && !m["word"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["word"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["word"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      word = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceKeywordsResponseBodyWords() = default;
};
class DescribeInstanceKeywordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeInstanceKeywordsResponseBodyWords> words{};

  DescribeInstanceKeywordsResponseBody() {}

  explicit DescribeInstanceKeywordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (words) {
      res["Words"] = words ? boost::any(words->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Words") != m.end() && !m["Words"].empty()) {
      if (typeid(map<string, boost::any>) == m["Words"].type()) {
        DescribeInstanceKeywordsResponseBodyWords model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Words"]));
        words = make_shared<DescribeInstanceKeywordsResponseBodyWords>(model1);
      }
    }
  }


  virtual ~DescribeInstanceKeywordsResponseBody() = default;
};
class DescribeInstanceKeywordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceKeywordsResponseBody> body{};

  DescribeInstanceKeywordsResponse() {}

  explicit DescribeInstanceKeywordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceKeywordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceKeywordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceKeywordsResponse() = default;
};
class DescribeLocalAvailableRecoveryTimeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> region{};

  DescribeLocalAvailableRecoveryTimeRequest() {}

  explicit DescribeLocalAvailableRecoveryTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~DescribeLocalAvailableRecoveryTimeRequest() = default;
};
class DescribeLocalAvailableRecoveryTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> recoveryEndTime{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> recoveryBeginTime{};

  DescribeLocalAvailableRecoveryTimeResponseBody() {}

  explicit DescribeLocalAvailableRecoveryTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recoveryEndTime) {
      res["RecoveryEndTime"] = boost::any(*recoveryEndTime);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (recoveryBeginTime) {
      res["RecoveryBeginTime"] = boost::any(*recoveryBeginTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecoveryEndTime") != m.end() && !m["RecoveryEndTime"].empty()) {
      recoveryEndTime = make_shared<string>(boost::any_cast<string>(m["RecoveryEndTime"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RecoveryBeginTime") != m.end() && !m["RecoveryBeginTime"].empty()) {
      recoveryBeginTime = make_shared<string>(boost::any_cast<string>(m["RecoveryBeginTime"]));
    }
  }


  virtual ~DescribeLocalAvailableRecoveryTimeResponseBody() = default;
};
class DescribeLocalAvailableRecoveryTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLocalAvailableRecoveryTimeResponseBody> body{};

  DescribeLocalAvailableRecoveryTimeResponse() {}

  explicit DescribeLocalAvailableRecoveryTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLocalAvailableRecoveryTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLocalAvailableRecoveryTimeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLocalAvailableRecoveryTimeResponse() = default;
};
class DescribeLogBackupFilesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> ownerAccount{};

  DescribeLogBackupFilesRequest() {}

  explicit DescribeLogBackupFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeLogBackupFilesRequest() = default;
};
class DescribeLogBackupFilesResponseBodyItemsBinLogFile : public Darabonba::Model {
public:
  shared_ptr<string> logBeginTime{};
  shared_ptr<string> intranetDownloadLink{};
  shared_ptr<string> linkExpiredTime{};
  shared_ptr<string> downloadLink{};
  shared_ptr<string> logEndTime{};
  shared_ptr<long> fileSize{};

  DescribeLogBackupFilesResponseBodyItemsBinLogFile() {}

  explicit DescribeLogBackupFilesResponseBodyItemsBinLogFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logBeginTime) {
      res["LogBeginTime"] = boost::any(*logBeginTime);
    }
    if (intranetDownloadLink) {
      res["IntranetDownloadLink"] = boost::any(*intranetDownloadLink);
    }
    if (linkExpiredTime) {
      res["LinkExpiredTime"] = boost::any(*linkExpiredTime);
    }
    if (downloadLink) {
      res["DownloadLink"] = boost::any(*downloadLink);
    }
    if (logEndTime) {
      res["LogEndTime"] = boost::any(*logEndTime);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogBeginTime") != m.end() && !m["LogBeginTime"].empty()) {
      logBeginTime = make_shared<string>(boost::any_cast<string>(m["LogBeginTime"]));
    }
    if (m.find("IntranetDownloadLink") != m.end() && !m["IntranetDownloadLink"].empty()) {
      intranetDownloadLink = make_shared<string>(boost::any_cast<string>(m["IntranetDownloadLink"]));
    }
    if (m.find("LinkExpiredTime") != m.end() && !m["LinkExpiredTime"].empty()) {
      linkExpiredTime = make_shared<string>(boost::any_cast<string>(m["LinkExpiredTime"]));
    }
    if (m.find("DownloadLink") != m.end() && !m["DownloadLink"].empty()) {
      downloadLink = make_shared<string>(boost::any_cast<string>(m["DownloadLink"]));
    }
    if (m.find("LogEndTime") != m.end() && !m["LogEndTime"].empty()) {
      logEndTime = make_shared<string>(boost::any_cast<string>(m["LogEndTime"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
  }


  virtual ~DescribeLogBackupFilesResponseBodyItemsBinLogFile() = default;
};
class DescribeLogBackupFilesResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLogBackupFilesResponseBodyItemsBinLogFile>> binLogFile{};

  DescribeLogBackupFilesResponseBodyItems() {}

  explicit DescribeLogBackupFilesResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binLogFile) {
      vector<boost::any> temp1;
      for(auto item1:*binLogFile){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BinLogFile"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BinLogFile") != m.end() && !m["BinLogFile"].empty()) {
      if (typeid(vector<boost::any>) == m["BinLogFile"].type()) {
        vector<DescribeLogBackupFilesResponseBodyItemsBinLogFile> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BinLogFile"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLogBackupFilesResponseBodyItemsBinLogFile model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        binLogFile = make_shared<vector<DescribeLogBackupFilesResponseBodyItemsBinLogFile>>(expect1);
      }
    }
  }


  virtual ~DescribeLogBackupFilesResponseBodyItems() = default;
};
class DescribeLogBackupFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalFileSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeLogBackupFilesResponseBodyItems> items{};

  DescribeLogBackupFilesResponseBody() {}

  explicit DescribeLogBackupFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalFileSize) {
      res["TotalFileSize"] = boost::any(*totalFileSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalFileSize") != m.end() && !m["TotalFileSize"].empty()) {
      totalFileSize = make_shared<long>(boost::any_cast<long>(m["TotalFileSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeLogBackupFilesResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeLogBackupFilesResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeLogBackupFilesResponseBody() = default;
};
class DescribeLogBackupFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLogBackupFilesResponseBody> body{};

  DescribeLogBackupFilesResponse() {}

  explicit DescribeLogBackupFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLogBackupFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLogBackupFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLogBackupFilesResponse() = default;
};
class DescribeMetaListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> restoreType{};
  shared_ptr<long> backupSetID{};
  shared_ptr<string> restoreTime{};
  shared_ptr<string> getDbName{};
  shared_ptr<string> pattern{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageIndex{};

  DescribeMetaListRequest() {}

  explicit DescribeMetaListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (restoreType) {
      res["RestoreType"] = boost::any(*restoreType);
    }
    if (backupSetID) {
      res["BackupSetID"] = boost::any(*backupSetID);
    }
    if (restoreTime) {
      res["RestoreTime"] = boost::any(*restoreTime);
    }
    if (getDbName) {
      res["GetDbName"] = boost::any(*getDbName);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RestoreType") != m.end() && !m["RestoreType"].empty()) {
      restoreType = make_shared<string>(boost::any_cast<string>(m["RestoreType"]));
    }
    if (m.find("BackupSetID") != m.end() && !m["BackupSetID"].empty()) {
      backupSetID = make_shared<long>(boost::any_cast<long>(m["BackupSetID"]));
    }
    if (m.find("RestoreTime") != m.end() && !m["RestoreTime"].empty()) {
      restoreTime = make_shared<string>(boost::any_cast<string>(m["RestoreTime"]));
    }
    if (m.find("GetDbName") != m.end() && !m["GetDbName"].empty()) {
      getDbName = make_shared<string>(boost::any_cast<string>(m["GetDbName"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
  }


  virtual ~DescribeMetaListRequest() = default;
};
class DescribeMetaListResponseBodyItemsMeta : public Darabonba::Model {
public:
  shared_ptr<string> tables{};
  shared_ptr<string> database{};
  shared_ptr<string> size{};

  DescribeMetaListResponseBodyItemsMeta() {}

  explicit DescribeMetaListResponseBodyItemsMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tables) {
      res["Tables"] = boost::any(*tables);
    }
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      tables = make_shared<string>(boost::any_cast<string>(m["Tables"]));
    }
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
  }


  virtual ~DescribeMetaListResponseBodyItemsMeta() = default;
};
class DescribeMetaListResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMetaListResponseBodyItemsMeta>> meta{};

  DescribeMetaListResponseBodyItems() {}

  explicit DescribeMetaListResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (meta) {
      vector<boost::any> temp1;
      for(auto item1:*meta){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Meta"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Meta") != m.end() && !m["Meta"].empty()) {
      if (typeid(vector<boost::any>) == m["Meta"].type()) {
        vector<DescribeMetaListResponseBodyItemsMeta> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Meta"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetaListResponseBodyItemsMeta model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        meta = make_shared<vector<DescribeMetaListResponseBodyItemsMeta>>(expect1);
      }
    }
  }


  virtual ~DescribeMetaListResponseBodyItems() = default;
};
class DescribeMetaListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceName{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeMetaListResponseBodyItems> items{};

  DescribeMetaListResponseBody() {}

  explicit DescribeMetaListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeMetaListResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeMetaListResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeMetaListResponseBody() = default;
};
class DescribeMetaListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeMetaListResponseBody> body{};

  DescribeMetaListResponse() {}

  explicit DescribeMetaListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetaListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetaListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetaListResponse() = default;
};
class DescribeMigrateTaskByIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> migrateTaskId{};

  DescribeMigrateTaskByIdRequest() {}

  explicit DescribeMigrateTaskByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (migrateTaskId) {
      res["MigrateTaskId"] = boost::any(*migrateTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("MigrateTaskId") != m.end() && !m["MigrateTaskId"].empty()) {
      migrateTaskId = make_shared<string>(boost::any_cast<string>(m["MigrateTaskId"]));
    }
  }


  virtual ~DescribeMigrateTaskByIdRequest() = default;
};
class DescribeMigrateTaskByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> endTime{};
  shared_ptr<string> DBInstanceName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> description{};
  shared_ptr<string> createTime{};
  shared_ptr<string> DBName{};
  shared_ptr<string> backupMode{};
  shared_ptr<string> migrateTaskId{};
  shared_ptr<string> isDBReplaced{};

  DescribeMigrateTaskByIdResponseBody() {}

  explicit DescribeMigrateTaskByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (backupMode) {
      res["BackupMode"] = boost::any(*backupMode);
    }
    if (migrateTaskId) {
      res["MigrateTaskId"] = boost::any(*migrateTaskId);
    }
    if (isDBReplaced) {
      res["IsDBReplaced"] = boost::any(*isDBReplaced);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("BackupMode") != m.end() && !m["BackupMode"].empty()) {
      backupMode = make_shared<string>(boost::any_cast<string>(m["BackupMode"]));
    }
    if (m.find("MigrateTaskId") != m.end() && !m["MigrateTaskId"].empty()) {
      migrateTaskId = make_shared<string>(boost::any_cast<string>(m["MigrateTaskId"]));
    }
    if (m.find("IsDBReplaced") != m.end() && !m["IsDBReplaced"].empty()) {
      isDBReplaced = make_shared<string>(boost::any_cast<string>(m["IsDBReplaced"]));
    }
  }


  virtual ~DescribeMigrateTaskByIdResponseBody() = default;
};
class DescribeMigrateTaskByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeMigrateTaskByIdResponseBody> body{};

  DescribeMigrateTaskByIdResponse() {}

  explicit DescribeMigrateTaskByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMigrateTaskByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMigrateTaskByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMigrateTaskByIdResponse() = default;
};
class DescribeMigrateTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeMigrateTasksRequest() {}

  explicit DescribeMigrateTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeMigrateTasksRequest() = default;
};
class DescribeMigrateTasksResponseBodyItemsMigrateTask : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> status{};
  shared_ptr<string> description{};
  shared_ptr<string> createTime{};
  shared_ptr<string> DBName{};
  shared_ptr<string> backupMode{};
  shared_ptr<string> migrateTaskId{};
  shared_ptr<string> isDBReplaced{};

  DescribeMigrateTasksResponseBodyItemsMigrateTask() {}

  explicit DescribeMigrateTasksResponseBodyItemsMigrateTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (backupMode) {
      res["BackupMode"] = boost::any(*backupMode);
    }
    if (migrateTaskId) {
      res["MigrateTaskId"] = boost::any(*migrateTaskId);
    }
    if (isDBReplaced) {
      res["IsDBReplaced"] = boost::any(*isDBReplaced);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("BackupMode") != m.end() && !m["BackupMode"].empty()) {
      backupMode = make_shared<string>(boost::any_cast<string>(m["BackupMode"]));
    }
    if (m.find("MigrateTaskId") != m.end() && !m["MigrateTaskId"].empty()) {
      migrateTaskId = make_shared<string>(boost::any_cast<string>(m["MigrateTaskId"]));
    }
    if (m.find("IsDBReplaced") != m.end() && !m["IsDBReplaced"].empty()) {
      isDBReplaced = make_shared<string>(boost::any_cast<string>(m["IsDBReplaced"]));
    }
  }


  virtual ~DescribeMigrateTasksResponseBodyItemsMigrateTask() = default;
};
class DescribeMigrateTasksResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMigrateTasksResponseBodyItemsMigrateTask>> migrateTask{};

  DescribeMigrateTasksResponseBodyItems() {}

  explicit DescribeMigrateTasksResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrateTask) {
      vector<boost::any> temp1;
      for(auto item1:*migrateTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MigrateTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrateTask") != m.end() && !m["MigrateTask"].empty()) {
      if (typeid(vector<boost::any>) == m["MigrateTask"].type()) {
        vector<DescribeMigrateTasksResponseBodyItemsMigrateTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MigrateTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrateTasksResponseBodyItemsMigrateTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        migrateTask = make_shared<vector<DescribeMigrateTasksResponseBodyItemsMigrateTask>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrateTasksResponseBodyItems() = default;
};
class DescribeMigrateTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeMigrateTasksResponseBodyItems> items{};

  DescribeMigrateTasksResponseBody() {}

  explicit DescribeMigrateTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeMigrateTasksResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeMigrateTasksResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeMigrateTasksResponseBody() = default;
};
class DescribeMigrateTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeMigrateTasksResponseBody> body{};

  DescribeMigrateTasksResponse() {}

  explicit DescribeMigrateTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMigrateTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMigrateTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMigrateTasksResponse() = default;
};
class DescribeMigrateTasksForSQLServerRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeMigrateTasksForSQLServerRequest() {}

  explicit DescribeMigrateTasksForSQLServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeMigrateTasksForSQLServerRequest() = default;
};
class DescribeMigrateTasksForSQLServerResponseBodyItemsMigrateTask : public Darabonba::Model {
public:
  shared_ptr<string> migrateIaskId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> status{};
  shared_ptr<string> taskType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> DBName{};
  shared_ptr<string> isDBReplaced{};
  shared_ptr<string> desc{};

  DescribeMigrateTasksForSQLServerResponseBodyItemsMigrateTask() {}

  explicit DescribeMigrateTasksForSQLServerResponseBodyItemsMigrateTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrateIaskId) {
      res["MigrateIaskId"] = boost::any(*migrateIaskId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (isDBReplaced) {
      res["IsDBReplaced"] = boost::any(*isDBReplaced);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrateIaskId") != m.end() && !m["MigrateIaskId"].empty()) {
      migrateIaskId = make_shared<string>(boost::any_cast<string>(m["MigrateIaskId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("IsDBReplaced") != m.end() && !m["IsDBReplaced"].empty()) {
      isDBReplaced = make_shared<string>(boost::any_cast<string>(m["IsDBReplaced"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
  }


  virtual ~DescribeMigrateTasksForSQLServerResponseBodyItemsMigrateTask() = default;
};
class DescribeMigrateTasksForSQLServerResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMigrateTasksForSQLServerResponseBodyItemsMigrateTask>> migrateTask{};

  DescribeMigrateTasksForSQLServerResponseBodyItems() {}

  explicit DescribeMigrateTasksForSQLServerResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrateTask) {
      vector<boost::any> temp1;
      for(auto item1:*migrateTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MigrateTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrateTask") != m.end() && !m["MigrateTask"].empty()) {
      if (typeid(vector<boost::any>) == m["MigrateTask"].type()) {
        vector<DescribeMigrateTasksForSQLServerResponseBodyItemsMigrateTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MigrateTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrateTasksForSQLServerResponseBodyItemsMigrateTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        migrateTask = make_shared<vector<DescribeMigrateTasksForSQLServerResponseBodyItemsMigrateTask>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrateTasksForSQLServerResponseBodyItems() = default;
};
class DescribeMigrateTasksForSQLServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> DBInstanceName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<string> DBInstanceID{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeMigrateTasksForSQLServerResponseBodyItems> items{};

  DescribeMigrateTasksForSQLServerResponseBody() {}

  explicit DescribeMigrateTasksForSQLServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (DBInstanceID) {
      res["DBInstanceID"] = boost::any(*DBInstanceID);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("DBInstanceID") != m.end() && !m["DBInstanceID"].empty()) {
      DBInstanceID = make_shared<string>(boost::any_cast<string>(m["DBInstanceID"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeMigrateTasksForSQLServerResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeMigrateTasksForSQLServerResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeMigrateTasksForSQLServerResponseBody() = default;
};
class DescribeMigrateTasksForSQLServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeMigrateTasksForSQLServerResponseBody> body{};

  DescribeMigrateTasksForSQLServerResponse() {}

  explicit DescribeMigrateTasksForSQLServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMigrateTasksForSQLServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMigrateTasksForSQLServerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMigrateTasksForSQLServerResponse() = default;
};
class DescribeModifyParameterLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> ownerAccount{};

  DescribeModifyParameterLogRequest() {}

  explicit DescribeModifyParameterLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeModifyParameterLogRequest() = default;
};
class DescribeModifyParameterLogResponseBodyItemsParameterChangeLog : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> oldParameterValue{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> newParameterValue{};
  shared_ptr<string> modifyTime{};

  DescribeModifyParameterLogResponseBodyItemsParameterChangeLog() {}

  explicit DescribeModifyParameterLogResponseBodyItemsParameterChangeLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (oldParameterValue) {
      res["OldParameterValue"] = boost::any(*oldParameterValue);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (newParameterValue) {
      res["NewParameterValue"] = boost::any(*newParameterValue);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("OldParameterValue") != m.end() && !m["OldParameterValue"].empty()) {
      oldParameterValue = make_shared<string>(boost::any_cast<string>(m["OldParameterValue"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("NewParameterValue") != m.end() && !m["NewParameterValue"].empty()) {
      newParameterValue = make_shared<string>(boost::any_cast<string>(m["NewParameterValue"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
  }


  virtual ~DescribeModifyParameterLogResponseBodyItemsParameterChangeLog() = default;
};
class DescribeModifyParameterLogResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeModifyParameterLogResponseBodyItemsParameterChangeLog>> parameterChangeLog{};

  DescribeModifyParameterLogResponseBodyItems() {}

  explicit DescribeModifyParameterLogResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterChangeLog) {
      vector<boost::any> temp1;
      for(auto item1:*parameterChangeLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParameterChangeLog"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterChangeLog") != m.end() && !m["ParameterChangeLog"].empty()) {
      if (typeid(vector<boost::any>) == m["ParameterChangeLog"].type()) {
        vector<DescribeModifyParameterLogResponseBodyItemsParameterChangeLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParameterChangeLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeModifyParameterLogResponseBodyItemsParameterChangeLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parameterChangeLog = make_shared<vector<DescribeModifyParameterLogResponseBodyItemsParameterChangeLog>>(expect1);
      }
    }
  }


  virtual ~DescribeModifyParameterLogResponseBodyItems() = default;
};
class DescribeModifyParameterLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> engine{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> engineVersion{};
  shared_ptr<DescribeModifyParameterLogResponseBodyItems> items{};

  DescribeModifyParameterLogResponseBody() {}

  explicit DescribeModifyParameterLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeModifyParameterLogResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeModifyParameterLogResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeModifyParameterLogResponseBody() = default;
};
class DescribeModifyParameterLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeModifyParameterLogResponseBody> body{};

  DescribeModifyParameterLogResponse() {}

  explicit DescribeModifyParameterLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeModifyParameterLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeModifyParameterLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeModifyParameterLogResponse() = default;
};
class DescribeOssDownloadsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> migrateTaskId{};

  DescribeOssDownloadsRequest() {}

  explicit DescribeOssDownloadsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (migrateTaskId) {
      res["MigrateTaskId"] = boost::any(*migrateTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("MigrateTaskId") != m.end() && !m["MigrateTaskId"].empty()) {
      migrateTaskId = make_shared<string>(boost::any_cast<string>(m["MigrateTaskId"]));
    }
  }


  virtual ~DescribeOssDownloadsRequest() = default;
};
class DescribeOssDownloadsResponseBodyItemsOssDownload : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> status{};
  shared_ptr<string> description{};
  shared_ptr<string> createTime{};
  shared_ptr<string> backupMode{};
  shared_ptr<string> isAvailable{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};

  DescribeOssDownloadsResponseBodyItemsOssDownload() {}

  explicit DescribeOssDownloadsResponseBodyItemsOssDownload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (backupMode) {
      res["BackupMode"] = boost::any(*backupMode);
    }
    if (isAvailable) {
      res["IsAvailable"] = boost::any(*isAvailable);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("BackupMode") != m.end() && !m["BackupMode"].empty()) {
      backupMode = make_shared<string>(boost::any_cast<string>(m["BackupMode"]));
    }
    if (m.find("IsAvailable") != m.end() && !m["IsAvailable"].empty()) {
      isAvailable = make_shared<string>(boost::any_cast<string>(m["IsAvailable"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
  }


  virtual ~DescribeOssDownloadsResponseBodyItemsOssDownload() = default;
};
class DescribeOssDownloadsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeOssDownloadsResponseBodyItemsOssDownload>> ossDownload{};

  DescribeOssDownloadsResponseBodyItems() {}

  explicit DescribeOssDownloadsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossDownload) {
      vector<boost::any> temp1;
      for(auto item1:*ossDownload){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OssDownload"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssDownload") != m.end() && !m["OssDownload"].empty()) {
      if (typeid(vector<boost::any>) == m["OssDownload"].type()) {
        vector<DescribeOssDownloadsResponseBodyItemsOssDownload> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OssDownload"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOssDownloadsResponseBodyItemsOssDownload model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ossDownload = make_shared<vector<DescribeOssDownloadsResponseBodyItemsOssDownload>>(expect1);
      }
    }
  }


  virtual ~DescribeOssDownloadsResponseBodyItems() = default;
};
class DescribeOssDownloadsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> migrateTaskId{};
  shared_ptr<DescribeOssDownloadsResponseBodyItems> items{};

  DescribeOssDownloadsResponseBody() {}

  explicit DescribeOssDownloadsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (migrateTaskId) {
      res["MigrateTaskId"] = boost::any(*migrateTaskId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MigrateTaskId") != m.end() && !m["MigrateTaskId"].empty()) {
      migrateTaskId = make_shared<string>(boost::any_cast<string>(m["MigrateTaskId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeOssDownloadsResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeOssDownloadsResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeOssDownloadsResponseBody() = default;
};
class DescribeOssDownloadsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeOssDownloadsResponseBody> body{};

  DescribeOssDownloadsResponse() {}

  explicit DescribeOssDownloadsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOssDownloadsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOssDownloadsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOssDownloadsResponse() = default;
};
class DescribeOssDownloadsForSQLServerRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> migrateTaskId{};

  DescribeOssDownloadsForSQLServerRequest() {}

  explicit DescribeOssDownloadsForSQLServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (migrateTaskId) {
      res["MigrateTaskId"] = boost::any(*migrateTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("MigrateTaskId") != m.end() && !m["MigrateTaskId"].empty()) {
      migrateTaskId = make_shared<string>(boost::any_cast<string>(m["MigrateTaskId"]));
    }
  }


  virtual ~DescribeOssDownloadsForSQLServerRequest() = default;
};
class DescribeOssDownloadsForSQLServerResponseBodyItemsOssDownload : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> createTime{};
  shared_ptr<string> isAvail{};
  shared_ptr<string> fileName{};
  shared_ptr<string> bakType{};
  shared_ptr<string> desc{};
  shared_ptr<string> fileSize{};

  DescribeOssDownloadsForSQLServerResponseBodyItemsOssDownload() {}

  explicit DescribeOssDownloadsForSQLServerResponseBodyItemsOssDownload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isAvail) {
      res["IsAvail"] = boost::any(*isAvail);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (bakType) {
      res["BakType"] = boost::any(*bakType);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("IsAvail") != m.end() && !m["IsAvail"].empty()) {
      isAvail = make_shared<string>(boost::any_cast<string>(m["IsAvail"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("BakType") != m.end() && !m["BakType"].empty()) {
      bakType = make_shared<string>(boost::any_cast<string>(m["BakType"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
  }


  virtual ~DescribeOssDownloadsForSQLServerResponseBodyItemsOssDownload() = default;
};
class DescribeOssDownloadsForSQLServerResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeOssDownloadsForSQLServerResponseBodyItemsOssDownload>> ossDownload{};

  DescribeOssDownloadsForSQLServerResponseBodyItems() {}

  explicit DescribeOssDownloadsForSQLServerResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossDownload) {
      vector<boost::any> temp1;
      for(auto item1:*ossDownload){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OssDownload"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssDownload") != m.end() && !m["OssDownload"].empty()) {
      if (typeid(vector<boost::any>) == m["OssDownload"].type()) {
        vector<DescribeOssDownloadsForSQLServerResponseBodyItemsOssDownload> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OssDownload"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOssDownloadsForSQLServerResponseBodyItemsOssDownload model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ossDownload = make_shared<vector<DescribeOssDownloadsForSQLServerResponseBodyItemsOssDownload>>(expect1);
      }
    }
  }


  virtual ~DescribeOssDownloadsForSQLServerResponseBodyItems() = default;
};
class DescribeOssDownloadsForSQLServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> migrateIaskId{};
  shared_ptr<string> DBInstanceName{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeOssDownloadsForSQLServerResponseBodyItems> items{};

  DescribeOssDownloadsForSQLServerResponseBody() {}

  explicit DescribeOssDownloadsForSQLServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrateIaskId) {
      res["MigrateIaskId"] = boost::any(*migrateIaskId);
    }
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrateIaskId") != m.end() && !m["MigrateIaskId"].empty()) {
      migrateIaskId = make_shared<string>(boost::any_cast<string>(m["MigrateIaskId"]));
    }
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeOssDownloadsForSQLServerResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeOssDownloadsForSQLServerResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeOssDownloadsForSQLServerResponseBody() = default;
};
class DescribeOssDownloadsForSQLServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeOssDownloadsForSQLServerResponseBody> body{};

  DescribeOssDownloadsForSQLServerResponse() {}

  explicit DescribeOssDownloadsForSQLServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOssDownloadsForSQLServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOssDownloadsForSQLServerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOssDownloadsForSQLServerResponse() = default;
};
class DescribeParameterGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> parameterGroupId{};
  shared_ptr<string> regionId{};

  DescribeParameterGroupRequest() {}

  explicit DescribeParameterGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (parameterGroupId) {
      res["ParameterGroupId"] = boost::any(*parameterGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ParameterGroupId") != m.end() && !m["ParameterGroupId"].empty()) {
      parameterGroupId = make_shared<string>(boost::any_cast<string>(m["ParameterGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeParameterGroupRequest() = default;
};
class DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail : public Darabonba::Model {
public:
  shared_ptr<string> paramName{};
  shared_ptr<string> paramValue{};

  DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail() {}

  explicit DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramValue) {
      res["ParamValue"] = boost::any(*paramValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamValue") != m.end() && !m["ParamValue"].empty()) {
      paramValue = make_shared<string>(boost::any_cast<string>(m["ParamValue"]));
    }
  }


  virtual ~DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail() = default;
};
class DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail>> parameterDetail{};

  DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail() {}

  explicit DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterDetail) {
      vector<boost::any> temp1;
      for(auto item1:*parameterDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParameterDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterDetail") != m.end() && !m["ParameterDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["ParameterDetail"].type()) {
        vector<DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParameterDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parameterDetail = make_shared<vector<DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail() = default;
};
class DescribeParameterGroupResponseBodyParamGroupParameterGroup : public Darabonba::Model {
public:
  shared_ptr<string> updateTime{};
  shared_ptr<string> parameterGroupDesc{};
  shared_ptr<string> createTime{};
  shared_ptr<long> forceRestart{};
  shared_ptr<string> parameterGroupId{};
  shared_ptr<string> parameterGroupName{};
  shared_ptr<string> engine{};
  shared_ptr<long> paramCounts{};
  shared_ptr<string> engineVersion{};
  shared_ptr<long> parameterGroupType{};
  shared_ptr<DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail> paramDetail{};

  DescribeParameterGroupResponseBodyParamGroupParameterGroup() {}

  explicit DescribeParameterGroupResponseBodyParamGroupParameterGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (parameterGroupDesc) {
      res["ParameterGroupDesc"] = boost::any(*parameterGroupDesc);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (forceRestart) {
      res["ForceRestart"] = boost::any(*forceRestart);
    }
    if (parameterGroupId) {
      res["ParameterGroupId"] = boost::any(*parameterGroupId);
    }
    if (parameterGroupName) {
      res["ParameterGroupName"] = boost::any(*parameterGroupName);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (paramCounts) {
      res["ParamCounts"] = boost::any(*paramCounts);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (parameterGroupType) {
      res["ParameterGroupType"] = boost::any(*parameterGroupType);
    }
    if (paramDetail) {
      res["ParamDetail"] = paramDetail ? boost::any(paramDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("ParameterGroupDesc") != m.end() && !m["ParameterGroupDesc"].empty()) {
      parameterGroupDesc = make_shared<string>(boost::any_cast<string>(m["ParameterGroupDesc"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ForceRestart") != m.end() && !m["ForceRestart"].empty()) {
      forceRestart = make_shared<long>(boost::any_cast<long>(m["ForceRestart"]));
    }
    if (m.find("ParameterGroupId") != m.end() && !m["ParameterGroupId"].empty()) {
      parameterGroupId = make_shared<string>(boost::any_cast<string>(m["ParameterGroupId"]));
    }
    if (m.find("ParameterGroupName") != m.end() && !m["ParameterGroupName"].empty()) {
      parameterGroupName = make_shared<string>(boost::any_cast<string>(m["ParameterGroupName"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("ParamCounts") != m.end() && !m["ParamCounts"].empty()) {
      paramCounts = make_shared<long>(boost::any_cast<long>(m["ParamCounts"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("ParameterGroupType") != m.end() && !m["ParameterGroupType"].empty()) {
      parameterGroupType = make_shared<long>(boost::any_cast<long>(m["ParameterGroupType"]));
    }
    if (m.find("ParamDetail") != m.end() && !m["ParamDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParamDetail"].type()) {
        DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParamDetail"]));
        paramDetail = make_shared<DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail>(model1);
      }
    }
  }


  virtual ~DescribeParameterGroupResponseBodyParamGroupParameterGroup() = default;
};
class DescribeParameterGroupResponseBodyParamGroup : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeParameterGroupResponseBodyParamGroupParameterGroup>> parameterGroup{};

  DescribeParameterGroupResponseBodyParamGroup() {}

  explicit DescribeParameterGroupResponseBodyParamGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterGroup) {
      vector<boost::any> temp1;
      for(auto item1:*parameterGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParameterGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterGroup") != m.end() && !m["ParameterGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["ParameterGroup"].type()) {
        vector<DescribeParameterGroupResponseBodyParamGroupParameterGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParameterGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeParameterGroupResponseBodyParamGroupParameterGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parameterGroup = make_shared<vector<DescribeParameterGroupResponseBodyParamGroupParameterGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeParameterGroupResponseBodyParamGroup() = default;
};
class DescribeParameterGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeParameterGroupResponseBodyParamGroup> paramGroup{};

  DescribeParameterGroupResponseBody() {}

  explicit DescribeParameterGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (paramGroup) {
      res["ParamGroup"] = paramGroup ? boost::any(paramGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ParamGroup") != m.end() && !m["ParamGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParamGroup"].type()) {
        DescribeParameterGroupResponseBodyParamGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParamGroup"]));
        paramGroup = make_shared<DescribeParameterGroupResponseBodyParamGroup>(model1);
      }
    }
  }


  virtual ~DescribeParameterGroupResponseBody() = default;
};
class DescribeParameterGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeParameterGroupResponseBody> body{};

  DescribeParameterGroupResponse() {}

  explicit DescribeParameterGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeParameterGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeParameterGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeParameterGroupResponse() = default;
};
class DescribeParameterGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};

  DescribeParameterGroupsRequest() {}

  explicit DescribeParameterGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeParameterGroupsRequest() = default;
};
class DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup : public Darabonba::Model {
public:
  shared_ptr<string> updateTime{};
  shared_ptr<string> parameterGroupDesc{};
  shared_ptr<string> createTime{};
  shared_ptr<long> forceRestart{};
  shared_ptr<string> parameterGroupId{};
  shared_ptr<string> parameterGroupName{};
  shared_ptr<string> engine{};
  shared_ptr<long> paramCounts{};
  shared_ptr<string> engineVersion{};
  shared_ptr<long> parameterGroupType{};

  DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup() {}

  explicit DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (parameterGroupDesc) {
      res["ParameterGroupDesc"] = boost::any(*parameterGroupDesc);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (forceRestart) {
      res["ForceRestart"] = boost::any(*forceRestart);
    }
    if (parameterGroupId) {
      res["ParameterGroupId"] = boost::any(*parameterGroupId);
    }
    if (parameterGroupName) {
      res["ParameterGroupName"] = boost::any(*parameterGroupName);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (paramCounts) {
      res["ParamCounts"] = boost::any(*paramCounts);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (parameterGroupType) {
      res["ParameterGroupType"] = boost::any(*parameterGroupType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("ParameterGroupDesc") != m.end() && !m["ParameterGroupDesc"].empty()) {
      parameterGroupDesc = make_shared<string>(boost::any_cast<string>(m["ParameterGroupDesc"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ForceRestart") != m.end() && !m["ForceRestart"].empty()) {
      forceRestart = make_shared<long>(boost::any_cast<long>(m["ForceRestart"]));
    }
    if (m.find("ParameterGroupId") != m.end() && !m["ParameterGroupId"].empty()) {
      parameterGroupId = make_shared<string>(boost::any_cast<string>(m["ParameterGroupId"]));
    }
    if (m.find("ParameterGroupName") != m.end() && !m["ParameterGroupName"].empty()) {
      parameterGroupName = make_shared<string>(boost::any_cast<string>(m["ParameterGroupName"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("ParamCounts") != m.end() && !m["ParamCounts"].empty()) {
      paramCounts = make_shared<long>(boost::any_cast<long>(m["ParamCounts"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("ParameterGroupType") != m.end() && !m["ParameterGroupType"].empty()) {
      parameterGroupType = make_shared<long>(boost::any_cast<long>(m["ParameterGroupType"]));
    }
  }


  virtual ~DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup() = default;
};
class DescribeParameterGroupsResponseBodyParameterGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup>> parameterGroup{};

  DescribeParameterGroupsResponseBodyParameterGroups() {}

  explicit DescribeParameterGroupsResponseBodyParameterGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterGroup) {
      vector<boost::any> temp1;
      for(auto item1:*parameterGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParameterGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterGroup") != m.end() && !m["ParameterGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["ParameterGroup"].type()) {
        vector<DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParameterGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parameterGroup = make_shared<vector<DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeParameterGroupsResponseBodyParameterGroups() = default;
};
class DescribeParameterGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> signalForOptimizeParams{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeParameterGroupsResponseBodyParameterGroups> parameterGroups{};

  DescribeParameterGroupsResponseBody() {}

  explicit DescribeParameterGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signalForOptimizeParams) {
      res["SignalForOptimizeParams"] = boost::any(*signalForOptimizeParams);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (parameterGroups) {
      res["ParameterGroups"] = parameterGroups ? boost::any(parameterGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignalForOptimizeParams") != m.end() && !m["SignalForOptimizeParams"].empty()) {
      signalForOptimizeParams = make_shared<bool>(boost::any_cast<bool>(m["SignalForOptimizeParams"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ParameterGroups") != m.end() && !m["ParameterGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParameterGroups"].type()) {
        DescribeParameterGroupsResponseBodyParameterGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParameterGroups"]));
        parameterGroups = make_shared<DescribeParameterGroupsResponseBodyParameterGroups>(model1);
      }
    }
  }


  virtual ~DescribeParameterGroupsResponseBody() = default;
};
class DescribeParameterGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeParameterGroupsResponseBody> body{};

  DescribeParameterGroupsResponse() {}

  explicit DescribeParameterGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeParameterGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeParameterGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeParameterGroupsResponse() = default;
};
class DescribeParametersRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> ownerAccount{};

  DescribeParametersRequest() {}

  explicit DescribeParametersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeParametersRequest() = default;
};
class DescribeParametersResponseBodyConfigParametersDBInstanceParameter : public Darabonba::Model {
public:
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> parameterValue{};

  DescribeParametersResponseBodyConfigParametersDBInstanceParameter() {}

  explicit DescribeParametersResponseBodyConfigParametersDBInstanceParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterValue) {
      res["ParameterValue"] = boost::any(*parameterValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterValue") != m.end() && !m["ParameterValue"].empty()) {
      parameterValue = make_shared<string>(boost::any_cast<string>(m["ParameterValue"]));
    }
  }


  virtual ~DescribeParametersResponseBodyConfigParametersDBInstanceParameter() = default;
};
class DescribeParametersResponseBodyConfigParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeParametersResponseBodyConfigParametersDBInstanceParameter>> DBInstanceParameter{};

  DescribeParametersResponseBodyConfigParameters() {}

  explicit DescribeParametersResponseBodyConfigParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceParameter) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstanceParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstanceParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceParameter") != m.end() && !m["DBInstanceParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstanceParameter"].type()) {
        vector<DescribeParametersResponseBodyConfigParametersDBInstanceParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstanceParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeParametersResponseBodyConfigParametersDBInstanceParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstanceParameter = make_shared<vector<DescribeParametersResponseBodyConfigParametersDBInstanceParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeParametersResponseBodyConfigParameters() = default;
};
class DescribeParametersResponseBodyRunningParametersDBInstanceParameter : public Darabonba::Model {
public:
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> parameterValue{};

  DescribeParametersResponseBodyRunningParametersDBInstanceParameter() {}

  explicit DescribeParametersResponseBodyRunningParametersDBInstanceParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterValue) {
      res["ParameterValue"] = boost::any(*parameterValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterValue") != m.end() && !m["ParameterValue"].empty()) {
      parameterValue = make_shared<string>(boost::any_cast<string>(m["ParameterValue"]));
    }
  }


  virtual ~DescribeParametersResponseBodyRunningParametersDBInstanceParameter() = default;
};
class DescribeParametersResponseBodyRunningParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeParametersResponseBodyRunningParametersDBInstanceParameter>> DBInstanceParameter{};

  DescribeParametersResponseBodyRunningParameters() {}

  explicit DescribeParametersResponseBodyRunningParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceParameter) {
      vector<boost::any> temp1;
      for(auto item1:*DBInstanceParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBInstanceParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceParameter") != m.end() && !m["DBInstanceParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["DBInstanceParameter"].type()) {
        vector<DescribeParametersResponseBodyRunningParametersDBInstanceParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBInstanceParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeParametersResponseBodyRunningParametersDBInstanceParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBInstanceParameter = make_shared<vector<DescribeParametersResponseBodyRunningParametersDBInstanceParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeParametersResponseBodyRunningParameters() = default;
};
class DescribeParametersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> engine{};
  shared_ptr<string> engineVersion{};
  shared_ptr<DescribeParametersResponseBodyConfigParameters> configParameters{};
  shared_ptr<DescribeParametersResponseBodyRunningParameters> runningParameters{};

  DescribeParametersResponseBody() {}

  explicit DescribeParametersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (configParameters) {
      res["ConfigParameters"] = configParameters ? boost::any(configParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runningParameters) {
      res["RunningParameters"] = runningParameters ? boost::any(runningParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("ConfigParameters") != m.end() && !m["ConfigParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigParameters"].type()) {
        DescribeParametersResponseBodyConfigParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigParameters"]));
        configParameters = make_shared<DescribeParametersResponseBodyConfigParameters>(model1);
      }
    }
    if (m.find("RunningParameters") != m.end() && !m["RunningParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunningParameters"].type()) {
        DescribeParametersResponseBodyRunningParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunningParameters"]));
        runningParameters = make_shared<DescribeParametersResponseBodyRunningParameters>(model1);
      }
    }
  }


  virtual ~DescribeParametersResponseBody() = default;
};
class DescribeParametersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeParametersResponseBody> body{};

  DescribeParametersResponse() {}

  explicit DescribeParametersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeParametersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeParametersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeParametersResponse() = default;
};
class DescribeParameterTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> engine{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> category{};
  shared_ptr<string> regionId{};
  shared_ptr<string> DBInstanceId{};

  DescribeParameterTemplatesRequest() {}

  explicit DescribeParameterTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~DescribeParameterTemplatesRequest() = default;
};
class DescribeParameterTemplatesResponseBodyParametersTemplateRecord : public Darabonba::Model {
public:
  shared_ptr<string> checkingCode{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> parameterValue{};
  shared_ptr<string> forceModify{};
  shared_ptr<string> forceRestart{};
  shared_ptr<string> parameterDescription{};

  DescribeParameterTemplatesResponseBodyParametersTemplateRecord() {}

  explicit DescribeParameterTemplatesResponseBodyParametersTemplateRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkingCode) {
      res["CheckingCode"] = boost::any(*checkingCode);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterValue) {
      res["ParameterValue"] = boost::any(*parameterValue);
    }
    if (forceModify) {
      res["ForceModify"] = boost::any(*forceModify);
    }
    if (forceRestart) {
      res["ForceRestart"] = boost::any(*forceRestart);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckingCode") != m.end() && !m["CheckingCode"].empty()) {
      checkingCode = make_shared<string>(boost::any_cast<string>(m["CheckingCode"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterValue") != m.end() && !m["ParameterValue"].empty()) {
      parameterValue = make_shared<string>(boost::any_cast<string>(m["ParameterValue"]));
    }
    if (m.find("ForceModify") != m.end() && !m["ForceModify"].empty()) {
      forceModify = make_shared<string>(boost::any_cast<string>(m["ForceModify"]));
    }
    if (m.find("ForceRestart") != m.end() && !m["ForceRestart"].empty()) {
      forceRestart = make_shared<string>(boost::any_cast<string>(m["ForceRestart"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
  }


  virtual ~DescribeParameterTemplatesResponseBodyParametersTemplateRecord() = default;
};
class DescribeParameterTemplatesResponseBodyParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeParameterTemplatesResponseBodyParametersTemplateRecord>> templateRecord{};

  DescribeParameterTemplatesResponseBodyParameters() {}

  explicit DescribeParameterTemplatesResponseBodyParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateRecord) {
      vector<boost::any> temp1;
      for(auto item1:*templateRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateRecord") != m.end() && !m["TemplateRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateRecord"].type()) {
        vector<DescribeParameterTemplatesResponseBodyParametersTemplateRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeParameterTemplatesResponseBodyParametersTemplateRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateRecord = make_shared<vector<DescribeParameterTemplatesResponseBodyParametersTemplateRecord>>(expect1);
      }
    }
  }


  virtual ~DescribeParameterTemplatesResponseBodyParameters() = default;
};
class DescribeParameterTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> engine{};
  shared_ptr<string> parameterCount{};
  shared_ptr<string> engineVersion{};
  shared_ptr<DescribeParameterTemplatesResponseBodyParameters> parameters{};

  DescribeParameterTemplatesResponseBody() {}

  explicit DescribeParameterTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (parameterCount) {
      res["ParameterCount"] = boost::any(*parameterCount);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (parameters) {
      res["Parameters"] = parameters ? boost::any(parameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("ParameterCount") != m.end() && !m["ParameterCount"].empty()) {
      parameterCount = make_shared<string>(boost::any_cast<string>(m["ParameterCount"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Parameters"].type()) {
        DescribeParameterTemplatesResponseBodyParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Parameters"]));
        parameters = make_shared<DescribeParameterTemplatesResponseBodyParameters>(model1);
      }
    }
  }


  virtual ~DescribeParameterTemplatesResponseBody() = default;
};
class DescribeParameterTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeParameterTemplatesResponseBody> body{};

  DescribeParameterTemplatesResponse() {}

  explicit DescribeParameterTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeParameterTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeParameterTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeParameterTemplatesResponse() = default;
};
class DescribePriceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> engine{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<long> DBInstanceStorage{};
  shared_ptr<string> payType{};
  shared_ptr<string> zoneId{};
  shared_ptr<long> usedTime{};
  shared_ptr<string> timeType{};
  shared_ptr<long> quantity{};
  shared_ptr<long> instanceUsedType{};
  shared_ptr<string> orderType{};
  shared_ptr<string> DBInstanceStorageType{};
  shared_ptr<string> DBInstanceId{};

  DescribePriceRequest() {}

  explicit DescribePriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (DBInstanceStorage) {
      res["DBInstanceStorage"] = boost::any(*DBInstanceStorage);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    if (timeType) {
      res["TimeType"] = boost::any(*timeType);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (instanceUsedType) {
      res["InstanceUsedType"] = boost::any(*instanceUsedType);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (DBInstanceStorageType) {
      res["DBInstanceStorageType"] = boost::any(*DBInstanceStorageType);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("DBInstanceStorage") != m.end() && !m["DBInstanceStorage"].empty()) {
      DBInstanceStorage = make_shared<long>(boost::any_cast<long>(m["DBInstanceStorage"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<long>(boost::any_cast<long>(m["UsedTime"]));
    }
    if (m.find("TimeType") != m.end() && !m["TimeType"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["TimeType"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("InstanceUsedType") != m.end() && !m["InstanceUsedType"].empty()) {
      instanceUsedType = make_shared<long>(boost::any_cast<long>(m["InstanceUsedType"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("DBInstanceStorageType") != m.end() && !m["DBInstanceStorageType"].empty()) {
      DBInstanceStorageType = make_shared<string>(boost::any_cast<string>(m["DBInstanceStorageType"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~DescribePriceRequest() = default;
};
class DescribePriceResponseBodyPriceInfoCouponsCoupon : public Darabonba::Model {
public:
  shared_ptr<string> isSelected{};
  shared_ptr<string> couponNo{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};

  DescribePriceResponseBodyPriceInfoCouponsCoupon() {}

  explicit DescribePriceResponseBodyPriceInfoCouponsCoupon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSelected) {
      res["IsSelected"] = boost::any(*isSelected);
    }
    if (couponNo) {
      res["CouponNo"] = boost::any(*couponNo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSelected") != m.end() && !m["IsSelected"].empty()) {
      isSelected = make_shared<string>(boost::any_cast<string>(m["IsSelected"]));
    }
    if (m.find("CouponNo") != m.end() && !m["CouponNo"].empty()) {
      couponNo = make_shared<string>(boost::any_cast<string>(m["CouponNo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoCouponsCoupon() = default;
};
class DescribePriceResponseBodyPriceInfoCoupons : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePriceResponseBodyPriceInfoCouponsCoupon>> coupon{};

  DescribePriceResponseBodyPriceInfoCoupons() {}

  explicit DescribePriceResponseBodyPriceInfoCoupons(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coupon) {
      vector<boost::any> temp1;
      for(auto item1:*coupon){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Coupon"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Coupon") != m.end() && !m["Coupon"].empty()) {
      if (typeid(vector<boost::any>) == m["Coupon"].type()) {
        vector<DescribePriceResponseBodyPriceInfoCouponsCoupon> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Coupon"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceResponseBodyPriceInfoCouponsCoupon model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coupon = make_shared<vector<DescribePriceResponseBodyPriceInfoCouponsCoupon>>(expect1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoCoupons() = default;
};
class DescribePriceResponseBodyPriceInfoRuleIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ruleId{};

  DescribePriceResponseBodyPriceInfoRuleIds() {}

  explicit DescribePriceResponseBodyPriceInfoRuleIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoRuleIds() = default;
};
class DescribePriceResponseBodyPriceInfoActivityInfo : public Darabonba::Model {
public:
  shared_ptr<string> checkErrMsg{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> success{};

  DescribePriceResponseBodyPriceInfoActivityInfo() {}

  explicit DescribePriceResponseBodyPriceInfoActivityInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkErrMsg) {
      res["CheckErrMsg"] = boost::any(*checkErrMsg);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckErrMsg") != m.end() && !m["CheckErrMsg"].empty()) {
      checkErrMsg = make_shared<string>(boost::any_cast<string>(m["CheckErrMsg"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoActivityInfo() = default;
};
class DescribePriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<double> originalPrice{};
  shared_ptr<double> discountPrice{};
  shared_ptr<string> currency{};
  shared_ptr<double> tradePrice{};
  shared_ptr<DescribePriceResponseBodyPriceInfoCoupons> coupons{};
  shared_ptr<DescribePriceResponseBodyPriceInfoRuleIds> ruleIds{};
  shared_ptr<DescribePriceResponseBodyPriceInfoActivityInfo> activityInfo{};

  DescribePriceResponseBodyPriceInfo() {}

  explicit DescribePriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    if (coupons) {
      res["Coupons"] = coupons ? boost::any(coupons->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ruleIds) {
      res["RuleIds"] = ruleIds ? boost::any(ruleIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (activityInfo) {
      res["ActivityInfo"] = activityInfo ? boost::any(activityInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
    if (m.find("Coupons") != m.end() && !m["Coupons"].empty()) {
      if (typeid(map<string, boost::any>) == m["Coupons"].type()) {
        DescribePriceResponseBodyPriceInfoCoupons model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Coupons"]));
        coupons = make_shared<DescribePriceResponseBodyPriceInfoCoupons>(model1);
      }
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleIds"].type()) {
        DescribePriceResponseBodyPriceInfoRuleIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleIds"]));
        ruleIds = make_shared<DescribePriceResponseBodyPriceInfoRuleIds>(model1);
      }
    }
    if (m.find("ActivityInfo") != m.end() && !m["ActivityInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivityInfo"].type()) {
        DescribePriceResponseBodyPriceInfoActivityInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivityInfo"]));
        activityInfo = make_shared<DescribePriceResponseBodyPriceInfoActivityInfo>(model1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfo() = default;
};
class DescribePriceResponseBodyRulesRule : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<long> ruleId{};

  DescribePriceResponseBodyRulesRule() {}

  explicit DescribePriceResponseBodyRulesRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DescribePriceResponseBodyRulesRule() = default;
};
class DescribePriceResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePriceResponseBodyRulesRule>> rule{};

  DescribePriceResponseBodyRules() {}

  explicit DescribePriceResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<DescribePriceResponseBodyRulesRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceResponseBodyRulesRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<DescribePriceResponseBodyRulesRule>>(expect1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyRules() = default;
};
class DescribePriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePriceResponseBodyPriceInfo> priceInfo{};
  shared_ptr<DescribePriceResponseBodyRules> rules{};

  DescribePriceResponseBody() {}

  explicit DescribePriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      res["Rules"] = rules ? boost::any(rules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribePriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribePriceResponseBodyPriceInfo>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rules"].type()) {
        DescribePriceResponseBodyRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rules"]));
        rules = make_shared<DescribePriceResponseBodyRules>(model1);
      }
    }
  }


  virtual ~DescribePriceResponseBody() = default;
};
class DescribePriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePriceResponseBody> body{};

  DescribePriceResponse() {}

  explicit DescribePriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePriceResponse() = default;
};
class DescribeRdsResourceSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceNiche{};

  DescribeRdsResourceSettingsRequest() {}

  explicit DescribeRdsResourceSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceNiche) {
      res["ResourceNiche"] = boost::any(*resourceNiche);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceNiche") != m.end() && !m["ResourceNiche"].empty()) {
      resourceNiche = make_shared<string>(boost::any_cast<string>(m["ResourceNiche"]));
    }
  }


  virtual ~DescribeRdsResourceSettingsRequest() = default;
};
class DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting : public Darabonba::Model {
public:
  shared_ptr<string> poppedUpButtonType{};
  shared_ptr<string> noticeBarContent{};
  shared_ptr<string> endDate{};
  shared_ptr<string> poppedUpContent{};
  shared_ptr<string> startDate{};
  shared_ptr<string> poppedUpButtonText{};
  shared_ptr<string> isTop{};
  shared_ptr<string> resourceNiche{};
  shared_ptr<string> poppedUpButtonUrl{};

  DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting() {}

  explicit DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (poppedUpButtonType) {
      res["PoppedUpButtonType"] = boost::any(*poppedUpButtonType);
    }
    if (noticeBarContent) {
      res["NoticeBarContent"] = boost::any(*noticeBarContent);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (poppedUpContent) {
      res["PoppedUpContent"] = boost::any(*poppedUpContent);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (poppedUpButtonText) {
      res["PoppedUpButtonText"] = boost::any(*poppedUpButtonText);
    }
    if (isTop) {
      res["IsTop"] = boost::any(*isTop);
    }
    if (resourceNiche) {
      res["ResourceNiche"] = boost::any(*resourceNiche);
    }
    if (poppedUpButtonUrl) {
      res["PoppedUpButtonUrl"] = boost::any(*poppedUpButtonUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PoppedUpButtonType") != m.end() && !m["PoppedUpButtonType"].empty()) {
      poppedUpButtonType = make_shared<string>(boost::any_cast<string>(m["PoppedUpButtonType"]));
    }
    if (m.find("NoticeBarContent") != m.end() && !m["NoticeBarContent"].empty()) {
      noticeBarContent = make_shared<string>(boost::any_cast<string>(m["NoticeBarContent"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("PoppedUpContent") != m.end() && !m["PoppedUpContent"].empty()) {
      poppedUpContent = make_shared<string>(boost::any_cast<string>(m["PoppedUpContent"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("PoppedUpButtonText") != m.end() && !m["PoppedUpButtonText"].empty()) {
      poppedUpButtonText = make_shared<string>(boost::any_cast<string>(m["PoppedUpButtonText"]));
    }
    if (m.find("IsTop") != m.end() && !m["IsTop"].empty()) {
      isTop = make_shared<string>(boost::any_cast<string>(m["IsTop"]));
    }
    if (m.find("ResourceNiche") != m.end() && !m["ResourceNiche"].empty()) {
      resourceNiche = make_shared<string>(boost::any_cast<string>(m["ResourceNiche"]));
    }
    if (m.find("PoppedUpButtonUrl") != m.end() && !m["PoppedUpButtonUrl"].empty()) {
      poppedUpButtonUrl = make_shared<string>(boost::any_cast<string>(m["PoppedUpButtonUrl"]));
    }
  }


  virtual ~DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting() = default;
};
class DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting>> rdsInstanceResourceSetting{};

  DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings() {}

  explicit DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rdsInstanceResourceSetting) {
      vector<boost::any> temp1;
      for(auto item1:*rdsInstanceResourceSetting){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RdsInstanceResourceSetting"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RdsInstanceResourceSetting") != m.end() && !m["RdsInstanceResourceSetting"].empty()) {
      if (typeid(vector<boost::any>) == m["RdsInstanceResourceSetting"].type()) {
        vector<DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RdsInstanceResourceSetting"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rdsInstanceResourceSetting = make_shared<vector<DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting>>(expect1);
      }
    }
  }


  virtual ~DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings() = default;
};
class DescribeRdsResourceSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings> rdsInstanceResourceSettings{};

  DescribeRdsResourceSettingsResponseBody() {}

  explicit DescribeRdsResourceSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rdsInstanceResourceSettings) {
      res["RdsInstanceResourceSettings"] = rdsInstanceResourceSettings ? boost::any(rdsInstanceResourceSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RdsInstanceResourceSettings") != m.end() && !m["RdsInstanceResourceSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["RdsInstanceResourceSettings"].type()) {
        DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RdsInstanceResourceSettings"]));
        rdsInstanceResourceSettings = make_shared<DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings>(model1);
      }
    }
  }


  virtual ~DescribeRdsResourceSettingsResponseBody() = default;
};
class DescribeRdsResourceSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRdsResourceSettingsResponseBody> body{};

  DescribeRdsResourceSettingsResponse() {}

  explicit DescribeRdsResourceSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRdsResourceSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRdsResourceSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRdsResourceSettingsResponse() = default;
};
class DescribeReadDBInstanceDelayRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> readInstanceId{};

  DescribeReadDBInstanceDelayRequest() {}

  explicit DescribeReadDBInstanceDelayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (readInstanceId) {
      res["ReadInstanceId"] = boost::any(*readInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ReadInstanceId") != m.end() && !m["ReadInstanceId"].empty()) {
      readInstanceId = make_shared<string>(boost::any_cast<string>(m["ReadInstanceId"]));
    }
  }


  virtual ~DescribeReadDBInstanceDelayRequest() = default;
};
class DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay : public Darabonba::Model {
public:
  shared_ptr<string> writeLatency{};
  shared_ptr<string> flushLatency{};
  shared_ptr<string> readDBInstanceName{};
  shared_ptr<string> writeLag{};
  shared_ptr<string> flushLag{};
  shared_ptr<string> sendLatency{};
  shared_ptr<string> replayLag{};
  shared_ptr<string> replayLatency{};

  DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay() {}

  explicit DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (writeLatency) {
      res["WriteLatency"] = boost::any(*writeLatency);
    }
    if (flushLatency) {
      res["FlushLatency"] = boost::any(*flushLatency);
    }
    if (readDBInstanceName) {
      res["ReadDBInstanceName"] = boost::any(*readDBInstanceName);
    }
    if (writeLag) {
      res["WriteLag"] = boost::any(*writeLag);
    }
    if (flushLag) {
      res["FlushLag"] = boost::any(*flushLag);
    }
    if (sendLatency) {
      res["SendLatency"] = boost::any(*sendLatency);
    }
    if (replayLag) {
      res["ReplayLag"] = boost::any(*replayLag);
    }
    if (replayLatency) {
      res["ReplayLatency"] = boost::any(*replayLatency);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WriteLatency") != m.end() && !m["WriteLatency"].empty()) {
      writeLatency = make_shared<string>(boost::any_cast<string>(m["WriteLatency"]));
    }
    if (m.find("FlushLatency") != m.end() && !m["FlushLatency"].empty()) {
      flushLatency = make_shared<string>(boost::any_cast<string>(m["FlushLatency"]));
    }
    if (m.find("ReadDBInstanceName") != m.end() && !m["ReadDBInstanceName"].empty()) {
      readDBInstanceName = make_shared<string>(boost::any_cast<string>(m["ReadDBInstanceName"]));
    }
    if (m.find("WriteLag") != m.end() && !m["WriteLag"].empty()) {
      writeLag = make_shared<string>(boost::any_cast<string>(m["WriteLag"]));
    }
    if (m.find("FlushLag") != m.end() && !m["FlushLag"].empty()) {
      flushLag = make_shared<string>(boost::any_cast<string>(m["FlushLag"]));
    }
    if (m.find("SendLatency") != m.end() && !m["SendLatency"].empty()) {
      sendLatency = make_shared<string>(boost::any_cast<string>(m["SendLatency"]));
    }
    if (m.find("ReplayLag") != m.end() && !m["ReplayLag"].empty()) {
      replayLag = make_shared<string>(boost::any_cast<string>(m["ReplayLag"]));
    }
    if (m.find("ReplayLatency") != m.end() && !m["ReplayLatency"].empty()) {
      replayLatency = make_shared<string>(boost::any_cast<string>(m["ReplayLatency"]));
    }
  }


  virtual ~DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay() = default;
};
class DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay>> readonlyInstanceDelay{};

  DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay() {}

  explicit DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (readonlyInstanceDelay) {
      vector<boost::any> temp1;
      for(auto item1:*readonlyInstanceDelay){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReadonlyInstanceDelay"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReadonlyInstanceDelay") != m.end() && !m["ReadonlyInstanceDelay"].empty()) {
      if (typeid(vector<boost::any>) == m["ReadonlyInstanceDelay"].type()) {
        vector<DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReadonlyInstanceDelay"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        readonlyInstanceDelay = make_shared<vector<DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay>>(expect1);
      }
    }
  }


  virtual ~DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay() = default;
};
class DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> readDelayTime{};

  DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes() {}

  explicit DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (readDelayTime) {
      res["ReadDelayTime"] = boost::any(*readDelayTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReadDelayTime") != m.end() && !m["ReadDelayTime"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReadDelayTime"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReadDelayTime"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      readDelayTime = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes() = default;
};
class DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames : public Darabonba::Model {
public:
  shared_ptr<vector<string>> readDBInstanceName{};

  DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames() {}

  explicit DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (readDBInstanceName) {
      res["ReadDBInstanceName"] = boost::any(*readDBInstanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReadDBInstanceName") != m.end() && !m["ReadDBInstanceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReadDBInstanceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReadDBInstanceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      readDBInstanceName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames() = default;
};
class DescribeReadDBInstanceDelayResponseBodyItemsItems : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay> readonlyInstanceDelay{};
  shared_ptr<DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes> readDelayTimes{};
  shared_ptr<DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames> readDBInstanceNames{};

  DescribeReadDBInstanceDelayResponseBodyItemsItems() {}

  explicit DescribeReadDBInstanceDelayResponseBodyItemsItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (readonlyInstanceDelay) {
      res["ReadonlyInstanceDelay"] = readonlyInstanceDelay ? boost::any(readonlyInstanceDelay->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readDelayTimes) {
      res["ReadDelayTimes"] = readDelayTimes ? boost::any(readDelayTimes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (readDBInstanceNames) {
      res["ReadDBInstanceNames"] = readDBInstanceNames ? boost::any(readDBInstanceNames->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ReadonlyInstanceDelay") != m.end() && !m["ReadonlyInstanceDelay"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadonlyInstanceDelay"].type()) {
        DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadonlyInstanceDelay"]));
        readonlyInstanceDelay = make_shared<DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay>(model1);
      }
    }
    if (m.find("ReadDelayTimes") != m.end() && !m["ReadDelayTimes"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadDelayTimes"].type()) {
        DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadDelayTimes"]));
        readDelayTimes = make_shared<DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes>(model1);
      }
    }
    if (m.find("ReadDBInstanceNames") != m.end() && !m["ReadDBInstanceNames"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadDBInstanceNames"].type()) {
        DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadDBInstanceNames"]));
        readDBInstanceNames = make_shared<DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames>(model1);
      }
    }
  }


  virtual ~DescribeReadDBInstanceDelayResponseBodyItemsItems() = default;
};
class DescribeReadDBInstanceDelayResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReadDBInstanceDelayResponseBodyItemsItems>> items{};

  DescribeReadDBInstanceDelayResponseBodyItems() {}

  explicit DescribeReadDBInstanceDelayResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<DescribeReadDBInstanceDelayResponseBodyItemsItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReadDBInstanceDelayResponseBodyItemsItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<DescribeReadDBInstanceDelayResponseBodyItemsItems>>(expect1);
      }
    }
  }


  virtual ~DescribeReadDBInstanceDelayResponseBodyItems() = default;
};
class DescribeReadDBInstanceDelayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> delayTime{};
  shared_ptr<string> readDBInstanceId{};
  shared_ptr<DescribeReadDBInstanceDelayResponseBodyItems> items{};

  DescribeReadDBInstanceDelayResponseBody() {}

  explicit DescribeReadDBInstanceDelayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (delayTime) {
      res["DelayTime"] = boost::any(*delayTime);
    }
    if (readDBInstanceId) {
      res["ReadDBInstanceId"] = boost::any(*readDBInstanceId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DelayTime") != m.end() && !m["DelayTime"].empty()) {
      delayTime = make_shared<long>(boost::any_cast<long>(m["DelayTime"]));
    }
    if (m.find("ReadDBInstanceId") != m.end() && !m["ReadDBInstanceId"].empty()) {
      readDBInstanceId = make_shared<string>(boost::any_cast<string>(m["ReadDBInstanceId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeReadDBInstanceDelayResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeReadDBInstanceDelayResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeReadDBInstanceDelayResponseBody() = default;
};
class DescribeReadDBInstanceDelayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeReadDBInstanceDelayResponseBody> body{};

  DescribeReadDBInstanceDelayResponse() {}

  explicit DescribeReadDBInstanceDelayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeReadDBInstanceDelayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeReadDBInstanceDelayResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeReadDBInstanceDelayResponse() = default;
};
class DescribeRegionInfosRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceUsedType{};
  shared_ptr<string> specifyCount{};
  shared_ptr<string> hostType{};

  DescribeRegionInfosRequest() {}

  explicit DescribeRegionInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceUsedType) {
      res["InstanceUsedType"] = boost::any(*instanceUsedType);
    }
    if (specifyCount) {
      res["SpecifyCount"] = boost::any(*specifyCount);
    }
    if (hostType) {
      res["HostType"] = boost::any(*hostType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceUsedType") != m.end() && !m["InstanceUsedType"].empty()) {
      instanceUsedType = make_shared<string>(boost::any_cast<string>(m["InstanceUsedType"]));
    }
    if (m.find("SpecifyCount") != m.end() && !m["SpecifyCount"].empty()) {
      specifyCount = make_shared<string>(boost::any_cast<string>(m["SpecifyCount"]));
    }
    if (m.find("HostType") != m.end() && !m["HostType"].empty()) {
      hostType = make_shared<string>(boost::any_cast<string>(m["HostType"]));
    }
  }


  virtual ~DescribeRegionInfosRequest() = default;
};
class DescribeRegionInfosResponseBodyRegionsRDSRegion : public Darabonba::Model {
public:
  shared_ptr<string> cnLocalName{};
  shared_ptr<string> regionName{};
  shared_ptr<string> avz{};
  shared_ptr<string> avzStatus{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> category{};
  shared_ptr<string> enLocalName{};
  shared_ptr<string> regionId{};

  DescribeRegionInfosResponseBodyRegionsRDSRegion() {}

  explicit DescribeRegionInfosResponseBodyRegionsRDSRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cnLocalName) {
      res["CnLocalName"] = boost::any(*cnLocalName);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (avz) {
      res["Avz"] = boost::any(*avz);
    }
    if (avzStatus) {
      res["AvzStatus"] = boost::any(*avzStatus);
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (enLocalName) {
      res["EnLocalName"] = boost::any(*enLocalName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CnLocalName") != m.end() && !m["CnLocalName"].empty()) {
      cnLocalName = make_shared<string>(boost::any_cast<string>(m["CnLocalName"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("Avz") != m.end() && !m["Avz"].empty()) {
      avz = make_shared<string>(boost::any_cast<string>(m["Avz"]));
    }
    if (m.find("AvzStatus") != m.end() && !m["AvzStatus"].empty()) {
      avzStatus = make_shared<string>(boost::any_cast<string>(m["AvzStatus"]));
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("EnLocalName") != m.end() && !m["EnLocalName"].empty()) {
      enLocalName = make_shared<string>(boost::any_cast<string>(m["EnLocalName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionInfosResponseBodyRegionsRDSRegion() = default;
};
class DescribeRegionInfosResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionInfosResponseBodyRegionsRDSRegion>> RDSRegion{};

  DescribeRegionInfosResponseBodyRegions() {}

  explicit DescribeRegionInfosResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (RDSRegion) {
      vector<boost::any> temp1;
      for(auto item1:*RDSRegion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RDSRegion"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RDSRegion") != m.end() && !m["RDSRegion"].empty()) {
      if (typeid(vector<boost::any>) == m["RDSRegion"].type()) {
        vector<DescribeRegionInfosResponseBodyRegionsRDSRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RDSRegion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionInfosResponseBodyRegionsRDSRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        RDSRegion = make_shared<vector<DescribeRegionInfosResponseBodyRegionsRDSRegion>>(expect1);
      }
    }
  }


  virtual ~DescribeRegionInfosResponseBodyRegions() = default;
};
class DescribeRegionInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRegionInfosResponseBodyRegions> regions{};

  DescribeRegionInfosResponseBody() {}

  explicit DescribeRegionInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeRegionInfosResponseBodyRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeRegionInfosResponseBodyRegions>(model1);
      }
    }
  }


  virtual ~DescribeRegionInfosResponseBody() = default;
};
class DescribeRegionInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRegionInfosResponseBody> body{};

  DescribeRegionInfosResponse() {}

  explicit DescribeRegionInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionInfosResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionInfosResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> acceptLanguage{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBodyRegionsRDSRegion : public Darabonba::Model {
public:
  shared_ptr<string> zoneId{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> localName{};
  shared_ptr<string> regionId{};

  DescribeRegionsResponseBodyRegionsRDSRegion() {}

  explicit DescribeRegionsResponseBodyRegionsRDSRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyRegionsRDSRegion() = default;
};
class DescribeRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionsResponseBodyRegionsRDSRegion>> RDSRegion{};

  DescribeRegionsResponseBodyRegions() {}

  explicit DescribeRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (RDSRegion) {
      vector<boost::any> temp1;
      for(auto item1:*RDSRegion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RDSRegion"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RDSRegion") != m.end() && !m["RDSRegion"].empty()) {
      if (typeid(vector<boost::any>) == m["RDSRegion"].type()) {
        vector<DescribeRegionsResponseBodyRegionsRDSRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RDSRegion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyRegionsRDSRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        RDSRegion = make_shared<vector<DescribeRegionsResponseBodyRegionsRDSRegion>>(expect1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBodyRegions() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRegionsResponseBodyRegions> regions{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeRegionsResponseBodyRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeRegionsResponseBodyRegions>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeRenewalPriceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> payType{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<long> usedTime{};
  shared_ptr<string> timeType{};
  shared_ptr<long> quantity{};
  shared_ptr<string> orderType{};
  shared_ptr<string> businessInfo{};

  DescribeRenewalPriceRequest() {}

  explicit DescribeRenewalPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    if (timeType) {
      res["TimeType"] = boost::any(*timeType);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (businessInfo) {
      res["BusinessInfo"] = boost::any(*businessInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<long>(boost::any_cast<long>(m["UsedTime"]));
    }
    if (m.find("TimeType") != m.end() && !m["TimeType"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["TimeType"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("BusinessInfo") != m.end() && !m["BusinessInfo"].empty()) {
      businessInfo = make_shared<string>(boost::any_cast<string>(m["BusinessInfo"]));
    }
  }


  virtual ~DescribeRenewalPriceRequest() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon : public Darabonba::Model {
public:
  shared_ptr<string> isSelected{};
  shared_ptr<string> couponNo{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};

  DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSelected) {
      res["IsSelected"] = boost::any(*isSelected);
    }
    if (couponNo) {
      res["CouponNo"] = boost::any(*couponNo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSelected") != m.end() && !m["IsSelected"].empty()) {
      isSelected = make_shared<string>(boost::any_cast<string>(m["IsSelected"]));
    }
    if (m.find("CouponNo") != m.end() && !m["CouponNo"].empty()) {
      couponNo = make_shared<string>(boost::any_cast<string>(m["CouponNo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoCoupons : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon>> coupon{};

  DescribeRenewalPriceResponseBodyPriceInfoCoupons() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoCoupons(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coupon) {
      vector<boost::any> temp1;
      for(auto item1:*coupon){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Coupon"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Coupon") != m.end() && !m["Coupon"].empty()) {
      if (typeid(vector<boost::any>) == m["Coupon"].type()) {
        vector<DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Coupon"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coupon = make_shared<vector<DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon>>(expect1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoCoupons() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoRuleIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ruleId{};

  DescribeRenewalPriceResponseBodyPriceInfoRuleIds() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoRuleIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoRuleIds() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfoActivityInfo : public Darabonba::Model {
public:
  shared_ptr<string> checkErrMsg{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> success{};

  DescribeRenewalPriceResponseBodyPriceInfoActivityInfo() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfoActivityInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkErrMsg) {
      res["CheckErrMsg"] = boost::any(*checkErrMsg);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckErrMsg") != m.end() && !m["CheckErrMsg"].empty()) {
      checkErrMsg = make_shared<string>(boost::any_cast<string>(m["CheckErrMsg"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfoActivityInfo() = default;
};
class DescribeRenewalPriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<double> originalPrice{};
  shared_ptr<double> discountPrice{};
  shared_ptr<string> currency{};
  shared_ptr<double> tradePrice{};
  shared_ptr<DescribeRenewalPriceResponseBodyPriceInfoCoupons> coupons{};
  shared_ptr<DescribeRenewalPriceResponseBodyPriceInfoRuleIds> ruleIds{};
  shared_ptr<DescribeRenewalPriceResponseBodyPriceInfoActivityInfo> activityInfo{};

  DescribeRenewalPriceResponseBodyPriceInfo() {}

  explicit DescribeRenewalPriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    if (coupons) {
      res["Coupons"] = coupons ? boost::any(coupons->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ruleIds) {
      res["RuleIds"] = ruleIds ? boost::any(ruleIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (activityInfo) {
      res["ActivityInfo"] = activityInfo ? boost::any(activityInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
    if (m.find("Coupons") != m.end() && !m["Coupons"].empty()) {
      if (typeid(map<string, boost::any>) == m["Coupons"].type()) {
        DescribeRenewalPriceResponseBodyPriceInfoCoupons model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Coupons"]));
        coupons = make_shared<DescribeRenewalPriceResponseBodyPriceInfoCoupons>(model1);
      }
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleIds"].type()) {
        DescribeRenewalPriceResponseBodyPriceInfoRuleIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleIds"]));
        ruleIds = make_shared<DescribeRenewalPriceResponseBodyPriceInfoRuleIds>(model1);
      }
    }
    if (m.find("ActivityInfo") != m.end() && !m["ActivityInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivityInfo"].type()) {
        DescribeRenewalPriceResponseBodyPriceInfoActivityInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivityInfo"]));
        activityInfo = make_shared<DescribeRenewalPriceResponseBodyPriceInfoActivityInfo>(model1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyPriceInfo() = default;
};
class DescribeRenewalPriceResponseBodyRulesRule : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<long> ruleId{};

  DescribeRenewalPriceResponseBodyRulesRule() {}

  explicit DescribeRenewalPriceResponseBodyRulesRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyRulesRule() = default;
};
class DescribeRenewalPriceResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRenewalPriceResponseBodyRulesRule>> rule{};

  DescribeRenewalPriceResponseBodyRules() {}

  explicit DescribeRenewalPriceResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<DescribeRenewalPriceResponseBodyRulesRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenewalPriceResponseBodyRulesRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<DescribeRenewalPriceResponseBodyRulesRule>>(expect1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponseBodyRules() = default;
};
class DescribeRenewalPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRenewalPriceResponseBodyPriceInfo> priceInfo{};
  shared_ptr<DescribeRenewalPriceResponseBodyRules> rules{};

  DescribeRenewalPriceResponseBody() {}

  explicit DescribeRenewalPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      res["Rules"] = rules ? boost::any(rules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribeRenewalPriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribeRenewalPriceResponseBodyPriceInfo>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rules"].type()) {
        DescribeRenewalPriceResponseBodyRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rules"]));
        rules = make_shared<DescribeRenewalPriceResponseBodyRules>(model1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponseBody() = default;
};
class DescribeRenewalPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRenewalPriceResponseBody> body{};

  DescribeRenewalPriceResponse() {}

  explicit DescribeRenewalPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRenewalPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRenewalPriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRenewalPriceResponse() = default;
};
class DescribeResourceUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> ownerAccount{};

  DescribeResourceUsageRequest() {}

  explicit DescribeResourceUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeResourceUsageRequest() = default;
};
class DescribeResourceUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> backupOssDataSize{};
  shared_ptr<long> diskUsed{};
  shared_ptr<long> archiveBackupSize{};
  shared_ptr<long> backupOssLogSize{};
  shared_ptr<long> backupLogSize{};
  shared_ptr<long> backupDataSize{};
  shared_ptr<long> coldBackupSize{};
  shared_ptr<long> dataSize{};
  shared_ptr<long> paidBackupSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> logSize{};
  shared_ptr<long> backupSize{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> engine{};
  shared_ptr<long> SQLSize{};

  DescribeResourceUsageResponseBody() {}

  explicit DescribeResourceUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupOssDataSize) {
      res["BackupOssDataSize"] = boost::any(*backupOssDataSize);
    }
    if (diskUsed) {
      res["DiskUsed"] = boost::any(*diskUsed);
    }
    if (archiveBackupSize) {
      res["ArchiveBackupSize"] = boost::any(*archiveBackupSize);
    }
    if (backupOssLogSize) {
      res["BackupOssLogSize"] = boost::any(*backupOssLogSize);
    }
    if (backupLogSize) {
      res["BackupLogSize"] = boost::any(*backupLogSize);
    }
    if (backupDataSize) {
      res["BackupDataSize"] = boost::any(*backupDataSize);
    }
    if (coldBackupSize) {
      res["ColdBackupSize"] = boost::any(*coldBackupSize);
    }
    if (dataSize) {
      res["DataSize"] = boost::any(*dataSize);
    }
    if (paidBackupSize) {
      res["PaidBackupSize"] = boost::any(*paidBackupSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (backupSize) {
      res["BackupSize"] = boost::any(*backupSize);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (SQLSize) {
      res["SQLSize"] = boost::any(*SQLSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupOssDataSize") != m.end() && !m["BackupOssDataSize"].empty()) {
      backupOssDataSize = make_shared<long>(boost::any_cast<long>(m["BackupOssDataSize"]));
    }
    if (m.find("DiskUsed") != m.end() && !m["DiskUsed"].empty()) {
      diskUsed = make_shared<long>(boost::any_cast<long>(m["DiskUsed"]));
    }
    if (m.find("ArchiveBackupSize") != m.end() && !m["ArchiveBackupSize"].empty()) {
      archiveBackupSize = make_shared<long>(boost::any_cast<long>(m["ArchiveBackupSize"]));
    }
    if (m.find("BackupOssLogSize") != m.end() && !m["BackupOssLogSize"].empty()) {
      backupOssLogSize = make_shared<long>(boost::any_cast<long>(m["BackupOssLogSize"]));
    }
    if (m.find("BackupLogSize") != m.end() && !m["BackupLogSize"].empty()) {
      backupLogSize = make_shared<long>(boost::any_cast<long>(m["BackupLogSize"]));
    }
    if (m.find("BackupDataSize") != m.end() && !m["BackupDataSize"].empty()) {
      backupDataSize = make_shared<long>(boost::any_cast<long>(m["BackupDataSize"]));
    }
    if (m.find("ColdBackupSize") != m.end() && !m["ColdBackupSize"].empty()) {
      coldBackupSize = make_shared<long>(boost::any_cast<long>(m["ColdBackupSize"]));
    }
    if (m.find("DataSize") != m.end() && !m["DataSize"].empty()) {
      dataSize = make_shared<long>(boost::any_cast<long>(m["DataSize"]));
    }
    if (m.find("PaidBackupSize") != m.end() && !m["PaidBackupSize"].empty()) {
      paidBackupSize = make_shared<long>(boost::any_cast<long>(m["PaidBackupSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("BackupSize") != m.end() && !m["BackupSize"].empty()) {
      backupSize = make_shared<long>(boost::any_cast<long>(m["BackupSize"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("SQLSize") != m.end() && !m["SQLSize"].empty()) {
      SQLSize = make_shared<long>(boost::any_cast<long>(m["SQLSize"]));
    }
  }


  virtual ~DescribeResourceUsageResponseBody() = default;
};
class DescribeResourceUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeResourceUsageResponseBody> body{};

  DescribeResourceUsageResponse() {}

  explicit DescribeResourceUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceUsageResponse() = default;
};
class DescribeSecurityGroupConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};

  DescribeSecurityGroupConfigurationRequest() {}

  explicit DescribeSecurityGroupConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~DescribeSecurityGroupConfigurationRequest() = default;
};
class DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation : public Darabonba::Model {
public:
  shared_ptr<string> networkType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> regionId{};

  DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation() {}

  explicit DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation() = default;
};
class DescribeSecurityGroupConfigurationResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation>> ecsSecurityGroupRelation{};

  DescribeSecurityGroupConfigurationResponseBodyItems() {}

  explicit DescribeSecurityGroupConfigurationResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsSecurityGroupRelation) {
      vector<boost::any> temp1;
      for(auto item1:*ecsSecurityGroupRelation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcsSecurityGroupRelation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsSecurityGroupRelation") != m.end() && !m["EcsSecurityGroupRelation"].empty()) {
      if (typeid(vector<boost::any>) == m["EcsSecurityGroupRelation"].type()) {
        vector<DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcsSecurityGroupRelation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecsSecurityGroupRelation = make_shared<vector<DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityGroupConfigurationResponseBodyItems() = default;
};
class DescribeSecurityGroupConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceName{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSecurityGroupConfigurationResponseBodyItems> items{};

  DescribeSecurityGroupConfigurationResponseBody() {}

  explicit DescribeSecurityGroupConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeSecurityGroupConfigurationResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeSecurityGroupConfigurationResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupConfigurationResponseBody() = default;
};
class DescribeSecurityGroupConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSecurityGroupConfigurationResponseBody> body{};

  DescribeSecurityGroupConfigurationResponse() {}

  explicit DescribeSecurityGroupConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityGroupConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityGroupConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupConfigurationResponse() = default;
};
class DescribeSlowLogRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> SQLHASH{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> DBName{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> ownerAccount{};

  DescribeSlowLogRecordsRequest() {}

  explicit DescribeSlowLogRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (SQLHASH) {
      res["SQLHASH"] = boost::any(*SQLHASH);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("SQLHASH") != m.end() && !m["SQLHASH"].empty()) {
      SQLHASH = make_shared<string>(boost::any_cast<string>(m["SQLHASH"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeSlowLogRecordsRequest() = default;
};
class DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord : public Darabonba::Model {
public:
  shared_ptr<string> hostAddress{};
  shared_ptr<long> rowsAffectedCount{};
  shared_ptr<long> queryTimes{};
  shared_ptr<string> SQLText{};
  shared_ptr<long> cpuTime{};
  shared_ptr<long> queryTimeMS{};
  shared_ptr<string> applicationName{};
  shared_ptr<long> lockTimes{};
  shared_ptr<string> executionStartTime{};
  shared_ptr<long> logicalIORead{};
  shared_ptr<long> writeIOCount{};
  shared_ptr<long> physicalIORead{};
  shared_ptr<long> returnRowCounts{};
  shared_ptr<long> parseRowCounts{};
  shared_ptr<string> DBName{};
  shared_ptr<string> clientHostName{};
  shared_ptr<string> userName{};
  shared_ptr<long> lastRowsAffectedCount{};

  DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord() {}

  explicit DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAddress) {
      res["HostAddress"] = boost::any(*hostAddress);
    }
    if (rowsAffectedCount) {
      res["RowsAffectedCount"] = boost::any(*rowsAffectedCount);
    }
    if (queryTimes) {
      res["QueryTimes"] = boost::any(*queryTimes);
    }
    if (SQLText) {
      res["SQLText"] = boost::any(*SQLText);
    }
    if (cpuTime) {
      res["CpuTime"] = boost::any(*cpuTime);
    }
    if (queryTimeMS) {
      res["QueryTimeMS"] = boost::any(*queryTimeMS);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (lockTimes) {
      res["LockTimes"] = boost::any(*lockTimes);
    }
    if (executionStartTime) {
      res["ExecutionStartTime"] = boost::any(*executionStartTime);
    }
    if (logicalIORead) {
      res["LogicalIORead"] = boost::any(*logicalIORead);
    }
    if (writeIOCount) {
      res["WriteIOCount"] = boost::any(*writeIOCount);
    }
    if (physicalIORead) {
      res["PhysicalIORead"] = boost::any(*physicalIORead);
    }
    if (returnRowCounts) {
      res["ReturnRowCounts"] = boost::any(*returnRowCounts);
    }
    if (parseRowCounts) {
      res["ParseRowCounts"] = boost::any(*parseRowCounts);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (clientHostName) {
      res["ClientHostName"] = boost::any(*clientHostName);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (lastRowsAffectedCount) {
      res["LastRowsAffectedCount"] = boost::any(*lastRowsAffectedCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAddress") != m.end() && !m["HostAddress"].empty()) {
      hostAddress = make_shared<string>(boost::any_cast<string>(m["HostAddress"]));
    }
    if (m.find("RowsAffectedCount") != m.end() && !m["RowsAffectedCount"].empty()) {
      rowsAffectedCount = make_shared<long>(boost::any_cast<long>(m["RowsAffectedCount"]));
    }
    if (m.find("QueryTimes") != m.end() && !m["QueryTimes"].empty()) {
      queryTimes = make_shared<long>(boost::any_cast<long>(m["QueryTimes"]));
    }
    if (m.find("SQLText") != m.end() && !m["SQLText"].empty()) {
      SQLText = make_shared<string>(boost::any_cast<string>(m["SQLText"]));
    }
    if (m.find("CpuTime") != m.end() && !m["CpuTime"].empty()) {
      cpuTime = make_shared<long>(boost::any_cast<long>(m["CpuTime"]));
    }
    if (m.find("QueryTimeMS") != m.end() && !m["QueryTimeMS"].empty()) {
      queryTimeMS = make_shared<long>(boost::any_cast<long>(m["QueryTimeMS"]));
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("LockTimes") != m.end() && !m["LockTimes"].empty()) {
      lockTimes = make_shared<long>(boost::any_cast<long>(m["LockTimes"]));
    }
    if (m.find("ExecutionStartTime") != m.end() && !m["ExecutionStartTime"].empty()) {
      executionStartTime = make_shared<string>(boost::any_cast<string>(m["ExecutionStartTime"]));
    }
    if (m.find("LogicalIORead") != m.end() && !m["LogicalIORead"].empty()) {
      logicalIORead = make_shared<long>(boost::any_cast<long>(m["LogicalIORead"]));
    }
    if (m.find("WriteIOCount") != m.end() && !m["WriteIOCount"].empty()) {
      writeIOCount = make_shared<long>(boost::any_cast<long>(m["WriteIOCount"]));
    }
    if (m.find("PhysicalIORead") != m.end() && !m["PhysicalIORead"].empty()) {
      physicalIORead = make_shared<long>(boost::any_cast<long>(m["PhysicalIORead"]));
    }
    if (m.find("ReturnRowCounts") != m.end() && !m["ReturnRowCounts"].empty()) {
      returnRowCounts = make_shared<long>(boost::any_cast<long>(m["ReturnRowCounts"]));
    }
    if (m.find("ParseRowCounts") != m.end() && !m["ParseRowCounts"].empty()) {
      parseRowCounts = make_shared<long>(boost::any_cast<long>(m["ParseRowCounts"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("ClientHostName") != m.end() && !m["ClientHostName"].empty()) {
      clientHostName = make_shared<string>(boost::any_cast<string>(m["ClientHostName"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("LastRowsAffectedCount") != m.end() && !m["LastRowsAffectedCount"].empty()) {
      lastRowsAffectedCount = make_shared<long>(boost::any_cast<long>(m["LastRowsAffectedCount"]));
    }
  }


  virtual ~DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord() = default;
};
class DescribeSlowLogRecordsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord>> SQLSlowRecord{};

  DescribeSlowLogRecordsResponseBodyItems() {}

  explicit DescribeSlowLogRecordsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SQLSlowRecord) {
      vector<boost::any> temp1;
      for(auto item1:*SQLSlowRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SQLSlowRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SQLSlowRecord") != m.end() && !m["SQLSlowRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["SQLSlowRecord"].type()) {
        vector<DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SQLSlowRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SQLSlowRecord = make_shared<vector<DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord>>(expect1);
      }
    }
  }


  virtual ~DescribeSlowLogRecordsResponseBodyItems() = default;
};
class DescribeSlowLogRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> rowsAffectedCount{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> writesIOCount{};
  shared_ptr<string> SQLHash{};
  shared_ptr<long> logicalIORead{};
  shared_ptr<string> requestId{};
  shared_ptr<long> physicalIORead{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> engine{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> CPUTime{};
  shared_ptr<string> userName{};
  shared_ptr<long> lastRowsAffectedCount{};
  shared_ptr<DescribeSlowLogRecordsResponseBodyItems> items{};

  DescribeSlowLogRecordsResponseBody() {}

  explicit DescribeSlowLogRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rowsAffectedCount) {
      res["RowsAffectedCount"] = boost::any(*rowsAffectedCount);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (writesIOCount) {
      res["WritesIOCount"] = boost::any(*writesIOCount);
    }
    if (SQLHash) {
      res["SQLHash"] = boost::any(*SQLHash);
    }
    if (logicalIORead) {
      res["LogicalIORead"] = boost::any(*logicalIORead);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (physicalIORead) {
      res["PhysicalIORead"] = boost::any(*physicalIORead);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (CPUTime) {
      res["CPUTime"] = boost::any(*CPUTime);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (lastRowsAffectedCount) {
      res["LastRowsAffectedCount"] = boost::any(*lastRowsAffectedCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RowsAffectedCount") != m.end() && !m["RowsAffectedCount"].empty()) {
      rowsAffectedCount = make_shared<long>(boost::any_cast<long>(m["RowsAffectedCount"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("WritesIOCount") != m.end() && !m["WritesIOCount"].empty()) {
      writesIOCount = make_shared<long>(boost::any_cast<long>(m["WritesIOCount"]));
    }
    if (m.find("SQLHash") != m.end() && !m["SQLHash"].empty()) {
      SQLHash = make_shared<string>(boost::any_cast<string>(m["SQLHash"]));
    }
    if (m.find("LogicalIORead") != m.end() && !m["LogicalIORead"].empty()) {
      logicalIORead = make_shared<long>(boost::any_cast<long>(m["LogicalIORead"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PhysicalIORead") != m.end() && !m["PhysicalIORead"].empty()) {
      physicalIORead = make_shared<long>(boost::any_cast<long>(m["PhysicalIORead"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("CPUTime") != m.end() && !m["CPUTime"].empty()) {
      CPUTime = make_shared<long>(boost::any_cast<long>(m["CPUTime"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("LastRowsAffectedCount") != m.end() && !m["LastRowsAffectedCount"].empty()) {
      lastRowsAffectedCount = make_shared<long>(boost::any_cast<long>(m["LastRowsAffectedCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeSlowLogRecordsResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeSlowLogRecordsResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeSlowLogRecordsResponseBody() = default;
};
class DescribeSlowLogRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSlowLogRecordsResponseBody> body{};

  DescribeSlowLogRecordsResponse() {}

  explicit DescribeSlowLogRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSlowLogRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSlowLogRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSlowLogRecordsResponse() = default;
};
class DescribeSlowLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> DBName{};
  shared_ptr<string> sortKey{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> ownerAccount{};

  DescribeSlowLogsRequest() {}

  explicit DescribeSlowLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (sortKey) {
      res["SortKey"] = boost::any(*sortKey);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("SortKey") != m.end() && !m["SortKey"].empty()) {
      sortKey = make_shared<string>(boost::any_cast<string>(m["SortKey"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeSlowLogsRequest() = default;
};
class DescribeSlowLogsResponseBodyItemsSQLSlowLog : public Darabonba::Model {
public:
  shared_ptr<long> maxLastRowsAffectedCounts{};
  shared_ptr<long> returnMaxRowCount{};
  shared_ptr<string> SQLText{};
  shared_ptr<long> SQLServerMaxCpuTime{};
  shared_ptr<string> createTime{};
  shared_ptr<long> avgLastRowsAffectedCounts{};
  shared_ptr<long> minLastRowsAffectedCounts{};
  shared_ptr<long> parseTotalRowCounts{};
  shared_ptr<long> totalLockTimes{};
  shared_ptr<long> mySQLTotalExecutionCounts{};
  shared_ptr<long> SQLServerMinCpuTime{};
  shared_ptr<string> SQLHASH{};
  shared_ptr<long> minIOWriteCounts{};
  shared_ptr<long> parseMaxRowCount{};
  shared_ptr<long> maxLogicalReadCounts{};
  shared_ptr<long> mySQLTotalExecutionTimes{};
  shared_ptr<long> SQLServerTotalExecutionCounts{};
  shared_ptr<long> returnTotalRowCounts{};
  shared_ptr<long> maxLockTime{};
  shared_ptr<string> DBName{};
  shared_ptr<long> minRowsAffectedCounts{};
  shared_ptr<long> totalLogicalReadCounts{};
  shared_ptr<long> totalPhysicalReadCounts{};
  shared_ptr<string> reportTime{};
  shared_ptr<long> maxPhysicalReadCounts{};
  shared_ptr<long> SQLServerTotalCpuTime{};
  shared_ptr<long> totalIOWriteCounts{};
  shared_ptr<long> maxRowsAffectedCounts{};
  shared_ptr<long> avgIOWriteCounts{};
  shared_ptr<long> minPhysicalReadCounts{};
  shared_ptr<long> slowLogId{};
  shared_ptr<long> maxExecutionTime{};
  shared_ptr<long> avgExecutionTime{};
  shared_ptr<long> SQLServerAvgExecutionTime{};
  shared_ptr<long> maxIOWriteCounts{};
  shared_ptr<long> SQLServerAvgCpuTime{};
  shared_ptr<long> totalLastRowsAffectedCounts{};
  shared_ptr<long> avgLogicalReadCounts{};
  shared_ptr<long> SQLServerMinExecutionTime{};
  shared_ptr<string> SQLIdStr{};
  shared_ptr<long> SQLServerTotalExecutionTimes{};
  shared_ptr<long> avgRowsAffectedCounts{};
  shared_ptr<long> totalRowsAffectedCounts{};
  shared_ptr<long> avgPhysicalReadCounts{};
  shared_ptr<long> minLogicalReadCounts{};

  DescribeSlowLogsResponseBodyItemsSQLSlowLog() {}

  explicit DescribeSlowLogsResponseBodyItemsSQLSlowLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxLastRowsAffectedCounts) {
      res["MaxLastRowsAffectedCounts"] = boost::any(*maxLastRowsAffectedCounts);
    }
    if (returnMaxRowCount) {
      res["ReturnMaxRowCount"] = boost::any(*returnMaxRowCount);
    }
    if (SQLText) {
      res["SQLText"] = boost::any(*SQLText);
    }
    if (SQLServerMaxCpuTime) {
      res["SQLServerMaxCpuTime"] = boost::any(*SQLServerMaxCpuTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (avgLastRowsAffectedCounts) {
      res["AvgLastRowsAffectedCounts"] = boost::any(*avgLastRowsAffectedCounts);
    }
    if (minLastRowsAffectedCounts) {
      res["MinLastRowsAffectedCounts"] = boost::any(*minLastRowsAffectedCounts);
    }
    if (parseTotalRowCounts) {
      res["ParseTotalRowCounts"] = boost::any(*parseTotalRowCounts);
    }
    if (totalLockTimes) {
      res["TotalLockTimes"] = boost::any(*totalLockTimes);
    }
    if (mySQLTotalExecutionCounts) {
      res["MySQLTotalExecutionCounts"] = boost::any(*mySQLTotalExecutionCounts);
    }
    if (SQLServerMinCpuTime) {
      res["SQLServerMinCpuTime"] = boost::any(*SQLServerMinCpuTime);
    }
    if (SQLHASH) {
      res["SQLHASH"] = boost::any(*SQLHASH);
    }
    if (minIOWriteCounts) {
      res["MinIOWriteCounts"] = boost::any(*minIOWriteCounts);
    }
    if (parseMaxRowCount) {
      res["ParseMaxRowCount"] = boost::any(*parseMaxRowCount);
    }
    if (maxLogicalReadCounts) {
      res["MaxLogicalReadCounts"] = boost::any(*maxLogicalReadCounts);
    }
    if (mySQLTotalExecutionTimes) {
      res["MySQLTotalExecutionTimes"] = boost::any(*mySQLTotalExecutionTimes);
    }
    if (SQLServerTotalExecutionCounts) {
      res["SQLServerTotalExecutionCounts"] = boost::any(*SQLServerTotalExecutionCounts);
    }
    if (returnTotalRowCounts) {
      res["ReturnTotalRowCounts"] = boost::any(*returnTotalRowCounts);
    }
    if (maxLockTime) {
      res["MaxLockTime"] = boost::any(*maxLockTime);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (minRowsAffectedCounts) {
      res["MinRowsAffectedCounts"] = boost::any(*minRowsAffectedCounts);
    }
    if (totalLogicalReadCounts) {
      res["TotalLogicalReadCounts"] = boost::any(*totalLogicalReadCounts);
    }
    if (totalPhysicalReadCounts) {
      res["TotalPhysicalReadCounts"] = boost::any(*totalPhysicalReadCounts);
    }
    if (reportTime) {
      res["ReportTime"] = boost::any(*reportTime);
    }
    if (maxPhysicalReadCounts) {
      res["MaxPhysicalReadCounts"] = boost::any(*maxPhysicalReadCounts);
    }
    if (SQLServerTotalCpuTime) {
      res["SQLServerTotalCpuTime"] = boost::any(*SQLServerTotalCpuTime);
    }
    if (totalIOWriteCounts) {
      res["TotalIOWriteCounts"] = boost::any(*totalIOWriteCounts);
    }
    if (maxRowsAffectedCounts) {
      res["MaxRowsAffectedCounts"] = boost::any(*maxRowsAffectedCounts);
    }
    if (avgIOWriteCounts) {
      res["AvgIOWriteCounts"] = boost::any(*avgIOWriteCounts);
    }
    if (minPhysicalReadCounts) {
      res["MinPhysicalReadCounts"] = boost::any(*minPhysicalReadCounts);
    }
    if (slowLogId) {
      res["SlowLogId"] = boost::any(*slowLogId);
    }
    if (maxExecutionTime) {
      res["MaxExecutionTime"] = boost::any(*maxExecutionTime);
    }
    if (avgExecutionTime) {
      res["AvgExecutionTime"] = boost::any(*avgExecutionTime);
    }
    if (SQLServerAvgExecutionTime) {
      res["SQLServerAvgExecutionTime"] = boost::any(*SQLServerAvgExecutionTime);
    }
    if (maxIOWriteCounts) {
      res["MaxIOWriteCounts"] = boost::any(*maxIOWriteCounts);
    }
    if (SQLServerAvgCpuTime) {
      res["SQLServerAvgCpuTime"] = boost::any(*SQLServerAvgCpuTime);
    }
    if (totalLastRowsAffectedCounts) {
      res["TotalLastRowsAffectedCounts"] = boost::any(*totalLastRowsAffectedCounts);
    }
    if (avgLogicalReadCounts) {
      res["AvgLogicalReadCounts"] = boost::any(*avgLogicalReadCounts);
    }
    if (SQLServerMinExecutionTime) {
      res["SQLServerMinExecutionTime"] = boost::any(*SQLServerMinExecutionTime);
    }
    if (SQLIdStr) {
      res["SQLIdStr"] = boost::any(*SQLIdStr);
    }
    if (SQLServerTotalExecutionTimes) {
      res["SQLServerTotalExecutionTimes"] = boost::any(*SQLServerTotalExecutionTimes);
    }
    if (avgRowsAffectedCounts) {
      res["AvgRowsAffectedCounts"] = boost::any(*avgRowsAffectedCounts);
    }
    if (totalRowsAffectedCounts) {
      res["TotalRowsAffectedCounts"] = boost::any(*totalRowsAffectedCounts);
    }
    if (avgPhysicalReadCounts) {
      res["AvgPhysicalReadCounts"] = boost::any(*avgPhysicalReadCounts);
    }
    if (minLogicalReadCounts) {
      res["MinLogicalReadCounts"] = boost::any(*minLogicalReadCounts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxLastRowsAffectedCounts") != m.end() && !m["MaxLastRowsAffectedCounts"].empty()) {
      maxLastRowsAffectedCounts = make_shared<long>(boost::any_cast<long>(m["MaxLastRowsAffectedCounts"]));
    }
    if (m.find("ReturnMaxRowCount") != m.end() && !m["ReturnMaxRowCount"].empty()) {
      returnMaxRowCount = make_shared<long>(boost::any_cast<long>(m["ReturnMaxRowCount"]));
    }
    if (m.find("SQLText") != m.end() && !m["SQLText"].empty()) {
      SQLText = make_shared<string>(boost::any_cast<string>(m["SQLText"]));
    }
    if (m.find("SQLServerMaxCpuTime") != m.end() && !m["SQLServerMaxCpuTime"].empty()) {
      SQLServerMaxCpuTime = make_shared<long>(boost::any_cast<long>(m["SQLServerMaxCpuTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("AvgLastRowsAffectedCounts") != m.end() && !m["AvgLastRowsAffectedCounts"].empty()) {
      avgLastRowsAffectedCounts = make_shared<long>(boost::any_cast<long>(m["AvgLastRowsAffectedCounts"]));
    }
    if (m.find("MinLastRowsAffectedCounts") != m.end() && !m["MinLastRowsAffectedCounts"].empty()) {
      minLastRowsAffectedCounts = make_shared<long>(boost::any_cast<long>(m["MinLastRowsAffectedCounts"]));
    }
    if (m.find("ParseTotalRowCounts") != m.end() && !m["ParseTotalRowCounts"].empty()) {
      parseTotalRowCounts = make_shared<long>(boost::any_cast<long>(m["ParseTotalRowCounts"]));
    }
    if (m.find("TotalLockTimes") != m.end() && !m["TotalLockTimes"].empty()) {
      totalLockTimes = make_shared<long>(boost::any_cast<long>(m["TotalLockTimes"]));
    }
    if (m.find("MySQLTotalExecutionCounts") != m.end() && !m["MySQLTotalExecutionCounts"].empty()) {
      mySQLTotalExecutionCounts = make_shared<long>(boost::any_cast<long>(m["MySQLTotalExecutionCounts"]));
    }
    if (m.find("SQLServerMinCpuTime") != m.end() && !m["SQLServerMinCpuTime"].empty()) {
      SQLServerMinCpuTime = make_shared<long>(boost::any_cast<long>(m["SQLServerMinCpuTime"]));
    }
    if (m.find("SQLHASH") != m.end() && !m["SQLHASH"].empty()) {
      SQLHASH = make_shared<string>(boost::any_cast<string>(m["SQLHASH"]));
    }
    if (m.find("MinIOWriteCounts") != m.end() && !m["MinIOWriteCounts"].empty()) {
      minIOWriteCounts = make_shared<long>(boost::any_cast<long>(m["MinIOWriteCounts"]));
    }
    if (m.find("ParseMaxRowCount") != m.end() && !m["ParseMaxRowCount"].empty()) {
      parseMaxRowCount = make_shared<long>(boost::any_cast<long>(m["ParseMaxRowCount"]));
    }
    if (m.find("MaxLogicalReadCounts") != m.end() && !m["MaxLogicalReadCounts"].empty()) {
      maxLogicalReadCounts = make_shared<long>(boost::any_cast<long>(m["MaxLogicalReadCounts"]));
    }
    if (m.find("MySQLTotalExecutionTimes") != m.end() && !m["MySQLTotalExecutionTimes"].empty()) {
      mySQLTotalExecutionTimes = make_shared<long>(boost::any_cast<long>(m["MySQLTotalExecutionTimes"]));
    }
    if (m.find("SQLServerTotalExecutionCounts") != m.end() && !m["SQLServerTotalExecutionCounts"].empty()) {
      SQLServerTotalExecutionCounts = make_shared<long>(boost::any_cast<long>(m["SQLServerTotalExecutionCounts"]));
    }
    if (m.find("ReturnTotalRowCounts") != m.end() && !m["ReturnTotalRowCounts"].empty()) {
      returnTotalRowCounts = make_shared<long>(boost::any_cast<long>(m["ReturnTotalRowCounts"]));
    }
    if (m.find("MaxLockTime") != m.end() && !m["MaxLockTime"].empty()) {
      maxLockTime = make_shared<long>(boost::any_cast<long>(m["MaxLockTime"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("MinRowsAffectedCounts") != m.end() && !m["MinRowsAffectedCounts"].empty()) {
      minRowsAffectedCounts = make_shared<long>(boost::any_cast<long>(m["MinRowsAffectedCounts"]));
    }
    if (m.find("TotalLogicalReadCounts") != m.end() && !m["TotalLogicalReadCounts"].empty()) {
      totalLogicalReadCounts = make_shared<long>(boost::any_cast<long>(m["TotalLogicalReadCounts"]));
    }
    if (m.find("TotalPhysicalReadCounts") != m.end() && !m["TotalPhysicalReadCounts"].empty()) {
      totalPhysicalReadCounts = make_shared<long>(boost::any_cast<long>(m["TotalPhysicalReadCounts"]));
    }
    if (m.find("ReportTime") != m.end() && !m["ReportTime"].empty()) {
      reportTime = make_shared<string>(boost::any_cast<string>(m["ReportTime"]));
    }
    if (m.find("MaxPhysicalReadCounts") != m.end() && !m["MaxPhysicalReadCounts"].empty()) {
      maxPhysicalReadCounts = make_shared<long>(boost::any_cast<long>(m["MaxPhysicalReadCounts"]));
    }
    if (m.find("SQLServerTotalCpuTime") != m.end() && !m["SQLServerTotalCpuTime"].empty()) {
      SQLServerTotalCpuTime = make_shared<long>(boost::any_cast<long>(m["SQLServerTotalCpuTime"]));
    }
    if (m.find("TotalIOWriteCounts") != m.end() && !m["TotalIOWriteCounts"].empty()) {
      totalIOWriteCounts = make_shared<long>(boost::any_cast<long>(m["TotalIOWriteCounts"]));
    }
    if (m.find("MaxRowsAffectedCounts") != m.end() && !m["MaxRowsAffectedCounts"].empty()) {
      maxRowsAffectedCounts = make_shared<long>(boost::any_cast<long>(m["MaxRowsAffectedCounts"]));
    }
    if (m.find("AvgIOWriteCounts") != m.end() && !m["AvgIOWriteCounts"].empty()) {
      avgIOWriteCounts = make_shared<long>(boost::any_cast<long>(m["AvgIOWriteCounts"]));
    }
    if (m.find("MinPhysicalReadCounts") != m.end() && !m["MinPhysicalReadCounts"].empty()) {
      minPhysicalReadCounts = make_shared<long>(boost::any_cast<long>(m["MinPhysicalReadCounts"]));
    }
    if (m.find("SlowLogId") != m.end() && !m["SlowLogId"].empty()) {
      slowLogId = make_shared<long>(boost::any_cast<long>(m["SlowLogId"]));
    }
    if (m.find("MaxExecutionTime") != m.end() && !m["MaxExecutionTime"].empty()) {
      maxExecutionTime = make_shared<long>(boost::any_cast<long>(m["MaxExecutionTime"]));
    }
    if (m.find("AvgExecutionTime") != m.end() && !m["AvgExecutionTime"].empty()) {
      avgExecutionTime = make_shared<long>(boost::any_cast<long>(m["AvgExecutionTime"]));
    }
    if (m.find("SQLServerAvgExecutionTime") != m.end() && !m["SQLServerAvgExecutionTime"].empty()) {
      SQLServerAvgExecutionTime = make_shared<long>(boost::any_cast<long>(m["SQLServerAvgExecutionTime"]));
    }
    if (m.find("MaxIOWriteCounts") != m.end() && !m["MaxIOWriteCounts"].empty()) {
      maxIOWriteCounts = make_shared<long>(boost::any_cast<long>(m["MaxIOWriteCounts"]));
    }
    if (m.find("SQLServerAvgCpuTime") != m.end() && !m["SQLServerAvgCpuTime"].empty()) {
      SQLServerAvgCpuTime = make_shared<long>(boost::any_cast<long>(m["SQLServerAvgCpuTime"]));
    }
    if (m.find("TotalLastRowsAffectedCounts") != m.end() && !m["TotalLastRowsAffectedCounts"].empty()) {
      totalLastRowsAffectedCounts = make_shared<long>(boost::any_cast<long>(m["TotalLastRowsAffectedCounts"]));
    }
    if (m.find("AvgLogicalReadCounts") != m.end() && !m["AvgLogicalReadCounts"].empty()) {
      avgLogicalReadCounts = make_shared<long>(boost::any_cast<long>(m["AvgLogicalReadCounts"]));
    }
    if (m.find("SQLServerMinExecutionTime") != m.end() && !m["SQLServerMinExecutionTime"].empty()) {
      SQLServerMinExecutionTime = make_shared<long>(boost::any_cast<long>(m["SQLServerMinExecutionTime"]));
    }
    if (m.find("SQLIdStr") != m.end() && !m["SQLIdStr"].empty()) {
      SQLIdStr = make_shared<string>(boost::any_cast<string>(m["SQLIdStr"]));
    }
    if (m.find("SQLServerTotalExecutionTimes") != m.end() && !m["SQLServerTotalExecutionTimes"].empty()) {
      SQLServerTotalExecutionTimes = make_shared<long>(boost::any_cast<long>(m["SQLServerTotalExecutionTimes"]));
    }
    if (m.find("AvgRowsAffectedCounts") != m.end() && !m["AvgRowsAffectedCounts"].empty()) {
      avgRowsAffectedCounts = make_shared<long>(boost::any_cast<long>(m["AvgRowsAffectedCounts"]));
    }
    if (m.find("TotalRowsAffectedCounts") != m.end() && !m["TotalRowsAffectedCounts"].empty()) {
      totalRowsAffectedCounts = make_shared<long>(boost::any_cast<long>(m["TotalRowsAffectedCounts"]));
    }
    if (m.find("AvgPhysicalReadCounts") != m.end() && !m["AvgPhysicalReadCounts"].empty()) {
      avgPhysicalReadCounts = make_shared<long>(boost::any_cast<long>(m["AvgPhysicalReadCounts"]));
    }
    if (m.find("MinLogicalReadCounts") != m.end() && !m["MinLogicalReadCounts"].empty()) {
      minLogicalReadCounts = make_shared<long>(boost::any_cast<long>(m["MinLogicalReadCounts"]));
    }
  }


  virtual ~DescribeSlowLogsResponseBodyItemsSQLSlowLog() = default;
};
class DescribeSlowLogsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSlowLogsResponseBodyItemsSQLSlowLog>> SQLSlowLog{};

  DescribeSlowLogsResponseBodyItems() {}

  explicit DescribeSlowLogsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SQLSlowLog) {
      vector<boost::any> temp1;
      for(auto item1:*SQLSlowLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SQLSlowLog"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SQLSlowLog") != m.end() && !m["SQLSlowLog"].empty()) {
      if (typeid(vector<boost::any>) == m["SQLSlowLog"].type()) {
        vector<DescribeSlowLogsResponseBodyItemsSQLSlowLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SQLSlowLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSlowLogsResponseBodyItemsSQLSlowLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SQLSlowLog = make_shared<vector<DescribeSlowLogsResponseBodyItemsSQLSlowLog>>(expect1);
      }
    }
  }


  virtual ~DescribeSlowLogsResponseBodyItems() = default;
};
class DescribeSlowLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> engine{};
  shared_ptr<DescribeSlowLogsResponseBodyItems> items{};

  DescribeSlowLogsResponseBody() {}

  explicit DescribeSlowLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeSlowLogsResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeSlowLogsResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeSlowLogsResponseBody() = default;
};
class DescribeSlowLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSlowLogsResponseBody> body{};

  DescribeSlowLogsResponse() {}

  explicit DescribeSlowLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSlowLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSlowLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSlowLogsResponse() = default;
};
class DescribeSQLCollectorPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceGroupId{};

  DescribeSQLCollectorPolicyRequest() {}

  explicit DescribeSQLCollectorPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeSQLCollectorPolicyRequest() = default;
};
class DescribeSQLCollectorPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> SQLCollectorStatus{};
  shared_ptr<long> storagePeriod{};

  DescribeSQLCollectorPolicyResponseBody() {}

  explicit DescribeSQLCollectorPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (SQLCollectorStatus) {
      res["SQLCollectorStatus"] = boost::any(*SQLCollectorStatus);
    }
    if (storagePeriod) {
      res["StoragePeriod"] = boost::any(*storagePeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SQLCollectorStatus") != m.end() && !m["SQLCollectorStatus"].empty()) {
      SQLCollectorStatus = make_shared<string>(boost::any_cast<string>(m["SQLCollectorStatus"]));
    }
    if (m.find("StoragePeriod") != m.end() && !m["StoragePeriod"].empty()) {
      storagePeriod = make_shared<long>(boost::any_cast<long>(m["StoragePeriod"]));
    }
  }


  virtual ~DescribeSQLCollectorPolicyResponseBody() = default;
};
class DescribeSQLCollectorPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSQLCollectorPolicyResponseBody> body{};

  DescribeSQLCollectorPolicyResponse() {}

  explicit DescribeSQLCollectorPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSQLCollectorPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSQLCollectorPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSQLCollectorPolicyResponse() = default;
};
class DescribeSQLCollectorRetentionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> resourceGroupId{};

  DescribeSQLCollectorRetentionRequest() {}

  explicit DescribeSQLCollectorRetentionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeSQLCollectorRetentionRequest() = default;
};
class DescribeSQLCollectorRetentionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> configValue{};
  shared_ptr<string> requestId{};

  DescribeSQLCollectorRetentionResponseBody() {}

  explicit DescribeSQLCollectorRetentionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSQLCollectorRetentionResponseBody() = default;
};
class DescribeSQLCollectorRetentionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSQLCollectorRetentionResponseBody> body{};

  DescribeSQLCollectorRetentionResponse() {}

  explicit DescribeSQLCollectorRetentionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSQLCollectorRetentionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSQLCollectorRetentionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSQLCollectorRetentionResponse() = default;
};
class DescribeSQLLogFilesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> fileName{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> ownerAccount{};

  DescribeSQLLogFilesRequest() {}

  explicit DescribeSQLLogFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeSQLLogFilesRequest() = default;
};
class DescribeSQLLogFilesResponseBodyItemsLogFile : public Darabonba::Model {
public:
  shared_ptr<string> fileID{};
  shared_ptr<string> logStartTime{};
  shared_ptr<string> logSize{};
  shared_ptr<string> logDownloadURL{};
  shared_ptr<string> logEndTime{};
  shared_ptr<string> logStatus{};

  DescribeSQLLogFilesResponseBodyItemsLogFile() {}

  explicit DescribeSQLLogFilesResponseBodyItemsLogFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileID) {
      res["FileID"] = boost::any(*fileID);
    }
    if (logStartTime) {
      res["LogStartTime"] = boost::any(*logStartTime);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (logDownloadURL) {
      res["LogDownloadURL"] = boost::any(*logDownloadURL);
    }
    if (logEndTime) {
      res["LogEndTime"] = boost::any(*logEndTime);
    }
    if (logStatus) {
      res["LogStatus"] = boost::any(*logStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileID") != m.end() && !m["FileID"].empty()) {
      fileID = make_shared<string>(boost::any_cast<string>(m["FileID"]));
    }
    if (m.find("LogStartTime") != m.end() && !m["LogStartTime"].empty()) {
      logStartTime = make_shared<string>(boost::any_cast<string>(m["LogStartTime"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<string>(boost::any_cast<string>(m["LogSize"]));
    }
    if (m.find("LogDownloadURL") != m.end() && !m["LogDownloadURL"].empty()) {
      logDownloadURL = make_shared<string>(boost::any_cast<string>(m["LogDownloadURL"]));
    }
    if (m.find("LogEndTime") != m.end() && !m["LogEndTime"].empty()) {
      logEndTime = make_shared<string>(boost::any_cast<string>(m["LogEndTime"]));
    }
    if (m.find("LogStatus") != m.end() && !m["LogStatus"].empty()) {
      logStatus = make_shared<string>(boost::any_cast<string>(m["LogStatus"]));
    }
  }


  virtual ~DescribeSQLLogFilesResponseBodyItemsLogFile() = default;
};
class DescribeSQLLogFilesResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSQLLogFilesResponseBodyItemsLogFile>> logFile{};

  DescribeSQLLogFilesResponseBodyItems() {}

  explicit DescribeSQLLogFilesResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logFile) {
      vector<boost::any> temp1;
      for(auto item1:*logFile){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogFile"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogFile") != m.end() && !m["LogFile"].empty()) {
      if (typeid(vector<boost::any>) == m["LogFile"].type()) {
        vector<DescribeSQLLogFilesResponseBodyItemsLogFile> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogFile"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSQLLogFilesResponseBodyItemsLogFile model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logFile = make_shared<vector<DescribeSQLLogFilesResponseBodyItemsLogFile>>(expect1);
      }
    }
  }


  virtual ~DescribeSQLLogFilesResponseBodyItems() = default;
};
class DescribeSQLLogFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeSQLLogFilesResponseBodyItems> items{};

  DescribeSQLLogFilesResponseBody() {}

  explicit DescribeSQLLogFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeSQLLogFilesResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeSQLLogFilesResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeSQLLogFilesResponseBody() = default;
};
class DescribeSQLLogFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSQLLogFilesResponseBody> body{};

  DescribeSQLLogFilesResponse() {}

  explicit DescribeSQLLogFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSQLLogFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSQLLogFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSQLLogFilesResponse() = default;
};
class DescribeSQLLogRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> SQLId{};
  shared_ptr<string> queryKeywords{};
  shared_ptr<string> startTime{};
  shared_ptr<string> database{};
  shared_ptr<string> user{};
  shared_ptr<string> form{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> ownerAccount{};

  DescribeSQLLogRecordsRequest() {}

  explicit DescribeSQLLogRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (queryKeywords) {
      res["QueryKeywords"] = boost::any(*queryKeywords);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (form) {
      res["Form"] = boost::any(*form);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<long>(boost::any_cast<long>(m["SQLId"]));
    }
    if (m.find("QueryKeywords") != m.end() && !m["QueryKeywords"].empty()) {
      queryKeywords = make_shared<string>(boost::any_cast<string>(m["QueryKeywords"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("Form") != m.end() && !m["Form"].empty()) {
      form = make_shared<string>(boost::any_cast<string>(m["Form"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeSQLLogRecordsRequest() = default;
};
class DescribeSQLLogRecordsResponseBodyItemsSQLRecord : public Darabonba::Model {
public:
  shared_ptr<string> hostAddress{};
  shared_ptr<string> SQLText{};
  shared_ptr<long> returnRowCounts{};
  shared_ptr<string> DBName{};
  shared_ptr<string> executeTime{};
  shared_ptr<string> threadID{};
  shared_ptr<long> totalExecutionTimes{};
  shared_ptr<string> accountName{};

  DescribeSQLLogRecordsResponseBodyItemsSQLRecord() {}

  explicit DescribeSQLLogRecordsResponseBodyItemsSQLRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAddress) {
      res["HostAddress"] = boost::any(*hostAddress);
    }
    if (SQLText) {
      res["SQLText"] = boost::any(*SQLText);
    }
    if (returnRowCounts) {
      res["ReturnRowCounts"] = boost::any(*returnRowCounts);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (threadID) {
      res["ThreadID"] = boost::any(*threadID);
    }
    if (totalExecutionTimes) {
      res["TotalExecutionTimes"] = boost::any(*totalExecutionTimes);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAddress") != m.end() && !m["HostAddress"].empty()) {
      hostAddress = make_shared<string>(boost::any_cast<string>(m["HostAddress"]));
    }
    if (m.find("SQLText") != m.end() && !m["SQLText"].empty()) {
      SQLText = make_shared<string>(boost::any_cast<string>(m["SQLText"]));
    }
    if (m.find("ReturnRowCounts") != m.end() && !m["ReturnRowCounts"].empty()) {
      returnRowCounts = make_shared<long>(boost::any_cast<long>(m["ReturnRowCounts"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<string>(boost::any_cast<string>(m["ExecuteTime"]));
    }
    if (m.find("ThreadID") != m.end() && !m["ThreadID"].empty()) {
      threadID = make_shared<string>(boost::any_cast<string>(m["ThreadID"]));
    }
    if (m.find("TotalExecutionTimes") != m.end() && !m["TotalExecutionTimes"].empty()) {
      totalExecutionTimes = make_shared<long>(boost::any_cast<long>(m["TotalExecutionTimes"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
  }


  virtual ~DescribeSQLLogRecordsResponseBodyItemsSQLRecord() = default;
};
class DescribeSQLLogRecordsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSQLLogRecordsResponseBodyItemsSQLRecord>> SQLRecord{};

  DescribeSQLLogRecordsResponseBodyItems() {}

  explicit DescribeSQLLogRecordsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SQLRecord) {
      vector<boost::any> temp1;
      for(auto item1:*SQLRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SQLRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SQLRecord") != m.end() && !m["SQLRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["SQLRecord"].type()) {
        vector<DescribeSQLLogRecordsResponseBodyItemsSQLRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SQLRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSQLLogRecordsResponseBodyItemsSQLRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SQLRecord = make_shared<vector<DescribeSQLLogRecordsResponseBodyItemsSQLRecord>>(expect1);
      }
    }
  }


  virtual ~DescribeSQLLogRecordsResponseBodyItems() = default;
};
class DescribeSQLLogRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeSQLLogRecordsResponseBodyItems> items{};

  DescribeSQLLogRecordsResponseBody() {}

  explicit DescribeSQLLogRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeSQLLogRecordsResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeSQLLogRecordsResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeSQLLogRecordsResponseBody() = default;
};
class DescribeSQLLogRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSQLLogRecordsResponseBody> body{};

  DescribeSQLLogRecordsResponse() {}

  explicit DescribeSQLLogRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSQLLogRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSQLLogRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSQLLogRecordsResponse() = default;
};
class DescribeSQLLogReportListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> ownerAccount{};

  DescribeSQLLogReportListRequest() {}

  explicit DescribeSQLLogReportListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeSQLLogReportListRequest() = default;
};
class DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem : public Darabonba::Model {
public:
  shared_ptr<string> SQLText{};
  shared_ptr<long> SQLExecuteTimes{};
  shared_ptr<long> avgLatency{};

  DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem() {}

  explicit DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SQLText) {
      res["SQLText"] = boost::any(*SQLText);
    }
    if (SQLExecuteTimes) {
      res["SQLExecuteTimes"] = boost::any(*SQLExecuteTimes);
    }
    if (avgLatency) {
      res["AvgLatency"] = boost::any(*avgLatency);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SQLText") != m.end() && !m["SQLText"].empty()) {
      SQLText = make_shared<string>(boost::any_cast<string>(m["SQLText"]));
    }
    if (m.find("SQLExecuteTimes") != m.end() && !m["SQLExecuteTimes"].empty()) {
      SQLExecuteTimes = make_shared<long>(boost::any_cast<long>(m["SQLExecuteTimes"]));
    }
    if (m.find("AvgLatency") != m.end() && !m["AvgLatency"].empty()) {
      avgLatency = make_shared<long>(boost::any_cast<long>(m["AvgLatency"]));
    }
  }


  virtual ~DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem() = default;
};
class DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem>> latencyTopNItem{};

  DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems() {}

  explicit DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (latencyTopNItem) {
      vector<boost::any> temp1;
      for(auto item1:*latencyTopNItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LatencyTopNItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LatencyTopNItem") != m.end() && !m["LatencyTopNItem"].empty()) {
      if (typeid(vector<boost::any>) == m["LatencyTopNItem"].type()) {
        vector<DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LatencyTopNItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        latencyTopNItem = make_shared<vector<DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem>>(expect1);
      }
    }
  }


  virtual ~DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems() = default;
};
class DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem : public Darabonba::Model {
public:
  shared_ptr<long> SQLExecuteTimes{};
  shared_ptr<string> SQLText{};

  DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem() {}

  explicit DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SQLExecuteTimes) {
      res["SQLExecuteTimes"] = boost::any(*SQLExecuteTimes);
    }
    if (SQLText) {
      res["SQLText"] = boost::any(*SQLText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SQLExecuteTimes") != m.end() && !m["SQLExecuteTimes"].empty()) {
      SQLExecuteTimes = make_shared<long>(boost::any_cast<long>(m["SQLExecuteTimes"]));
    }
    if (m.find("SQLText") != m.end() && !m["SQLText"].empty()) {
      SQLText = make_shared<string>(boost::any_cast<string>(m["SQLText"]));
    }
  }


  virtual ~DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem() = default;
};
class DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem>> QPSTopNItem{};

  DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems() {}

  explicit DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (QPSTopNItem) {
      vector<boost::any> temp1;
      for(auto item1:*QPSTopNItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QPSTopNItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QPSTopNItem") != m.end() && !m["QPSTopNItem"].empty()) {
      if (typeid(vector<boost::any>) == m["QPSTopNItem"].type()) {
        vector<DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QPSTopNItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        QPSTopNItem = make_shared<vector<DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem>>(expect1);
      }
    }
  }


  virtual ~DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems() = default;
};
class DescribeSQLLogReportListResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> reportTime{};
  shared_ptr<DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems> latencyTopNItems{};
  shared_ptr<DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems> QPSTopNItems{};

  DescribeSQLLogReportListResponseBodyItemsItem() {}

  explicit DescribeSQLLogReportListResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportTime) {
      res["ReportTime"] = boost::any(*reportTime);
    }
    if (latencyTopNItems) {
      res["LatencyTopNItems"] = latencyTopNItems ? boost::any(latencyTopNItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (QPSTopNItems) {
      res["QPSTopNItems"] = QPSTopNItems ? boost::any(QPSTopNItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportTime") != m.end() && !m["ReportTime"].empty()) {
      reportTime = make_shared<string>(boost::any_cast<string>(m["ReportTime"]));
    }
    if (m.find("LatencyTopNItems") != m.end() && !m["LatencyTopNItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["LatencyTopNItems"].type()) {
        DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LatencyTopNItems"]));
        latencyTopNItems = make_shared<DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems>(model1);
      }
    }
    if (m.find("QPSTopNItems") != m.end() && !m["QPSTopNItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["QPSTopNItems"].type()) {
        DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QPSTopNItems"]));
        QPSTopNItems = make_shared<DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems>(model1);
      }
    }
  }


  virtual ~DescribeSQLLogReportListResponseBodyItemsItem() = default;
};
class DescribeSQLLogReportListResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSQLLogReportListResponseBodyItemsItem>> item{};

  DescribeSQLLogReportListResponseBodyItems() {}

  explicit DescribeSQLLogReportListResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<DescribeSQLLogReportListResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSQLLogReportListResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<DescribeSQLLogReportListResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~DescribeSQLLogReportListResponseBodyItems() = default;
};
class DescribeSQLLogReportListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeSQLLogReportListResponseBodyItems> items{};

  DescribeSQLLogReportListResponseBody() {}

  explicit DescribeSQLLogReportListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeSQLLogReportListResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeSQLLogReportListResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeSQLLogReportListResponseBody() = default;
};
class DescribeSQLLogReportListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSQLLogReportListResponseBody> body{};

  DescribeSQLLogReportListResponse() {}

  explicit DescribeSQLLogReportListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSQLLogReportListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSQLLogReportListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSQLLogReportListResponse() = default;
};
class DescribeSQLLogReportsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> ownerAccount{};

  DescribeSQLLogReportsRequest() {}

  explicit DescribeSQLLogReportsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeSQLLogReportsRequest() = default;
};
class DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem : public Darabonba::Model {
public:
  shared_ptr<string> SQLText{};
  shared_ptr<long> SQLExecuteTimes{};
  shared_ptr<long> avgLatency{};

  DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem() {}

  explicit DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SQLText) {
      res["SQLText"] = boost::any(*SQLText);
    }
    if (SQLExecuteTimes) {
      res["SQLExecuteTimes"] = boost::any(*SQLExecuteTimes);
    }
    if (avgLatency) {
      res["AvgLatency"] = boost::any(*avgLatency);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SQLText") != m.end() && !m["SQLText"].empty()) {
      SQLText = make_shared<string>(boost::any_cast<string>(m["SQLText"]));
    }
    if (m.find("SQLExecuteTimes") != m.end() && !m["SQLExecuteTimes"].empty()) {
      SQLExecuteTimes = make_shared<long>(boost::any_cast<long>(m["SQLExecuteTimes"]));
    }
    if (m.find("AvgLatency") != m.end() && !m["AvgLatency"].empty()) {
      avgLatency = make_shared<long>(boost::any_cast<long>(m["AvgLatency"]));
    }
  }


  virtual ~DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem() = default;
};
class DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem>> latencyTopNItem{};

  DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItems() {}

  explicit DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (latencyTopNItem) {
      vector<boost::any> temp1;
      for(auto item1:*latencyTopNItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LatencyTopNItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LatencyTopNItem") != m.end() && !m["LatencyTopNItem"].empty()) {
      if (typeid(vector<boost::any>) == m["LatencyTopNItem"].type()) {
        vector<DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LatencyTopNItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        latencyTopNItem = make_shared<vector<DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem>>(expect1);
      }
    }
  }


  virtual ~DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItems() = default;
};
class DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItemsQPSTopNItem : public Darabonba::Model {
public:
  shared_ptr<long> SQLExecuteTimes{};
  shared_ptr<string> SQLText{};

  DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItemsQPSTopNItem() {}

  explicit DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItemsQPSTopNItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SQLExecuteTimes) {
      res["SQLExecuteTimes"] = boost::any(*SQLExecuteTimes);
    }
    if (SQLText) {
      res["SQLText"] = boost::any(*SQLText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SQLExecuteTimes") != m.end() && !m["SQLExecuteTimes"].empty()) {
      SQLExecuteTimes = make_shared<long>(boost::any_cast<long>(m["SQLExecuteTimes"]));
    }
    if (m.find("SQLText") != m.end() && !m["SQLText"].empty()) {
      SQLText = make_shared<string>(boost::any_cast<string>(m["SQLText"]));
    }
  }


  virtual ~DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItemsQPSTopNItem() = default;
};
class DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItemsQPSTopNItem>> QPSTopNItem{};

  DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItems() {}

  explicit DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (QPSTopNItem) {
      vector<boost::any> temp1;
      for(auto item1:*QPSTopNItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QPSTopNItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QPSTopNItem") != m.end() && !m["QPSTopNItem"].empty()) {
      if (typeid(vector<boost::any>) == m["QPSTopNItem"].type()) {
        vector<DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItemsQPSTopNItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QPSTopNItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItemsQPSTopNItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        QPSTopNItem = make_shared<vector<DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItemsQPSTopNItem>>(expect1);
      }
    }
  }


  virtual ~DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItems() = default;
};
class DescribeSQLLogReportsResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> reportTime{};
  shared_ptr<DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItems> latencyTopNItems{};
  shared_ptr<DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItems> QPSTopNItems{};

  DescribeSQLLogReportsResponseBodyItemsItem() {}

  explicit DescribeSQLLogReportsResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportTime) {
      res["ReportTime"] = boost::any(*reportTime);
    }
    if (latencyTopNItems) {
      res["LatencyTopNItems"] = latencyTopNItems ? boost::any(latencyTopNItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (QPSTopNItems) {
      res["QPSTopNItems"] = QPSTopNItems ? boost::any(QPSTopNItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportTime") != m.end() && !m["ReportTime"].empty()) {
      reportTime = make_shared<string>(boost::any_cast<string>(m["ReportTime"]));
    }
    if (m.find("LatencyTopNItems") != m.end() && !m["LatencyTopNItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["LatencyTopNItems"].type()) {
        DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LatencyTopNItems"]));
        latencyTopNItems = make_shared<DescribeSQLLogReportsResponseBodyItemsItemLatencyTopNItems>(model1);
      }
    }
    if (m.find("QPSTopNItems") != m.end() && !m["QPSTopNItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["QPSTopNItems"].type()) {
        DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QPSTopNItems"]));
        QPSTopNItems = make_shared<DescribeSQLLogReportsResponseBodyItemsItemQPSTopNItems>(model1);
      }
    }
  }


  virtual ~DescribeSQLLogReportsResponseBodyItemsItem() = default;
};
class DescribeSQLLogReportsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSQLLogReportsResponseBodyItemsItem>> item{};

  DescribeSQLLogReportsResponseBodyItems() {}

  explicit DescribeSQLLogReportsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<DescribeSQLLogReportsResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSQLLogReportsResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<DescribeSQLLogReportsResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~DescribeSQLLogReportsResponseBodyItems() = default;
};
class DescribeSQLLogReportsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeSQLLogReportsResponseBodyItems> items{};

  DescribeSQLLogReportsResponseBody() {}

  explicit DescribeSQLLogReportsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeSQLLogReportsResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeSQLLogReportsResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeSQLLogReportsResponseBody() = default;
};
class DescribeSQLLogReportsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSQLLogReportsResponseBody> body{};

  DescribeSQLLogReportsResponse() {}

  explicit DescribeSQLLogReportsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSQLLogReportsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSQLLogReportsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSQLLogReportsResponse() = default;
};
class DescribeTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> proxyId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> tags{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceType{};

  DescribeTagsRequest() {}

  explicit DescribeTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (proxyId) {
      res["proxyId"] = boost::any(*proxyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("proxyId") != m.end() && !m["proxyId"].empty()) {
      proxyId = make_shared<string>(boost::any_cast<string>(m["proxyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeTagsRequest() = default;
};
class DescribeTagsResponseBodyItemsTagInfosDBInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> DBInstanceIds{};

  DescribeTagsResponseBodyItemsTagInfosDBInstanceIds() {}

  explicit DescribeTagsResponseBodyItemsTagInfosDBInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceIds) {
      res["DBInstanceIds"] = boost::any(*DBInstanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceIds") != m.end() && !m["DBInstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DBInstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DBInstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      DBInstanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeTagsResponseBodyItemsTagInfosDBInstanceIds() = default;
};
class DescribeTagsResponseBodyItemsTagInfos : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};
  shared_ptr<DescribeTagsResponseBodyItemsTagInfosDBInstanceIds> DBInstanceIds{};

  DescribeTagsResponseBodyItemsTagInfos() {}

  explicit DescribeTagsResponseBodyItemsTagInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (DBInstanceIds) {
      res["DBInstanceIds"] = DBInstanceIds ? boost::any(DBInstanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("DBInstanceIds") != m.end() && !m["DBInstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DBInstanceIds"].type()) {
        DescribeTagsResponseBodyItemsTagInfosDBInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DBInstanceIds"]));
        DBInstanceIds = make_shared<DescribeTagsResponseBodyItemsTagInfosDBInstanceIds>(model1);
      }
    }
  }


  virtual ~DescribeTagsResponseBodyItemsTagInfos() = default;
};
class DescribeTagsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTagsResponseBodyItemsTagInfos>> tagInfos{};

  DescribeTagsResponseBodyItems() {}

  explicit DescribeTagsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagInfos) {
      vector<boost::any> temp1;
      for(auto item1:*tagInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagInfos") != m.end() && !m["TagInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["TagInfos"].type()) {
        vector<DescribeTagsResponseBodyItemsTagInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagsResponseBodyItemsTagInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagInfos = make_shared<vector<DescribeTagsResponseBodyItemsTagInfos>>(expect1);
      }
    }
  }


  virtual ~DescribeTagsResponseBodyItems() = default;
};
class DescribeTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTagsResponseBodyItems> items{};

  DescribeTagsResponseBody() {}

  explicit DescribeTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeTagsResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeTagsResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeTagsResponseBody() = default;
};
class DescribeTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeTagsResponseBody> body{};

  DescribeTagsResponse() {}

  explicit DescribeTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagsResponse() = default;
};
class DescribeTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> status{};
  shared_ptr<string> taskAction{};
  shared_ptr<string> ownerAccount{};

  DescribeTasksRequest() {}

  explicit DescribeTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskAction) {
      res["TaskAction"] = boost::any(*taskAction);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskAction") != m.end() && !m["TaskAction"].empty()) {
      taskAction = make_shared<string>(boost::any_cast<string>(m["TaskAction"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DescribeTasksRequest() = default;
};
class DescribeTasksResponseBodyItemsTaskProgressInfo : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> progress{};
  shared_ptr<string> stepsInfo{};
  shared_ptr<string> beginTime{};
  shared_ptr<string> expectedFinishTime{};
  shared_ptr<string> taskErrorCode{};
  shared_ptr<string> currentStepName{};
  shared_ptr<string> progressInfo{};
  shared_ptr<string> stepProgressInfo{};
  shared_ptr<string> taskErrorMessage{};
  shared_ptr<string> taskAction{};
  shared_ptr<long> remain{};
  shared_ptr<string> DBName{};
  shared_ptr<string> taskId{};

  DescribeTasksResponseBodyItemsTaskProgressInfo() {}

  explicit DescribeTasksResponseBodyItemsTaskProgressInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (stepsInfo) {
      res["StepsInfo"] = boost::any(*stepsInfo);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (expectedFinishTime) {
      res["ExpectedFinishTime"] = boost::any(*expectedFinishTime);
    }
    if (taskErrorCode) {
      res["TaskErrorCode"] = boost::any(*taskErrorCode);
    }
    if (currentStepName) {
      res["CurrentStepName"] = boost::any(*currentStepName);
    }
    if (progressInfo) {
      res["ProgressInfo"] = boost::any(*progressInfo);
    }
    if (stepProgressInfo) {
      res["StepProgressInfo"] = boost::any(*stepProgressInfo);
    }
    if (taskErrorMessage) {
      res["TaskErrorMessage"] = boost::any(*taskErrorMessage);
    }
    if (taskAction) {
      res["TaskAction"] = boost::any(*taskAction);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("StepsInfo") != m.end() && !m["StepsInfo"].empty()) {
      stepsInfo = make_shared<string>(boost::any_cast<string>(m["StepsInfo"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
    if (m.find("ExpectedFinishTime") != m.end() && !m["ExpectedFinishTime"].empty()) {
      expectedFinishTime = make_shared<string>(boost::any_cast<string>(m["ExpectedFinishTime"]));
    }
    if (m.find("TaskErrorCode") != m.end() && !m["TaskErrorCode"].empty()) {
      taskErrorCode = make_shared<string>(boost::any_cast<string>(m["TaskErrorCode"]));
    }
    if (m.find("CurrentStepName") != m.end() && !m["CurrentStepName"].empty()) {
      currentStepName = make_shared<string>(boost::any_cast<string>(m["CurrentStepName"]));
    }
    if (m.find("ProgressInfo") != m.end() && !m["ProgressInfo"].empty()) {
      progressInfo = make_shared<string>(boost::any_cast<string>(m["ProgressInfo"]));
    }
    if (m.find("StepProgressInfo") != m.end() && !m["StepProgressInfo"].empty()) {
      stepProgressInfo = make_shared<string>(boost::any_cast<string>(m["StepProgressInfo"]));
    }
    if (m.find("TaskErrorMessage") != m.end() && !m["TaskErrorMessage"].empty()) {
      taskErrorMessage = make_shared<string>(boost::any_cast<string>(m["TaskErrorMessage"]));
    }
    if (m.find("TaskAction") != m.end() && !m["TaskAction"].empty()) {
      taskAction = make_shared<string>(boost::any_cast<string>(m["TaskAction"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeTasksResponseBodyItemsTaskProgressInfo() = default;
};
class DescribeTasksResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTasksResponseBodyItemsTaskProgressInfo>> taskProgressInfo{};

  DescribeTasksResponseBodyItems() {}

  explicit DescribeTasksResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskProgressInfo) {
      vector<boost::any> temp1;
      for(auto item1:*taskProgressInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskProgressInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskProgressInfo") != m.end() && !m["TaskProgressInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskProgressInfo"].type()) {
        vector<DescribeTasksResponseBodyItemsTaskProgressInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskProgressInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTasksResponseBodyItemsTaskProgressInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskProgressInfo = make_shared<vector<DescribeTasksResponseBodyItemsTaskProgressInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeTasksResponseBodyItems() = default;
};
class DescribeTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<long> totalRecordCount{};
  shared_ptr<DescribeTasksResponseBodyItems> items{};

  DescribeTasksResponseBody() {}

  explicit DescribeTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        DescribeTasksResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<DescribeTasksResponseBodyItems>(model1);
      }
    }
  }


  virtual ~DescribeTasksResponseBody() = default;
};
class DescribeTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeTasksResponseBody> body{};

  DescribeTasksResponse() {}

  explicit DescribeTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTasksResponse() = default;
};
class DescribeVSwitchesRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeVSwitchesRequest() {}

  explicit DescribeVSwitchesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeVSwitchesRequest() = default;
};
class DescribeVSwitchesResponseBodyVSwitchs : public Darabonba::Model {
public:
  shared_ptr<string> aliUid{};
  shared_ptr<string> bid{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> izNo{};
  shared_ptr<string> regionNo{};
  shared_ptr<string> status{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};

  DescribeVSwitchesResponseBodyVSwitchs() {}

  explicit DescribeVSwitchesResponseBodyVSwitchs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (izNo) {
      res["IzNo"] = boost::any(*izNo);
    }
    if (regionNo) {
      res["RegionNo"] = boost::any(*regionNo);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("IzNo") != m.end() && !m["IzNo"].empty()) {
      izNo = make_shared<string>(boost::any_cast<string>(m["IzNo"]));
    }
    if (m.find("RegionNo") != m.end() && !m["RegionNo"].empty()) {
      regionNo = make_shared<string>(boost::any_cast<string>(m["RegionNo"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitchs() = default;
};
class DescribeVSwitchesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeVSwitchesResponseBodyVSwitchs>> vSwitchs{};

  DescribeVSwitchesResponseBody() {}

  explicit DescribeVSwitchesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (vSwitchs) {
      vector<boost::any> temp1;
      for(auto item1:*vSwitchs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VSwitchs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("VSwitchs") != m.end() && !m["VSwitchs"].empty()) {
      if (typeid(vector<boost::any>) == m["VSwitchs"].type()) {
        vector<DescribeVSwitchesResponseBodyVSwitchs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VSwitchs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVSwitchesResponseBodyVSwitchs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vSwitchs = make_shared<vector<DescribeVSwitchesResponseBodyVSwitchs>>(expect1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponseBody() = default;
};
class DescribeVSwitchesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVSwitchesResponseBody> body{};

  DescribeVSwitchesResponse() {}

  explicit DescribeVSwitchesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVSwitchesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVSwitchesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponse() = default;
};
class DestroyDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> ownerAccount{};

  DestroyDBInstanceRequest() {}

  explicit DestroyDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DestroyDBInstanceRequest() = default;
};
class DestroyDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DestroyDBInstanceResponseBody() {}

  explicit DestroyDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DestroyDBInstanceResponseBody() = default;
};
class DestroyDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DestroyDBInstanceResponseBody> body{};

  DestroyDBInstanceResponse() {}

  explicit DestroyDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DestroyDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DestroyDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DestroyDBInstanceResponse() = default;
};
class DropDedicatedHostUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> dedicatedHostName{};
  shared_ptr<string> userName{};
  shared_ptr<string> regionId{};

  DropDedicatedHostUserRequest() {}

  explicit DropDedicatedHostUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (dedicatedHostName) {
      res["DedicatedHostName"] = boost::any(*dedicatedHostName);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DedicatedHostName") != m.end() && !m["DedicatedHostName"].empty()) {
      dedicatedHostName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostName"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DropDedicatedHostUserRequest() = default;
};
class DropDedicatedHostUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DropDedicatedHostUserResponseBody() {}

  explicit DropDedicatedHostUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DropDedicatedHostUserResponseBody() = default;
};
class DropDedicatedHostUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DropDedicatedHostUserResponseBody> body{};

  DropDedicatedHostUserResponse() {}

  explicit DropDedicatedHostUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DropDedicatedHostUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DropDedicatedHostUserResponseBody>(model1);
      }
    }
  }


  virtual ~DropDedicatedHostUserResponse() = default;
};
class EvaluateDedicatedHostInstanceResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> diskType{};
  shared_ptr<string> diskSize{};
  shared_ptr<string> instanceClassNames{};
  shared_ptr<string> engine{};
  shared_ptr<string> engineVersion{};

  EvaluateDedicatedHostInstanceResourceRequest() {}

  explicit EvaluateDedicatedHostInstanceResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (instanceClassNames) {
      res["InstanceClassNames"] = boost::any(*instanceClassNames);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<string>(boost::any_cast<string>(m["DiskSize"]));
    }
    if (m.find("InstanceClassNames") != m.end() && !m["InstanceClassNames"].empty()) {
      instanceClassNames = make_shared<string>(boost::any_cast<string>(m["InstanceClassNames"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
  }


  virtual ~EvaluateDedicatedHostInstanceResourceRequest() = default;
};
class EvaluateDedicatedHostInstanceResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<long> available{};

  EvaluateDedicatedHostInstanceResourceResponseBody() {}

  explicit EvaluateDedicatedHostInstanceResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (available) {
      res["Available"] = boost::any(*available);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("Available") != m.end() && !m["Available"].empty()) {
      available = make_shared<long>(boost::any_cast<long>(m["Available"]));
    }
  }


  virtual ~EvaluateDedicatedHostInstanceResourceResponseBody() = default;
};
class EvaluateDedicatedHostInstanceResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EvaluateDedicatedHostInstanceResourceResponseBody> body{};

  EvaluateDedicatedHostInstanceResourceResponse() {}

  explicit EvaluateDedicatedHostInstanceResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EvaluateDedicatedHostInstanceResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EvaluateDedicatedHostInstanceResourceResponseBody>(model1);
      }
    }
  }


  virtual ~EvaluateDedicatedHostInstanceResourceResponse() = default;
};
class GetDbProxyInstanceSslRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> dbInstanceId{};

  GetDbProxyInstanceSslRequest() {}

  explicit GetDbProxyInstanceSslRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dbInstanceId) {
      res["DbInstanceId"] = boost::any(*dbInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DbInstanceId") != m.end() && !m["DbInstanceId"].empty()) {
      dbInstanceId = make_shared<string>(boost::any_cast<string>(m["DbInstanceId"]));
    }
  }


  virtual ~GetDbProxyInstanceSslRequest() = default;
};
class GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems : public Darabonba::Model {
public:
  shared_ptr<string> dbInstanceName{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointType{};
  shared_ptr<string> sslExpiredTime{};
  shared_ptr<string> certCommonName{};

  GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems() {}

  explicit GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbInstanceName) {
      res["DbInstanceName"] = boost::any(*dbInstanceName);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    if (sslExpiredTime) {
      res["SslExpiredTime"] = boost::any(*sslExpiredTime);
    }
    if (certCommonName) {
      res["CertCommonName"] = boost::any(*certCommonName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbInstanceName") != m.end() && !m["DbInstanceName"].empty()) {
      dbInstanceName = make_shared<string>(boost::any_cast<string>(m["DbInstanceName"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
    if (m.find("SslExpiredTime") != m.end() && !m["SslExpiredTime"].empty()) {
      sslExpiredTime = make_shared<string>(boost::any_cast<string>(m["SslExpiredTime"]));
    }
    if (m.find("CertCommonName") != m.end() && !m["CertCommonName"].empty()) {
      certCommonName = make_shared<string>(boost::any_cast<string>(m["CertCommonName"]));
    }
  }


  virtual ~GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems() = default;
};
class GetDbProxyInstanceSslResponseBodyDbProxyCertListItems : public Darabonba::Model {
public:
  shared_ptr<vector<GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems>> dbProxyCertListItems{};

  GetDbProxyInstanceSslResponseBodyDbProxyCertListItems() {}

  explicit GetDbProxyInstanceSslResponseBodyDbProxyCertListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbProxyCertListItems) {
      vector<boost::any> temp1;
      for(auto item1:*dbProxyCertListItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DbProxyCertListItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbProxyCertListItems") != m.end() && !m["DbProxyCertListItems"].empty()) {
      if (typeid(vector<boost::any>) == m["DbProxyCertListItems"].type()) {
        vector<GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DbProxyCertListItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dbProxyCertListItems = make_shared<vector<GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems>>(expect1);
      }
    }
  }


  virtual ~GetDbProxyInstanceSslResponseBodyDbProxyCertListItems() = default;
};
class GetDbProxyInstanceSslResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetDbProxyInstanceSslResponseBodyDbProxyCertListItems> dbProxyCertListItems{};

  GetDbProxyInstanceSslResponseBody() {}

  explicit GetDbProxyInstanceSslResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dbProxyCertListItems) {
      res["DbProxyCertListItems"] = dbProxyCertListItems ? boost::any(dbProxyCertListItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DbProxyCertListItems") != m.end() && !m["DbProxyCertListItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["DbProxyCertListItems"].type()) {
        GetDbProxyInstanceSslResponseBodyDbProxyCertListItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DbProxyCertListItems"]));
        dbProxyCertListItems = make_shared<GetDbProxyInstanceSslResponseBodyDbProxyCertListItems>(model1);
      }
    }
  }


  virtual ~GetDbProxyInstanceSslResponseBody() = default;
};
class GetDbProxyInstanceSslResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDbProxyInstanceSslResponseBody> body{};

  GetDbProxyInstanceSslResponse() {}

  explicit GetDbProxyInstanceSslResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDbProxyInstanceSslResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDbProxyInstanceSslResponseBody>(model1);
      }
    }
  }


  virtual ~GetDbProxyInstanceSslResponse() = default;
};
class GrantAccountPrivilegeRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> DBName{};
  shared_ptr<string> accountPrivilege{};

  GrantAccountPrivilegeRequest() {}

  explicit GrantAccountPrivilegeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (accountPrivilege) {
      res["AccountPrivilege"] = boost::any(*accountPrivilege);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("AccountPrivilege") != m.end() && !m["AccountPrivilege"].empty()) {
      accountPrivilege = make_shared<string>(boost::any_cast<string>(m["AccountPrivilege"]));
    }
  }


  virtual ~GrantAccountPrivilegeRequest() = default;
};
class GrantAccountPrivilegeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  GrantAccountPrivilegeResponseBody() {}

  explicit GrantAccountPrivilegeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GrantAccountPrivilegeResponseBody() = default;
};
class GrantAccountPrivilegeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GrantAccountPrivilegeResponseBody> body{};

  GrantAccountPrivilegeResponse() {}

  explicit GrantAccountPrivilegeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantAccountPrivilegeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantAccountPrivilegeResponseBody>(model1);
      }
    }
  }


  virtual ~GrantAccountPrivilegeResponse() = default;
};
class GrantOperatorPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> privileges{};
  shared_ptr<string> ownerAccount{};

  GrantOperatorPermissionRequest() {}

  explicit GrantOperatorPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (privileges) {
      res["Privileges"] = boost::any(*privileges);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("Privileges") != m.end() && !m["Privileges"].empty()) {
      privileges = make_shared<string>(boost::any_cast<string>(m["Privileges"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~GrantOperatorPermissionRequest() = default;
};
class GrantOperatorPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  GrantOperatorPermissionResponseBody() {}

  explicit GrantOperatorPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GrantOperatorPermissionResponseBody() = default;
};
class GrantOperatorPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GrantOperatorPermissionResponseBody> body{};

  GrantOperatorPermissionResponse() {}

  explicit GrantOperatorPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantOperatorPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantOperatorPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~GrantOperatorPermissionResponse() = default;
};
class ImportDatabaseBetweenInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> sourceDBInstanceId{};
  shared_ptr<string> DBInfo{};
  shared_ptr<string> ownerAccount{};

  ImportDatabaseBetweenInstancesRequest() {}

  explicit ImportDatabaseBetweenInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (sourceDBInstanceId) {
      res["SourceDBInstanceId"] = boost::any(*sourceDBInstanceId);
    }
    if (DBInfo) {
      res["DBInfo"] = boost::any(*DBInfo);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("SourceDBInstanceId") != m.end() && !m["SourceDBInstanceId"].empty()) {
      sourceDBInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceDBInstanceId"]));
    }
    if (m.find("DBInfo") != m.end() && !m["DBInfo"].empty()) {
      DBInfo = make_shared<string>(boost::any_cast<string>(m["DBInfo"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ImportDatabaseBetweenInstancesRequest() = default;
};
class ImportDatabaseBetweenInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> importId{};
  shared_ptr<string> requestId{};

  ImportDatabaseBetweenInstancesResponseBody() {}

  explicit ImportDatabaseBetweenInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (importId) {
      res["ImportId"] = boost::any(*importId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImportId") != m.end() && !m["ImportId"].empty()) {
      importId = make_shared<string>(boost::any_cast<string>(m["ImportId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportDatabaseBetweenInstancesResponseBody() = default;
};
class ImportDatabaseBetweenInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ImportDatabaseBetweenInstancesResponseBody> body{};

  ImportDatabaseBetweenInstancesResponse() {}

  explicit ImportDatabaseBetweenInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportDatabaseBetweenInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportDatabaseBetweenInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ImportDatabaseBetweenInstancesResponse() = default;
};
class ImportUserBackupFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> bucketRegion{};
  shared_ptr<string> backupFile{};
  shared_ptr<string> comment{};
  shared_ptr<long> restoreSize{};
  shared_ptr<long> retention{};
  shared_ptr<string> zoneId{};

  ImportUserBackupFileRequest() {}

  explicit ImportUserBackupFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (bucketRegion) {
      res["BucketRegion"] = boost::any(*bucketRegion);
    }
    if (backupFile) {
      res["BackupFile"] = boost::any(*backupFile);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (restoreSize) {
      res["RestoreSize"] = boost::any(*restoreSize);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("BucketRegion") != m.end() && !m["BucketRegion"].empty()) {
      bucketRegion = make_shared<string>(boost::any_cast<string>(m["BucketRegion"]));
    }
    if (m.find("BackupFile") != m.end() && !m["BackupFile"].empty()) {
      backupFile = make_shared<string>(boost::any_cast<string>(m["BackupFile"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("RestoreSize") != m.end() && !m["RestoreSize"].empty()) {
      restoreSize = make_shared<long>(boost::any_cast<long>(m["RestoreSize"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ImportUserBackupFileRequest() = default;
};
class ImportUserBackupFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> status{};
  shared_ptr<string> requestId{};
  shared_ptr<string> backupId{};

  ImportUserBackupFileResponseBody() {}

  explicit ImportUserBackupFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
  }


  virtual ~ImportUserBackupFileResponseBody() = default;
};
class ImportUserBackupFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ImportUserBackupFileResponseBody> body{};

  ImportUserBackupFileResponse() {}

  explicit ImportUserBackupFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportUserBackupFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportUserBackupFileResponseBody>(model1);
      }
    }
  }


  virtual ~ImportUserBackupFileResponse() = default;
};
class ListClassesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> orderType{};
  shared_ptr<string> regionId{};

  ListClassesRequest() {}

  explicit ListClassesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListClassesRequest() = default;
};
class ListClassesResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<string> maxIOPS{};
  shared_ptr<string> cpu{};
  shared_ptr<string> referencePrice{};
  shared_ptr<string> maxConnections{};
  shared_ptr<string> memoryClass{};
  shared_ptr<string> classCode{};
  shared_ptr<string> classGroup{};
  shared_ptr<string> maxIOMBPS{};

  ListClassesResponseBodyItems() {}

  explicit ListClassesResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxIOPS) {
      res["MaxIOPS"] = boost::any(*maxIOPS);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (referencePrice) {
      res["ReferencePrice"] = boost::any(*referencePrice);
    }
    if (maxConnections) {
      res["MaxConnections"] = boost::any(*maxConnections);
    }
    if (memoryClass) {
      res["MemoryClass"] = boost::any(*memoryClass);
    }
    if (classCode) {
      res["ClassCode"] = boost::any(*classCode);
    }
    if (classGroup) {
      res["ClassGroup"] = boost::any(*classGroup);
    }
    if (maxIOMBPS) {
      res["MaxIOMBPS"] = boost::any(*maxIOMBPS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxIOPS") != m.end() && !m["MaxIOPS"].empty()) {
      maxIOPS = make_shared<string>(boost::any_cast<string>(m["MaxIOPS"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<string>(boost::any_cast<string>(m["Cpu"]));
    }
    if (m.find("ReferencePrice") != m.end() && !m["ReferencePrice"].empty()) {
      referencePrice = make_shared<string>(boost::any_cast<string>(m["ReferencePrice"]));
    }
    if (m.find("MaxConnections") != m.end() && !m["MaxConnections"].empty()) {
      maxConnections = make_shared<string>(boost::any_cast<string>(m["MaxConnections"]));
    }
    if (m.find("MemoryClass") != m.end() && !m["MemoryClass"].empty()) {
      memoryClass = make_shared<string>(boost::any_cast<string>(m["MemoryClass"]));
    }
    if (m.find("ClassCode") != m.end() && !m["ClassCode"].empty()) {
      classCode = make_shared<string>(boost::any_cast<string>(m["ClassCode"]));
    }
    if (m.find("ClassGroup") != m.end() && !m["ClassGroup"].empty()) {
      classGroup = make_shared<string>(boost::any_cast<string>(m["ClassGroup"]));
    }
    if (m.find("MaxIOMBPS") != m.end() && !m["MaxIOMBPS"].empty()) {
      maxIOMBPS = make_shared<string>(boost::any_cast<string>(m["MaxIOMBPS"]));
    }
  }


  virtual ~ListClassesResponseBodyItems() = default;
};
class ListClassesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ListClassesResponseBodyItems>> items{};

  ListClassesResponseBody() {}

  explicit ListClassesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<ListClassesResponseBodyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClassesResponseBodyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListClassesResponseBodyItems>>(expect1);
      }
    }
  }


  virtual ~ListClassesResponseBody() = default;
};
class ListClassesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClassesResponseBody> body{};

  ListClassesResponse() {}

  explicit ListClassesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClassesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClassesResponseBody>(model1);
      }
    }
  }


  virtual ~ListClassesResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> tagKey{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListUserBackupFilesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<string> regionId{};
  shared_ptr<string> comment{};
  shared_ptr<string> backupId{};
  shared_ptr<string> ossUrl{};
  shared_ptr<string> tags{};

  ListUserBackupFilesRequest() {}

  explicit ListUserBackupFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~ListUserBackupFilesRequest() = default;
};
class ListUserBackupFilesResponseBodyRecords : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> comment{};
  shared_ptr<string> ossFilePath{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> modificationTime{};
  shared_ptr<long> ossFileSize{};
  shared_ptr<string> ossFileName{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> backupId{};
  shared_ptr<string> restoreSize{};
  shared_ptr<string> zoneId{};
  shared_ptr<long> retention{};
  shared_ptr<string> engine{};
  shared_ptr<string> ossUrl{};
  shared_ptr<string> ossFileMetaData{};
  shared_ptr<string> binlogInfo{};
  shared_ptr<string> reason{};

  ListUserBackupFilesResponseBodyRecords() {}

  explicit ListUserBackupFilesResponseBodyRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ossFilePath) {
      res["OssFilePath"] = boost::any(*ossFilePath);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (ossFileSize) {
      res["OssFileSize"] = boost::any(*ossFileSize);
    }
    if (ossFileName) {
      res["OssFileName"] = boost::any(*ossFileName);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (restoreSize) {
      res["RestoreSize"] = boost::any(*restoreSize);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    if (ossFileMetaData) {
      res["OssFileMetaData"] = boost::any(*ossFileMetaData);
    }
    if (binlogInfo) {
      res["BinlogInfo"] = boost::any(*binlogInfo);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("OssFilePath") != m.end() && !m["OssFilePath"].empty()) {
      ossFilePath = make_shared<string>(boost::any_cast<string>(m["OssFilePath"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("OssFileSize") != m.end() && !m["OssFileSize"].empty()) {
      ossFileSize = make_shared<long>(boost::any_cast<long>(m["OssFileSize"]));
    }
    if (m.find("OssFileName") != m.end() && !m["OssFileName"].empty()) {
      ossFileName = make_shared<string>(boost::any_cast<string>(m["OssFileName"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("RestoreSize") != m.end() && !m["RestoreSize"].empty()) {
      restoreSize = make_shared<string>(boost::any_cast<string>(m["RestoreSize"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
    if (m.find("OssFileMetaData") != m.end() && !m["OssFileMetaData"].empty()) {
      ossFileMetaData = make_shared<string>(boost::any_cast<string>(m["OssFileMetaData"]));
    }
    if (m.find("BinlogInfo") != m.end() && !m["BinlogInfo"].empty()) {
      binlogInfo = make_shared<string>(boost::any_cast<string>(m["BinlogInfo"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~ListUserBackupFilesResponseBodyRecords() = default;
};
class ListUserBackupFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListUserBackupFilesResponseBodyRecords>> records{};

  ListUserBackupFilesResponseBody() {}

  explicit ListUserBackupFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<ListUserBackupFilesResponseBodyRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserBackupFilesResponseBodyRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<ListUserBackupFilesResponseBodyRecords>>(expect1);
      }
    }
  }


  virtual ~ListUserBackupFilesResponseBody() = default;
};
class ListUserBackupFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListUserBackupFilesResponseBody> body{};

  ListUserBackupFilesResponse() {}

  explicit ListUserBackupFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserBackupFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserBackupFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserBackupFilesResponse() = default;
};
class LockAccountRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> accountName{};

  LockAccountRequest() {}

  explicit LockAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
  }


  virtual ~LockAccountRequest() = default;
};
class LockAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  LockAccountResponseBody() {}

  explicit LockAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~LockAccountResponseBody() = default;
};
class LockAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<LockAccountResponseBody> body{};

  LockAccountResponse() {}

  explicit LockAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LockAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LockAccountResponseBody>(model1);
      }
    }
  }


  virtual ~LockAccountResponse() = default;
};
class MigrateDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> targetDedicatedHostIdForMaster{};
  shared_ptr<string> targetDedicatedHostIdForSlave{};
  shared_ptr<string> effectiveTime{};
  shared_ptr<string> specifiedTime{};
  shared_ptr<string> zoneIdForLog{};
  shared_ptr<string> zoneIdForFollower{};

  MigrateDBInstanceRequest() {}

  explicit MigrateDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (targetDedicatedHostIdForMaster) {
      res["TargetDedicatedHostIdForMaster"] = boost::any(*targetDedicatedHostIdForMaster);
    }
    if (targetDedicatedHostIdForSlave) {
      res["TargetDedicatedHostIdForSlave"] = boost::any(*targetDedicatedHostIdForSlave);
    }
    if (effectiveTime) {
      res["EffectiveTime"] = boost::any(*effectiveTime);
    }
    if (specifiedTime) {
      res["SpecifiedTime"] = boost::any(*specifiedTime);
    }
    if (zoneIdForLog) {
      res["ZoneIdForLog"] = boost::any(*zoneIdForLog);
    }
    if (zoneIdForFollower) {
      res["ZoneIdForFollower"] = boost::any(*zoneIdForFollower);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("TargetDedicatedHostIdForMaster") != m.end() && !m["TargetDedicatedHostIdForMaster"].empty()) {
      targetDedicatedHostIdForMaster = make_shared<string>(boost::any_cast<string>(m["TargetDedicatedHostIdForMaster"]));
    }
    if (m.find("TargetDedicatedHostIdForSlave") != m.end() && !m["TargetDedicatedHostIdForSlave"].empty()) {
      targetDedicatedHostIdForSlave = make_shared<string>(boost::any_cast<string>(m["TargetDedicatedHostIdForSlave"]));
    }
    if (m.find("EffectiveTime") != m.end() && !m["EffectiveTime"].empty()) {
      effectiveTime = make_shared<string>(boost::any_cast<string>(m["EffectiveTime"]));
    }
    if (m.find("SpecifiedTime") != m.end() && !m["SpecifiedTime"].empty()) {
      specifiedTime = make_shared<string>(boost::any_cast<string>(m["SpecifiedTime"]));
    }
    if (m.find("ZoneIdForLog") != m.end() && !m["ZoneIdForLog"].empty()) {
      zoneIdForLog = make_shared<string>(boost::any_cast<string>(m["ZoneIdForLog"]));
    }
    if (m.find("ZoneIdForFollower") != m.end() && !m["ZoneIdForFollower"].empty()) {
      zoneIdForFollower = make_shared<string>(boost::any_cast<string>(m["ZoneIdForFollower"]));
    }
  }


  virtual ~MigrateDBInstanceRequest() = default;
};
class MigrateDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> taskId{};
  shared_ptr<long> migrationId{};

  MigrateDBInstanceResponseBody() {}

  explicit MigrateDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (migrationId) {
      res["MigrationId"] = boost::any(*migrationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("MigrationId") != m.end() && !m["MigrationId"].empty()) {
      migrationId = make_shared<long>(boost::any_cast<long>(m["MigrationId"]));
    }
  }


  virtual ~MigrateDBInstanceResponseBody() = default;
};
class MigrateDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<MigrateDBInstanceResponseBody> body{};

  MigrateDBInstanceResponse() {}

  explicit MigrateDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MigrateDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MigrateDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~MigrateDBInstanceResponse() = default;
};
class MigrateSecurityIPModeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};

  MigrateSecurityIPModeRequest() {}

  explicit MigrateSecurityIPModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~MigrateSecurityIPModeRequest() = default;
};
class MigrateSecurityIPModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> securityIPMode{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};

  MigrateSecurityIPModeResponseBody() {}

  explicit MigrateSecurityIPModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityIPMode) {
      res["SecurityIPMode"] = boost::any(*securityIPMode);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityIPMode") != m.end() && !m["SecurityIPMode"].empty()) {
      securityIPMode = make_shared<string>(boost::any_cast<string>(m["SecurityIPMode"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MigrateSecurityIPModeResponseBody() = default;
};
class MigrateSecurityIPModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<MigrateSecurityIPModeResponseBody> body{};

  MigrateSecurityIPModeResponse() {}

  explicit MigrateSecurityIPModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MigrateSecurityIPModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MigrateSecurityIPModeResponseBody>(model1);
      }
    }
  }


  virtual ~MigrateSecurityIPModeResponse() = default;
};
class MigrateToOtherZoneRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> effectiveTime{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> category{};
  shared_ptr<string> zoneIdSlave1{};
  shared_ptr<string> zoneIdSlave2{};

  MigrateToOtherZoneRequest() {}

  explicit MigrateToOtherZoneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (effectiveTime) {
      res["EffectiveTime"] = boost::any(*effectiveTime);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (zoneIdSlave1) {
      res["ZoneIdSlave1"] = boost::any(*zoneIdSlave1);
    }
    if (zoneIdSlave2) {
      res["ZoneIdSlave2"] = boost::any(*zoneIdSlave2);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("EffectiveTime") != m.end() && !m["EffectiveTime"].empty()) {
      effectiveTime = make_shared<string>(boost::any_cast<string>(m["EffectiveTime"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ZoneIdSlave1") != m.end() && !m["ZoneIdSlave1"].empty()) {
      zoneIdSlave1 = make_shared<string>(boost::any_cast<string>(m["ZoneIdSlave1"]));
    }
    if (m.find("ZoneIdSlave2") != m.end() && !m["ZoneIdSlave2"].empty()) {
      zoneIdSlave2 = make_shared<string>(boost::any_cast<string>(m["ZoneIdSlave2"]));
    }
  }


  virtual ~MigrateToOtherZoneRequest() = default;
};
class MigrateToOtherZoneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  MigrateToOtherZoneResponseBody() {}

  explicit MigrateToOtherZoneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MigrateToOtherZoneResponseBody() = default;
};
class MigrateToOtherZoneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<MigrateToOtherZoneResponseBody> body{};

  MigrateToOtherZoneResponse() {}

  explicit MigrateToOtherZoneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MigrateToOtherZoneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MigrateToOtherZoneResponseBody>(model1);
      }
    }
  }


  virtual ~MigrateToOtherZoneResponse() = default;
};
class ModifyAccountDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> accountDescription{};
  shared_ptr<string> ownerAccount{};

  ModifyAccountDescriptionRequest() {}

  explicit ModifyAccountDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountDescription) {
      res["AccountDescription"] = boost::any(*accountDescription);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountDescription") != m.end() && !m["AccountDescription"].empty()) {
      accountDescription = make_shared<string>(boost::any_cast<string>(m["AccountDescription"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyAccountDescriptionRequest() = default;
};
class ModifyAccountDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAccountDescriptionResponseBody() {}

  explicit ModifyAccountDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAccountDescriptionResponseBody() = default;
};
class ModifyAccountDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyAccountDescriptionResponseBody> body{};

  ModifyAccountDescriptionResponse() {}

  explicit ModifyAccountDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAccountDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAccountDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAccountDescriptionResponse() = default;
};
class ModifyActionEventPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> enableEventLog{};

  ModifyActionEventPolicyRequest() {}

  explicit ModifyActionEventPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (enableEventLog) {
      res["EnableEventLog"] = boost::any(*enableEventLog);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EnableEventLog") != m.end() && !m["EnableEventLog"].empty()) {
      enableEventLog = make_shared<string>(boost::any_cast<string>(m["EnableEventLog"]));
    }
  }


  virtual ~ModifyActionEventPolicyRequest() = default;
};
class ModifyActionEventPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> enableEventLog{};
  shared_ptr<string> requestId{};
  shared_ptr<string> regionId{};

  ModifyActionEventPolicyResponseBody() {}

  explicit ModifyActionEventPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableEventLog) {
      res["EnableEventLog"] = boost::any(*enableEventLog);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableEventLog") != m.end() && !m["EnableEventLog"].empty()) {
      enableEventLog = make_shared<string>(boost::any_cast<string>(m["EnableEventLog"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyActionEventPolicyResponseBody() = default;
};
class ModifyActionEventPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyActionEventPolicyResponseBody> body{};

  ModifyActionEventPolicyResponse() {}

  explicit ModifyActionEventPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyActionEventPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyActionEventPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyActionEventPolicyResponse() = default;
};
class ModifyBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> backupPolicyMode{};
  shared_ptr<string> preferredBackupTime{};
  shared_ptr<string> preferredBackupPeriod{};
  shared_ptr<string> backupRetentionPeriod{};
  shared_ptr<string> backupLog{};
  shared_ptr<string> logBackupRetentionPeriod{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> enableBackupLog{};
  shared_ptr<string> localLogRetentionHours{};
  shared_ptr<string> localLogRetentionSpace{};
  shared_ptr<string> highSpaceUsageProtection{};
  shared_ptr<string> logBackupFrequency{};
  shared_ptr<string> compressType{};
  shared_ptr<string> archiveBackupRetentionPeriod{};
  shared_ptr<string> archiveBackupKeepPolicy{};
  shared_ptr<long> archiveBackupKeepCount{};
  shared_ptr<string> releasedKeepPolicy{};
  shared_ptr<long> logBackupLocalRetentionNumber{};
  shared_ptr<string> category{};
  shared_ptr<string> backupInterval{};
  shared_ptr<string> backupMethod{};

  ModifyBackupPolicyRequest() {}

  explicit ModifyBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (backupPolicyMode) {
      res["BackupPolicyMode"] = boost::any(*backupPolicyMode);
    }
    if (preferredBackupTime) {
      res["PreferredBackupTime"] = boost::any(*preferredBackupTime);
    }
    if (preferredBackupPeriod) {
      res["PreferredBackupPeriod"] = boost::any(*preferredBackupPeriod);
    }
    if (backupRetentionPeriod) {
      res["BackupRetentionPeriod"] = boost::any(*backupRetentionPeriod);
    }
    if (backupLog) {
      res["BackupLog"] = boost::any(*backupLog);
    }
    if (logBackupRetentionPeriod) {
      res["LogBackupRetentionPeriod"] = boost::any(*logBackupRetentionPeriod);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (enableBackupLog) {
      res["EnableBackupLog"] = boost::any(*enableBackupLog);
    }
    if (localLogRetentionHours) {
      res["LocalLogRetentionHours"] = boost::any(*localLogRetentionHours);
    }
    if (localLogRetentionSpace) {
      res["LocalLogRetentionSpace"] = boost::any(*localLogRetentionSpace);
    }
    if (highSpaceUsageProtection) {
      res["HighSpaceUsageProtection"] = boost::any(*highSpaceUsageProtection);
    }
    if (logBackupFrequency) {
      res["LogBackupFrequency"] = boost::any(*logBackupFrequency);
    }
    if (compressType) {
      res["CompressType"] = boost::any(*compressType);
    }
    if (archiveBackupRetentionPeriod) {
      res["ArchiveBackupRetentionPeriod"] = boost::any(*archiveBackupRetentionPeriod);
    }
    if (archiveBackupKeepPolicy) {
      res["ArchiveBackupKeepPolicy"] = boost::any(*archiveBackupKeepPolicy);
    }
    if (archiveBackupKeepCount) {
      res["ArchiveBackupKeepCount"] = boost::any(*archiveBackupKeepCount);
    }
    if (releasedKeepPolicy) {
      res["ReleasedKeepPolicy"] = boost::any(*releasedKeepPolicy);
    }
    if (logBackupLocalRetentionNumber) {
      res["LogBackupLocalRetentionNumber"] = boost::any(*logBackupLocalRetentionNumber);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (backupInterval) {
      res["BackupInterval"] = boost::any(*backupInterval);
    }
    if (backupMethod) {
      res["BackupMethod"] = boost::any(*backupMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("BackupPolicyMode") != m.end() && !m["BackupPolicyMode"].empty()) {
      backupPolicyMode = make_shared<string>(boost::any_cast<string>(m["BackupPolicyMode"]));
    }
    if (m.find("PreferredBackupTime") != m.end() && !m["PreferredBackupTime"].empty()) {
      preferredBackupTime = make_shared<string>(boost::any_cast<string>(m["PreferredBackupTime"]));
    }
    if (m.find("PreferredBackupPeriod") != m.end() && !m["PreferredBackupPeriod"].empty()) {
      preferredBackupPeriod = make_shared<string>(boost::any_cast<string>(m["PreferredBackupPeriod"]));
    }
    if (m.find("BackupRetentionPeriod") != m.end() && !m["BackupRetentionPeriod"].empty()) {
      backupRetentionPeriod = make_shared<string>(boost::any_cast<string>(m["BackupRetentionPeriod"]));
    }
    if (m.find("BackupLog") != m.end() && !m["BackupLog"].empty()) {
      backupLog = make_shared<string>(boost::any_cast<string>(m["BackupLog"]));
    }
    if (m.find("LogBackupRetentionPeriod") != m.end() && !m["LogBackupRetentionPeriod"].empty()) {
      logBackupRetentionPeriod = make_shared<string>(boost::any_cast<string>(m["LogBackupRetentionPeriod"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("EnableBackupLog") != m.end() && !m["EnableBackupLog"].empty()) {
      enableBackupLog = make_shared<string>(boost::any_cast<string>(m["EnableBackupLog"]));
    }
    if (m.find("LocalLogRetentionHours") != m.end() && !m["LocalLogRetentionHours"].empty()) {
      localLogRetentionHours = make_shared<string>(boost::any_cast<string>(m["LocalLogRetentionHours"]));
    }
    if (m.find("LocalLogRetentionSpace") != m.end() && !m["LocalLogRetentionSpace"].empty()) {
      localLogRetentionSpace = make_shared<string>(boost::any_cast<string>(m["LocalLogRetentionSpace"]));
    }
    if (m.find("HighSpaceUsageProtection") != m.end() && !m["HighSpaceUsageProtection"].empty()) {
      highSpaceUsageProtection = make_shared<string>(boost::any_cast<string>(m["HighSpaceUsageProtection"]));
    }
    if (m.find("LogBackupFrequency") != m.end() && !m["LogBackupFrequency"].empty()) {
      logBackupFrequency = make_shared<string>(boost::any_cast<string>(m["LogBackupFrequency"]));
    }
    if (m.find("CompressType") != m.end() && !m["CompressType"].empty()) {
      compressType = make_shared<string>(boost::any_cast<string>(m["CompressType"]));
    }
    if (m.find("ArchiveBackupRetentionPeriod") != m.end() && !m["ArchiveBackupRetentionPeriod"].empty()) {
      archiveBackupRetentionPeriod = make_shared<string>(boost::any_cast<string>(m["ArchiveBackupRetentionPeriod"]));
    }
    if (m.find("ArchiveBackupKeepPolicy") != m.end() && !m["ArchiveBackupKeepPolicy"].empty()) {
      archiveBackupKeepPolicy = make_shared<string>(boost::any_cast<string>(m["ArchiveBackupKeepPolicy"]));
    }
    if (m.find("ArchiveBackupKeepCount") != m.end() && !m["ArchiveBackupKeepCount"].empty()) {
      archiveBackupKeepCount = make_shared<long>(boost::any_cast<long>(m["ArchiveBackupKeepCount"]));
    }
    if (m.find("ReleasedKeepPolicy") != m.end() && !m["ReleasedKeepPolicy"].empty()) {
      releasedKeepPolicy = make_shared<string>(boost::any_cast<string>(m["ReleasedKeepPolicy"]));
    }
    if (m.find("LogBackupLocalRetentionNumber") != m.end() && !m["LogBackupLocalRetentionNumber"].empty()) {
      logBackupLocalRetentionNumber = make_shared<long>(boost::any_cast<long>(m["LogBackupLocalRetentionNumber"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("BackupInterval") != m.end() && !m["BackupInterval"].empty()) {
      backupInterval = make_shared<string>(boost::any_cast<string>(m["BackupInterval"]));
    }
    if (m.find("BackupMethod") != m.end() && !m["BackupMethod"].empty()) {
      backupMethod = make_shared<string>(boost::any_cast<string>(m["BackupMethod"]));
    }
  }


  virtual ~ModifyBackupPolicyRequest() = default;
};
class ModifyBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> compressType{};
  shared_ptr<string> localLogRetentionSpace{};
  shared_ptr<long> logBackupLocalRetentionNumber{};
  shared_ptr<string> DBInstanceID{};
  shared_ptr<string> enableBackupLog{};
  shared_ptr<long> localLogRetentionHours{};
  shared_ptr<string> highSpaceUsageProtection{};

  ModifyBackupPolicyResponseBody() {}

  explicit ModifyBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (compressType) {
      res["CompressType"] = boost::any(*compressType);
    }
    if (localLogRetentionSpace) {
      res["LocalLogRetentionSpace"] = boost::any(*localLogRetentionSpace);
    }
    if (logBackupLocalRetentionNumber) {
      res["LogBackupLocalRetentionNumber"] = boost::any(*logBackupLocalRetentionNumber);
    }
    if (DBInstanceID) {
      res["DBInstanceID"] = boost::any(*DBInstanceID);
    }
    if (enableBackupLog) {
      res["EnableBackupLog"] = boost::any(*enableBackupLog);
    }
    if (localLogRetentionHours) {
      res["LocalLogRetentionHours"] = boost::any(*localLogRetentionHours);
    }
    if (highSpaceUsageProtection) {
      res["HighSpaceUsageProtection"] = boost::any(*highSpaceUsageProtection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CompressType") != m.end() && !m["CompressType"].empty()) {
      compressType = make_shared<string>(boost::any_cast<string>(m["CompressType"]));
    }
    if (m.find("LocalLogRetentionSpace") != m.end() && !m["LocalLogRetentionSpace"].empty()) {
      localLogRetentionSpace = make_shared<string>(boost::any_cast<string>(m["LocalLogRetentionSpace"]));
    }
    if (m.find("LogBackupLocalRetentionNumber") != m.end() && !m["LogBackupLocalRetentionNumber"].empty()) {
      logBackupLocalRetentionNumber = make_shared<long>(boost::any_cast<long>(m["LogBackupLocalRetentionNumber"]));
    }
    if (m.find("DBInstanceID") != m.end() && !m["DBInstanceID"].empty()) {
      DBInstanceID = make_shared<string>(boost::any_cast<string>(m["DBInstanceID"]));
    }
    if (m.find("EnableBackupLog") != m.end() && !m["EnableBackupLog"].empty()) {
      enableBackupLog = make_shared<string>(boost::any_cast<string>(m["EnableBackupLog"]));
    }
    if (m.find("LocalLogRetentionHours") != m.end() && !m["LocalLogRetentionHours"].empty()) {
      localLogRetentionHours = make_shared<long>(boost::any_cast<long>(m["LocalLogRetentionHours"]));
    }
    if (m.find("HighSpaceUsageProtection") != m.end() && !m["HighSpaceUsageProtection"].empty()) {
      highSpaceUsageProtection = make_shared<string>(boost::any_cast<string>(m["HighSpaceUsageProtection"]));
    }
  }


  virtual ~ModifyBackupPolicyResponseBody() = default;
};
class ModifyBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyBackupPolicyResponseBody> body{};

  ModifyBackupPolicyResponse() {}

  explicit ModifyBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBackupPolicyResponse() = default;
};
class ModifyCollationTimeZoneRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> collation{};
  shared_ptr<string> timezone{};

  ModifyCollationTimeZoneRequest() {}

  explicit ModifyCollationTimeZoneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (collation) {
      res["Collation"] = boost::any(*collation);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Collation") != m.end() && !m["Collation"].empty()) {
      collation = make_shared<string>(boost::any_cast<string>(m["Collation"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
  }


  virtual ~ModifyCollationTimeZoneRequest() = default;
};
class ModifyCollationTimeZoneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> collation{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> timezone{};
  shared_ptr<string> taskId{};

  ModifyCollationTimeZoneResponseBody() {}

  explicit ModifyCollationTimeZoneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collation) {
      res["Collation"] = boost::any(*collation);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Collation") != m.end() && !m["Collation"].empty()) {
      collation = make_shared<string>(boost::any_cast<string>(m["Collation"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ModifyCollationTimeZoneResponseBody() = default;
};
class ModifyCollationTimeZoneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyCollationTimeZoneResponseBody> body{};

  ModifyCollationTimeZoneResponse() {}

  explicit ModifyCollationTimeZoneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCollationTimeZoneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCollationTimeZoneResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCollationTimeZoneResponse() = default;
};
class ModifyDasInstanceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> storageAutoScale{};
  shared_ptr<long> storageThreshold{};
  shared_ptr<long> storageUpperBound{};

  ModifyDasInstanceConfigRequest() {}

  explicit ModifyDasInstanceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (storageAutoScale) {
      res["StorageAutoScale"] = boost::any(*storageAutoScale);
    }
    if (storageThreshold) {
      res["StorageThreshold"] = boost::any(*storageThreshold);
    }
    if (storageUpperBound) {
      res["StorageUpperBound"] = boost::any(*storageUpperBound);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("StorageAutoScale") != m.end() && !m["StorageAutoScale"].empty()) {
      storageAutoScale = make_shared<string>(boost::any_cast<string>(m["StorageAutoScale"]));
    }
    if (m.find("StorageThreshold") != m.end() && !m["StorageThreshold"].empty()) {
      storageThreshold = make_shared<long>(boost::any_cast<long>(m["StorageThreshold"]));
    }
    if (m.find("StorageUpperBound") != m.end() && !m["StorageUpperBound"].empty()) {
      storageUpperBound = make_shared<long>(boost::any_cast<long>(m["StorageUpperBound"]));
    }
  }


  virtual ~ModifyDasInstanceConfigRequest() = default;
};
class ModifyDasInstanceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDasInstanceConfigResponseBody() {}

  explicit ModifyDasInstanceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDasInstanceConfigResponseBody() = default;
};
class ModifyDasInstanceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDasInstanceConfigResponseBody> body{};

  ModifyDasInstanceConfigResponse() {}

  explicit ModifyDasInstanceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDasInstanceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDasInstanceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDasInstanceConfigResponse() = default;
};
class ModifyDBDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBName{};
  shared_ptr<string> DBDescription{};
  shared_ptr<string> ownerAccount{};

  ModifyDBDescriptionRequest() {}

  explicit ModifyDBDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (DBDescription) {
      res["DBDescription"] = boost::any(*DBDescription);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("DBDescription") != m.end() && !m["DBDescription"].empty()) {
      DBDescription = make_shared<string>(boost::any_cast<string>(m["DBDescription"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyDBDescriptionRequest() = default;
};
class ModifyDBDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBDescriptionResponseBody() {}

  explicit ModifyDBDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBDescriptionResponseBody() = default;
};
class ModifyDBDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBDescriptionResponseBody> body{};

  ModifyDBDescriptionResponse() {}

  explicit ModifyDBDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBDescriptionResponse() = default;
};
class ModifyDBInstanceAutoUpgradeMinorVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> autoUpgradeMinorVersion{};

  ModifyDBInstanceAutoUpgradeMinorVersionRequest() {}

  explicit ModifyDBInstanceAutoUpgradeMinorVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (autoUpgradeMinorVersion) {
      res["AutoUpgradeMinorVersion"] = boost::any(*autoUpgradeMinorVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AutoUpgradeMinorVersion") != m.end() && !m["AutoUpgradeMinorVersion"].empty()) {
      autoUpgradeMinorVersion = make_shared<string>(boost::any_cast<string>(m["AutoUpgradeMinorVersion"]));
    }
  }


  virtual ~ModifyDBInstanceAutoUpgradeMinorVersionRequest() = default;
};
class ModifyDBInstanceAutoUpgradeMinorVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBInstanceAutoUpgradeMinorVersionResponseBody() {}

  explicit ModifyDBInstanceAutoUpgradeMinorVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBInstanceAutoUpgradeMinorVersionResponseBody() = default;
};
class ModifyDBInstanceAutoUpgradeMinorVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceAutoUpgradeMinorVersionResponseBody> body{};

  ModifyDBInstanceAutoUpgradeMinorVersionResponse() {}

  explicit ModifyDBInstanceAutoUpgradeMinorVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceAutoUpgradeMinorVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceAutoUpgradeMinorVersionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceAutoUpgradeMinorVersionResponse() = default;
};
class ModifyDBInstanceConnectionModeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> connectionMode{};
  shared_ptr<string> ownerAccount{};

  ModifyDBInstanceConnectionModeRequest() {}

  explicit ModifyDBInstanceConnectionModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (connectionMode) {
      res["ConnectionMode"] = boost::any(*connectionMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ConnectionMode") != m.end() && !m["ConnectionMode"].empty()) {
      connectionMode = make_shared<string>(boost::any_cast<string>(m["ConnectionMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyDBInstanceConnectionModeRequest() = default;
};
class ModifyDBInstanceConnectionModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBInstanceConnectionModeResponseBody() {}

  explicit ModifyDBInstanceConnectionModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBInstanceConnectionModeResponseBody() = default;
};
class ModifyDBInstanceConnectionModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceConnectionModeResponseBody> body{};

  ModifyDBInstanceConnectionModeResponse() {}

  explicit ModifyDBInstanceConnectionModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceConnectionModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceConnectionModeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceConnectionModeResponse() = default;
};
class ModifyDBInstanceConnectionStringRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> currentConnectionString{};
  shared_ptr<string> connectionStringPrefix{};
  shared_ptr<string> port{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> generalGroupName{};

  ModifyDBInstanceConnectionStringRequest() {}

  explicit ModifyDBInstanceConnectionStringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (currentConnectionString) {
      res["CurrentConnectionString"] = boost::any(*currentConnectionString);
    }
    if (connectionStringPrefix) {
      res["ConnectionStringPrefix"] = boost::any(*connectionStringPrefix);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (generalGroupName) {
      res["GeneralGroupName"] = boost::any(*generalGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("CurrentConnectionString") != m.end() && !m["CurrentConnectionString"].empty()) {
      currentConnectionString = make_shared<string>(boost::any_cast<string>(m["CurrentConnectionString"]));
    }
    if (m.find("ConnectionStringPrefix") != m.end() && !m["ConnectionStringPrefix"].empty()) {
      connectionStringPrefix = make_shared<string>(boost::any_cast<string>(m["ConnectionStringPrefix"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("GeneralGroupName") != m.end() && !m["GeneralGroupName"].empty()) {
      generalGroupName = make_shared<string>(boost::any_cast<string>(m["GeneralGroupName"]));
    }
  }


  virtual ~ModifyDBInstanceConnectionStringRequest() = default;
};
class ModifyDBInstanceConnectionStringResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBInstanceConnectionStringResponseBody() {}

  explicit ModifyDBInstanceConnectionStringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBInstanceConnectionStringResponseBody() = default;
};
class ModifyDBInstanceConnectionStringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceConnectionStringResponseBody> body{};

  ModifyDBInstanceConnectionStringResponse() {}

  explicit ModifyDBInstanceConnectionStringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceConnectionStringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceConnectionStringResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceConnectionStringResponse() = default;
};
class ModifyDBInstanceDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBInstanceDescription{};
  shared_ptr<string> ownerAccount{};

  ModifyDBInstanceDescriptionRequest() {}

  explicit ModifyDBInstanceDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBInstanceDescription) {
      res["DBInstanceDescription"] = boost::any(*DBInstanceDescription);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBInstanceDescription") != m.end() && !m["DBInstanceDescription"].empty()) {
      DBInstanceDescription = make_shared<string>(boost::any_cast<string>(m["DBInstanceDescription"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyDBInstanceDescriptionRequest() = default;
};
class ModifyDBInstanceDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBInstanceDescriptionResponseBody() {}

  explicit ModifyDBInstanceDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBInstanceDescriptionResponseBody() = default;
};
class ModifyDBInstanceDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceDescriptionResponseBody> body{};

  ModifyDBInstanceDescriptionResponse() {}

  explicit ModifyDBInstanceDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceDescriptionResponse() = default;
};
class ModifyDBInstanceHAConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> syncMode{};
  shared_ptr<string> HAMode{};
  shared_ptr<string> dbInstanceId{};
  shared_ptr<string> ownerAccount{};

  ModifyDBInstanceHAConfigRequest() {}

  explicit ModifyDBInstanceHAConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (syncMode) {
      res["SyncMode"] = boost::any(*syncMode);
    }
    if (HAMode) {
      res["HAMode"] = boost::any(*HAMode);
    }
    if (dbInstanceId) {
      res["DbInstanceId"] = boost::any(*dbInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SyncMode") != m.end() && !m["SyncMode"].empty()) {
      syncMode = make_shared<string>(boost::any_cast<string>(m["SyncMode"]));
    }
    if (m.find("HAMode") != m.end() && !m["HAMode"].empty()) {
      HAMode = make_shared<string>(boost::any_cast<string>(m["HAMode"]));
    }
    if (m.find("DbInstanceId") != m.end() && !m["DbInstanceId"].empty()) {
      dbInstanceId = make_shared<string>(boost::any_cast<string>(m["DbInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyDBInstanceHAConfigRequest() = default;
};
class ModifyDBInstanceHAConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBInstanceHAConfigResponseBody() {}

  explicit ModifyDBInstanceHAConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBInstanceHAConfigResponseBody() = default;
};
class ModifyDBInstanceHAConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceHAConfigResponseBody> body{};

  ModifyDBInstanceHAConfigResponse() {}

  explicit ModifyDBInstanceHAConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceHAConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceHAConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceHAConfigResponse() = default;
};
class ModifyDBInstanceMaintainTimeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> maintainTime{};
  shared_ptr<string> ownerAccount{};

  ModifyDBInstanceMaintainTimeRequest() {}

  explicit ModifyDBInstanceMaintainTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (maintainTime) {
      res["MaintainTime"] = boost::any(*maintainTime);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("MaintainTime") != m.end() && !m["MaintainTime"].empty()) {
      maintainTime = make_shared<string>(boost::any_cast<string>(m["MaintainTime"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyDBInstanceMaintainTimeRequest() = default;
};
class ModifyDBInstanceMaintainTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBInstanceMaintainTimeResponseBody() {}

  explicit ModifyDBInstanceMaintainTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBInstanceMaintainTimeResponseBody() = default;
};
class ModifyDBInstanceMaintainTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceMaintainTimeResponseBody> body{};

  ModifyDBInstanceMaintainTimeResponse() {}

  explicit ModifyDBInstanceMaintainTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceMaintainTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceMaintainTimeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceMaintainTimeResponse() = default;
};
class ModifyDBInstanceMetricsRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceName{};
  shared_ptr<string> scope{};
  shared_ptr<string> metricsConfig{};

  ModifyDBInstanceMetricsRequest() {}

  explicit ModifyDBInstanceMetricsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (metricsConfig) {
      res["MetricsConfig"] = boost::any(*metricsConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("MetricsConfig") != m.end() && !m["MetricsConfig"].empty()) {
      metricsConfig = make_shared<string>(boost::any_cast<string>(m["MetricsConfig"]));
    }
  }


  virtual ~ModifyDBInstanceMetricsRequest() = default;
};
class ModifyDBInstanceMetricsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scope{};

  ModifyDBInstanceMetricsResponseBody() {}

  explicit ModifyDBInstanceMetricsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~ModifyDBInstanceMetricsResponseBody() = default;
};
class ModifyDBInstanceMetricsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceMetricsResponseBody> body{};

  ModifyDBInstanceMetricsResponse() {}

  explicit ModifyDBInstanceMetricsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceMetricsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceMetricsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceMetricsResponse() = default;
};
class ModifyDBInstanceMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> period{};
  shared_ptr<string> ownerAccount{};

  ModifyDBInstanceMonitorRequest() {}

  explicit ModifyDBInstanceMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyDBInstanceMonitorRequest() = default;
};
class ModifyDBInstanceMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBInstanceMonitorResponseBody() {}

  explicit ModifyDBInstanceMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBInstanceMonitorResponseBody() = default;
};
class ModifyDBInstanceMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceMonitorResponseBody> body{};

  ModifyDBInstanceMonitorResponse() {}

  explicit ModifyDBInstanceMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceMonitorResponse() = default;
};
class ModifyDBInstanceNetworkExpireTimeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> connectionString{};
  shared_ptr<long> classicExpiredDays{};
  shared_ptr<string> ownerAccount{};

  ModifyDBInstanceNetworkExpireTimeRequest() {}

  explicit ModifyDBInstanceNetworkExpireTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (connectionString) {
      res["ConnectionString"] = boost::any(*connectionString);
    }
    if (classicExpiredDays) {
      res["ClassicExpiredDays"] = boost::any(*classicExpiredDays);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ConnectionString") != m.end() && !m["ConnectionString"].empty()) {
      connectionString = make_shared<string>(boost::any_cast<string>(m["ConnectionString"]));
    }
    if (m.find("ClassicExpiredDays") != m.end() && !m["ClassicExpiredDays"].empty()) {
      classicExpiredDays = make_shared<long>(boost::any_cast<long>(m["ClassicExpiredDays"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyDBInstanceNetworkExpireTimeRequest() = default;
};
class ModifyDBInstanceNetworkExpireTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBInstanceNetworkExpireTimeResponseBody() {}

  explicit ModifyDBInstanceNetworkExpireTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBInstanceNetworkExpireTimeResponseBody() = default;
};
class ModifyDBInstanceNetworkExpireTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceNetworkExpireTimeResponseBody> body{};

  ModifyDBInstanceNetworkExpireTimeResponse() {}

  explicit ModifyDBInstanceNetworkExpireTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceNetworkExpireTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceNetworkExpireTimeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceNetworkExpireTimeResponse() = default;
};
class ModifyDBInstanceNetworkTypeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> retainClassic{};
  shared_ptr<string> classicExpiredDays{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<long> readWriteSplittingClassicExpiredDays{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> readWriteSplittingPrivateIpAddress{};
  shared_ptr<string> ownerAccount{};

  ModifyDBInstanceNetworkTypeRequest() {}

  explicit ModifyDBInstanceNetworkTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (retainClassic) {
      res["RetainClassic"] = boost::any(*retainClassic);
    }
    if (classicExpiredDays) {
      res["ClassicExpiredDays"] = boost::any(*classicExpiredDays);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (readWriteSplittingClassicExpiredDays) {
      res["ReadWriteSplittingClassicExpiredDays"] = boost::any(*readWriteSplittingClassicExpiredDays);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (readWriteSplittingPrivateIpAddress) {
      res["ReadWriteSplittingPrivateIpAddress"] = boost::any(*readWriteSplittingPrivateIpAddress);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RetainClassic") != m.end() && !m["RetainClassic"].empty()) {
      retainClassic = make_shared<string>(boost::any_cast<string>(m["RetainClassic"]));
    }
    if (m.find("ClassicExpiredDays") != m.end() && !m["ClassicExpiredDays"].empty()) {
      classicExpiredDays = make_shared<string>(boost::any_cast<string>(m["ClassicExpiredDays"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("ReadWriteSplittingClassicExpiredDays") != m.end() && !m["ReadWriteSplittingClassicExpiredDays"].empty()) {
      readWriteSplittingClassicExpiredDays = make_shared<long>(boost::any_cast<long>(m["ReadWriteSplittingClassicExpiredDays"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("ReadWriteSplittingPrivateIpAddress") != m.end() && !m["ReadWriteSplittingPrivateIpAddress"].empty()) {
      readWriteSplittingPrivateIpAddress = make_shared<string>(boost::any_cast<string>(m["ReadWriteSplittingPrivateIpAddress"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ModifyDBInstanceNetworkTypeRequest() = default;
};
class ModifyDBInstanceNetworkTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> connectionString{};

  ModifyDBInstanceNetworkTypeResponseBody() {}

  explicit ModifyDBInstanceNetworkTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (connectionString) {
      res["ConnectionString"] = boost::any(*connectionString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ConnectionString") != m.end() && !m["ConnectionString"].empty()) {
      connectionString = make_shared<string>(boost::any_cast<string>(m["ConnectionString"]));
    }
  }


  virtual ~ModifyDBInstanceNetworkTypeResponseBody() = default;
};
class ModifyDBInstanceNetworkTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceNetworkTypeResponseBody> body{};

  ModifyDBInstanceNetworkTypeResponse() {}

  explicit ModifyDBInstanceNetworkTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceNetworkTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceNetworkTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceNetworkTypeResponse() = default;
};
class ModifyDBInstancePayTypeRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> usedTime{};
  shared_ptr<string> payType{};
  shared_ptr<string> period{};

  ModifyDBInstancePayTypeRequest() {}

  explicit ModifyDBInstancePayTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<long>(boost::any_cast<long>(m["UsedTime"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
  }


  virtual ~ModifyDBInstancePayTypeRequest() = default;
};
class ModifyDBInstancePayTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};

  ModifyDBInstancePayTypeResponseBody() {}

  explicit ModifyDBInstancePayTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
  }


  virtual ~ModifyDBInstancePayTypeResponseBody() = default;
};
class ModifyDBInstancePayTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstancePayTypeResponseBody> body{};

  ModifyDBInstancePayTypeResponse() {}

  explicit ModifyDBInstancePayTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstancePayTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstancePayTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstancePayTypeResponse() = default;
};
class ModifyDBInstanceProxyConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> proxyConfigurationKey{};
  shared_ptr<string> proxyConfigurationValue{};

  ModifyDBInstanceProxyConfigurationRequest() {}

  explicit ModifyDBInstanceProxyConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (proxyConfigurationKey) {
      res["ProxyConfigurationKey"] = boost::any(*proxyConfigurationKey);
    }
    if (proxyConfigurationValue) {
      res["ProxyConfigurationValue"] = boost::any(*proxyConfigurationValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ProxyConfigurationKey") != m.end() && !m["ProxyConfigurationKey"].empty()) {
      proxyConfigurationKey = make_shared<string>(boost::any_cast<string>(m["ProxyConfigurationKey"]));
    }
    if (m.find("ProxyConfigurationValue") != m.end() && !m["ProxyConfigurationValue"].empty()) {
      proxyConfigurationValue = make_shared<string>(boost::any_cast<string>(m["ProxyConfigurationValue"]));
    }
  }


  virtual ~ModifyDBInstanceProxyConfigurationRequest() = default;
};
class ModifyDBInstanceProxyConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBInstanceProxyConfigurationResponseBody() {}

  explicit ModifyDBInstanceProxyConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBInstanceProxyConfigurationResponseBody() = default;
};
class ModifyDBInstanceProxyConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceProxyConfigurationResponseBody> body{};

  ModifyDBInstanceProxyConfigurationResponse() {}

  explicit ModifyDBInstanceProxyConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceProxyConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceProxyConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceProxyConfigurationResponse() = default;
};
class ModifyDBInstanceSpecRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<long> DBInstanceStorage{};
  shared_ptr<string> payType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> effectiveTime{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> DBInstanceStorageType{};
  shared_ptr<string> direction{};
  shared_ptr<string> sourceBiz{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> switchTime{};

  ModifyDBInstanceSpecRequest() {}

  explicit ModifyDBInstanceSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (DBInstanceStorage) {
      res["DBInstanceStorage"] = boost::any(*DBInstanceStorage);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (effectiveTime) {
      res["EffectiveTime"] = boost::any(*effectiveTime);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (DBInstanceStorageType) {
      res["DBInstanceStorageType"] = boost::any(*DBInstanceStorageType);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (sourceBiz) {
      res["SourceBiz"] = boost::any(*sourceBiz);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (switchTime) {
      res["SwitchTime"] = boost::any(*switchTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("DBInstanceStorage") != m.end() && !m["DBInstanceStorage"].empty()) {
      DBInstanceStorage = make_shared<long>(boost::any_cast<long>(m["DBInstanceStorage"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("EffectiveTime") != m.end() && !m["EffectiveTime"].empty()) {
      effectiveTime = make_shared<string>(boost::any_cast<string>(m["EffectiveTime"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("DBInstanceStorageType") != m.end() && !m["DBInstanceStorageType"].empty()) {
      DBInstanceStorageType = make_shared<string>(boost::any_cast<string>(m["DBInstanceStorageType"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("SourceBiz") != m.end() && !m["SourceBiz"].empty()) {
      sourceBiz = make_shared<string>(boost::any_cast<string>(m["SourceBiz"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("SwitchTime") != m.end() && !m["SwitchTime"].empty()) {
      switchTime = make_shared<string>(boost::any_cast<string>(m["SwitchTime"]));
    }
  }


  virtual ~ModifyDBInstanceSpecRequest() = default;
};
class ModifyDBInstanceSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> orderId{};

  ModifyDBInstanceSpecResponseBody() {}

  explicit ModifyDBInstanceSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
  }


  virtual ~ModifyDBInstanceSpecResponseBody() = default;
};
class ModifyDBInstanceSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceSpecResponseBody> body{};

  ModifyDBInstanceSpecResponse() {}

  explicit ModifyDBInstanceSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceSpecResponse() = default;
};
class ModifyDBInstanceSSLRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> connectionString{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> SSLEnabled{};
  shared_ptr<string> CAType{};
  shared_ptr<string> serverCert{};
  shared_ptr<string> serverKey{};
  shared_ptr<long> clientCAEnabled{};
  shared_ptr<string> clientCACert{};
  shared_ptr<long> clientCrlEnabled{};
  shared_ptr<string> clientCertRevocationList{};
  shared_ptr<string> ACL{};
  shared_ptr<string> replicationACL{};

  ModifyDBInstanceSSLRequest() {}

  explicit ModifyDBInstanceSSLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (connectionString) {
      res["ConnectionString"] = boost::any(*connectionString);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (SSLEnabled) {
      res["SSLEnabled"] = boost::any(*SSLEnabled);
    }
    if (CAType) {
      res["CAType"] = boost::any(*CAType);
    }
    if (serverCert) {
      res["ServerCert"] = boost::any(*serverCert);
    }
    if (serverKey) {
      res["ServerKey"] = boost::any(*serverKey);
    }
    if (clientCAEnabled) {
      res["ClientCAEnabled"] = boost::any(*clientCAEnabled);
    }
    if (clientCACert) {
      res["ClientCACert"] = boost::any(*clientCACert);
    }
    if (clientCrlEnabled) {
      res["ClientCrlEnabled"] = boost::any(*clientCrlEnabled);
    }
    if (clientCertRevocationList) {
      res["ClientCertRevocationList"] = boost::any(*clientCertRevocationList);
    }
    if (ACL) {
      res["ACL"] = boost::any(*ACL);
    }
    if (replicationACL) {
      res["ReplicationACL"] = boost::any(*replicationACL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ConnectionString") != m.end() && !m["ConnectionString"].empty()) {
      connectionString = make_shared<string>(boost::any_cast<string>(m["ConnectionString"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SSLEnabled") != m.end() && !m["SSLEnabled"].empty()) {
      SSLEnabled = make_shared<long>(boost::any_cast<long>(m["SSLEnabled"]));
    }
    if (m.find("CAType") != m.end() && !m["CAType"].empty()) {
      CAType = make_shared<string>(boost::any_cast<string>(m["CAType"]));
    }
    if (m.find("ServerCert") != m.end() && !m["ServerCert"].empty()) {
      serverCert = make_shared<string>(boost::any_cast<string>(m["ServerCert"]));
    }
    if (m.find("ServerKey") != m.end() && !m["ServerKey"].empty()) {
      serverKey = make_shared<string>(boost::any_cast<string>(m["ServerKey"]));
    }
    if (m.find("ClientCAEnabled") != m.end() && !m["ClientCAEnabled"].empty()) {
      clientCAEnabled = make_shared<long>(boost::any_cast<long>(m["ClientCAEnabled"]));
    }
    if (m.find("ClientCACert") != m.end() && !m["ClientCACert"].empty()) {
      clientCACert = make_shared<string>(boost::any_cast<string>(m["ClientCACert"]));
    }
    if (m.find("ClientCrlEnabled") != m.end() && !m["ClientCrlEnabled"].empty()) {
      clientCrlEnabled = make_shared<long>(boost::any_cast<long>(m["ClientCrlEnabled"]));
    }
    if (m.find("ClientCertRevocationList") != m.end() && !m["ClientCertRevocationList"].empty()) {
      clientCertRevocationList = make_shared<string>(boost::any_cast<string>(m["ClientCertRevocationList"]));
    }
    if (m.find("ACL") != m.end() && !m["ACL"].empty()) {
      ACL = make_shared<string>(boost::any_cast<string>(m["ACL"]));
    }
    if (m.find("ReplicationACL") != m.end() && !m["ReplicationACL"].empty()) {
      replicationACL = make_shared<string>(boost::any_cast<string>(m["ReplicationACL"]));
    }
  }


  virtual ~ModifyDBInstanceSSLRequest() = default;
};
class ModifyDBInstanceSSLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBInstanceSSLResponseBody() {}

  explicit ModifyDBInstanceSSLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBInstanceSSLResponseBody() = default;
};
class ModifyDBInstanceSSLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceSSLResponseBody> body{};

  ModifyDBInstanceSSLResponse() {}

  explicit ModifyDBInstanceSSLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceSSLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceSSLResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceSSLResponse() = default;
};
class ModifyDBInstanceTDERequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> TDEStatus{};
  shared_ptr<string> DBName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> encryptionKey{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> certificate{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> passWord{};

  ModifyDBInstanceTDERequest() {}

  explicit ModifyDBInstanceTDERequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (TDEStatus) {
      res["TDEStatus"] = boost::any(*TDEStatus);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (encryptionKey) {
      res["EncryptionKey"] = boost::any(*encryptionKey);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (passWord) {
      res["PassWord"] = boost::any(*passWord);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("TDEStatus") != m.end() && !m["TDEStatus"].empty()) {
      TDEStatus = make_shared<string>(boost::any_cast<string>(m["TDEStatus"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("EncryptionKey") != m.end() && !m["EncryptionKey"].empty()) {
      encryptionKey = make_shared<string>(boost::any_cast<string>(m["EncryptionKey"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("PassWord") != m.end() && !m["PassWord"].empty()) {
      passWord = make_shared<string>(boost::any_cast<string>(m["PassWord"]));
    }
  }


  virtual ~ModifyDBInstanceTDERequest() = default;
};
class ModifyDBInstanceTDEResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBInstanceTDEResponseBody() {}

  explicit ModifyDBInstanceTDEResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBInstanceTDEResponseBody() = default;
};
class ModifyDBInstanceTDEResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBInstanceTDEResponseBody> body{};

  ModifyDBInstanceTDEResponse() {}

  explicit ModifyDBInstanceTDEResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBInstanceTDEResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBInstanceTDEResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBInstanceTDEResponse() = default;
};
class ModifyDBProxyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> configDBProxyService{};
  shared_ptr<string> DBProxyInstanceNum{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> vSwitchId{};

  ModifyDBProxyRequest() {}

  explicit ModifyDBProxyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (configDBProxyService) {
      res["ConfigDBProxyService"] = boost::any(*configDBProxyService);
    }
    if (DBProxyInstanceNum) {
      res["DBProxyInstanceNum"] = boost::any(*DBProxyInstanceNum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ConfigDBProxyService") != m.end() && !m["ConfigDBProxyService"].empty()) {
      configDBProxyService = make_shared<string>(boost::any_cast<string>(m["ConfigDBProxyService"]));
    }
    if (m.find("DBProxyInstanceNum") != m.end() && !m["DBProxyInstanceNum"].empty()) {
      DBProxyInstanceNum = make_shared<string>(boost::any_cast<string>(m["DBProxyInstanceNum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~ModifyDBProxyRequest() = default;
};
class ModifyDBProxyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBProxyResponseBody() {}

  explicit ModifyDBProxyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBProxyResponseBody() = default;
};
class ModifyDBProxyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBProxyResponseBody> body{};

  ModifyDBProxyResponse() {}

  explicit ModifyDBProxyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBProxyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBProxyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBProxyResponse() = default;
};
class ModifyDBProxyEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBProxyEndpointId{};
  shared_ptr<string> configDBProxyFeatures{};
  shared_ptr<string> regionId{};
  shared_ptr<string> readOnlyInstanceMaxDelayTime{};
  shared_ptr<string> readOnlyInstanceDistributionType{};
  shared_ptr<string> readOnlyInstanceWeight{};
  shared_ptr<string> dbEndpointOperator{};
  shared_ptr<string> dbEndpointAliases{};
  shared_ptr<string> dbEndpointType{};
  shared_ptr<string> dbEndpointReadWriteMode{};

  ModifyDBProxyEndpointRequest() {}

  explicit ModifyDBProxyEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBProxyEndpointId) {
      res["DBProxyEndpointId"] = boost::any(*DBProxyEndpointId);
    }
    if (configDBProxyFeatures) {
      res["ConfigDBProxyFeatures"] = boost::any(*configDBProxyFeatures);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (readOnlyInstanceMaxDelayTime) {
      res["ReadOnlyInstanceMaxDelayTime"] = boost::any(*readOnlyInstanceMaxDelayTime);
    }
    if (readOnlyInstanceDistributionType) {
      res["ReadOnlyInstanceDistributionType"] = boost::any(*readOnlyInstanceDistributionType);
    }
    if (readOnlyInstanceWeight) {
      res["ReadOnlyInstanceWeight"] = boost::any(*readOnlyInstanceWeight);
    }
    if (dbEndpointOperator) {
      res["DbEndpointOperator"] = boost::any(*dbEndpointOperator);
    }
    if (dbEndpointAliases) {
      res["DbEndpointAliases"] = boost::any(*dbEndpointAliases);
    }
    if (dbEndpointType) {
      res["DbEndpointType"] = boost::any(*dbEndpointType);
    }
    if (dbEndpointReadWriteMode) {
      res["DbEndpointReadWriteMode"] = boost::any(*dbEndpointReadWriteMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBProxyEndpointId") != m.end() && !m["DBProxyEndpointId"].empty()) {
      DBProxyEndpointId = make_shared<string>(boost::any_cast<string>(m["DBProxyEndpointId"]));
    }
    if (m.find("ConfigDBProxyFeatures") != m.end() && !m["ConfigDBProxyFeatures"].empty()) {
      configDBProxyFeatures = make_shared<string>(boost::any_cast<string>(m["ConfigDBProxyFeatures"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReadOnlyInstanceMaxDelayTime") != m.end() && !m["ReadOnlyInstanceMaxDelayTime"].empty()) {
      readOnlyInstanceMaxDelayTime = make_shared<string>(boost::any_cast<string>(m["ReadOnlyInstanceMaxDelayTime"]));
    }
    if (m.find("ReadOnlyInstanceDistributionType") != m.end() && !m["ReadOnlyInstanceDistributionType"].empty()) {
      readOnlyInstanceDistributionType = make_shared<string>(boost::any_cast<string>(m["ReadOnlyInstanceDistributionType"]));
    }
    if (m.find("ReadOnlyInstanceWeight") != m.end() && !m["ReadOnlyInstanceWeight"].empty()) {
      readOnlyInstanceWeight = make_shared<string>(boost::any_cast<string>(m["ReadOnlyInstanceWeight"]));
    }
    if (m.find("DbEndpointOperator") != m.end() && !m["DbEndpointOperator"].empty()) {
      dbEndpointOperator = make_shared<string>(boost::any_cast<string>(m["DbEndpointOperator"]));
    }
    if (m.find("DbEndpointAliases") != m.end() && !m["DbEndpointAliases"].empty()) {
      dbEndpointAliases = make_shared<string>(boost::any_cast<string>(m["DbEndpointAliases"]));
    }
    if (m.find("DbEndpointType") != m.end() && !m["DbEndpointType"].empty()) {
      dbEndpointType = make_shared<string>(boost::any_cast<string>(m["DbEndpointType"]));
    }
    if (m.find("DbEndpointReadWriteMode") != m.end() && !m["DbEndpointReadWriteMode"].empty()) {
      dbEndpointReadWriteMode = make_shared<string>(boost::any_cast<string>(m["DbEndpointReadWriteMode"]));
    }
  }


  virtual ~ModifyDBProxyEndpointRequest() = default;
};
class ModifyDBProxyEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBProxyEndpointResponseBody() {}

  explicit ModifyDBProxyEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBProxyEndpointResponseBody() = default;
};
class ModifyDBProxyEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBProxyEndpointResponseBody> body{};

  ModifyDBProxyEndpointResponse() {}

  explicit ModifyDBProxyEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBProxyEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBProxyEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBProxyEndpointResponse() = default;
};
class ModifyDBProxyEndpointAddressRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBProxyEndpointId{};
  shared_ptr<string> DBProxyNewConnectString{};
  shared_ptr<string> DBProxyNewConnectStringPort{};
  shared_ptr<string> DBProxyConnectStringNetType{};

  ModifyDBProxyEndpointAddressRequest() {}

  explicit ModifyDBProxyEndpointAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBProxyEndpointId) {
      res["DBProxyEndpointId"] = boost::any(*DBProxyEndpointId);
    }
    if (DBProxyNewConnectString) {
      res["DBProxyNewConnectString"] = boost::any(*DBProxyNewConnectString);
    }
    if (DBProxyNewConnectStringPort) {
      res["DBProxyNewConnectStringPort"] = boost::any(*DBProxyNewConnectStringPort);
    }
    if (DBProxyConnectStringNetType) {
      res["DBProxyConnectStringNetType"] = boost::any(*DBProxyConnectStringNetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBProxyEndpointId") != m.end() && !m["DBProxyEndpointId"].empty()) {
      DBProxyEndpointId = make_shared<string>(boost::any_cast<string>(m["DBProxyEndpointId"]));
    }
    if (m.find("DBProxyNewConnectString") != m.end() && !m["DBProxyNewConnectString"].empty()) {
      DBProxyNewConnectString = make_shared<string>(boost::any_cast<string>(m["DBProxyNewConnectString"]));
    }
    if (m.find("DBProxyNewConnectStringPort") != m.end() && !m["DBProxyNewConnectStringPort"].empty()) {
      DBProxyNewConnectStringPort = make_shared<string>(boost::any_cast<string>(m["DBProxyNewConnectStringPort"]));
    }
    if (m.find("DBProxyConnectStringNetType") != m.end() && !m["DBProxyConnectStringNetType"].empty()) {
      DBProxyConnectStringNetType = make_shared<string>(boost::any_cast<string>(m["DBProxyConnectStringNetType"]));
    }
  }


  virtual ~ModifyDBProxyEndpointAddressRequest() = default;
};
class ModifyDBProxyEndpointAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBProxyEndpointAddressResponseBody() {}

  explicit ModifyDBProxyEndpointAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBProxyEndpointAddressResponseBody() = default;
};
class ModifyDBProxyEndpointAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBProxyEndpointAddressResponseBody> body{};

  ModifyDBProxyEndpointAddressResponse() {}

  explicit ModifyDBProxyEndpointAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBProxyEndpointAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBProxyEndpointAddressResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBProxyEndpointAddressResponse() = default;
};
class ModifyDBProxyInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> DBProxyInstanceType{};
  shared_ptr<string> DBProxyInstanceNum{};
  shared_ptr<string> effectiveTime{};
  shared_ptr<string> effectiveSpecificTime{};
  shared_ptr<string> regionId{};

  ModifyDBProxyInstanceRequest() {}

  explicit ModifyDBProxyInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (DBProxyInstanceType) {
      res["DBProxyInstanceType"] = boost::any(*DBProxyInstanceType);
    }
    if (DBProxyInstanceNum) {
      res["DBProxyInstanceNum"] = boost::any(*DBProxyInstanceNum);
    }
    if (effectiveTime) {
      res["EffectiveTime"] = boost::any(*effectiveTime);
    }
    if (effectiveSpecificTime) {
      res["EffectiveSpecificTime"] = boost::any(*effectiveSpecificTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DBProxyInstanceType") != m.end() && !m["DBProxyInstanceType"].empty()) {
      DBProxyInstanceType = make_shared<string>(boost::any_cast<string>(m["DBProxyInstanceType"]));
    }
    if (m.find("DBProxyInstanceNum") != m.end() && !m["DBProxyInstanceNum"].empty()) {
      DBProxyInstanceNum = make_shared<string>(boost::any_cast<string>(m["DBProxyInstanceNum"]));
    }
    if (m.find("EffectiveTime") != m.end() && !m["EffectiveTime"].empty()) {
      effectiveTime = make_shared<string>(boost::any_cast<string>(m["EffectiveTime"]));
    }
    if (m.find("EffectiveSpecificTime") != m.end() && !m["EffectiveSpecificTime"].empty()) {
      effectiveSpecificTime = make_shared<string>(boost::any_cast<string>(m["EffectiveSpecificTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDBProxyInstanceRequest() = default;
};
class ModifyDBProxyInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDBProxyInstanceResponseBody() {}

  explicit ModifyDBProxyInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDBProxyInstanceResponseBody() = default;
};
class ModifyDBProxyInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDBProxyInstanceResponseBody> body{};

  ModifyDBProxyInstanceResponse() {}

  explicit ModifyDBProxyInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDBProxyInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDBProxyInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDBProxyInstanceResponse() = default;
};
class ModifyDbProxyInstanceSslRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> dbInstanceId{};
  shared_ptr<string> dbProxyEndpointId{};
  shared_ptr<string> dbProxyConnectString{};
  shared_ptr<string> dbProxySslEnabled{};

  ModifyDbProxyInstanceSslRequest() {}

  explicit ModifyDbProxyInstanceSslRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dbInstanceId) {
      res["DbInstanceId"] = boost::any(*dbInstanceId);
    }
    if (dbProxyEndpointId) {
      res["DbProxyEndpointId"] = boost::any(*dbProxyEndpointId);
    }
    if (dbProxyConnectString) {
      res["DbProxyConnectString"] = boost::any(*dbProxyConnectString);
    }
    if (dbProxySslEnabled) {
      res["DbProxySslEnabled"] = boost::any(*dbProxySslEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DbInstanceId") != m.end() && !m["DbInstanceId"].empty()) {
      dbInstanceId = make_shared<string>(boost::any_cast<string>(m["DbInstanceId"]));
    }
    if (m.find("DbProxyEndpointId") != m.end() && !m["DbProxyEndpointId"].empty()) {
      dbProxyEndpointId = make_shared<string>(boost::any_cast<string>(m["DbProxyEndpointId"]));
    }
    if (m.find("DbProxyConnectString") != m.end() && !m["DbProxyConnectString"].empty()) {
      dbProxyConnectString = make_shared<string>(boost::any_cast<string>(m["DbProxyConnectString"]));
    }
    if (m.find("DbProxySslEnabled") != m.end() && !m["DbProxySslEnabled"].empty()) {
      dbProxySslEnabled = make_shared<string>(boost::any_cast<string>(m["DbProxySslEnabled"]));
    }
  }


  virtual ~ModifyDbProxyInstanceSslRequest() = default;
};
class ModifyDbProxyInstanceSslResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDbProxyInstanceSslResponseBody() {}

  explicit ModifyDbProxyInstanceSslResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDbProxyInstanceSslResponseBody() = default;
};
class ModifyDbProxyInstanceSslResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDbProxyInstanceSslResponseBody> body{};

  ModifyDbProxyInstanceSslResponse() {}

  explicit ModifyDbProxyInstanceSslResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDbProxyInstanceSslResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDbProxyInstanceSslResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDbProxyInstanceSslResponse() = default;
};
class ModifyDedicatedHostAccountRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> accountPassword{};
  shared_ptr<string> regionId{};

  ModifyDedicatedHostAccountRequest() {}

  explicit ModifyDedicatedHostAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountPassword) {
      res["AccountPassword"] = boost::any(*accountPassword);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountPassword") != m.end() && !m["AccountPassword"].empty()) {
      accountPassword = make_shared<string>(boost::any_cast<string>(m["AccountPassword"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDedicatedHostAccountRequest() = default;
};
class ModifyDedicatedHostAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDedicatedHostAccountResponseBody() {}

  explicit ModifyDedicatedHostAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDedicatedHostAccountResponseBody() = default;
};
class ModifyDedicatedHostAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDedicatedHostAccountResponseBody> body{};

  ModifyDedicatedHostAccountResponse() {}

  explicit ModifyDedicatedHostAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedHostAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedHostAccountResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostAccountResponse() = default;
};
class ModifyDedicatedHostAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> allocationStatus{};

  ModifyDedicatedHostAttributeRequest() {}

  explicit ModifyDedicatedHostAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (allocationStatus) {
      res["AllocationStatus"] = boost::any(*allocationStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("AllocationStatus") != m.end() && !m["AllocationStatus"].empty()) {
      allocationStatus = make_shared<string>(boost::any_cast<string>(m["AllocationStatus"]));
    }
  }


  virtual ~ModifyDedicatedHostAttributeRequest() = default;
};
class ModifyDedicatedHostAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDedicatedHostAttributeResponseBody() {}

  explicit ModifyDedicatedHostAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDedicatedHostAttributeResponseBody() = default;
};
class ModifyDedicatedHostAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDedicatedHostAttributeResponseBody> body{};

  ModifyDedicatedHostAttributeResponse() {}

  explicit ModifyDedicatedHostAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedHostAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedHostAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostAttributeResponse() = default;
};
class ModifyDedicatedHostGroupAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> dedicatedHostGroupDesc{};
  shared_ptr<long> cpuAllocationRatio{};
  shared_ptr<long> memAllocationRatio{};
  shared_ptr<long> diskAllocationRatio{};
  shared_ptr<string> allocationPolicy{};
  shared_ptr<string> hostReplacePolicy{};

  ModifyDedicatedHostGroupAttributeRequest() {}

  explicit ModifyDedicatedHostGroupAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (dedicatedHostGroupDesc) {
      res["DedicatedHostGroupDesc"] = boost::any(*dedicatedHostGroupDesc);
    }
    if (cpuAllocationRatio) {
      res["CpuAllocationRatio"] = boost::any(*cpuAllocationRatio);
    }
    if (memAllocationRatio) {
      res["MemAllocationRatio"] = boost::any(*memAllocationRatio);
    }
    if (diskAllocationRatio) {
      res["DiskAllocationRatio"] = boost::any(*diskAllocationRatio);
    }
    if (allocationPolicy) {
      res["AllocationPolicy"] = boost::any(*allocationPolicy);
    }
    if (hostReplacePolicy) {
      res["HostReplacePolicy"] = boost::any(*hostReplacePolicy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("DedicatedHostGroupDesc") != m.end() && !m["DedicatedHostGroupDesc"].empty()) {
      dedicatedHostGroupDesc = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupDesc"]));
    }
    if (m.find("CpuAllocationRatio") != m.end() && !m["CpuAllocationRatio"].empty()) {
      cpuAllocationRatio = make_shared<long>(boost::any_cast<long>(m["CpuAllocationRatio"]));
    }
    if (m.find("MemAllocationRatio") != m.end() && !m["MemAllocationRatio"].empty()) {
      memAllocationRatio = make_shared<long>(boost::any_cast<long>(m["MemAllocationRatio"]));
    }
    if (m.find("DiskAllocationRatio") != m.end() && !m["DiskAllocationRatio"].empty()) {
      diskAllocationRatio = make_shared<long>(boost::any_cast<long>(m["DiskAllocationRatio"]));
    }
    if (m.find("AllocationPolicy") != m.end() && !m["AllocationPolicy"].empty()) {
      allocationPolicy = make_shared<string>(boost::any_cast<string>(m["AllocationPolicy"]));
    }
    if (m.find("HostReplacePolicy") != m.end() && !m["HostReplacePolicy"].empty()) {
      hostReplacePolicy = make_shared<string>(boost::any_cast<string>(m["HostReplacePolicy"]));
    }
  }


  virtual ~ModifyDedicatedHostGroupAttributeRequest() = default;
};
class ModifyDedicatedHostGroupAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDedicatedHostGroupAttributeResponseBody() {}

  explicit ModifyDedicatedHostGroupAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDedicatedHostGroupAttributeResponseBody() = default;
};
class ModifyDedicatedHostGroupAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDedicatedHostGroupAttributeResponseBody> body{};

  ModifyDedicatedHostGroupAttributeResponse() {}

  explicit ModifyDedicatedHostGroupAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedHostGroupAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedHostGroupAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostGroupAttributeResponse() = default;
};
class ModifyDedicatedHostUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> dedicatedHostName{};
  shared_ptr<string> userName{};
  shared_ptr<string> oldPassword{};
  shared_ptr<string> newPassword{};
  shared_ptr<string> regionId{};

  ModifyDedicatedHostUserRequest() {}

  explicit ModifyDedicatedHostUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (dedicatedHostName) {
      res["DedicatedHostName"] = boost::any(*dedicatedHostName);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (oldPassword) {
      res["OldPassword"] = boost::any(*oldPassword);
    }
    if (newPassword) {
      res["NewPassword"] = boost::any(*newPassword);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DedicatedHostName") != m.end() && !m["DedicatedHostName"].empty()) {
      dedicatedHostName = make_shared<string>(boost::any_cast<string>(m["DedicatedHostName"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("OldPassword") != m.end() && !m["OldPassword"].empty()) {
      oldPassword = make_shared<string>(boost::any_cast<string>(m["OldPassword"]));
    }
    if (m.find("NewPassword") != m.end() && !m["NewPassword"].empty()) {
      newPassword = make_shared<string>(boost::any_cast<string>(m["NewPassword"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDedicatedHostUserRequest() = default;
};
class ModifyDedicatedHostUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDedicatedHostUserResponseBody() {}

  explicit ModifyDedicatedHostUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDedicatedHostUserResponseBody() = default;
};
class ModifyDedicatedHostUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDedicatedHostUserResponseBody> body{};

  ModifyDedicatedHostUserResponse() {}

  explicit ModifyDedicatedHostUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedHostUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedHostUserResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedHostUserResponse() = default;
};
class ModifyDTCSecurityIpHostsForSQLServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> securityIpHosts{};
  shared_ptr<string> whiteListGroupName{};
  shared_ptr<string> regionId{};

  ModifyDTCSecurityIpHostsForSQLServerRequest() {}

  explicit ModifyDTCSecurityIpHostsForSQLServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (securityIpHosts) {
      res["SecurityIpHosts"] = boost::any(*securityIpHosts);
    }
    if (whiteListGroupName) {
      res["WhiteListGroupName"] = boost::any(*whiteListGroupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("SecurityIpHosts") != m.end() && !m["SecurityIpHosts"].empty()) {
      securityIpHosts = make_shared<string>(boost::any_cast<string>(m["SecurityIpHosts"]));
    }
    if (m.find("WhiteListGroupName") != m.end() && !m["WhiteListGroupName"].empty()) {
      whiteListGroupName = make_shared<string>(boost::any_cast<string>(m["WhiteListGroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDTCSecurityIpHostsForSQLServerRequest() = default;
};
class ModifyDTCSecurityIpHostsForSQLServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> DTCSetResult{};

  ModifyDTCSecurityIpHostsForSQLServerResponseBody() {}

  explicit ModifyDTCSecurityIpHostsForSQLServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (DTCSetResult) {
      res["DTCSetResult"] = boost::any(*DTCSetResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("DTCSetResult") != m.end() && !m["DTCSetResult"].empty()) {
      DTCSetResult = make_shared<string>(boost::any_cast<string>(m["DTCSetResult"]));
    }
  }


  virtual ~ModifyDTCSecurityIpHostsForSQLServerResponseBody() = default;
};
class ModifyDTCSecurityIpHostsForSQLServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDTCSecurityIpHostsForSQLServerResponseBody> body{};

  ModifyDTCSecurityIpHostsForSQLServerResponse() {}

  explicit ModifyDTCSecurityIpHostsForSQLServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDTCSecurityIpHostsForSQLServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDTCSecurityIpHostsForSQLServerResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDTCSecurityIpHostsForSQLServerResponse() = default;
};
class ModifyHADiagnoseConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> tcpConnectionType{};
  shared_ptr<string> regionId{};

  ModifyHADiagnoseConfigRequest() {}

  explicit ModifyHADiagnoseConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (tcpConnectionType) {
      res["TcpConnectionType"] = boost::any(*tcpConnectionType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("TcpConnectionType") != m.end() && !m["TcpConnectionType"].empty()) {
      tcpConnectionType = make_shared<string>(boost::any_cast<string>(m["TcpConnectionType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyHADiagnoseConfigRequest() = default;
};
class ModifyHADiagnoseConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHADiagnoseConfigResponseBody() {}

  explicit ModifyHADiagnoseConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHADiagnoseConfigResponseBody() = default;
};
class ModifyHADiagnoseConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyHADiagnoseConfigResponseBody> body{};

  ModifyHADiagnoseConfigResponse() {}

  explicit ModifyHADiagnoseConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHADiagnoseConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHADiagnoseConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHADiagnoseConfigResponse() = default;
};
class ModifyHASwitchConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> HAConfig{};
  shared_ptr<string> manualHATime{};
  shared_ptr<string> regionId{};

  ModifyHASwitchConfigRequest() {}

  explicit ModifyHASwitchConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (HAConfig) {
      res["HAConfig"] = boost::any(*HAConfig);
    }
    if (manualHATime) {
      res["ManualHATime"] = boost::any(*manualHATime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("HAConfig") != m.end() && !m["HAConfig"].empty()) {
      HAConfig = make_shared<string>(boost::any_cast<string>(m["HAConfig"]));
    }
    if (m.find("ManualHATime") != m.end() && !m["ManualHATime"].empty()) {
      manualHATime = make_shared<string>(boost::any_cast<string>(m["ManualHATime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyHASwitchConfigRequest() = default;
};
class ModifyHASwitchConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHASwitchConfigResponseBody() {}

  explicit ModifyHASwitchConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHASwitchConfigResponseBody() = default;
};
class ModifyHASwitchConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyHASwitchConfigResponseBody> body{};

  ModifyHASwitchConfigResponse() {}

  explicit ModifyHASwitchConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHASwitchConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHASwitchConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHASwitchConfigResponse() = default;
};
class ModifyInstanceAutoRenewalAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> duration{};
  shared_ptr<string> autoRenew{};

  ModifyInstanceAutoRenewalAttributeRequest() {}

  explicit ModifyInstanceAutoRenewalAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<string>(boost::any_cast<string>(m["AutoRenew"]));
    }
  }


  virtual ~ModifyInstanceAutoRenewalAttributeRequest() = default;
};
class ModifyInstanceAutoRenewalAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceAutoRenewalAttributeResponseBody() {}

  explicit ModifyInstanceAutoRenewalAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAutoRenewalAttributeResponseBody() = default;
};
class ModifyInstanceAutoRenewalAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceAutoRenewalAttributeResponseBody> body{};

  ModifyInstanceAutoRenewalAttributeResponse() {}

  explicit ModifyInstanceAutoRenewalAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAutoRenewalAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAutoRenewalAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAutoRenewalAttributeResponse() = default;
};
class ModifyInstanceCrossBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> crossBackupType{};
  shared_ptr<string> logBackupEnabled{};
  shared_ptr<string> backupEnabled{};
  shared_ptr<string> crossBackupRegion{};
  shared_ptr<long> retentType{};
  shared_ptr<long> retention{};

  ModifyInstanceCrossBackupPolicyRequest() {}

  explicit ModifyInstanceCrossBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (crossBackupType) {
      res["CrossBackupType"] = boost::any(*crossBackupType);
    }
    if (logBackupEnabled) {
      res["LogBackupEnabled"] = boost::any(*logBackupEnabled);
    }
    if (backupEnabled) {
      res["BackupEnabled"] = boost::any(*backupEnabled);
    }
    if (crossBackupRegion) {
      res["CrossBackupRegion"] = boost::any(*crossBackupRegion);
    }
    if (retentType) {
      res["RetentType"] = boost::any(*retentType);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("CrossBackupType") != m.end() && !m["CrossBackupType"].empty()) {
      crossBackupType = make_shared<string>(boost::any_cast<string>(m["CrossBackupType"]));
    }
    if (m.find("LogBackupEnabled") != m.end() && !m["LogBackupEnabled"].empty()) {
      logBackupEnabled = make_shared<string>(boost::any_cast<string>(m["LogBackupEnabled"]));
    }
    if (m.find("BackupEnabled") != m.end() && !m["BackupEnabled"].empty()) {
      backupEnabled = make_shared<string>(boost::any_cast<string>(m["BackupEnabled"]));
    }
    if (m.find("CrossBackupRegion") != m.end() && !m["CrossBackupRegion"].empty()) {
      crossBackupRegion = make_shared<string>(boost::any_cast<string>(m["CrossBackupRegion"]));
    }
    if (m.find("RetentType") != m.end() && !m["RetentType"].empty()) {
      retentType = make_shared<long>(boost::any_cast<long>(m["RetentType"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
  }


  virtual ~ModifyInstanceCrossBackupPolicyRequest() = default;
};
class ModifyInstanceCrossBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> backupEnabled{};
  shared_ptr<string> regionId{};
  shared_ptr<string> logBackupEnabled{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retentType{};
  shared_ptr<string> crossBackupRegion{};
  shared_ptr<string> crossBackupType{};
  shared_ptr<long> retention{};
  shared_ptr<string> DBInstanceId{};

  ModifyInstanceCrossBackupPolicyResponseBody() {}

  explicit ModifyInstanceCrossBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupEnabled) {
      res["BackupEnabled"] = boost::any(*backupEnabled);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (logBackupEnabled) {
      res["LogBackupEnabled"] = boost::any(*logBackupEnabled);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retentType) {
      res["RetentType"] = boost::any(*retentType);
    }
    if (crossBackupRegion) {
      res["CrossBackupRegion"] = boost::any(*crossBackupRegion);
    }
    if (crossBackupType) {
      res["CrossBackupType"] = boost::any(*crossBackupType);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupEnabled") != m.end() && !m["BackupEnabled"].empty()) {
      backupEnabled = make_shared<string>(boost::any_cast<string>(m["BackupEnabled"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("LogBackupEnabled") != m.end() && !m["LogBackupEnabled"].empty()) {
      logBackupEnabled = make_shared<string>(boost::any_cast<string>(m["LogBackupEnabled"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetentType") != m.end() && !m["RetentType"].empty()) {
      retentType = make_shared<long>(boost::any_cast<long>(m["RetentType"]));
    }
    if (m.find("CrossBackupRegion") != m.end() && !m["CrossBackupRegion"].empty()) {
      crossBackupRegion = make_shared<string>(boost::any_cast<string>(m["CrossBackupRegion"]));
    }
    if (m.find("CrossBackupType") != m.end() && !m["CrossBackupType"].empty()) {
      crossBackupType = make_shared<string>(boost::any_cast<string>(m["CrossBackupType"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~ModifyInstanceCrossBackupPolicyResponseBody() = default;
};
class ModifyInstanceCrossBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceCrossBackupPolicyResponseBody> body{};

  ModifyInstanceCrossBackupPolicyResponse() {}

  explicit ModifyInstanceCrossBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceCrossBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceCrossBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceCrossBackupPolicyResponse() = default;
};
class ModifyParameterRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> parameters{};
  shared_ptr<bool> forcerestart{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> parameterGroupId{};

  ModifyParameterRequest() {}

  explicit ModifyParameterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (forcerestart) {
      res["Forcerestart"] = boost::any(*forcerestart);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (parameterGroupId) {
      res["ParameterGroupId"] = boost::any(*parameterGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("Forcerestart") != m.end() && !m["Forcerestart"].empty()) {
      forcerestart = make_shared<bool>(boost::any_cast<bool>(m["Forcerestart"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ParameterGroupId") != m.end() && !m["ParameterGroupId"].empty()) {
      parameterGroupId = make_shared<string>(boost::any_cast<string>(m["ParameterGroupId"]));
    }
  }


  virtual ~ModifyParameterRequest() = default;
};
class ModifyParameterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyParameterResponseBody() {}

  explicit ModifyParameterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyParameterResponseBody() = default;
};
class ModifyParameterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyParameterResponseBody> body{};

  ModifyParameterResponse() {}

  explicit ModifyParameterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyParameterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyParameterResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyParameterResponse() = default;
};
class ModifyParameterGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> parameterGroupId{};
  shared_ptr<string> parameterGroupName{};
  shared_ptr<string> parameterGroupDesc{};
  shared_ptr<string> parameters{};
  shared_ptr<string> regionId{};

  ModifyParameterGroupRequest() {}

  explicit ModifyParameterGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (parameterGroupId) {
      res["ParameterGroupId"] = boost::any(*parameterGroupId);
    }
    if (parameterGroupName) {
      res["ParameterGroupName"] = boost::any(*parameterGroupName);
    }
    if (parameterGroupDesc) {
      res["ParameterGroupDesc"] = boost::any(*parameterGroupDesc);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ParameterGroupId") != m.end() && !m["ParameterGroupId"].empty()) {
      parameterGroupId = make_shared<string>(boost::any_cast<string>(m["ParameterGroupId"]));
    }
    if (m.find("ParameterGroupName") != m.end() && !m["ParameterGroupName"].empty()) {
      parameterGroupName = make_shared<string>(boost::any_cast<string>(m["ParameterGroupName"]));
    }
    if (m.find("ParameterGroupDesc") != m.end() && !m["ParameterGroupDesc"].empty()) {
      parameterGroupDesc = make_shared<string>(boost::any_cast<string>(m["ParameterGroupDesc"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyParameterGroupRequest() = default;
};
class ModifyParameterGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> parameterGroupId{};
  shared_ptr<string> requestId{};

  ModifyParameterGroupResponseBody() {}

  explicit ModifyParameterGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterGroupId) {
      res["ParameterGroupId"] = boost::any(*parameterGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterGroupId") != m.end() && !m["ParameterGroupId"].empty()) {
      parameterGroupId = make_shared<string>(boost::any_cast<string>(m["ParameterGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyParameterGroupResponseBody() = default;
};
class ModifyParameterGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyParameterGroupResponseBody> body{};

  ModifyParameterGroupResponse() {}

  explicit ModifyParameterGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyParameterGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyParameterGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyParameterGroupResponse() = default;
};
class ModifyReadonlyInstanceDelayReplicationTimeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> readSQLReplicationTime{};

  ModifyReadonlyInstanceDelayReplicationTimeRequest() {}

  explicit ModifyReadonlyInstanceDelayReplicationTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (readSQLReplicationTime) {
      res["ReadSQLReplicationTime"] = boost::any(*readSQLReplicationTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ReadSQLReplicationTime") != m.end() && !m["ReadSQLReplicationTime"].empty()) {
      readSQLReplicationTime = make_shared<string>(boost::any_cast<string>(m["ReadSQLReplicationTime"]));
    }
  }


  virtual ~ModifyReadonlyInstanceDelayReplicationTimeRequest() = default;
};
class ModifyReadonlyInstanceDelayReplicationTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> readSQLReplicationTime{};

  ModifyReadonlyInstanceDelayReplicationTimeResponseBody() {}

  explicit ModifyReadonlyInstanceDelayReplicationTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (readSQLReplicationTime) {
      res["ReadSQLReplicationTime"] = boost::any(*readSQLReplicationTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ReadSQLReplicationTime") != m.end() && !m["ReadSQLReplicationTime"].empty()) {
      readSQLReplicationTime = make_shared<string>(boost::any_cast<string>(m["ReadSQLReplicationTime"]));
    }
  }


  virtual ~ModifyReadonlyInstanceDelayReplicationTimeResponseBody() = default;
};
class ModifyReadonlyInstanceDelayReplicationTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyReadonlyInstanceDelayReplicationTimeResponseBody> body{};

  ModifyReadonlyInstanceDelayReplicationTimeResponse() {}

  explicit ModifyReadonlyInstanceDelayReplicationTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyReadonlyInstanceDelayReplicationTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyReadonlyInstanceDelayReplicationTimeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyReadonlyInstanceDelayReplicationTimeResponse() = default;
};
class ModifyReadWriteSplittingConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> connectionStringPrefix{};
  shared_ptr<string> port{};
  shared_ptr<string> maxDelayTime{};
  shared_ptr<string> distributionType{};
  shared_ptr<string> weight{};

  ModifyReadWriteSplittingConnectionRequest() {}

  explicit ModifyReadWriteSplittingConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (connectionStringPrefix) {
      res["ConnectionStringPrefix"] = boost::any(*connectionStringPrefix);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (maxDelayTime) {
      res["MaxDelayTime"] = boost::any(*maxDelayTime);
    }
    if (distributionType) {
      res["DistributionType"] = boost::any(*distributionType);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ConnectionStringPrefix") != m.end() && !m["ConnectionStringPrefix"].empty()) {
      connectionStringPrefix = make_shared<string>(boost::any_cast<string>(m["ConnectionStringPrefix"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("MaxDelayTime") != m.end() && !m["MaxDelayTime"].empty()) {
      maxDelayTime = make_shared<string>(boost::any_cast<string>(m["MaxDelayTime"]));
    }
    if (m.find("DistributionType") != m.end() && !m["DistributionType"].empty()) {
      distributionType = make_shared<string>(boost::any_cast<string>(m["DistributionType"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~ModifyReadWriteSplittingConnectionRequest() = default;
};
class ModifyReadWriteSplittingConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyReadWriteSplittingConnectionResponseBody() {}

  explicit ModifyReadWriteSplittingConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyReadWriteSplittingConnectionResponseBody() = default;
};
class ModifyReadWriteSplittingConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyReadWriteSplittingConnectionResponseBody> body{};

  ModifyReadWriteSplittingConnectionResponse() {}

  explicit ModifyReadWriteSplittingConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyReadWriteSplittingConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyReadWriteSplittingConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyReadWriteSplittingConnectionResponse() = default;
};
class ModifyResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> resourceGroupId{};

  ModifyResourceGroupRequest() {}

  explicit ModifyResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifyResourceGroupRequest() = default;
};
class ModifyResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyResourceGroupResponseBody() {}

  explicit ModifyResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyResourceGroupResponseBody() = default;
};
class ModifyResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyResourceGroupResponseBody> body{};

  ModifyResourceGroupResponse() {}

  explicit ModifyResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyResourceGroupResponse() = default;
};
class ModifySecurityGroupConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> securityGroupId{};

  ModifySecurityGroupConfigurationRequest() {}

  explicit ModifySecurityGroupConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~ModifySecurityGroupConfigurationRequest() = default;
};
class ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation : public Darabonba::Model {
public:
  shared_ptr<string> networkType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> regionId{};

  ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation() {}

  explicit ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation() = default;
};
class ModifySecurityGroupConfigurationResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation>> ecsSecurityGroupRelation{};

  ModifySecurityGroupConfigurationResponseBodyItems() {}

  explicit ModifySecurityGroupConfigurationResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsSecurityGroupRelation) {
      vector<boost::any> temp1;
      for(auto item1:*ecsSecurityGroupRelation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcsSecurityGroupRelation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsSecurityGroupRelation") != m.end() && !m["EcsSecurityGroupRelation"].empty()) {
      if (typeid(vector<boost::any>) == m["EcsSecurityGroupRelation"].type()) {
        vector<ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcsSecurityGroupRelation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecsSecurityGroupRelation = make_shared<vector<ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation>>(expect1);
      }
    }
  }


  virtual ~ModifySecurityGroupConfigurationResponseBodyItems() = default;
};
class ModifySecurityGroupConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceName{};
  shared_ptr<string> requestId{};
  shared_ptr<ModifySecurityGroupConfigurationResponseBodyItems> items{};

  ModifySecurityGroupConfigurationResponseBody() {}

  explicit ModifySecurityGroupConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        ModifySecurityGroupConfigurationResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<ModifySecurityGroupConfigurationResponseBodyItems>(model1);
      }
    }
  }


  virtual ~ModifySecurityGroupConfigurationResponseBody() = default;
};
class ModifySecurityGroupConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySecurityGroupConfigurationResponseBody> body{};

  ModifySecurityGroupConfigurationResponse() {}

  explicit ModifySecurityGroupConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySecurityGroupConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySecurityGroupConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySecurityGroupConfigurationResponse() = default;
};
class ModifySecurityIpsRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> securityIps{};
  shared_ptr<string> DBInstanceIPArrayName{};
  shared_ptr<string> DBInstanceIPArrayAttribute{};
  shared_ptr<string> securityIPType{};
  shared_ptr<string> whitelistNetworkType{};
  shared_ptr<string> modifyMode{};

  ModifySecurityIpsRequest() {}

  explicit ModifySecurityIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (securityIps) {
      res["SecurityIps"] = boost::any(*securityIps);
    }
    if (DBInstanceIPArrayName) {
      res["DBInstanceIPArrayName"] = boost::any(*DBInstanceIPArrayName);
    }
    if (DBInstanceIPArrayAttribute) {
      res["DBInstanceIPArrayAttribute"] = boost::any(*DBInstanceIPArrayAttribute);
    }
    if (securityIPType) {
      res["SecurityIPType"] = boost::any(*securityIPType);
    }
    if (whitelistNetworkType) {
      res["WhitelistNetworkType"] = boost::any(*whitelistNetworkType);
    }
    if (modifyMode) {
      res["ModifyMode"] = boost::any(*modifyMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("SecurityIps") != m.end() && !m["SecurityIps"].empty()) {
      securityIps = make_shared<string>(boost::any_cast<string>(m["SecurityIps"]));
    }
    if (m.find("DBInstanceIPArrayName") != m.end() && !m["DBInstanceIPArrayName"].empty()) {
      DBInstanceIPArrayName = make_shared<string>(boost::any_cast<string>(m["DBInstanceIPArrayName"]));
    }
    if (m.find("DBInstanceIPArrayAttribute") != m.end() && !m["DBInstanceIPArrayAttribute"].empty()) {
      DBInstanceIPArrayAttribute = make_shared<string>(boost::any_cast<string>(m["DBInstanceIPArrayAttribute"]));
    }
    if (m.find("SecurityIPType") != m.end() && !m["SecurityIPType"].empty()) {
      securityIPType = make_shared<string>(boost::any_cast<string>(m["SecurityIPType"]));
    }
    if (m.find("WhitelistNetworkType") != m.end() && !m["WhitelistNetworkType"].empty()) {
      whitelistNetworkType = make_shared<string>(boost::any_cast<string>(m["WhitelistNetworkType"]));
    }
    if (m.find("ModifyMode") != m.end() && !m["ModifyMode"].empty()) {
      modifyMode = make_shared<string>(boost::any_cast<string>(m["ModifyMode"]));
    }
  }


  virtual ~ModifySecurityIpsRequest() = default;
};
class ModifySecurityIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> requestId{};

  ModifySecurityIpsResponseBody() {}

  explicit ModifySecurityIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySecurityIpsResponseBody() = default;
};
class ModifySecurityIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySecurityIpsResponseBody> body{};

  ModifySecurityIpsResponse() {}

  explicit ModifySecurityIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySecurityIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySecurityIpsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySecurityIpsResponse() = default;
};
class ModifySQLCollectorPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> SQLCollectorStatus{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceGroupId{};

  ModifySQLCollectorPolicyRequest() {}

  explicit ModifySQLCollectorPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (SQLCollectorStatus) {
      res["SQLCollectorStatus"] = boost::any(*SQLCollectorStatus);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("SQLCollectorStatus") != m.end() && !m["SQLCollectorStatus"].empty()) {
      SQLCollectorStatus = make_shared<string>(boost::any_cast<string>(m["SQLCollectorStatus"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifySQLCollectorPolicyRequest() = default;
};
class ModifySQLCollectorPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySQLCollectorPolicyResponseBody() {}

  explicit ModifySQLCollectorPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySQLCollectorPolicyResponseBody() = default;
};
class ModifySQLCollectorPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySQLCollectorPolicyResponseBody> body{};

  ModifySQLCollectorPolicyResponse() {}

  explicit ModifySQLCollectorPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySQLCollectorPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySQLCollectorPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySQLCollectorPolicyResponse() = default;
};
class ModifySQLCollectorRetentionRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> configValue{};
  shared_ptr<string> resourceGroupId{};

  ModifySQLCollectorRetentionRequest() {}

  explicit ModifySQLCollectorRetentionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifySQLCollectorRetentionRequest() = default;
};
class ModifySQLCollectorRetentionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySQLCollectorRetentionResponseBody() {}

  explicit ModifySQLCollectorRetentionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySQLCollectorRetentionResponseBody() = default;
};
class ModifySQLCollectorRetentionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySQLCollectorRetentionResponseBody> body{};

  ModifySQLCollectorRetentionResponse() {}

  explicit ModifySQLCollectorRetentionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySQLCollectorRetentionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySQLCollectorRetentionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySQLCollectorRetentionResponse() = default;
};
class PurgeDBInstanceLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> ownerAccount{};

  PurgeDBInstanceLogRequest() {}

  explicit PurgeDBInstanceLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~PurgeDBInstanceLogRequest() = default;
};
class PurgeDBInstanceLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PurgeDBInstanceLogResponseBody() {}

  explicit PurgeDBInstanceLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PurgeDBInstanceLogResponseBody() = default;
};
class PurgeDBInstanceLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PurgeDBInstanceLogResponseBody> body{};

  PurgeDBInstanceLogResponse() {}

  explicit PurgeDBInstanceLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PurgeDBInstanceLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PurgeDBInstanceLogResponseBody>(model1);
      }
    }
  }


  virtual ~PurgeDBInstanceLogResponse() = default;
};
class RebuildDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> rebuildNodeType{};

  RebuildDBInstanceRequest() {}

  explicit RebuildDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (rebuildNodeType) {
      res["RebuildNodeType"] = boost::any(*rebuildNodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("RebuildNodeType") != m.end() && !m["RebuildNodeType"].empty()) {
      rebuildNodeType = make_shared<string>(boost::any_cast<string>(m["RebuildNodeType"]));
    }
  }


  virtual ~RebuildDBInstanceRequest() = default;
};
class RebuildDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> taskId{};
  shared_ptr<long> migrationId{};

  RebuildDBInstanceResponseBody() {}

  explicit RebuildDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (migrationId) {
      res["MigrationId"] = boost::any(*migrationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("MigrationId") != m.end() && !m["MigrationId"].empty()) {
      migrationId = make_shared<long>(boost::any_cast<long>(m["MigrationId"]));
    }
  }


  virtual ~RebuildDBInstanceResponseBody() = default;
};
class RebuildDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RebuildDBInstanceResponseBody> body{};

  RebuildDBInstanceResponse() {}

  explicit RebuildDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebuildDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebuildDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RebuildDBInstanceResponse() = default;
};
class RecoveryDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceClass{};
  shared_ptr<long> DBInstanceStorage{};
  shared_ptr<string> payType{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> targetDBInstanceId{};
  shared_ptr<string> dbNames{};
  shared_ptr<string> backupId{};
  shared_ptr<string> restoreTime{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> usedTime{};
  shared_ptr<string> period{};
  shared_ptr<string> DBInstanceStorageType{};

  RecoveryDBInstanceRequest() {}

  explicit RecoveryDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceClass) {
      res["DBInstanceClass"] = boost::any(*DBInstanceClass);
    }
    if (DBInstanceStorage) {
      res["DBInstanceStorage"] = boost::any(*DBInstanceStorage);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (targetDBInstanceId) {
      res["TargetDBInstanceId"] = boost::any(*targetDBInstanceId);
    }
    if (dbNames) {
      res["DbNames"] = boost::any(*dbNames);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (restoreTime) {
      res["RestoreTime"] = boost::any(*restoreTime);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (DBInstanceStorageType) {
      res["DBInstanceStorageType"] = boost::any(*DBInstanceStorageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceClass") != m.end() && !m["DBInstanceClass"].empty()) {
      DBInstanceClass = make_shared<string>(boost::any_cast<string>(m["DBInstanceClass"]));
    }
    if (m.find("DBInstanceStorage") != m.end() && !m["DBInstanceStorage"].empty()) {
      DBInstanceStorage = make_shared<long>(boost::any_cast<long>(m["DBInstanceStorage"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("TargetDBInstanceId") != m.end() && !m["TargetDBInstanceId"].empty()) {
      targetDBInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetDBInstanceId"]));
    }
    if (m.find("DbNames") != m.end() && !m["DbNames"].empty()) {
      dbNames = make_shared<string>(boost::any_cast<string>(m["DbNames"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("RestoreTime") != m.end() && !m["RestoreTime"].empty()) {
      restoreTime = make_shared<string>(boost::any_cast<string>(m["RestoreTime"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<string>(boost::any_cast<string>(m["UsedTime"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("DBInstanceStorageType") != m.end() && !m["DBInstanceStorageType"].empty()) {
      DBInstanceStorageType = make_shared<string>(boost::any_cast<string>(m["DBInstanceStorageType"]));
    }
  }


  virtual ~RecoveryDBInstanceRequest() = default;
};
class RecoveryDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> orderId{};

  RecoveryDBInstanceResponseBody() {}

  explicit RecoveryDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~RecoveryDBInstanceResponseBody() = default;
};
class RecoveryDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RecoveryDBInstanceResponseBody> body{};

  RecoveryDBInstanceResponse() {}

  explicit RecoveryDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecoveryDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecoveryDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RecoveryDBInstanceResponse() = default;
};
class ReleaseInstanceConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> currentConnectionString{};
  shared_ptr<string> instanceNetworkType{};
  shared_ptr<string> ownerAccount{};

  ReleaseInstanceConnectionRequest() {}

  explicit ReleaseInstanceConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (currentConnectionString) {
      res["CurrentConnectionString"] = boost::any(*currentConnectionString);
    }
    if (instanceNetworkType) {
      res["InstanceNetworkType"] = boost::any(*instanceNetworkType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("CurrentConnectionString") != m.end() && !m["CurrentConnectionString"].empty()) {
      currentConnectionString = make_shared<string>(boost::any_cast<string>(m["CurrentConnectionString"]));
    }
    if (m.find("InstanceNetworkType") != m.end() && !m["InstanceNetworkType"].empty()) {
      instanceNetworkType = make_shared<string>(boost::any_cast<string>(m["InstanceNetworkType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReleaseInstanceConnectionRequest() = default;
};
class ReleaseInstanceConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseInstanceConnectionResponseBody() {}

  explicit ReleaseInstanceConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseInstanceConnectionResponseBody() = default;
};
class ReleaseInstanceConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReleaseInstanceConnectionResponseBody> body{};

  ReleaseInstanceConnectionResponse() {}

  explicit ReleaseInstanceConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseInstanceConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseInstanceConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseInstanceConnectionResponse() = default;
};
class ReleaseInstancePublicConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> currentConnectionString{};
  shared_ptr<string> ownerAccount{};

  ReleaseInstancePublicConnectionRequest() {}

  explicit ReleaseInstancePublicConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (currentConnectionString) {
      res["CurrentConnectionString"] = boost::any(*currentConnectionString);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("CurrentConnectionString") != m.end() && !m["CurrentConnectionString"].empty()) {
      currentConnectionString = make_shared<string>(boost::any_cast<string>(m["CurrentConnectionString"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ReleaseInstancePublicConnectionRequest() = default;
};
class ReleaseInstancePublicConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseInstancePublicConnectionResponseBody() {}

  explicit ReleaseInstancePublicConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseInstancePublicConnectionResponseBody() = default;
};
class ReleaseInstancePublicConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReleaseInstancePublicConnectionResponseBody> body{};

  ReleaseInstancePublicConnectionResponse() {}

  explicit ReleaseInstancePublicConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseInstancePublicConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseInstancePublicConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseInstancePublicConnectionResponse() = default;
};
class ReleaseReadWriteSplittingConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};

  ReleaseReadWriteSplittingConnectionRequest() {}

  explicit ReleaseReadWriteSplittingConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
  }


  virtual ~ReleaseReadWriteSplittingConnectionRequest() = default;
};
class ReleaseReadWriteSplittingConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseReadWriteSplittingConnectionResponseBody() {}

  explicit ReleaseReadWriteSplittingConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseReadWriteSplittingConnectionResponseBody() = default;
};
class ReleaseReadWriteSplittingConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReleaseReadWriteSplittingConnectionResponseBody> body{};

  ReleaseReadWriteSplittingConnectionResponse() {}

  explicit ReleaseReadWriteSplittingConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseReadWriteSplittingConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseReadWriteSplittingConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseReadWriteSplittingConnectionResponse() = default;
};
class RemoveTagsFromResourceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  RemoveTagsFromResourceRequestTag() {}

  explicit RemoveTagsFromResourceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~RemoveTagsFromResourceRequestTag() = default;
};
class RemoveTagsFromResourceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<RemoveTagsFromResourceRequestTag>> tag{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> proxyId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> tags{};
  shared_ptr<string> ownerAccount{};

  RemoveTagsFromResourceRequest() {}

  explicit RemoveTagsFromResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (proxyId) {
      res["proxyId"] = boost::any(*proxyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<RemoveTagsFromResourceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveTagsFromResourceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<RemoveTagsFromResourceRequestTag>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("proxyId") != m.end() && !m["proxyId"].empty()) {
      proxyId = make_shared<string>(boost::any_cast<string>(m["proxyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~RemoveTagsFromResourceRequest() = default;
};
class RemoveTagsFromResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveTagsFromResourceResponseBody() {}

  explicit RemoveTagsFromResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveTagsFromResourceResponseBody() = default;
};
class RemoveTagsFromResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveTagsFromResourceResponseBody> body{};

  RemoveTagsFromResourceResponse() {}

  explicit RemoveTagsFromResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveTagsFromResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveTagsFromResourceResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveTagsFromResourceResponse() = default;
};
class RenewInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> period{};
  shared_ptr<string> autoPay{};

  RenewInstanceRequest() {}

  explicit RenewInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<string>(boost::any_cast<string>(m["AutoPay"]));
    }
  }


  virtual ~RenewInstanceRequest() = default;
};
class RenewInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<string> requestId{};

  RenewInstanceResponseBody() {}

  explicit RenewInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RenewInstanceResponseBody() = default;
};
class RenewInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RenewInstanceResponseBody> body{};

  RenewInstanceResponse() {}

  explicit RenewInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RenewInstanceResponse() = default;
};
class ReplaceDedicatedHostRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> failoverMode{};

  ReplaceDedicatedHostRequest() {}

  explicit ReplaceDedicatedHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (failoverMode) {
      res["FailoverMode"] = boost::any(*failoverMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("FailoverMode") != m.end() && !m["FailoverMode"].empty()) {
      failoverMode = make_shared<string>(boost::any_cast<string>(m["FailoverMode"]));
    }
  }


  virtual ~ReplaceDedicatedHostRequest() = default;
};
class ReplaceDedicatedHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<long> taskId{};
  shared_ptr<string> requestId{};

  ReplaceDedicatedHostResponseBody() {}

  explicit ReplaceDedicatedHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReplaceDedicatedHostResponseBody() = default;
};
class ReplaceDedicatedHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReplaceDedicatedHostResponseBody> body{};

  ReplaceDedicatedHostResponse() {}

  explicit ReplaceDedicatedHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReplaceDedicatedHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReplaceDedicatedHostResponseBody>(model1);
      }
    }
  }


  virtual ~ReplaceDedicatedHostResponse() = default;
};
class ResetAccountRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> accountPassword{};
  shared_ptr<string> ownerAccount{};

  ResetAccountRequest() {}

  explicit ResetAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountPassword) {
      res["AccountPassword"] = boost::any(*accountPassword);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountPassword") != m.end() && !m["AccountPassword"].empty()) {
      accountPassword = make_shared<string>(boost::any_cast<string>(m["AccountPassword"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ResetAccountRequest() = default;
};
class ResetAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetAccountResponseBody() {}

  explicit ResetAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetAccountResponseBody() = default;
};
class ResetAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResetAccountResponseBody> body{};

  ResetAccountResponse() {}

  explicit ResetAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAccountResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAccountResponse() = default;
};
class ResetAccountPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> accountPassword{};
  shared_ptr<string> ownerAccount{};

  ResetAccountPasswordRequest() {}

  explicit ResetAccountPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountPassword) {
      res["AccountPassword"] = boost::any(*accountPassword);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountPassword") != m.end() && !m["AccountPassword"].empty()) {
      accountPassword = make_shared<string>(boost::any_cast<string>(m["AccountPassword"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~ResetAccountPasswordRequest() = default;
};
class ResetAccountPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetAccountPasswordResponseBody() {}

  explicit ResetAccountPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetAccountPasswordResponseBody() = default;
};
class ResetAccountPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResetAccountPasswordResponseBody> body{};

  ResetAccountPasswordResponse() {}

  explicit ResetAccountPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAccountPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAccountPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAccountPasswordResponse() = default;
};
class RestartDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> ownerAccount{};

  RestartDBInstanceRequest() {}

  explicit RestartDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~RestartDBInstanceRequest() = default;
};
class RestartDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RestartDBInstanceResponseBody() {}

  explicit RestartDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RestartDBInstanceResponseBody() = default;
};
class RestartDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RestartDBInstanceResponseBody> body{};

  RestartDBInstanceResponse() {}

  explicit RestartDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RestartDBInstanceResponse() = default;
};
class RestartDedicatedHostRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<string> failoverMode{};

  RestartDedicatedHostRequest() {}

  explicit RestartDedicatedHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (failoverMode) {
      res["FailoverMode"] = boost::any(*failoverMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("FailoverMode") != m.end() && !m["FailoverMode"].empty()) {
      failoverMode = make_shared<string>(boost::any_cast<string>(m["FailoverMode"]));
    }
  }


  virtual ~RestartDedicatedHostRequest() = default;
};
class RestartDedicatedHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedHostId{};
  shared_ptr<long> taskId{};
  shared_ptr<string> requestId{};

  RestartDedicatedHostResponseBody() {}

  explicit RestartDedicatedHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedHostId) {
      res["DedicatedHostId"] = boost::any(*dedicatedHostId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedHostId") != m.end() && !m["DedicatedHostId"].empty()) {
      dedicatedHostId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RestartDedicatedHostResponseBody() = default;
};
class RestartDedicatedHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RestartDedicatedHostResponseBody> body{};

  RestartDedicatedHostResponse() {}

  explicit RestartDedicatedHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartDedicatedHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartDedicatedHostResponseBody>(model1);
      }
    }
  }


  virtual ~RestartDedicatedHostResponse() = default;
};
class RestoreDdrTableRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> restoreType{};
  shared_ptr<string> backupId{};
  shared_ptr<string> restoreTime{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> sourceDBInstanceName{};
  shared_ptr<string> tableMeta{};

  RestoreDdrTableRequest() {}

  explicit RestoreDdrTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (restoreType) {
      res["RestoreType"] = boost::any(*restoreType);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (restoreTime) {
      res["RestoreTime"] = boost::any(*restoreTime);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (sourceDBInstanceName) {
      res["SourceDBInstanceName"] = boost::any(*sourceDBInstanceName);
    }
    if (tableMeta) {
      res["TableMeta"] = boost::any(*tableMeta);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RestoreType") != m.end() && !m["RestoreType"].empty()) {
      restoreType = make_shared<string>(boost::any_cast<string>(m["RestoreType"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("RestoreTime") != m.end() && !m["RestoreTime"].empty()) {
      restoreTime = make_shared<string>(boost::any_cast<string>(m["RestoreTime"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("SourceDBInstanceName") != m.end() && !m["SourceDBInstanceName"].empty()) {
      sourceDBInstanceName = make_shared<string>(boost::any_cast<string>(m["SourceDBInstanceName"]));
    }
    if (m.find("TableMeta") != m.end() && !m["TableMeta"].empty()) {
      tableMeta = make_shared<string>(boost::any_cast<string>(m["TableMeta"]));
    }
  }


  virtual ~RestoreDdrTableRequest() = default;
};
class RestoreDdrTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RestoreDdrTableResponseBody() {}

  explicit RestoreDdrTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RestoreDdrTableResponseBody() = default;
};
class RestoreDdrTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RestoreDdrTableResponseBody> body{};

  RestoreDdrTableResponse() {}

  explicit RestoreDdrTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestoreDdrTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestoreDdrTableResponseBody>(model1);
      }
    }
  }


  virtual ~RestoreDdrTableResponse() = default;
};
class RestoreTableRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> backupId{};
  shared_ptr<string> restoreTime{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> tableMeta{};

  RestoreTableRequest() {}

  explicit RestoreTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (restoreTime) {
      res["RestoreTime"] = boost::any(*restoreTime);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (tableMeta) {
      res["TableMeta"] = boost::any(*tableMeta);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("RestoreTime") != m.end() && !m["RestoreTime"].empty()) {
      restoreTime = make_shared<string>(boost::any_cast<string>(m["RestoreTime"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("TableMeta") != m.end() && !m["TableMeta"].empty()) {
      tableMeta = make_shared<string>(boost::any_cast<string>(m["TableMeta"]));
    }
  }


  virtual ~RestoreTableRequest() = default;
};
class RestoreTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RestoreTableResponseBody() {}

  explicit RestoreTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RestoreTableResponseBody() = default;
};
class RestoreTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RestoreTableResponseBody> body{};

  RestoreTableResponse() {}

  explicit RestoreTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestoreTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestoreTableResponseBody>(model1);
      }
    }
  }


  virtual ~RestoreTableResponse() = default;
};
class RevokeAccountPrivilegeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> DBName{};
  shared_ptr<string> ownerAccount{};

  RevokeAccountPrivilegeRequest() {}

  explicit RevokeAccountPrivilegeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~RevokeAccountPrivilegeRequest() = default;
};
class RevokeAccountPrivilegeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeAccountPrivilegeResponseBody() {}

  explicit RevokeAccountPrivilegeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeAccountPrivilegeResponseBody() = default;
};
class RevokeAccountPrivilegeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RevokeAccountPrivilegeResponseBody> body{};

  RevokeAccountPrivilegeResponse() {}

  explicit RevokeAccountPrivilegeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeAccountPrivilegeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeAccountPrivilegeResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeAccountPrivilegeResponse() = default;
};
class RevokeOperatorPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> ownerAccount{};

  RevokeOperatorPermissionRequest() {}

  explicit RevokeOperatorPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~RevokeOperatorPermissionRequest() = default;
};
class RevokeOperatorPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeOperatorPermissionResponseBody() {}

  explicit RevokeOperatorPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeOperatorPermissionResponseBody() = default;
};
class RevokeOperatorPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RevokeOperatorPermissionResponseBody> body{};

  RevokeOperatorPermissionResponse() {}

  explicit RevokeOperatorPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeOperatorPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeOperatorPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeOperatorPermissionResponse() = default;
};
class StartDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> dedicatedHostGroupId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> targetDedicatedHostIdForMaster{};
  shared_ptr<string> targetDedicatedHostIdForSlave{};
  shared_ptr<string> targetDedicatedHostIdForLog{};
  shared_ptr<string> effectiveTime{};
  shared_ptr<string> specifiedTime{};
  shared_ptr<string> targetDBInstanceClass{};
  shared_ptr<string> engineVersion{};
  shared_ptr<long> DBInstanceTransType{};
  shared_ptr<long> storage{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> zoneId{};

  StartDBInstanceRequest() {}

  explicit StartDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (dedicatedHostGroupId) {
      res["DedicatedHostGroupId"] = boost::any(*dedicatedHostGroupId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (targetDedicatedHostIdForMaster) {
      res["TargetDedicatedHostIdForMaster"] = boost::any(*targetDedicatedHostIdForMaster);
    }
    if (targetDedicatedHostIdForSlave) {
      res["TargetDedicatedHostIdForSlave"] = boost::any(*targetDedicatedHostIdForSlave);
    }
    if (targetDedicatedHostIdForLog) {
      res["TargetDedicatedHostIdForLog"] = boost::any(*targetDedicatedHostIdForLog);
    }
    if (effectiveTime) {
      res["EffectiveTime"] = boost::any(*effectiveTime);
    }
    if (specifiedTime) {
      res["SpecifiedTime"] = boost::any(*specifiedTime);
    }
    if (targetDBInstanceClass) {
      res["TargetDBInstanceClass"] = boost::any(*targetDBInstanceClass);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (DBInstanceTransType) {
      res["DBInstanceTransType"] = boost::any(*DBInstanceTransType);
    }
    if (storage) {
      res["Storage"] = boost::any(*storage);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DedicatedHostGroupId") != m.end() && !m["DedicatedHostGroupId"].empty()) {
      dedicatedHostGroupId = make_shared<string>(boost::any_cast<string>(m["DedicatedHostGroupId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("TargetDedicatedHostIdForMaster") != m.end() && !m["TargetDedicatedHostIdForMaster"].empty()) {
      targetDedicatedHostIdForMaster = make_shared<string>(boost::any_cast<string>(m["TargetDedicatedHostIdForMaster"]));
    }
    if (m.find("TargetDedicatedHostIdForSlave") != m.end() && !m["TargetDedicatedHostIdForSlave"].empty()) {
      targetDedicatedHostIdForSlave = make_shared<string>(boost::any_cast<string>(m["TargetDedicatedHostIdForSlave"]));
    }
    if (m.find("TargetDedicatedHostIdForLog") != m.end() && !m["TargetDedicatedHostIdForLog"].empty()) {
      targetDedicatedHostIdForLog = make_shared<string>(boost::any_cast<string>(m["TargetDedicatedHostIdForLog"]));
    }
    if (m.find("EffectiveTime") != m.end() && !m["EffectiveTime"].empty()) {
      effectiveTime = make_shared<string>(boost::any_cast<string>(m["EffectiveTime"]));
    }
    if (m.find("SpecifiedTime") != m.end() && !m["SpecifiedTime"].empty()) {
      specifiedTime = make_shared<string>(boost::any_cast<string>(m["SpecifiedTime"]));
    }
    if (m.find("TargetDBInstanceClass") != m.end() && !m["TargetDBInstanceClass"].empty()) {
      targetDBInstanceClass = make_shared<string>(boost::any_cast<string>(m["TargetDBInstanceClass"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("DBInstanceTransType") != m.end() && !m["DBInstanceTransType"].empty()) {
      DBInstanceTransType = make_shared<long>(boost::any_cast<long>(m["DBInstanceTransType"]));
    }
    if (m.find("Storage") != m.end() && !m["Storage"].empty()) {
      storage = make_shared<long>(boost::any_cast<long>(m["Storage"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~StartDBInstanceRequest() = default;
};
class StartDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> taskId{};
  shared_ptr<long> migrationId{};

  StartDBInstanceResponseBody() {}

  explicit StartDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (migrationId) {
      res["MigrationId"] = boost::any(*migrationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("MigrationId") != m.end() && !m["MigrationId"].empty()) {
      migrationId = make_shared<long>(boost::any_cast<long>(m["MigrationId"]));
    }
  }


  virtual ~StartDBInstanceResponseBody() = default;
};
class StartDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartDBInstanceResponseBody> body{};

  StartDBInstanceResponse() {}

  explicit StartDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StartDBInstanceResponse() = default;
};
class StopDBInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> regionId{};

  StopDBInstanceRequest() {}

  explicit StopDBInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StopDBInstanceRequest() = default;
};
class StopDBInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopDBInstanceResponseBody() {}

  explicit StopDBInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopDBInstanceResponseBody() = default;
};
class StopDBInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopDBInstanceResponseBody> body{};

  StopDBInstanceResponse() {}

  explicit StopDBInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopDBInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopDBInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StopDBInstanceResponse() = default;
};
class SwitchDBInstanceHARequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> force{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> effectiveTime{};

  SwitchDBInstanceHARequest() {}

  explicit SwitchDBInstanceHARequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (effectiveTime) {
      res["EffectiveTime"] = boost::any(*effectiveTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<string>(boost::any_cast<string>(m["Force"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("EffectiveTime") != m.end() && !m["EffectiveTime"].empty()) {
      effectiveTime = make_shared<string>(boost::any_cast<string>(m["EffectiveTime"]));
    }
  }


  virtual ~SwitchDBInstanceHARequest() = default;
};
class SwitchDBInstanceHAResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SwitchDBInstanceHAResponseBody() {}

  explicit SwitchDBInstanceHAResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SwitchDBInstanceHAResponseBody() = default;
};
class SwitchDBInstanceHAResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SwitchDBInstanceHAResponseBody> body{};

  SwitchDBInstanceHAResponse() {}

  explicit SwitchDBInstanceHAResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchDBInstanceHAResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchDBInstanceHAResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchDBInstanceHAResponse() = default;
};
class SwitchDBInstanceNetTypeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> connectionStringPrefix{};
  shared_ptr<string> port{};
  shared_ptr<string> connectionStringType{};
  shared_ptr<string> ownerAccount{};

  SwitchDBInstanceNetTypeRequest() {}

  explicit SwitchDBInstanceNetTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (connectionStringPrefix) {
      res["ConnectionStringPrefix"] = boost::any(*connectionStringPrefix);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (connectionStringType) {
      res["ConnectionStringType"] = boost::any(*connectionStringType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("ConnectionStringPrefix") != m.end() && !m["ConnectionStringPrefix"].empty()) {
      connectionStringPrefix = make_shared<string>(boost::any_cast<string>(m["ConnectionStringPrefix"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ConnectionStringType") != m.end() && !m["ConnectionStringType"].empty()) {
      connectionStringType = make_shared<string>(boost::any_cast<string>(m["ConnectionStringType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SwitchDBInstanceNetTypeRequest() = default;
};
class SwitchDBInstanceNetTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> newConnectionString{};
  shared_ptr<string> requestId{};
  shared_ptr<string> oldConnectionString{};

  SwitchDBInstanceNetTypeResponseBody() {}

  explicit SwitchDBInstanceNetTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newConnectionString) {
      res["NewConnectionString"] = boost::any(*newConnectionString);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (oldConnectionString) {
      res["OldConnectionString"] = boost::any(*oldConnectionString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewConnectionString") != m.end() && !m["NewConnectionString"].empty()) {
      newConnectionString = make_shared<string>(boost::any_cast<string>(m["NewConnectionString"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OldConnectionString") != m.end() && !m["OldConnectionString"].empty()) {
      oldConnectionString = make_shared<string>(boost::any_cast<string>(m["OldConnectionString"]));
    }
  }


  virtual ~SwitchDBInstanceNetTypeResponseBody() = default;
};
class SwitchDBInstanceNetTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SwitchDBInstanceNetTypeResponseBody> body{};

  SwitchDBInstanceNetTypeResponse() {}

  explicit SwitchDBInstanceNetTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchDBInstanceNetTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchDBInstanceNetTypeResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchDBInstanceNetTypeResponse() = default;
};
class SwitchDBInstanceVpcRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> VPCId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> privateIpAddress{};

  SwitchDBInstanceVpcRequest() {}

  explicit SwitchDBInstanceVpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
  }


  virtual ~SwitchDBInstanceVpcRequest() = default;
};
class SwitchDBInstanceVpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SwitchDBInstanceVpcResponseBody() {}

  explicit SwitchDBInstanceVpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SwitchDBInstanceVpcResponseBody() = default;
};
class SwitchDBInstanceVpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SwitchDBInstanceVpcResponseBody> body{};

  SwitchDBInstanceVpcResponse() {}

  explicit SwitchDBInstanceVpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchDBInstanceVpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchDBInstanceVpcResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchDBInstanceVpcResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class TerminateMigrateTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> migrateTaskId{};

  TerminateMigrateTaskRequest() {}

  explicit TerminateMigrateTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (migrateTaskId) {
      res["MigrateTaskId"] = boost::any(*migrateTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("MigrateTaskId") != m.end() && !m["MigrateTaskId"].empty()) {
      migrateTaskId = make_shared<string>(boost::any_cast<string>(m["MigrateTaskId"]));
    }
  }


  virtual ~TerminateMigrateTaskRequest() = default;
};
class TerminateMigrateTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TerminateMigrateTaskResponseBody() {}

  explicit TerminateMigrateTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TerminateMigrateTaskResponseBody() = default;
};
class TerminateMigrateTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TerminateMigrateTaskResponseBody> body{};

  TerminateMigrateTaskResponse() {}

  explicit TerminateMigrateTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TerminateMigrateTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TerminateMigrateTaskResponseBody>(model1);
      }
    }
  }


  virtual ~TerminateMigrateTaskResponse() = default;
};
class TransformDBInstancePayTypeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<long> usedTime{};
  shared_ptr<string> payType{};
  shared_ptr<string> period{};
  shared_ptr<string> businessInfo{};

  TransformDBInstancePayTypeRequest() {}

  explicit TransformDBInstancePayTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (businessInfo) {
      res["BusinessInfo"] = boost::any(*businessInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<long>(boost::any_cast<long>(m["UsedTime"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("BusinessInfo") != m.end() && !m["BusinessInfo"].empty()) {
      businessInfo = make_shared<string>(boost::any_cast<string>(m["BusinessInfo"]));
    }
  }


  virtual ~TransformDBInstancePayTypeRequest() = default;
};
class TransformDBInstancePayTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> expiredTime{};
  shared_ptr<long> orderId{};
  shared_ptr<string> chargeType{};

  TransformDBInstancePayTypeResponseBody() {}

  explicit TransformDBInstancePayTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
  }


  virtual ~TransformDBInstancePayTypeResponseBody() = default;
};
class TransformDBInstancePayTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TransformDBInstancePayTypeResponseBody> body{};

  TransformDBInstancePayTypeResponse() {}

  explicit TransformDBInstancePayTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TransformDBInstancePayTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TransformDBInstancePayTypeResponseBody>(model1);
      }
    }
  }


  virtual ~TransformDBInstancePayTypeResponse() = default;
};
class UnlockAccountRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> accountName{};

  UnlockAccountRequest() {}

  explicit UnlockAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
  }


  virtual ~UnlockAccountRequest() = default;
};
class UnlockAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnlockAccountResponseBody() {}

  explicit UnlockAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnlockAccountResponseBody() = default;
};
class UnlockAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnlockAccountResponseBody> body{};

  UnlockAccountResponse() {}

  explicit UnlockAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnlockAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnlockAccountResponseBody>(model1);
      }
    }
  }


  virtual ~UnlockAccountResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<bool> all{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateUserBackupFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> backupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> comment{};
  shared_ptr<long> retention{};

  UpdateUserBackupFileRequest() {}

  explicit UpdateUserBackupFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
  }


  virtual ~UpdateUserBackupFileRequest() = default;
};
class UpdateUserBackupFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> backupId{};
  shared_ptr<string> requestId{};

  UpdateUserBackupFileResponseBody() {}

  explicit UpdateUserBackupFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupId) {
      res["BackupId"] = boost::any(*backupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupId") != m.end() && !m["BackupId"].empty()) {
      backupId = make_shared<string>(boost::any_cast<string>(m["BackupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateUserBackupFileResponseBody() = default;
};
class UpdateUserBackupFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateUserBackupFileResponseBody> body{};

  UpdateUserBackupFileResponse() {}

  explicit UpdateUserBackupFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUserBackupFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUserBackupFileResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUserBackupFileResponse() = default;
};
class UpgradeDBInstanceEngineVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> effectiveTime{};

  UpgradeDBInstanceEngineVersionRequest() {}

  explicit UpgradeDBInstanceEngineVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (effectiveTime) {
      res["EffectiveTime"] = boost::any(*effectiveTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("EffectiveTime") != m.end() && !m["EffectiveTime"].empty()) {
      effectiveTime = make_shared<string>(boost::any_cast<string>(m["EffectiveTime"]));
    }
  }


  virtual ~UpgradeDBInstanceEngineVersionRequest() = default;
};
class UpgradeDBInstanceEngineVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> requestId{};

  UpgradeDBInstanceEngineVersionResponseBody() {}

  explicit UpgradeDBInstanceEngineVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpgradeDBInstanceEngineVersionResponseBody() = default;
};
class UpgradeDBInstanceEngineVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpgradeDBInstanceEngineVersionResponseBody> body{};

  UpgradeDBInstanceEngineVersionResponse() {}

  explicit UpgradeDBInstanceEngineVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeDBInstanceEngineVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeDBInstanceEngineVersionResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeDBInstanceEngineVersionResponse() = default;
};
class UpgradeDBInstanceKernelVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> upgradeTime{};
  shared_ptr<string> switchTime{};
  shared_ptr<string> targetMinorVersion{};

  UpgradeDBInstanceKernelVersionRequest() {}

  explicit UpgradeDBInstanceKernelVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (upgradeTime) {
      res["UpgradeTime"] = boost::any(*upgradeTime);
    }
    if (switchTime) {
      res["SwitchTime"] = boost::any(*switchTime);
    }
    if (targetMinorVersion) {
      res["TargetMinorVersion"] = boost::any(*targetMinorVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("UpgradeTime") != m.end() && !m["UpgradeTime"].empty()) {
      upgradeTime = make_shared<string>(boost::any_cast<string>(m["UpgradeTime"]));
    }
    if (m.find("SwitchTime") != m.end() && !m["SwitchTime"].empty()) {
      switchTime = make_shared<string>(boost::any_cast<string>(m["SwitchTime"]));
    }
    if (m.find("TargetMinorVersion") != m.end() && !m["TargetMinorVersion"].empty()) {
      targetMinorVersion = make_shared<string>(boost::any_cast<string>(m["TargetMinorVersion"]));
    }
  }


  virtual ~UpgradeDBInstanceKernelVersionRequest() = default;
};
class UpgradeDBInstanceKernelVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceName{};
  shared_ptr<string> targetMinorVersion{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  UpgradeDBInstanceKernelVersionResponseBody() {}

  explicit UpgradeDBInstanceKernelVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    if (targetMinorVersion) {
      res["TargetMinorVersion"] = boost::any(*targetMinorVersion);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
    if (m.find("TargetMinorVersion") != m.end() && !m["TargetMinorVersion"].empty()) {
      targetMinorVersion = make_shared<string>(boost::any_cast<string>(m["TargetMinorVersion"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~UpgradeDBInstanceKernelVersionResponseBody() = default;
};
class UpgradeDBInstanceKernelVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpgradeDBInstanceKernelVersionResponseBody> body{};

  UpgradeDBInstanceKernelVersionResponse() {}

  explicit UpgradeDBInstanceKernelVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeDBInstanceKernelVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeDBInstanceKernelVersionResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeDBInstanceKernelVersionResponse() = default;
};
class UpgradeDBProxyInstanceKernelVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> DBInstanceId{};
  shared_ptr<string> upgradeTime{};
  shared_ptr<string> switchTime{};

  UpgradeDBProxyInstanceKernelVersionRequest() {}

  explicit UpgradeDBProxyInstanceKernelVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (DBInstanceId) {
      res["DBInstanceId"] = boost::any(*DBInstanceId);
    }
    if (upgradeTime) {
      res["UpgradeTime"] = boost::any(*upgradeTime);
    }
    if (switchTime) {
      res["SwitchTime"] = boost::any(*switchTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("DBInstanceId") != m.end() && !m["DBInstanceId"].empty()) {
      DBInstanceId = make_shared<string>(boost::any_cast<string>(m["DBInstanceId"]));
    }
    if (m.find("UpgradeTime") != m.end() && !m["UpgradeTime"].empty()) {
      upgradeTime = make_shared<string>(boost::any_cast<string>(m["UpgradeTime"]));
    }
    if (m.find("SwitchTime") != m.end() && !m["SwitchTime"].empty()) {
      switchTime = make_shared<string>(boost::any_cast<string>(m["SwitchTime"]));
    }
  }


  virtual ~UpgradeDBProxyInstanceKernelVersionRequest() = default;
};
class UpgradeDBProxyInstanceKernelVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DBInstanceName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  UpgradeDBProxyInstanceKernelVersionResponseBody() {}

  explicit UpgradeDBProxyInstanceKernelVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInstanceName) {
      res["DBInstanceName"] = boost::any(*DBInstanceName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInstanceName") != m.end() && !m["DBInstanceName"].empty()) {
      DBInstanceName = make_shared<string>(boost::any_cast<string>(m["DBInstanceName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~UpgradeDBProxyInstanceKernelVersionResponseBody() = default;
};
class UpgradeDBProxyInstanceKernelVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpgradeDBProxyInstanceKernelVersionResponseBody> body{};

  UpgradeDBProxyInstanceKernelVersionResponse() {}

  explicit UpgradeDBProxyInstanceKernelVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeDBProxyInstanceKernelVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeDBProxyInstanceKernelVersionResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeDBProxyInstanceKernelVersionResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddTagsToResourceResponse addTagsToResourceWithOptions(shared_ptr<AddTagsToResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTagsToResourceResponse addTagsToResource(shared_ptr<AddTagsToResourceRequest> request);
  AllocateInstancePublicConnectionResponse allocateInstancePublicConnectionWithOptions(shared_ptr<AllocateInstancePublicConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllocateInstancePublicConnectionResponse allocateInstancePublicConnection(shared_ptr<AllocateInstancePublicConnectionRequest> request);
  AllocateReadWriteSplittingConnectionResponse allocateReadWriteSplittingConnectionWithOptions(shared_ptr<AllocateReadWriteSplittingConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllocateReadWriteSplittingConnectionResponse allocateReadWriteSplittingConnection(shared_ptr<AllocateReadWriteSplittingConnectionRequest> request);
  CalculateDBInstanceWeightResponse calculateDBInstanceWeightWithOptions(shared_ptr<CalculateDBInstanceWeightRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CalculateDBInstanceWeightResponse calculateDBInstanceWeight(shared_ptr<CalculateDBInstanceWeightRequest> request);
  CancelImportResponse cancelImportWithOptions(shared_ptr<CancelImportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelImportResponse cancelImport(shared_ptr<CancelImportRequest> request);
  CheckAccountNameAvailableResponse checkAccountNameAvailableWithOptions(shared_ptr<CheckAccountNameAvailableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckAccountNameAvailableResponse checkAccountNameAvailable(shared_ptr<CheckAccountNameAvailableRequest> request);
  CheckCloudResourceAuthorizedResponse checkCloudResourceAuthorizedWithOptions(shared_ptr<CheckCloudResourceAuthorizedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckCloudResourceAuthorizedResponse checkCloudResourceAuthorized(shared_ptr<CheckCloudResourceAuthorizedRequest> request);
  CheckCreateDdrDBInstanceResponse checkCreateDdrDBInstanceWithOptions(shared_ptr<CheckCreateDdrDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckCreateDdrDBInstanceResponse checkCreateDdrDBInstance(shared_ptr<CheckCreateDdrDBInstanceRequest> request);
  CheckDBNameAvailableResponse checkDBNameAvailableWithOptions(shared_ptr<CheckDBNameAvailableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckDBNameAvailableResponse checkDBNameAvailable(shared_ptr<CheckDBNameAvailableRequest> request);
  CheckInstanceExistResponse checkInstanceExistWithOptions(shared_ptr<CheckInstanceExistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckInstanceExistResponse checkInstanceExist(shared_ptr<CheckInstanceExistRequest> request);
  ClearDedicatedHostResponse clearDedicatedHostWithOptions(shared_ptr<ClearDedicatedHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearDedicatedHostResponse clearDedicatedHost(shared_ptr<ClearDedicatedHostRequest> request);
  CloneDBInstanceResponse cloneDBInstanceWithOptions(shared_ptr<CloneDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloneDBInstanceResponse cloneDBInstance(shared_ptr<CloneDBInstanceRequest> request);
  CloneParameterGroupResponse cloneParameterGroupWithOptions(shared_ptr<CloneParameterGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloneParameterGroupResponse cloneParameterGroup(shared_ptr<CloneParameterGroupRequest> request);
  CopyDatabaseResponse copyDatabaseWithOptions(shared_ptr<CopyDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyDatabaseResponse copyDatabase(shared_ptr<CopyDatabaseRequest> request);
  CopyDatabaseBetweenInstancesResponse copyDatabaseBetweenInstancesWithOptions(shared_ptr<CopyDatabaseBetweenInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyDatabaseBetweenInstancesResponse copyDatabaseBetweenInstances(shared_ptr<CopyDatabaseBetweenInstancesRequest> request);
  CreateAccountResponse createAccountWithOptions(shared_ptr<CreateAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAccountResponse createAccount(shared_ptr<CreateAccountRequest> request);
  CreateBackupResponse createBackupWithOptions(shared_ptr<CreateBackupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBackupResponse createBackup(shared_ptr<CreateBackupRequest> request);
  CreateDatabaseResponse createDatabaseWithOptions(shared_ptr<CreateDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDatabaseResponse createDatabase(shared_ptr<CreateDatabaseRequest> request);
  CreateDBInstanceResponse createDBInstanceWithOptions(shared_ptr<CreateDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDBInstanceResponse createDBInstance(shared_ptr<CreateDBInstanceRequest> request);
  CreateDBProxyEndpointAddressResponse createDBProxyEndpointAddressWithOptions(shared_ptr<CreateDBProxyEndpointAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDBProxyEndpointAddressResponse createDBProxyEndpointAddress(shared_ptr<CreateDBProxyEndpointAddressRequest> request);
  CreateDdrInstanceResponse createDdrInstanceWithOptions(shared_ptr<CreateDdrInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDdrInstanceResponse createDdrInstance(shared_ptr<CreateDdrInstanceRequest> request);
  CreateDedicatedHostResponse createDedicatedHostWithOptions(shared_ptr<CreateDedicatedHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDedicatedHostResponse createDedicatedHost(shared_ptr<CreateDedicatedHostRequest> request);
  CreateDedicatedHostAccountResponse createDedicatedHostAccountWithOptions(shared_ptr<CreateDedicatedHostAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDedicatedHostAccountResponse createDedicatedHostAccount(shared_ptr<CreateDedicatedHostAccountRequest> request);
  CreateDedicatedHostGroupResponse createDedicatedHostGroupWithOptions(shared_ptr<CreateDedicatedHostGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDedicatedHostGroupResponse createDedicatedHostGroup(shared_ptr<CreateDedicatedHostGroupRequest> request);
  CreateDedicatedHostUserResponse createDedicatedHostUserWithOptions(shared_ptr<CreateDedicatedHostUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDedicatedHostUserResponse createDedicatedHostUser(shared_ptr<CreateDedicatedHostUserRequest> request);
  CreateDiagnosticReportResponse createDiagnosticReportWithOptions(shared_ptr<CreateDiagnosticReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDiagnosticReportResponse createDiagnosticReport(shared_ptr<CreateDiagnosticReportRequest> request);
  CreateMigrateTaskResponse createMigrateTaskWithOptions(shared_ptr<CreateMigrateTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMigrateTaskResponse createMigrateTask(shared_ptr<CreateMigrateTaskRequest> request);
  CreateMigrateTaskForSQLServerResponse createMigrateTaskForSQLServerWithOptions(shared_ptr<CreateMigrateTaskForSQLServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMigrateTaskForSQLServerResponse createMigrateTaskForSQLServer(shared_ptr<CreateMigrateTaskForSQLServerRequest> request);
  CreateOnlineDatabaseTaskResponse createOnlineDatabaseTaskWithOptions(shared_ptr<CreateOnlineDatabaseTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOnlineDatabaseTaskResponse createOnlineDatabaseTask(shared_ptr<CreateOnlineDatabaseTaskRequest> request);
  CreateParameterGroupResponse createParameterGroupWithOptions(shared_ptr<CreateParameterGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateParameterGroupResponse createParameterGroup(shared_ptr<CreateParameterGroupRequest> request);
  CreateReadOnlyDBInstanceResponse createReadOnlyDBInstanceWithOptions(shared_ptr<CreateReadOnlyDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateReadOnlyDBInstanceResponse createReadOnlyDBInstance(shared_ptr<CreateReadOnlyDBInstanceRequest> request);
  CreateTempDBInstanceResponse createTempDBInstanceWithOptions(shared_ptr<CreateTempDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTempDBInstanceResponse createTempDBInstance(shared_ptr<CreateTempDBInstanceRequest> request);
  DeleteAccountResponse deleteAccountWithOptions(shared_ptr<DeleteAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAccountResponse deleteAccount(shared_ptr<DeleteAccountRequest> request);
  DeleteBackupResponse deleteBackupWithOptions(shared_ptr<DeleteBackupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBackupResponse deleteBackup(shared_ptr<DeleteBackupRequest> request);
  DeleteBackupFileResponse deleteBackupFileWithOptions(shared_ptr<DeleteBackupFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBackupFileResponse deleteBackupFile(shared_ptr<DeleteBackupFileRequest> request);
  DeleteDatabaseResponse deleteDatabaseWithOptions(shared_ptr<DeleteDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDatabaseResponse deleteDatabase(shared_ptr<DeleteDatabaseRequest> request);
  DeleteDBInstanceResponse deleteDBInstanceWithOptions(shared_ptr<DeleteDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDBInstanceResponse deleteDBInstance(shared_ptr<DeleteDBInstanceRequest> request);
  DeleteDBProxyEndpointAddressResponse deleteDBProxyEndpointAddressWithOptions(shared_ptr<DeleteDBProxyEndpointAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDBProxyEndpointAddressResponse deleteDBProxyEndpointAddress(shared_ptr<DeleteDBProxyEndpointAddressRequest> request);
  DeleteDedicatedHostAccountResponse deleteDedicatedHostAccountWithOptions(shared_ptr<DeleteDedicatedHostAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDedicatedHostAccountResponse deleteDedicatedHostAccount(shared_ptr<DeleteDedicatedHostAccountRequest> request);
  DeleteDedicatedHostGroupResponse deleteDedicatedHostGroupWithOptions(shared_ptr<DeleteDedicatedHostGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDedicatedHostGroupResponse deleteDedicatedHostGroup(shared_ptr<DeleteDedicatedHostGroupRequest> request);
  DeleteParameterGroupResponse deleteParameterGroupWithOptions(shared_ptr<DeleteParameterGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteParameterGroupResponse deleteParameterGroup(shared_ptr<DeleteParameterGroupRequest> request);
  DeleteUserBackupFileResponse deleteUserBackupFileWithOptions(shared_ptr<DeleteUserBackupFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserBackupFileResponse deleteUserBackupFile(shared_ptr<DeleteUserBackupFileRequest> request);
  DescibeImportsFromDatabaseResponse descibeImportsFromDatabaseWithOptions(shared_ptr<DescibeImportsFromDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescibeImportsFromDatabaseResponse descibeImportsFromDatabase(shared_ptr<DescibeImportsFromDatabaseRequest> request);
  DescribeAccountsResponse describeAccountsWithOptions(shared_ptr<DescribeAccountsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccountsResponse describeAccounts(shared_ptr<DescribeAccountsRequest> request);
  DescribeActionEventPolicyResponse describeActionEventPolicyWithOptions(shared_ptr<DescribeActionEventPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeActionEventPolicyResponse describeActionEventPolicy(shared_ptr<DescribeActionEventPolicyRequest> request);
  DescribeAvailableClassesResponse describeAvailableClassesWithOptions(shared_ptr<DescribeAvailableClassesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableClassesResponse describeAvailableClasses(shared_ptr<DescribeAvailableClassesRequest> request);
  DescribeAvailableCrossRegionResponse describeAvailableCrossRegionWithOptions(shared_ptr<DescribeAvailableCrossRegionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableCrossRegionResponse describeAvailableCrossRegion(shared_ptr<DescribeAvailableCrossRegionRequest> request);
  DescribeAvailableDedicatedHostClassesResponse describeAvailableDedicatedHostClassesWithOptions(shared_ptr<DescribeAvailableDedicatedHostClassesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableDedicatedHostClassesResponse describeAvailableDedicatedHostClasses(shared_ptr<DescribeAvailableDedicatedHostClassesRequest> request);
  DescribeAvailableDedicatedHostZonesResponse describeAvailableDedicatedHostZonesWithOptions(shared_ptr<DescribeAvailableDedicatedHostZonesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableDedicatedHostZonesResponse describeAvailableDedicatedHostZones(shared_ptr<DescribeAvailableDedicatedHostZonesRequest> request);
  DescribeAvailableMetricsResponse describeAvailableMetricsWithOptions(shared_ptr<DescribeAvailableMetricsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableMetricsResponse describeAvailableMetrics(shared_ptr<DescribeAvailableMetricsRequest> request);
  DescribeAvailableRecoveryTimeResponse describeAvailableRecoveryTimeWithOptions(shared_ptr<DescribeAvailableRecoveryTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableRecoveryTimeResponse describeAvailableRecoveryTime(shared_ptr<DescribeAvailableRecoveryTimeRequest> request);
  DescribeAvailableZonesResponse describeAvailableZonesWithOptions(shared_ptr<DescribeAvailableZonesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableZonesResponse describeAvailableZones(shared_ptr<DescribeAvailableZonesRequest> request);
  DescribeBackupDatabaseResponse describeBackupDatabaseWithOptions(shared_ptr<DescribeBackupDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupDatabaseResponse describeBackupDatabase(shared_ptr<DescribeBackupDatabaseRequest> request);
  DescribeBackupPolicyResponse describeBackupPolicyWithOptions(shared_ptr<DescribeBackupPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupPolicyResponse describeBackupPolicy(shared_ptr<DescribeBackupPolicyRequest> request);
  DescribeBackupsResponse describeBackupsWithOptions(shared_ptr<DescribeBackupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupsResponse describeBackups(shared_ptr<DescribeBackupsRequest> request);
  DescribeBackupTasksResponse describeBackupTasksWithOptions(shared_ptr<DescribeBackupTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupTasksResponse describeBackupTasks(shared_ptr<DescribeBackupTasksRequest> request);
  DescribeBinlogFilesResponse describeBinlogFilesWithOptions(shared_ptr<DescribeBinlogFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBinlogFilesResponse describeBinlogFiles(shared_ptr<DescribeBinlogFilesRequest> request);
  DescribeCharacterSetNameResponse describeCharacterSetNameWithOptions(shared_ptr<DescribeCharacterSetNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCharacterSetNameResponse describeCharacterSetName(shared_ptr<DescribeCharacterSetNameRequest> request);
  DescribeCollationTimeZonesResponse describeCollationTimeZonesWithOptions(shared_ptr<DescribeCollationTimeZonesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCollationTimeZonesResponse describeCollationTimeZones(shared_ptr<DescribeCollationTimeZonesRequest> request);
  DescribeCrossBackupMetaListResponse describeCrossBackupMetaListWithOptions(shared_ptr<DescribeCrossBackupMetaListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCrossBackupMetaListResponse describeCrossBackupMetaList(shared_ptr<DescribeCrossBackupMetaListRequest> request);
  DescribeCrossRegionBackupDBInstanceResponse describeCrossRegionBackupDBInstanceWithOptions(shared_ptr<DescribeCrossRegionBackupDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCrossRegionBackupDBInstanceResponse describeCrossRegionBackupDBInstance(shared_ptr<DescribeCrossRegionBackupDBInstanceRequest> request);
  DescribeCrossRegionBackupsResponse describeCrossRegionBackupsWithOptions(shared_ptr<DescribeCrossRegionBackupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCrossRegionBackupsResponse describeCrossRegionBackups(shared_ptr<DescribeCrossRegionBackupsRequest> request);
  DescribeCrossRegionLogBackupFilesResponse describeCrossRegionLogBackupFilesWithOptions(shared_ptr<DescribeCrossRegionLogBackupFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCrossRegionLogBackupFilesResponse describeCrossRegionLogBackupFiles(shared_ptr<DescribeCrossRegionLogBackupFilesRequest> request);
  DescribeDatabasesResponse describeDatabasesWithOptions(shared_ptr<DescribeDatabasesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDatabasesResponse describeDatabases(shared_ptr<DescribeDatabasesRequest> request);
  DescribeDBInstanceAttributeResponse describeDBInstanceAttributeWithOptions(shared_ptr<DescribeDBInstanceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstanceAttributeResponse describeDBInstanceAttribute(shared_ptr<DescribeDBInstanceAttributeRequest> request);
  DescribeDBInstanceDetailResponse describeDBInstanceDetailWithOptions(shared_ptr<DescribeDBInstanceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstanceDetailResponse describeDBInstanceDetail(shared_ptr<DescribeDBInstanceDetailRequest> request);
  DescribeDBInstanceEncryptionKeyResponse describeDBInstanceEncryptionKeyWithOptions(shared_ptr<DescribeDBInstanceEncryptionKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstanceEncryptionKeyResponse describeDBInstanceEncryptionKey(shared_ptr<DescribeDBInstanceEncryptionKeyRequest> request);
  DescribeDBInstanceHAConfigResponse describeDBInstanceHAConfigWithOptions(shared_ptr<DescribeDBInstanceHAConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstanceHAConfigResponse describeDBInstanceHAConfig(shared_ptr<DescribeDBInstanceHAConfigRequest> request);
  DescribeDBInstanceIPArrayListResponse describeDBInstanceIPArrayListWithOptions(shared_ptr<DescribeDBInstanceIPArrayListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstanceIPArrayListResponse describeDBInstanceIPArrayList(shared_ptr<DescribeDBInstanceIPArrayListRequest> request);
  DescribeDBInstanceIpHostnameResponse describeDBInstanceIpHostnameWithOptions(shared_ptr<DescribeDBInstanceIpHostnameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstanceIpHostnameResponse describeDBInstanceIpHostname(shared_ptr<DescribeDBInstanceIpHostnameRequest> request);
  DescribeDBInstanceMetricsResponse describeDBInstanceMetricsWithOptions(shared_ptr<DescribeDBInstanceMetricsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstanceMetricsResponse describeDBInstanceMetrics(shared_ptr<DescribeDBInstanceMetricsRequest> request);
  DescribeDBInstanceMonitorResponse describeDBInstanceMonitorWithOptions(shared_ptr<DescribeDBInstanceMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstanceMonitorResponse describeDBInstanceMonitor(shared_ptr<DescribeDBInstanceMonitorRequest> request);
  DescribeDBInstanceNetInfoResponse describeDBInstanceNetInfoWithOptions(shared_ptr<DescribeDBInstanceNetInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstanceNetInfoResponse describeDBInstanceNetInfo(shared_ptr<DescribeDBInstanceNetInfoRequest> request);
  DescribeDBInstancePerformanceResponse describeDBInstancePerformanceWithOptions(shared_ptr<DescribeDBInstancePerformanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstancePerformanceResponse describeDBInstancePerformance(shared_ptr<DescribeDBInstancePerformanceRequest> request);
  DescribeDBInstanceProxyConfigurationResponse describeDBInstanceProxyConfigurationWithOptions(shared_ptr<DescribeDBInstanceProxyConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstanceProxyConfigurationResponse describeDBInstanceProxyConfiguration(shared_ptr<DescribeDBInstanceProxyConfigurationRequest> request);
  DescribeDBInstancesResponse describeDBInstancesWithOptions(shared_ptr<DescribeDBInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstancesResponse describeDBInstances(shared_ptr<DescribeDBInstancesRequest> request);
  DescribeDBInstancesAsCsvResponse describeDBInstancesAsCsvWithOptions(shared_ptr<DescribeDBInstancesAsCsvRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstancesAsCsvResponse describeDBInstancesAsCsv(shared_ptr<DescribeDBInstancesAsCsvRequest> request);
  DescribeDBInstancesByExpireTimeResponse describeDBInstancesByExpireTimeWithOptions(shared_ptr<DescribeDBInstancesByExpireTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstancesByExpireTimeResponse describeDBInstancesByExpireTime(shared_ptr<DescribeDBInstancesByExpireTimeRequest> request);
  DescribeDBInstancesByPerformanceResponse describeDBInstancesByPerformanceWithOptions(shared_ptr<DescribeDBInstancesByPerformanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstancesByPerformanceResponse describeDBInstancesByPerformance(shared_ptr<DescribeDBInstancesByPerformanceRequest> request);
  DescribeDBInstancesForCloneResponse describeDBInstancesForCloneWithOptions(shared_ptr<DescribeDBInstancesForCloneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstancesForCloneResponse describeDBInstancesForClone(shared_ptr<DescribeDBInstancesForCloneRequest> request);
  DescribeDBInstanceSSLResponse describeDBInstanceSSLWithOptions(shared_ptr<DescribeDBInstanceSSLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstanceSSLResponse describeDBInstanceSSL(shared_ptr<DescribeDBInstanceSSLRequest> request);
  DescribeDBInstanceStatusResponse describeDBInstanceStatusWithOptions(shared_ptr<DescribeDBInstanceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstanceStatusResponse describeDBInstanceStatus(shared_ptr<DescribeDBInstanceStatusRequest> request);
  DescribeDBInstanceTDEResponse describeDBInstanceTDEWithOptions(shared_ptr<DescribeDBInstanceTDERequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBInstanceTDEResponse describeDBInstanceTDE(shared_ptr<DescribeDBInstanceTDERequest> request);
  DescribeDBProxyResponse describeDBProxyWithOptions(shared_ptr<DescribeDBProxyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBProxyResponse describeDBProxy(shared_ptr<DescribeDBProxyRequest> request);
  DescribeDBProxyEndpointResponse describeDBProxyEndpointWithOptions(shared_ptr<DescribeDBProxyEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBProxyEndpointResponse describeDBProxyEndpoint(shared_ptr<DescribeDBProxyEndpointRequest> request);
  DescribeDBProxyPerformanceResponse describeDBProxyPerformanceWithOptions(shared_ptr<DescribeDBProxyPerformanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDBProxyPerformanceResponse describeDBProxyPerformance(shared_ptr<DescribeDBProxyPerformanceRequest> request);
  DescribeDedicatedHostAttributeResponse describeDedicatedHostAttributeWithOptions(shared_ptr<DescribeDedicatedHostAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedHostAttributeResponse describeDedicatedHostAttribute(shared_ptr<DescribeDedicatedHostAttributeRequest> request);
  DescribeDedicatedHostGroupsResponse describeDedicatedHostGroupsWithOptions(shared_ptr<DescribeDedicatedHostGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedHostGroupsResponse describeDedicatedHostGroups(shared_ptr<DescribeDedicatedHostGroupsRequest> request);
  DescribeDedicatedHostImageCategoriesResponse describeDedicatedHostImageCategoriesWithOptions(shared_ptr<DescribeDedicatedHostImageCategoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedHostImageCategoriesResponse describeDedicatedHostImageCategories(shared_ptr<DescribeDedicatedHostImageCategoriesRequest> request);
  DescribeDedicatedHostsResponse describeDedicatedHostsWithOptions(shared_ptr<DescribeDedicatedHostsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedHostsResponse describeDedicatedHosts(shared_ptr<DescribeDedicatedHostsRequest> request);
  DescribeDetachedBackupsResponse describeDetachedBackupsWithOptions(shared_ptr<DescribeDetachedBackupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDetachedBackupsResponse describeDetachedBackups(shared_ptr<DescribeDetachedBackupsRequest> request);
  DescribeDiagnosticReportListResponse describeDiagnosticReportListWithOptions(shared_ptr<DescribeDiagnosticReportListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDiagnosticReportListResponse describeDiagnosticReportList(shared_ptr<DescribeDiagnosticReportListRequest> request);
  DescribeDownloadLinkDetailsResponse describeDownloadLinkDetailsWithOptions(shared_ptr<DescribeDownloadLinkDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDownloadLinkDetailsResponse describeDownloadLinkDetails(shared_ptr<DescribeDownloadLinkDetailsRequest> request);
  DescribeDTCSecurityIpHostsForSQLServerResponse describeDTCSecurityIpHostsForSQLServerWithOptions(shared_ptr<DescribeDTCSecurityIpHostsForSQLServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDTCSecurityIpHostsForSQLServerResponse describeDTCSecurityIpHostsForSQLServer(shared_ptr<DescribeDTCSecurityIpHostsForSQLServerRequest> request);
  DescribeErrorLogsResponse describeErrorLogsWithOptions(shared_ptr<DescribeErrorLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeErrorLogsResponse describeErrorLogs(shared_ptr<DescribeErrorLogsRequest> request);
  DescribeEventsResponse describeEventsWithOptions(shared_ptr<DescribeEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventsResponse describeEvents(shared_ptr<DescribeEventsRequest> request);
  DescribeHADiagnoseConfigResponse describeHADiagnoseConfigWithOptions(shared_ptr<DescribeHADiagnoseConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHADiagnoseConfigResponse describeHADiagnoseConfig(shared_ptr<DescribeHADiagnoseConfigRequest> request);
  DescribeHASwitchConfigResponse describeHASwitchConfigWithOptions(shared_ptr<DescribeHASwitchConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHASwitchConfigResponse describeHASwitchConfig(shared_ptr<DescribeHASwitchConfigRequest> request);
  DescribeInstanceAutoRenewalAttributeResponse describeInstanceAutoRenewalAttributeWithOptions(shared_ptr<DescribeInstanceAutoRenewalAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceAutoRenewalAttributeResponse describeInstanceAutoRenewalAttribute(shared_ptr<DescribeInstanceAutoRenewalAttributeRequest> request);
  DescribeInstanceCrossBackupPolicyResponse describeInstanceCrossBackupPolicyWithOptions(shared_ptr<DescribeInstanceCrossBackupPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceCrossBackupPolicyResponse describeInstanceCrossBackupPolicy(shared_ptr<DescribeInstanceCrossBackupPolicyRequest> request);
  DescribeInstanceKeywordsResponse describeInstanceKeywordsWithOptions(shared_ptr<DescribeInstanceKeywordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceKeywordsResponse describeInstanceKeywords(shared_ptr<DescribeInstanceKeywordsRequest> request);
  DescribeLocalAvailableRecoveryTimeResponse describeLocalAvailableRecoveryTimeWithOptions(shared_ptr<DescribeLocalAvailableRecoveryTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLocalAvailableRecoveryTimeResponse describeLocalAvailableRecoveryTime(shared_ptr<DescribeLocalAvailableRecoveryTimeRequest> request);
  DescribeLogBackupFilesResponse describeLogBackupFilesWithOptions(shared_ptr<DescribeLogBackupFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLogBackupFilesResponse describeLogBackupFiles(shared_ptr<DescribeLogBackupFilesRequest> request);
  DescribeMetaListResponse describeMetaListWithOptions(shared_ptr<DescribeMetaListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetaListResponse describeMetaList(shared_ptr<DescribeMetaListRequest> request);
  DescribeMigrateTaskByIdResponse describeMigrateTaskByIdWithOptions(shared_ptr<DescribeMigrateTaskByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMigrateTaskByIdResponse describeMigrateTaskById(shared_ptr<DescribeMigrateTaskByIdRequest> request);
  DescribeMigrateTasksResponse describeMigrateTasksWithOptions(shared_ptr<DescribeMigrateTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMigrateTasksResponse describeMigrateTasks(shared_ptr<DescribeMigrateTasksRequest> request);
  DescribeMigrateTasksForSQLServerResponse describeMigrateTasksForSQLServerWithOptions(shared_ptr<DescribeMigrateTasksForSQLServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMigrateTasksForSQLServerResponse describeMigrateTasksForSQLServer(shared_ptr<DescribeMigrateTasksForSQLServerRequest> request);
  DescribeModifyParameterLogResponse describeModifyParameterLogWithOptions(shared_ptr<DescribeModifyParameterLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeModifyParameterLogResponse describeModifyParameterLog(shared_ptr<DescribeModifyParameterLogRequest> request);
  DescribeOssDownloadsResponse describeOssDownloadsWithOptions(shared_ptr<DescribeOssDownloadsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOssDownloadsResponse describeOssDownloads(shared_ptr<DescribeOssDownloadsRequest> request);
  DescribeOssDownloadsForSQLServerResponse describeOssDownloadsForSQLServerWithOptions(shared_ptr<DescribeOssDownloadsForSQLServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOssDownloadsForSQLServerResponse describeOssDownloadsForSQLServer(shared_ptr<DescribeOssDownloadsForSQLServerRequest> request);
  DescribeParameterGroupResponse describeParameterGroupWithOptions(shared_ptr<DescribeParameterGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeParameterGroupResponse describeParameterGroup(shared_ptr<DescribeParameterGroupRequest> request);
  DescribeParameterGroupsResponse describeParameterGroupsWithOptions(shared_ptr<DescribeParameterGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeParameterGroupsResponse describeParameterGroups(shared_ptr<DescribeParameterGroupsRequest> request);
  DescribeParametersResponse describeParametersWithOptions(shared_ptr<DescribeParametersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeParametersResponse describeParameters(shared_ptr<DescribeParametersRequest> request);
  DescribeParameterTemplatesResponse describeParameterTemplatesWithOptions(shared_ptr<DescribeParameterTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeParameterTemplatesResponse describeParameterTemplates(shared_ptr<DescribeParameterTemplatesRequest> request);
  DescribePriceResponse describePriceWithOptions(shared_ptr<DescribePriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePriceResponse describePrice(shared_ptr<DescribePriceRequest> request);
  DescribeRdsResourceSettingsResponse describeRdsResourceSettingsWithOptions(shared_ptr<DescribeRdsResourceSettingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRdsResourceSettingsResponse describeRdsResourceSettings(shared_ptr<DescribeRdsResourceSettingsRequest> request);
  DescribeReadDBInstanceDelayResponse describeReadDBInstanceDelayWithOptions(shared_ptr<DescribeReadDBInstanceDelayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeReadDBInstanceDelayResponse describeReadDBInstanceDelay(shared_ptr<DescribeReadDBInstanceDelayRequest> request);
  DescribeRegionInfosResponse describeRegionInfosWithOptions(shared_ptr<DescribeRegionInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionInfosResponse describeRegionInfos(shared_ptr<DescribeRegionInfosRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  DescribeRenewalPriceResponse describeRenewalPriceWithOptions(shared_ptr<DescribeRenewalPriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRenewalPriceResponse describeRenewalPrice(shared_ptr<DescribeRenewalPriceRequest> request);
  DescribeResourceUsageResponse describeResourceUsageWithOptions(shared_ptr<DescribeResourceUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceUsageResponse describeResourceUsage(shared_ptr<DescribeResourceUsageRequest> request);
  DescribeSecurityGroupConfigurationResponse describeSecurityGroupConfigurationWithOptions(shared_ptr<DescribeSecurityGroupConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityGroupConfigurationResponse describeSecurityGroupConfiguration(shared_ptr<DescribeSecurityGroupConfigurationRequest> request);
  DescribeSlowLogRecordsResponse describeSlowLogRecordsWithOptions(shared_ptr<DescribeSlowLogRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSlowLogRecordsResponse describeSlowLogRecords(shared_ptr<DescribeSlowLogRecordsRequest> request);
  DescribeSlowLogsResponse describeSlowLogsWithOptions(shared_ptr<DescribeSlowLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSlowLogsResponse describeSlowLogs(shared_ptr<DescribeSlowLogsRequest> request);
  DescribeSQLCollectorPolicyResponse describeSQLCollectorPolicyWithOptions(shared_ptr<DescribeSQLCollectorPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSQLCollectorPolicyResponse describeSQLCollectorPolicy(shared_ptr<DescribeSQLCollectorPolicyRequest> request);
  DescribeSQLCollectorRetentionResponse describeSQLCollectorRetentionWithOptions(shared_ptr<DescribeSQLCollectorRetentionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSQLCollectorRetentionResponse describeSQLCollectorRetention(shared_ptr<DescribeSQLCollectorRetentionRequest> request);
  DescribeSQLLogFilesResponse describeSQLLogFilesWithOptions(shared_ptr<DescribeSQLLogFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSQLLogFilesResponse describeSQLLogFiles(shared_ptr<DescribeSQLLogFilesRequest> request);
  DescribeSQLLogRecordsResponse describeSQLLogRecordsWithOptions(shared_ptr<DescribeSQLLogRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSQLLogRecordsResponse describeSQLLogRecords(shared_ptr<DescribeSQLLogRecordsRequest> request);
  DescribeSQLLogReportListResponse describeSQLLogReportListWithOptions(shared_ptr<DescribeSQLLogReportListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSQLLogReportListResponse describeSQLLogReportList(shared_ptr<DescribeSQLLogReportListRequest> request);
  DescribeSQLLogReportsResponse describeSQLLogReportsWithOptions(shared_ptr<DescribeSQLLogReportsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSQLLogReportsResponse describeSQLLogReports(shared_ptr<DescribeSQLLogReportsRequest> request);
  DescribeTagsResponse describeTagsWithOptions(shared_ptr<DescribeTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagsResponse describeTags(shared_ptr<DescribeTagsRequest> request);
  DescribeTasksResponse describeTasksWithOptions(shared_ptr<DescribeTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTasksResponse describeTasks(shared_ptr<DescribeTasksRequest> request);
  DescribeVSwitchesResponse describeVSwitchesWithOptions(shared_ptr<DescribeVSwitchesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVSwitchesResponse describeVSwitches(shared_ptr<DescribeVSwitchesRequest> request);
  DestroyDBInstanceResponse destroyDBInstanceWithOptions(shared_ptr<DestroyDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DestroyDBInstanceResponse destroyDBInstance(shared_ptr<DestroyDBInstanceRequest> request);
  DropDedicatedHostUserResponse dropDedicatedHostUserWithOptions(shared_ptr<DropDedicatedHostUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DropDedicatedHostUserResponse dropDedicatedHostUser(shared_ptr<DropDedicatedHostUserRequest> request);
  EvaluateDedicatedHostInstanceResourceResponse evaluateDedicatedHostInstanceResourceWithOptions(shared_ptr<EvaluateDedicatedHostInstanceResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EvaluateDedicatedHostInstanceResourceResponse evaluateDedicatedHostInstanceResource(shared_ptr<EvaluateDedicatedHostInstanceResourceRequest> request);
  GetDbProxyInstanceSslResponse getDbProxyInstanceSslWithOptions(shared_ptr<GetDbProxyInstanceSslRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDbProxyInstanceSslResponse getDbProxyInstanceSsl(shared_ptr<GetDbProxyInstanceSslRequest> request);
  GrantAccountPrivilegeResponse grantAccountPrivilegeWithOptions(shared_ptr<GrantAccountPrivilegeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantAccountPrivilegeResponse grantAccountPrivilege(shared_ptr<GrantAccountPrivilegeRequest> request);
  GrantOperatorPermissionResponse grantOperatorPermissionWithOptions(shared_ptr<GrantOperatorPermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantOperatorPermissionResponse grantOperatorPermission(shared_ptr<GrantOperatorPermissionRequest> request);
  ImportDatabaseBetweenInstancesResponse importDatabaseBetweenInstancesWithOptions(shared_ptr<ImportDatabaseBetweenInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportDatabaseBetweenInstancesResponse importDatabaseBetweenInstances(shared_ptr<ImportDatabaseBetweenInstancesRequest> request);
  ImportUserBackupFileResponse importUserBackupFileWithOptions(shared_ptr<ImportUserBackupFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportUserBackupFileResponse importUserBackupFile(shared_ptr<ImportUserBackupFileRequest> request);
  ListClassesResponse listClassesWithOptions(shared_ptr<ListClassesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClassesResponse listClasses(shared_ptr<ListClassesRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListUserBackupFilesResponse listUserBackupFilesWithOptions(shared_ptr<ListUserBackupFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserBackupFilesResponse listUserBackupFiles(shared_ptr<ListUserBackupFilesRequest> request);
  LockAccountResponse lockAccountWithOptions(shared_ptr<LockAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LockAccountResponse lockAccount(shared_ptr<LockAccountRequest> request);
  MigrateDBInstanceResponse migrateDBInstanceWithOptions(shared_ptr<MigrateDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MigrateDBInstanceResponse migrateDBInstance(shared_ptr<MigrateDBInstanceRequest> request);
  MigrateSecurityIPModeResponse migrateSecurityIPModeWithOptions(shared_ptr<MigrateSecurityIPModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MigrateSecurityIPModeResponse migrateSecurityIPMode(shared_ptr<MigrateSecurityIPModeRequest> request);
  MigrateToOtherZoneResponse migrateToOtherZoneWithOptions(shared_ptr<MigrateToOtherZoneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MigrateToOtherZoneResponse migrateToOtherZone(shared_ptr<MigrateToOtherZoneRequest> request);
  ModifyAccountDescriptionResponse modifyAccountDescriptionWithOptions(shared_ptr<ModifyAccountDescriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAccountDescriptionResponse modifyAccountDescription(shared_ptr<ModifyAccountDescriptionRequest> request);
  ModifyActionEventPolicyResponse modifyActionEventPolicyWithOptions(shared_ptr<ModifyActionEventPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyActionEventPolicyResponse modifyActionEventPolicy(shared_ptr<ModifyActionEventPolicyRequest> request);
  ModifyBackupPolicyResponse modifyBackupPolicyWithOptions(shared_ptr<ModifyBackupPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBackupPolicyResponse modifyBackupPolicy(shared_ptr<ModifyBackupPolicyRequest> request);
  ModifyCollationTimeZoneResponse modifyCollationTimeZoneWithOptions(shared_ptr<ModifyCollationTimeZoneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCollationTimeZoneResponse modifyCollationTimeZone(shared_ptr<ModifyCollationTimeZoneRequest> request);
  ModifyDasInstanceConfigResponse modifyDasInstanceConfigWithOptions(shared_ptr<ModifyDasInstanceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDasInstanceConfigResponse modifyDasInstanceConfig(shared_ptr<ModifyDasInstanceConfigRequest> request);
  ModifyDBDescriptionResponse modifyDBDescriptionWithOptions(shared_ptr<ModifyDBDescriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBDescriptionResponse modifyDBDescription(shared_ptr<ModifyDBDescriptionRequest> request);
  ModifyDBInstanceAutoUpgradeMinorVersionResponse modifyDBInstanceAutoUpgradeMinorVersionWithOptions(shared_ptr<ModifyDBInstanceAutoUpgradeMinorVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceAutoUpgradeMinorVersionResponse modifyDBInstanceAutoUpgradeMinorVersion(shared_ptr<ModifyDBInstanceAutoUpgradeMinorVersionRequest> request);
  ModifyDBInstanceConnectionModeResponse modifyDBInstanceConnectionModeWithOptions(shared_ptr<ModifyDBInstanceConnectionModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceConnectionModeResponse modifyDBInstanceConnectionMode(shared_ptr<ModifyDBInstanceConnectionModeRequest> request);
  ModifyDBInstanceConnectionStringResponse modifyDBInstanceConnectionStringWithOptions(shared_ptr<ModifyDBInstanceConnectionStringRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceConnectionStringResponse modifyDBInstanceConnectionString(shared_ptr<ModifyDBInstanceConnectionStringRequest> request);
  ModifyDBInstanceDescriptionResponse modifyDBInstanceDescriptionWithOptions(shared_ptr<ModifyDBInstanceDescriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceDescriptionResponse modifyDBInstanceDescription(shared_ptr<ModifyDBInstanceDescriptionRequest> request);
  ModifyDBInstanceHAConfigResponse modifyDBInstanceHAConfigWithOptions(shared_ptr<ModifyDBInstanceHAConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceHAConfigResponse modifyDBInstanceHAConfig(shared_ptr<ModifyDBInstanceHAConfigRequest> request);
  ModifyDBInstanceMaintainTimeResponse modifyDBInstanceMaintainTimeWithOptions(shared_ptr<ModifyDBInstanceMaintainTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceMaintainTimeResponse modifyDBInstanceMaintainTime(shared_ptr<ModifyDBInstanceMaintainTimeRequest> request);
  ModifyDBInstanceMetricsResponse modifyDBInstanceMetricsWithOptions(shared_ptr<ModifyDBInstanceMetricsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceMetricsResponse modifyDBInstanceMetrics(shared_ptr<ModifyDBInstanceMetricsRequest> request);
  ModifyDBInstanceMonitorResponse modifyDBInstanceMonitorWithOptions(shared_ptr<ModifyDBInstanceMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceMonitorResponse modifyDBInstanceMonitor(shared_ptr<ModifyDBInstanceMonitorRequest> request);
  ModifyDBInstanceNetworkExpireTimeResponse modifyDBInstanceNetworkExpireTimeWithOptions(shared_ptr<ModifyDBInstanceNetworkExpireTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceNetworkExpireTimeResponse modifyDBInstanceNetworkExpireTime(shared_ptr<ModifyDBInstanceNetworkExpireTimeRequest> request);
  ModifyDBInstanceNetworkTypeResponse modifyDBInstanceNetworkTypeWithOptions(shared_ptr<ModifyDBInstanceNetworkTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceNetworkTypeResponse modifyDBInstanceNetworkType(shared_ptr<ModifyDBInstanceNetworkTypeRequest> request);
  ModifyDBInstancePayTypeResponse modifyDBInstancePayTypeWithOptions(shared_ptr<ModifyDBInstancePayTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstancePayTypeResponse modifyDBInstancePayType(shared_ptr<ModifyDBInstancePayTypeRequest> request);
  ModifyDBInstanceProxyConfigurationResponse modifyDBInstanceProxyConfigurationWithOptions(shared_ptr<ModifyDBInstanceProxyConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceProxyConfigurationResponse modifyDBInstanceProxyConfiguration(shared_ptr<ModifyDBInstanceProxyConfigurationRequest> request);
  ModifyDBInstanceSpecResponse modifyDBInstanceSpecWithOptions(shared_ptr<ModifyDBInstanceSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceSpecResponse modifyDBInstanceSpec(shared_ptr<ModifyDBInstanceSpecRequest> request);
  ModifyDBInstanceSSLResponse modifyDBInstanceSSLWithOptions(shared_ptr<ModifyDBInstanceSSLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceSSLResponse modifyDBInstanceSSL(shared_ptr<ModifyDBInstanceSSLRequest> request);
  ModifyDBInstanceTDEResponse modifyDBInstanceTDEWithOptions(shared_ptr<ModifyDBInstanceTDERequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBInstanceTDEResponse modifyDBInstanceTDE(shared_ptr<ModifyDBInstanceTDERequest> request);
  ModifyDBProxyResponse modifyDBProxyWithOptions(shared_ptr<ModifyDBProxyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBProxyResponse modifyDBProxy(shared_ptr<ModifyDBProxyRequest> request);
  ModifyDBProxyEndpointResponse modifyDBProxyEndpointWithOptions(shared_ptr<ModifyDBProxyEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBProxyEndpointResponse modifyDBProxyEndpoint(shared_ptr<ModifyDBProxyEndpointRequest> request);
  ModifyDBProxyEndpointAddressResponse modifyDBProxyEndpointAddressWithOptions(shared_ptr<ModifyDBProxyEndpointAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBProxyEndpointAddressResponse modifyDBProxyEndpointAddress(shared_ptr<ModifyDBProxyEndpointAddressRequest> request);
  ModifyDBProxyInstanceResponse modifyDBProxyInstanceWithOptions(shared_ptr<ModifyDBProxyInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDBProxyInstanceResponse modifyDBProxyInstance(shared_ptr<ModifyDBProxyInstanceRequest> request);
  ModifyDbProxyInstanceSslResponse modifyDbProxyInstanceSslWithOptions(shared_ptr<ModifyDbProxyInstanceSslRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDbProxyInstanceSslResponse modifyDbProxyInstanceSsl(shared_ptr<ModifyDbProxyInstanceSslRequest> request);
  ModifyDedicatedHostAccountResponse modifyDedicatedHostAccountWithOptions(shared_ptr<ModifyDedicatedHostAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedHostAccountResponse modifyDedicatedHostAccount(shared_ptr<ModifyDedicatedHostAccountRequest> request);
  ModifyDedicatedHostAttributeResponse modifyDedicatedHostAttributeWithOptions(shared_ptr<ModifyDedicatedHostAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedHostAttributeResponse modifyDedicatedHostAttribute(shared_ptr<ModifyDedicatedHostAttributeRequest> request);
  ModifyDedicatedHostGroupAttributeResponse modifyDedicatedHostGroupAttributeWithOptions(shared_ptr<ModifyDedicatedHostGroupAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedHostGroupAttributeResponse modifyDedicatedHostGroupAttribute(shared_ptr<ModifyDedicatedHostGroupAttributeRequest> request);
  ModifyDedicatedHostUserResponse modifyDedicatedHostUserWithOptions(shared_ptr<ModifyDedicatedHostUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedHostUserResponse modifyDedicatedHostUser(shared_ptr<ModifyDedicatedHostUserRequest> request);
  ModifyDTCSecurityIpHostsForSQLServerResponse modifyDTCSecurityIpHostsForSQLServerWithOptions(shared_ptr<ModifyDTCSecurityIpHostsForSQLServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDTCSecurityIpHostsForSQLServerResponse modifyDTCSecurityIpHostsForSQLServer(shared_ptr<ModifyDTCSecurityIpHostsForSQLServerRequest> request);
  ModifyHADiagnoseConfigResponse modifyHADiagnoseConfigWithOptions(shared_ptr<ModifyHADiagnoseConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHADiagnoseConfigResponse modifyHADiagnoseConfig(shared_ptr<ModifyHADiagnoseConfigRequest> request);
  ModifyHASwitchConfigResponse modifyHASwitchConfigWithOptions(shared_ptr<ModifyHASwitchConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHASwitchConfigResponse modifyHASwitchConfig(shared_ptr<ModifyHASwitchConfigRequest> request);
  ModifyInstanceAutoRenewalAttributeResponse modifyInstanceAutoRenewalAttributeWithOptions(shared_ptr<ModifyInstanceAutoRenewalAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAutoRenewalAttributeResponse modifyInstanceAutoRenewalAttribute(shared_ptr<ModifyInstanceAutoRenewalAttributeRequest> request);
  ModifyInstanceCrossBackupPolicyResponse modifyInstanceCrossBackupPolicyWithOptions(shared_ptr<ModifyInstanceCrossBackupPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceCrossBackupPolicyResponse modifyInstanceCrossBackupPolicy(shared_ptr<ModifyInstanceCrossBackupPolicyRequest> request);
  ModifyParameterResponse modifyParameterWithOptions(shared_ptr<ModifyParameterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyParameterResponse modifyParameter(shared_ptr<ModifyParameterRequest> request);
  ModifyParameterGroupResponse modifyParameterGroupWithOptions(shared_ptr<ModifyParameterGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyParameterGroupResponse modifyParameterGroup(shared_ptr<ModifyParameterGroupRequest> request);
  ModifyReadonlyInstanceDelayReplicationTimeResponse modifyReadonlyInstanceDelayReplicationTimeWithOptions(shared_ptr<ModifyReadonlyInstanceDelayReplicationTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyReadonlyInstanceDelayReplicationTimeResponse modifyReadonlyInstanceDelayReplicationTime(shared_ptr<ModifyReadonlyInstanceDelayReplicationTimeRequest> request);
  ModifyReadWriteSplittingConnectionResponse modifyReadWriteSplittingConnectionWithOptions(shared_ptr<ModifyReadWriteSplittingConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyReadWriteSplittingConnectionResponse modifyReadWriteSplittingConnection(shared_ptr<ModifyReadWriteSplittingConnectionRequest> request);
  ModifyResourceGroupResponse modifyResourceGroupWithOptions(shared_ptr<ModifyResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyResourceGroupResponse modifyResourceGroup(shared_ptr<ModifyResourceGroupRequest> request);
  ModifySecurityGroupConfigurationResponse modifySecurityGroupConfigurationWithOptions(shared_ptr<ModifySecurityGroupConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySecurityGroupConfigurationResponse modifySecurityGroupConfiguration(shared_ptr<ModifySecurityGroupConfigurationRequest> request);
  ModifySecurityIpsResponse modifySecurityIpsWithOptions(shared_ptr<ModifySecurityIpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySecurityIpsResponse modifySecurityIps(shared_ptr<ModifySecurityIpsRequest> request);
  ModifySQLCollectorPolicyResponse modifySQLCollectorPolicyWithOptions(shared_ptr<ModifySQLCollectorPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySQLCollectorPolicyResponse modifySQLCollectorPolicy(shared_ptr<ModifySQLCollectorPolicyRequest> request);
  ModifySQLCollectorRetentionResponse modifySQLCollectorRetentionWithOptions(shared_ptr<ModifySQLCollectorRetentionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySQLCollectorRetentionResponse modifySQLCollectorRetention(shared_ptr<ModifySQLCollectorRetentionRequest> request);
  PurgeDBInstanceLogResponse purgeDBInstanceLogWithOptions(shared_ptr<PurgeDBInstanceLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PurgeDBInstanceLogResponse purgeDBInstanceLog(shared_ptr<PurgeDBInstanceLogRequest> request);
  RebuildDBInstanceResponse rebuildDBInstanceWithOptions(shared_ptr<RebuildDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebuildDBInstanceResponse rebuildDBInstance(shared_ptr<RebuildDBInstanceRequest> request);
  RecoveryDBInstanceResponse recoveryDBInstanceWithOptions(shared_ptr<RecoveryDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecoveryDBInstanceResponse recoveryDBInstance(shared_ptr<RecoveryDBInstanceRequest> request);
  ReleaseInstanceConnectionResponse releaseInstanceConnectionWithOptions(shared_ptr<ReleaseInstanceConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseInstanceConnectionResponse releaseInstanceConnection(shared_ptr<ReleaseInstanceConnectionRequest> request);
  ReleaseInstancePublicConnectionResponse releaseInstancePublicConnectionWithOptions(shared_ptr<ReleaseInstancePublicConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseInstancePublicConnectionResponse releaseInstancePublicConnection(shared_ptr<ReleaseInstancePublicConnectionRequest> request);
  ReleaseReadWriteSplittingConnectionResponse releaseReadWriteSplittingConnectionWithOptions(shared_ptr<ReleaseReadWriteSplittingConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseReadWriteSplittingConnectionResponse releaseReadWriteSplittingConnection(shared_ptr<ReleaseReadWriteSplittingConnectionRequest> request);
  RemoveTagsFromResourceResponse removeTagsFromResourceWithOptions(shared_ptr<RemoveTagsFromResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveTagsFromResourceResponse removeTagsFromResource(shared_ptr<RemoveTagsFromResourceRequest> request);
  RenewInstanceResponse renewInstanceWithOptions(shared_ptr<RenewInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewInstanceResponse renewInstance(shared_ptr<RenewInstanceRequest> request);
  ReplaceDedicatedHostResponse replaceDedicatedHostWithOptions(shared_ptr<ReplaceDedicatedHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReplaceDedicatedHostResponse replaceDedicatedHost(shared_ptr<ReplaceDedicatedHostRequest> request);
  ResetAccountResponse resetAccountWithOptions(shared_ptr<ResetAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAccountResponse resetAccount(shared_ptr<ResetAccountRequest> request);
  ResetAccountPasswordResponse resetAccountPasswordWithOptions(shared_ptr<ResetAccountPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAccountPasswordResponse resetAccountPassword(shared_ptr<ResetAccountPasswordRequest> request);
  RestartDBInstanceResponse restartDBInstanceWithOptions(shared_ptr<RestartDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartDBInstanceResponse restartDBInstance(shared_ptr<RestartDBInstanceRequest> request);
  RestartDedicatedHostResponse restartDedicatedHostWithOptions(shared_ptr<RestartDedicatedHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartDedicatedHostResponse restartDedicatedHost(shared_ptr<RestartDedicatedHostRequest> request);
  RestoreDdrTableResponse restoreDdrTableWithOptions(shared_ptr<RestoreDdrTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestoreDdrTableResponse restoreDdrTable(shared_ptr<RestoreDdrTableRequest> request);
  RestoreTableResponse restoreTableWithOptions(shared_ptr<RestoreTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestoreTableResponse restoreTable(shared_ptr<RestoreTableRequest> request);
  RevokeAccountPrivilegeResponse revokeAccountPrivilegeWithOptions(shared_ptr<RevokeAccountPrivilegeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeAccountPrivilegeResponse revokeAccountPrivilege(shared_ptr<RevokeAccountPrivilegeRequest> request);
  RevokeOperatorPermissionResponse revokeOperatorPermissionWithOptions(shared_ptr<RevokeOperatorPermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeOperatorPermissionResponse revokeOperatorPermission(shared_ptr<RevokeOperatorPermissionRequest> request);
  StartDBInstanceResponse startDBInstanceWithOptions(shared_ptr<StartDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDBInstanceResponse startDBInstance(shared_ptr<StartDBInstanceRequest> request);
  StopDBInstanceResponse stopDBInstanceWithOptions(shared_ptr<StopDBInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDBInstanceResponse stopDBInstance(shared_ptr<StopDBInstanceRequest> request);
  SwitchDBInstanceHAResponse switchDBInstanceHAWithOptions(shared_ptr<SwitchDBInstanceHARequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchDBInstanceHAResponse switchDBInstanceHA(shared_ptr<SwitchDBInstanceHARequest> request);
  SwitchDBInstanceNetTypeResponse switchDBInstanceNetTypeWithOptions(shared_ptr<SwitchDBInstanceNetTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchDBInstanceNetTypeResponse switchDBInstanceNetType(shared_ptr<SwitchDBInstanceNetTypeRequest> request);
  SwitchDBInstanceVpcResponse switchDBInstanceVpcWithOptions(shared_ptr<SwitchDBInstanceVpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchDBInstanceVpcResponse switchDBInstanceVpc(shared_ptr<SwitchDBInstanceVpcRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  TerminateMigrateTaskResponse terminateMigrateTaskWithOptions(shared_ptr<TerminateMigrateTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TerminateMigrateTaskResponse terminateMigrateTask(shared_ptr<TerminateMigrateTaskRequest> request);
  TransformDBInstancePayTypeResponse transformDBInstancePayTypeWithOptions(shared_ptr<TransformDBInstancePayTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TransformDBInstancePayTypeResponse transformDBInstancePayType(shared_ptr<TransformDBInstancePayTypeRequest> request);
  UnlockAccountResponse unlockAccountWithOptions(shared_ptr<UnlockAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnlockAccountResponse unlockAccount(shared_ptr<UnlockAccountRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateUserBackupFileResponse updateUserBackupFileWithOptions(shared_ptr<UpdateUserBackupFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUserBackupFileResponse updateUserBackupFile(shared_ptr<UpdateUserBackupFileRequest> request);
  UpgradeDBInstanceEngineVersionResponse upgradeDBInstanceEngineVersionWithOptions(shared_ptr<UpgradeDBInstanceEngineVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeDBInstanceEngineVersionResponse upgradeDBInstanceEngineVersion(shared_ptr<UpgradeDBInstanceEngineVersionRequest> request);
  UpgradeDBInstanceKernelVersionResponse upgradeDBInstanceKernelVersionWithOptions(shared_ptr<UpgradeDBInstanceKernelVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeDBInstanceKernelVersionResponse upgradeDBInstanceKernelVersion(shared_ptr<UpgradeDBInstanceKernelVersionRequest> request);
  UpgradeDBProxyInstanceKernelVersionResponse upgradeDBProxyInstanceKernelVersionWithOptions(shared_ptr<UpgradeDBProxyInstanceKernelVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeDBProxyInstanceKernelVersionResponse upgradeDBProxyInstanceKernelVersion(shared_ptr<UpgradeDBProxyInstanceKernelVersionRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Rds20140815

#endif
