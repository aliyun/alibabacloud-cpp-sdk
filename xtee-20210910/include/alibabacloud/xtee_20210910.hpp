// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_XTEE20210910_H_
#define ALIBABACLOUD_XTEE20210910_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Xtee20210910 {
class BindVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> apiRegionId{};
  shared_ptr<string> apiType{};
  shared_ptr<string> createType{};
  shared_ptr<string> defineId{};
  shared_ptr<string> defineIds{};
  shared_ptr<string> description{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> exceptionValue{};
  shared_ptr<long> id{};
  shared_ptr<string> outputField{};
  shared_ptr<string> outputType{};
  shared_ptr<string> params{};
  shared_ptr<string> paramsList{};
  shared_ptr<string> regId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};

  BindVariableRequest() {}

  explicit BindVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (apiRegionId) {
      res["apiRegionId"] = boost::any(*apiRegionId);
    }
    if (apiType) {
      res["apiType"] = boost::any(*apiType);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (defineIds) {
      res["defineIds"] = boost::any(*defineIds);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (exceptionValue) {
      res["exceptionValue"] = boost::any(*exceptionValue);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (outputField) {
      res["outputField"] = boost::any(*outputField);
    }
    if (outputType) {
      res["outputType"] = boost::any(*outputType);
    }
    if (params) {
      res["params"] = boost::any(*params);
    }
    if (paramsList) {
      res["paramsList"] = boost::any(*paramsList);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("apiRegionId") != m.end() && !m["apiRegionId"].empty()) {
      apiRegionId = make_shared<string>(boost::any_cast<string>(m["apiRegionId"]));
    }
    if (m.find("apiType") != m.end() && !m["apiType"].empty()) {
      apiType = make_shared<string>(boost::any_cast<string>(m["apiType"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("defineIds") != m.end() && !m["defineIds"].empty()) {
      defineIds = make_shared<string>(boost::any_cast<string>(m["defineIds"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("exceptionValue") != m.end() && !m["exceptionValue"].empty()) {
      exceptionValue = make_shared<string>(boost::any_cast<string>(m["exceptionValue"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("outputField") != m.end() && !m["outputField"].empty()) {
      outputField = make_shared<string>(boost::any_cast<string>(m["outputField"]));
    }
    if (m.find("outputType") != m.end() && !m["outputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["outputType"]));
    }
    if (m.find("params") != m.end() && !m["params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["params"]));
    }
    if (m.find("paramsList") != m.end() && !m["paramsList"].empty()) {
      paramsList = make_shared<string>(boost::any_cast<string>(m["paramsList"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~BindVariableRequest() = default;
};
class BindVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  BindVariableResponseBody() {}

  explicit BindVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~BindVariableResponseBody() = default;
};
class BindVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindVariableResponseBody> body{};

  BindVariableResponse() {}

  explicit BindVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindVariableResponseBody>(model1);
      }
    }
  }


  virtual ~BindVariableResponse() = default;
};
class CheckCustVariableLimitRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> regId{};

  CheckCustVariableLimitRequest() {}

  explicit CheckCustVariableLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~CheckCustVariableLimitRequest() = default;
};
class CheckCustVariableLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CheckCustVariableLimitResponseBody() {}

  explicit CheckCustVariableLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CheckCustVariableLimitResponseBody() = default;
};
class CheckCustVariableLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckCustVariableLimitResponseBody> body{};

  CheckCustVariableLimitResponse() {}

  explicit CheckCustVariableLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckCustVariableLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckCustVariableLimitResponseBody>(model1);
      }
    }
  }


  virtual ~CheckCustVariableLimitResponse() = default;
};
class CheckExpressionVariableLimitRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  CheckExpressionVariableLimitRequest() {}

  explicit CheckExpressionVariableLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~CheckExpressionVariableLimitRequest() = default;
};
class CheckExpressionVariableLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CheckExpressionVariableLimitResponseBody() {}

  explicit CheckExpressionVariableLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CheckExpressionVariableLimitResponseBody() = default;
};
class CheckExpressionVariableLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckExpressionVariableLimitResponseBody> body{};

  CheckExpressionVariableLimitResponse() {}

  explicit CheckExpressionVariableLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckExpressionVariableLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckExpressionVariableLimitResponseBody>(model1);
      }
    }
  }


  virtual ~CheckExpressionVariableLimitResponse() = default;
};
class CheckFieldLimitRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> source{};

  CheckFieldLimitRequest() {}

  explicit CheckFieldLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
  }


  virtual ~CheckFieldLimitRequest() = default;
};
class CheckFieldLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CheckFieldLimitResponseBody() {}

  explicit CheckFieldLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CheckFieldLimitResponseBody() = default;
};
class CheckFieldLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckFieldLimitResponseBody> body{};

  CheckFieldLimitResponse() {}

  explicit CheckFieldLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckFieldLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckFieldLimitResponseBody>(model1);
      }
    }
  }


  virtual ~CheckFieldLimitResponse() = default;
};
class CheckPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  CheckPermissionRequest() {}

  explicit CheckPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~CheckPermissionRequest() = default;
};
class CheckPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CheckPermissionResponseBody() {}

  explicit CheckPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CheckPermissionResponseBody() = default;
};
class CheckPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckPermissionResponseBody> body{};

  CheckPermissionResponse() {}

  explicit CheckPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~CheckPermissionResponse() = default;
};
class CheckUsageVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  CheckUsageVariableRequest() {}

  explicit CheckUsageVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~CheckUsageVariableRequest() = default;
};
class CheckUsageVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CheckUsageVariableResponseBody() {}

  explicit CheckUsageVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CheckUsageVariableResponseBody() = default;
};
class CheckUsageVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckUsageVariableResponseBody> body{};

  CheckUsageVariableResponse() {}

  explicit CheckUsageVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckUsageVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckUsageVariableResponseBody>(model1);
      }
    }
  }


  virtual ~CheckUsageVariableResponse() = default;
};
class ClearNameListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<long> variableId{};

  ClearNameListRequest() {}

  explicit ClearNameListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (variableId) {
      res["variableId"] = boost::any(*variableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("variableId") != m.end() && !m["variableId"].empty()) {
      variableId = make_shared<long>(boost::any_cast<long>(m["variableId"]));
    }
  }


  virtual ~ClearNameListRequest() = default;
};
class ClearNameListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  ClearNameListResponseBody() {}

  explicit ClearNameListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~ClearNameListResponseBody() = default;
};
class ClearNameListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ClearNameListResponseBody> body{};

  ClearNameListResponse() {}

  explicit ClearNameListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClearNameListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClearNameListResponseBody>(model1);
      }
    }
  }


  virtual ~ClearNameListResponse() = default;
};
class CreateAnalysisConditionFavoriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> condition{};
  shared_ptr<long> eventBeginTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<long> eventEndTime{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<string> name{};
  shared_ptr<string> regId{};
  shared_ptr<string> type{};

  CreateAnalysisConditionFavoriteRequest() {}

  explicit CreateAnalysisConditionFavoriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (eventBeginTime) {
      res["eventBeginTime"] = boost::any(*eventBeginTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (eventEndTime) {
      res["eventEndTime"] = boost::any(*eventEndTime);
    }
    if (fieldName) {
      res["fieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("eventBeginTime") != m.end() && !m["eventBeginTime"].empty()) {
      eventBeginTime = make_shared<long>(boost::any_cast<long>(m["eventBeginTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("eventEndTime") != m.end() && !m["eventEndTime"].empty()) {
      eventEndTime = make_shared<long>(boost::any_cast<long>(m["eventEndTime"]));
    }
    if (m.find("fieldName") != m.end() && !m["fieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["fieldName"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateAnalysisConditionFavoriteRequest() = default;
};
class CreateAnalysisConditionFavoriteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateAnalysisConditionFavoriteResponseBody() {}

  explicit CreateAnalysisConditionFavoriteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateAnalysisConditionFavoriteResponseBody() = default;
};
class CreateAnalysisConditionFavoriteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAnalysisConditionFavoriteResponseBody> body{};

  CreateAnalysisConditionFavoriteResponse() {}

  explicit CreateAnalysisConditionFavoriteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAnalysisConditionFavoriteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAnalysisConditionFavoriteResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAnalysisConditionFavoriteResponse() = default;
};
class CreateAnalysisExportTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> columns{};
  shared_ptr<string> conditions{};
  shared_ptr<long> eventBeginTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<long> eventEndTime{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> regId{};
  shared_ptr<string> scope{};
  shared_ptr<string> type{};

  CreateAnalysisExportTaskRequest() {}

  explicit CreateAnalysisExportTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (columns) {
      res["columns"] = boost::any(*columns);
    }
    if (conditions) {
      res["conditions"] = boost::any(*conditions);
    }
    if (eventBeginTime) {
      res["eventBeginTime"] = boost::any(*eventBeginTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (eventEndTime) {
      res["eventEndTime"] = boost::any(*eventEndTime);
    }
    if (fieldName) {
      res["fieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    if (fileFormat) {
      res["fileFormat"] = boost::any(*fileFormat);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("columns") != m.end() && !m["columns"].empty()) {
      columns = make_shared<string>(boost::any_cast<string>(m["columns"]));
    }
    if (m.find("conditions") != m.end() && !m["conditions"].empty()) {
      conditions = make_shared<string>(boost::any_cast<string>(m["conditions"]));
    }
    if (m.find("eventBeginTime") != m.end() && !m["eventBeginTime"].empty()) {
      eventBeginTime = make_shared<long>(boost::any_cast<long>(m["eventBeginTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("eventEndTime") != m.end() && !m["eventEndTime"].empty()) {
      eventEndTime = make_shared<long>(boost::any_cast<long>(m["eventEndTime"]));
    }
    if (m.find("fieldName") != m.end() && !m["fieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["fieldName"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
    if (m.find("fileFormat") != m.end() && !m["fileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["fileFormat"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateAnalysisExportTaskRequest() = default;
};
class CreateAnalysisExportTaskResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> columns{};
  shared_ptr<string> conditions{};
  shared_ptr<long> eventBeginTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<long> eventEndTime{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> ossKey{};
  shared_ptr<string> scope{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<long> userId{};

  CreateAnalysisExportTaskResponseBodyResultObject() {}

  explicit CreateAnalysisExportTaskResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      res["columns"] = boost::any(*columns);
    }
    if (conditions) {
      res["conditions"] = boost::any(*conditions);
    }
    if (eventBeginTime) {
      res["eventBeginTime"] = boost::any(*eventBeginTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (eventEndTime) {
      res["eventEndTime"] = boost::any(*eventEndTime);
    }
    if (fileFormat) {
      res["fileFormat"] = boost::any(*fileFormat);
    }
    if (ossKey) {
      res["ossKey"] = boost::any(*ossKey);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("columns") != m.end() && !m["columns"].empty()) {
      columns = make_shared<string>(boost::any_cast<string>(m["columns"]));
    }
    if (m.find("conditions") != m.end() && !m["conditions"].empty()) {
      conditions = make_shared<string>(boost::any_cast<string>(m["conditions"]));
    }
    if (m.find("eventBeginTime") != m.end() && !m["eventBeginTime"].empty()) {
      eventBeginTime = make_shared<long>(boost::any_cast<long>(m["eventBeginTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("eventEndTime") != m.end() && !m["eventEndTime"].empty()) {
      eventEndTime = make_shared<long>(boost::any_cast<long>(m["eventEndTime"]));
    }
    if (m.find("fileFormat") != m.end() && !m["fileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["fileFormat"]));
    }
    if (m.find("ossKey") != m.end() && !m["ossKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["ossKey"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~CreateAnalysisExportTaskResponseBodyResultObject() = default;
};
class CreateAnalysisExportTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAnalysisExportTaskResponseBodyResultObject> resultObject{};

  CreateAnalysisExportTaskResponseBody() {}

  explicit CreateAnalysisExportTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        CreateAnalysisExportTaskResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<CreateAnalysisExportTaskResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~CreateAnalysisExportTaskResponseBody() = default;
};
class CreateAnalysisExportTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAnalysisExportTaskResponseBody> body{};

  CreateAnalysisExportTaskResponse() {}

  explicit CreateAnalysisExportTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAnalysisExportTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAnalysisExportTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAnalysisExportTaskResponse() = default;
};
class CreateAppKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  CreateAppKeyRequest() {}

  explicit CreateAppKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~CreateAppKeyRequest() = default;
};
class CreateAppKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  CreateAppKeyResponseBody() {}

  explicit CreateAppKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~CreateAppKeyResponseBody() = default;
};
class CreateAppKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAppKeyResponseBody> body{};

  CreateAppKeyResponse() {}

  explicit CreateAppKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAppKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAppKeyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAppKeyResponse() = default;
};
class CreateAuthorizationUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> bindId{};
  shared_ptr<string> createType{};
  shared_ptr<long> eventTemplateId{};
  shared_ptr<string> regId{};

  CreateAuthorizationUserRequest() {}

  explicit CreateAuthorizationUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (bindId) {
      res["bindId"] = boost::any(*bindId);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventTemplateId) {
      res["eventTemplateId"] = boost::any(*eventTemplateId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("bindId") != m.end() && !m["bindId"].empty()) {
      bindId = make_shared<long>(boost::any_cast<long>(m["bindId"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventTemplateId") != m.end() && !m["eventTemplateId"].empty()) {
      eventTemplateId = make_shared<long>(boost::any_cast<long>(m["eventTemplateId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~CreateAuthorizationUserRequest() = default;
};
class CreateAuthorizationUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateAuthorizationUserResponseBody() {}

  explicit CreateAuthorizationUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateAuthorizationUserResponseBody() = default;
};
class CreateAuthorizationUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAuthorizationUserResponseBody> body{};

  CreateAuthorizationUserResponse() {}

  explicit CreateAuthorizationUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAuthorizationUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAuthorizationUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAuthorizationUserResponse() = default;
};
class CreateCustVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> condition{};
  shared_ptr<string> createType{};
  shared_ptr<string> description{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> historyValueType{};
  shared_ptr<string> object{};
  shared_ptr<string> outputs{};
  shared_ptr<string> regId{};
  shared_ptr<string> subject{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};
  shared_ptr<long> twCount{};
  shared_ptr<string> velocityFC{};
  shared_ptr<string> velocityTW{};

  CreateCustVariableRequest() {}

  explicit CreateCustVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (historyValueType) {
      res["historyValueType"] = boost::any(*historyValueType);
    }
    if (object) {
      res["object"] = boost::any(*object);
    }
    if (outputs) {
      res["outputs"] = boost::any(*outputs);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (timeType) {
      res["timeType"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (twCount) {
      res["twCount"] = boost::any(*twCount);
    }
    if (velocityFC) {
      res["velocityFC"] = boost::any(*velocityFC);
    }
    if (velocityTW) {
      res["velocityTW"] = boost::any(*velocityTW);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("historyValueType") != m.end() && !m["historyValueType"].empty()) {
      historyValueType = make_shared<string>(boost::any_cast<string>(m["historyValueType"]));
    }
    if (m.find("object") != m.end() && !m["object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["object"]));
    }
    if (m.find("outputs") != m.end() && !m["outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["outputs"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("timeType") != m.end() && !m["timeType"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["timeType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("twCount") != m.end() && !m["twCount"].empty()) {
      twCount = make_shared<long>(boost::any_cast<long>(m["twCount"]));
    }
    if (m.find("velocityFC") != m.end() && !m["velocityFC"].empty()) {
      velocityFC = make_shared<string>(boost::any_cast<string>(m["velocityFC"]));
    }
    if (m.find("velocityTW") != m.end() && !m["velocityTW"].empty()) {
      velocityTW = make_shared<string>(boost::any_cast<string>(m["velocityTW"]));
    }
  }


  virtual ~CreateCustVariableRequest() = default;
};
class CreateCustVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateCustVariableResponseBody() {}

  explicit CreateCustVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateCustVariableResponseBody() = default;
};
class CreateCustVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustVariableResponseBody> body{};

  CreateCustVariableResponse() {}

  explicit CreateCustVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustVariableResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustVariableResponse() = default;
};
class CreateDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> ossKey{};
  shared_ptr<string> regId{};
  shared_ptr<string> type{};

  CreateDataSourceRequest() {}

  explicit CreateDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (ossKey) {
      res["ossKey"] = boost::any(*ossKey);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("ossKey") != m.end() && !m["ossKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["ossKey"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateDataSourceRequest() = default;
};
class CreateDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateDataSourceResponseBody() {}

  explicit CreateDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateDataSourceResponseBody() = default;
};
class CreateDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataSourceResponseBody> body{};

  CreateDataSourceResponse() {}

  explicit CreateDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataSourceResponse() = default;
};
class CreateEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> eventName{};
  shared_ptr<string> inputFieldsStr{};
  shared_ptr<string> memo{};
  shared_ptr<string> regId{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};

  CreateEventRequest() {}

  explicit CreateEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (inputFieldsStr) {
      res["inputFieldsStr"] = boost::any(*inputFieldsStr);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (templateCode) {
      res["templateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["templateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["templateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("inputFieldsStr") != m.end() && !m["inputFieldsStr"].empty()) {
      inputFieldsStr = make_shared<string>(boost::any_cast<string>(m["inputFieldsStr"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("templateCode") != m.end() && !m["templateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["templateCode"]));
    }
    if (m.find("templateName") != m.end() && !m["templateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["templateName"]));
    }
    if (m.find("templateType") != m.end() && !m["templateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["templateType"]));
    }
  }


  virtual ~CreateEventRequest() = default;
};
class CreateEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  CreateEventResponseBody() {}

  explicit CreateEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateEventResponseBody() = default;
};
class CreateEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEventResponseBody> body{};

  CreateEventResponse() {}

  explicit CreateEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEventResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEventResponse() = default;
};
class CreateExpressionVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> description{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> expression{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<string> expressionVariable{};
  shared_ptr<string> outlier{};
  shared_ptr<string> outputs{};
  shared_ptr<string> regId{};
  shared_ptr<string> title{};

  CreateExpressionVariableRequest() {}

  explicit CreateExpressionVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (expression) {
      res["expression"] = boost::any(*expression);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (expressionVariable) {
      res["expressionVariable"] = boost::any(*expressionVariable);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputs) {
      res["outputs"] = boost::any(*outputs);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("expression") != m.end() && !m["expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["expression"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("expressionVariable") != m.end() && !m["expressionVariable"].empty()) {
      expressionVariable = make_shared<string>(boost::any_cast<string>(m["expressionVariable"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputs") != m.end() && !m["outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["outputs"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CreateExpressionVariableRequest() = default;
};
class CreateExpressionVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateExpressionVariableResponseBody() {}

  explicit CreateExpressionVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateExpressionVariableResponseBody() = default;
};
class CreateExpressionVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateExpressionVariableResponseBody> body{};

  CreateExpressionVariableResponse() {}

  explicit CreateExpressionVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateExpressionVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateExpressionVariableResponseBody>(model1);
      }
    }
  }


  virtual ~CreateExpressionVariableResponse() = default;
};
class CreateFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> classify{};
  shared_ptr<string> description{};
  shared_ptr<string> enumData{};
  shared_ptr<string> name{};
  shared_ptr<string> regId{};
  shared_ptr<string> source{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  CreateFieldRequest() {}

  explicit CreateFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (classify) {
      res["classify"] = boost::any(*classify);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (enumData) {
      res["enumData"] = boost::any(*enumData);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("classify") != m.end() && !m["classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["classify"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("enumData") != m.end() && !m["enumData"].empty()) {
      enumData = make_shared<string>(boost::any_cast<string>(m["enumData"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateFieldRequest() = default;
};
class CreateFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateFieldResponseBody() {}

  explicit CreateFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateFieldResponseBody() = default;
};
class CreateFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFieldResponseBody> body{};

  CreateFieldResponse() {}

  explicit CreateFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFieldResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFieldResponse() = default;
};
class CreateGroupSignRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> signList{};
  shared_ptr<string> regId{};

  CreateGroupSignRequest() {}

  explicit CreateGroupSignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (signList) {
      res["SignList"] = boost::any(*signList);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SignList") != m.end() && !m["SignList"].empty()) {
      signList = make_shared<string>(boost::any_cast<string>(m["SignList"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~CreateGroupSignRequest() = default;
};
class CreateGroupSignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  CreateGroupSignResponseBody() {}

  explicit CreateGroupSignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~CreateGroupSignResponseBody() = default;
};
class CreateGroupSignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateGroupSignResponseBody> body{};

  CreateGroupSignResponse() {}

  explicit CreateGroupSignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateGroupSignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateGroupSignResponseBody>(model1);
      }
    }
  }


  virtual ~CreateGroupSignResponse() = default;
};
class CreateMonitorTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> bizType{};
  shared_ptr<string> cycleType{};
  shared_ptr<long> endTime{};
  shared_ptr<string> filePath{};
  shared_ptr<string> listdayStr{};
  shared_ptr<string> regId{};
  shared_ptr<long> startTime{};

  CreateMonitorTaskRequest() {}

  explicit CreateMonitorTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (bizType) {
      res["bizType"] = boost::any(*bizType);
    }
    if (cycleType) {
      res["cycleType"] = boost::any(*cycleType);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (listdayStr) {
      res["listdayStr"] = boost::any(*listdayStr);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("bizType") != m.end() && !m["bizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["bizType"]));
    }
    if (m.find("cycleType") != m.end() && !m["cycleType"].empty()) {
      cycleType = make_shared<string>(boost::any_cast<string>(m["cycleType"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("listdayStr") != m.end() && !m["listdayStr"].empty()) {
      listdayStr = make_shared<string>(boost::any_cast<string>(m["listdayStr"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
  }


  virtual ~CreateMonitorTaskRequest() = default;
};
class CreateMonitorTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateMonitorTaskResponseBody() {}

  explicit CreateMonitorTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateMonitorTaskResponseBody() = default;
};
class CreateMonitorTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMonitorTaskResponseBody> body{};

  CreateMonitorTaskResponse() {}

  explicit CreateMonitorTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMonitorTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMonitorTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMonitorTaskResponse() = default;
};
class CreatePocRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> configStr{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> regId{};
  shared_ptr<string> serviceCode{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> taskName{};

  CreatePocRequest() {}

  explicit CreatePocRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (configStr) {
      res["configStr"] = boost::any(*configStr);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["fileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["fileUrl"] = boost::any(*fileUrl);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (serviceCode) {
      res["serviceCode"] = boost::any(*serviceCode);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (taskName) {
      res["taskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("configStr") != m.end() && !m["configStr"].empty()) {
      configStr = make_shared<string>(boost::any_cast<string>(m["configStr"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
    if (m.find("fileType") != m.end() && !m["fileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["fileType"]));
    }
    if (m.find("fileUrl") != m.end() && !m["fileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["fileUrl"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("serviceCode") != m.end() && !m["serviceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["serviceCode"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("taskName") != m.end() && !m["taskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["taskName"]));
    }
  }


  virtual ~CreatePocRequest() = default;
};
class CreatePocResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreatePocResponseBody() {}

  explicit CreatePocResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreatePocResponseBody() = default;
};
class CreatePocResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePocResponseBody> body{};

  CreatePocResponse() {}

  explicit CreatePocResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePocResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePocResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePocResponse() = default;
};
class CreatePocEvRequest : public Darabonba::Model {
public:
  shared_ptr<string> dateFormat{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> serviceCode{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> tab{};
  shared_ptr<string> taskName{};
  shared_ptr<string> type{};

  CreatePocEvRequest() {}

  explicit CreatePocEvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateFormat) {
      res["DateFormat"] = boost::any(*dateFormat);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["RegId"] = boost::any(*regId);
    }
    if (serviceCode) {
      res["ServiceCode"] = boost::any(*serviceCode);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (tab) {
      res["Tab"] = boost::any(*tab);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateFormat") != m.end() && !m["DateFormat"].empty()) {
      dateFormat = make_shared<string>(boost::any_cast<string>(m["DateFormat"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RegId") != m.end() && !m["RegId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["RegId"]));
    }
    if (m.find("ServiceCode") != m.end() && !m["ServiceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["ServiceCode"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Tab") != m.end() && !m["Tab"].empty()) {
      tab = make_shared<string>(boost::any_cast<string>(m["Tab"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreatePocEvRequest() = default;
};
class CreatePocEvResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultObject{};

  CreatePocEvResponseBody() {}

  explicit CreatePocEvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["ResultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultObject") != m.end() && !m["ResultObject"].empty()) {
      resultObject = make_shared<string>(boost::any_cast<string>(m["ResultObject"]));
    }
  }


  virtual ~CreatePocEvResponseBody() = default;
};
class CreatePocEvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePocEvResponseBody> body{};

  CreatePocEvResponse() {}

  explicit CreatePocEvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePocEvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePocEvResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePocEvResponse() = default;
};
class CreateQueryVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> dataSourceCode{};
  shared_ptr<string> description{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> expression{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<string> expressionVariable{};
  shared_ptr<string> outlier{};
  shared_ptr<string> outputs{};
  shared_ptr<string> regId{};
  shared_ptr<string> title{};

  CreateQueryVariableRequest() {}

  explicit CreateQueryVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (dataSourceCode) {
      res["dataSourceCode"] = boost::any(*dataSourceCode);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (expression) {
      res["expression"] = boost::any(*expression);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (expressionVariable) {
      res["expressionVariable"] = boost::any(*expressionVariable);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputs) {
      res["outputs"] = boost::any(*outputs);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("dataSourceCode") != m.end() && !m["dataSourceCode"].empty()) {
      dataSourceCode = make_shared<string>(boost::any_cast<string>(m["dataSourceCode"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("expression") != m.end() && !m["expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["expression"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("expressionVariable") != m.end() && !m["expressionVariable"].empty()) {
      expressionVariable = make_shared<string>(boost::any_cast<string>(m["expressionVariable"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputs") != m.end() && !m["outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["outputs"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CreateQueryVariableRequest() = default;
};
class CreateQueryVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateQueryVariableResponseBody() {}

  explicit CreateQueryVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateQueryVariableResponseBody() = default;
};
class CreateQueryVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateQueryVariableResponseBody> body{};

  CreateQueryVariableResponse() {}

  explicit CreateQueryVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateQueryVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateQueryVariableResponseBody>(model1);
      }
    }
  }


  virtual ~CreateQueryVariableResponse() = default;
};
class CreateRecommendEventRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> recommendRuleIdsStr{};
  shared_ptr<string> regId{};
  shared_ptr<long> taskId{};

  CreateRecommendEventRuleRequest() {}

  explicit CreateRecommendEventRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (recommendRuleIdsStr) {
      res["recommendRuleIdsStr"] = boost::any(*recommendRuleIdsStr);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("recommendRuleIdsStr") != m.end() && !m["recommendRuleIdsStr"].empty()) {
      recommendRuleIdsStr = make_shared<string>(boost::any_cast<string>(m["recommendRuleIdsStr"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["taskId"]));
    }
  }


  virtual ~CreateRecommendEventRuleRequest() = default;
};
class CreateRecommendEventRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateRecommendEventRuleResponseBody() {}

  explicit CreateRecommendEventRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateRecommendEventRuleResponseBody() = default;
};
class CreateRecommendEventRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRecommendEventRuleResponseBody> body{};

  CreateRecommendEventRuleResponse() {}

  explicit CreateRecommendEventRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRecommendEventRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRecommendEventRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRecommendEventRuleResponse() = default;
};
class CreateRecommendTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> name{};
  shared_ptr<string> regId{};
  shared_ptr<long> sampleId{};
  shared_ptr<string> variablesStr{};
  shared_ptr<string> velocitiesStr{};

  CreateRecommendTaskRequest() {}

  explicit CreateRecommendTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (sampleId) {
      res["sampleId"] = boost::any(*sampleId);
    }
    if (variablesStr) {
      res["variablesStr"] = boost::any(*variablesStr);
    }
    if (velocitiesStr) {
      res["velocitiesStr"] = boost::any(*velocitiesStr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("sampleId") != m.end() && !m["sampleId"].empty()) {
      sampleId = make_shared<long>(boost::any_cast<long>(m["sampleId"]));
    }
    if (m.find("variablesStr") != m.end() && !m["variablesStr"].empty()) {
      variablesStr = make_shared<string>(boost::any_cast<string>(m["variablesStr"]));
    }
    if (m.find("velocitiesStr") != m.end() && !m["velocitiesStr"].empty()) {
      velocitiesStr = make_shared<string>(boost::any_cast<string>(m["velocitiesStr"]));
    }
  }


  virtual ~CreateRecommendTaskRequest() = default;
};
class CreateRecommendTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateRecommendTaskResponseBody() {}

  explicit CreateRecommendTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateRecommendTaskResponseBody() = default;
};
class CreateRecommendTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRecommendTaskResponseBody> body{};

  CreateRecommendTaskResponse() {}

  explicit CreateRecommendTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRecommendTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRecommendTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRecommendTaskResponse() = default;
};
class CreateReplenishTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientFileName{};
  shared_ptr<string> clientPath{};
  shared_ptr<string> lang{};
  shared_ptr<string> taskId{};
  shared_ptr<string> regId{};

  CreateReplenishTaskRequest() {}

  explicit CreateReplenishTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientFileName) {
      res["ClientFileName"] = boost::any(*clientFileName);
    }
    if (clientPath) {
      res["ClientPath"] = boost::any(*clientPath);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientFileName") != m.end() && !m["ClientFileName"].empty()) {
      clientFileName = make_shared<string>(boost::any_cast<string>(m["ClientFileName"]));
    }
    if (m.find("ClientPath") != m.end() && !m["ClientPath"].empty()) {
      clientPath = make_shared<string>(boost::any_cast<string>(m["ClientPath"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~CreateReplenishTaskRequest() = default;
};
class CreateReplenishTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  CreateReplenishTaskResponseBody() {}

  explicit CreateReplenishTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~CreateReplenishTaskResponseBody() = default;
};
class CreateReplenishTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateReplenishTaskResponseBody> body{};

  CreateReplenishTaskResponse() {}

  explicit CreateReplenishTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateReplenishTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateReplenishTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateReplenishTaskResponse() = default;
};
class CreateRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> consoleRuleId{};
  shared_ptr<string> createType{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> logicExpression{};
  shared_ptr<string> memo{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleActions{};
  shared_ptr<string> ruleExpressions{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};

  CreateRuleRequest() {}

  explicit CreateRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (logicExpression) {
      res["logicExpression"] = boost::any(*logicExpression);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleActions) {
      res["ruleActions"] = boost::any(*ruleActions);
    }
    if (ruleExpressions) {
      res["ruleExpressions"] = boost::any(*ruleExpressions);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("logicExpression") != m.end() && !m["logicExpression"].empty()) {
      logicExpression = make_shared<string>(boost::any_cast<string>(m["logicExpression"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleActions") != m.end() && !m["ruleActions"].empty()) {
      ruleActions = make_shared<string>(boost::any_cast<string>(m["ruleActions"]));
    }
    if (m.find("ruleExpressions") != m.end() && !m["ruleExpressions"].empty()) {
      ruleExpressions = make_shared<string>(boost::any_cast<string>(m["ruleExpressions"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
  }


  virtual ~CreateRuleRequest() = default;
};
class CreateRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateRuleResponseBody() {}

  explicit CreateRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateRuleResponseBody() = default;
};
class CreateRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRuleResponseBody> body{};

  CreateRuleResponse() {}

  explicit CreateRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRuleResponse() = default;
};
class CreateSampleRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> clientFileName{};
  shared_ptr<string> clientPath{};
  shared_ptr<string> fileType{};
  shared_ptr<string> regId{};
  shared_ptr<string> sampleTag{};
  shared_ptr<string> sampleType{};
  shared_ptr<string> sampleValues{};
  shared_ptr<string> uploadType{};

  CreateSampleRequest() {}

  explicit CreateSampleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (clientFileName) {
      res["clientFileName"] = boost::any(*clientFileName);
    }
    if (clientPath) {
      res["clientPath"] = boost::any(*clientPath);
    }
    if (fileType) {
      res["fileType"] = boost::any(*fileType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (sampleTag) {
      res["sampleTag"] = boost::any(*sampleTag);
    }
    if (sampleType) {
      res["sampleType"] = boost::any(*sampleType);
    }
    if (sampleValues) {
      res["sampleValues"] = boost::any(*sampleValues);
    }
    if (uploadType) {
      res["uploadType"] = boost::any(*uploadType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("clientFileName") != m.end() && !m["clientFileName"].empty()) {
      clientFileName = make_shared<string>(boost::any_cast<string>(m["clientFileName"]));
    }
    if (m.find("clientPath") != m.end() && !m["clientPath"].empty()) {
      clientPath = make_shared<string>(boost::any_cast<string>(m["clientPath"]));
    }
    if (m.find("fileType") != m.end() && !m["fileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["fileType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("sampleTag") != m.end() && !m["sampleTag"].empty()) {
      sampleTag = make_shared<string>(boost::any_cast<string>(m["sampleTag"]));
    }
    if (m.find("sampleType") != m.end() && !m["sampleType"].empty()) {
      sampleType = make_shared<string>(boost::any_cast<string>(m["sampleType"]));
    }
    if (m.find("sampleValues") != m.end() && !m["sampleValues"].empty()) {
      sampleValues = make_shared<string>(boost::any_cast<string>(m["sampleValues"]));
    }
    if (m.find("uploadType") != m.end() && !m["uploadType"].empty()) {
      uploadType = make_shared<string>(boost::any_cast<string>(m["uploadType"]));
    }
  }


  virtual ~CreateSampleRequest() = default;
};
class CreateSampleResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> communityCount{};
  shared_ptr<long> failCount{};
  shared_ptr<string> recallProbability{};
  shared_ptr<string> riskDensity{};
  shared_ptr<long> sampleCount{};
  shared_ptr<long> successCount{};

  CreateSampleResponseBodyResultObject() {}

  explicit CreateSampleResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (communityCount) {
      res["communityCount"] = boost::any(*communityCount);
    }
    if (failCount) {
      res["failCount"] = boost::any(*failCount);
    }
    if (recallProbability) {
      res["recallProbability"] = boost::any(*recallProbability);
    }
    if (riskDensity) {
      res["riskDensity"] = boost::any(*riskDensity);
    }
    if (sampleCount) {
      res["sampleCount"] = boost::any(*sampleCount);
    }
    if (successCount) {
      res["successCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("communityCount") != m.end() && !m["communityCount"].empty()) {
      communityCount = make_shared<long>(boost::any_cast<long>(m["communityCount"]));
    }
    if (m.find("failCount") != m.end() && !m["failCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["failCount"]));
    }
    if (m.find("recallProbability") != m.end() && !m["recallProbability"].empty()) {
      recallProbability = make_shared<string>(boost::any_cast<string>(m["recallProbability"]));
    }
    if (m.find("riskDensity") != m.end() && !m["riskDensity"].empty()) {
      riskDensity = make_shared<string>(boost::any_cast<string>(m["riskDensity"]));
    }
    if (m.find("sampleCount") != m.end() && !m["sampleCount"].empty()) {
      sampleCount = make_shared<long>(boost::any_cast<long>(m["sampleCount"]));
    }
    if (m.find("successCount") != m.end() && !m["successCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["successCount"]));
    }
  }


  virtual ~CreateSampleResponseBodyResultObject() = default;
};
class CreateSampleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateSampleResponseBodyResultObject> resultObject{};

  CreateSampleResponseBody() {}

  explicit CreateSampleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        CreateSampleResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<CreateSampleResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~CreateSampleResponseBody() = default;
};
class CreateSampleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSampleResponseBody> body{};

  CreateSampleResponse() {}

  explicit CreateSampleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSampleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSampleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSampleResponse() = default;
};
class CreateSampleApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataType{};
  shared_ptr<string> dataValue{};
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> sampleBatchType{};
  shared_ptr<string> serviceList{};

  CreateSampleApiRequest() {}

  explicit CreateSampleApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (dataValue) {
      res["DataValue"] = boost::any(*dataValue);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["RegId"] = boost::any(*regId);
    }
    if (sampleBatchType) {
      res["SampleBatchType"] = boost::any(*sampleBatchType);
    }
    if (serviceList) {
      res["ServiceList"] = boost::any(*serviceList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("DataValue") != m.end() && !m["DataValue"].empty()) {
      dataValue = make_shared<string>(boost::any_cast<string>(m["DataValue"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RegId") != m.end() && !m["RegId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["RegId"]));
    }
    if (m.find("SampleBatchType") != m.end() && !m["SampleBatchType"].empty()) {
      sampleBatchType = make_shared<string>(boost::any_cast<string>(m["SampleBatchType"]));
    }
    if (m.find("ServiceList") != m.end() && !m["ServiceList"].empty()) {
      serviceList = make_shared<string>(boost::any_cast<string>(m["ServiceList"]));
    }
  }


  virtual ~CreateSampleApiRequest() = default;
};
class CreateSampleApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateSampleApiResponseBody() {}

  explicit CreateSampleApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSampleApiResponseBody() = default;
};
class CreateSampleApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSampleApiResponseBody> body{};

  CreateSampleApiResponse() {}

  explicit CreateSampleApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSampleApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSampleApiResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSampleApiResponse() = default;
};
class CreateSampleDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> description{};
  shared_ptr<string> encryptType{};
  shared_ptr<string> name{};
  shared_ptr<string> regId{};
  shared_ptr<string> riskValue{};
  shared_ptr<string> scene{};
  shared_ptr<string> storePath{};
  shared_ptr<string> storeType{};

  CreateSampleDataRequest() {}

  explicit CreateSampleDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (encryptType) {
      res["encryptType"] = boost::any(*encryptType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (riskValue) {
      res["riskValue"] = boost::any(*riskValue);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    if (storePath) {
      res["storePath"] = boost::any(*storePath);
    }
    if (storeType) {
      res["storeType"] = boost::any(*storeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("encryptType") != m.end() && !m["encryptType"].empty()) {
      encryptType = make_shared<string>(boost::any_cast<string>(m["encryptType"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("riskValue") != m.end() && !m["riskValue"].empty()) {
      riskValue = make_shared<string>(boost::any_cast<string>(m["riskValue"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["scene"]));
    }
    if (m.find("storePath") != m.end() && !m["storePath"].empty()) {
      storePath = make_shared<string>(boost::any_cast<string>(m["storePath"]));
    }
    if (m.find("storeType") != m.end() && !m["storeType"].empty()) {
      storeType = make_shared<string>(boost::any_cast<string>(m["storeType"]));
    }
  }


  virtual ~CreateSampleDataRequest() = default;
};
class CreateSampleDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateSampleDataResponseBody() {}

  explicit CreateSampleDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateSampleDataResponseBody() = default;
};
class CreateSampleDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSampleDataResponseBody> body{};

  CreateSampleDataResponse() {}

  explicit CreateSampleDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSampleDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSampleDataResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSampleDataResponse() = default;
};
class CreateSimulationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> dataSourceConfig{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> filtersStr{};
  shared_ptr<string> regId{};
  shared_ptr<string> rulesStr{};
  shared_ptr<bool> runTask{};
  shared_ptr<long> startTime{};
  shared_ptr<string> taskName{};

  CreateSimulationTaskRequest() {}

  explicit CreateSimulationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (dataSourceConfig) {
      res["dataSourceConfig"] = boost::any(*dataSourceConfig);
    }
    if (dataSourceType) {
      res["dataSourceType"] = boost::any(*dataSourceType);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (filtersStr) {
      res["filtersStr"] = boost::any(*filtersStr);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (rulesStr) {
      res["rulesStr"] = boost::any(*rulesStr);
    }
    if (runTask) {
      res["runTask"] = boost::any(*runTask);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (taskName) {
      res["taskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("dataSourceConfig") != m.end() && !m["dataSourceConfig"].empty()) {
      dataSourceConfig = make_shared<string>(boost::any_cast<string>(m["dataSourceConfig"]));
    }
    if (m.find("dataSourceType") != m.end() && !m["dataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["dataSourceType"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("filtersStr") != m.end() && !m["filtersStr"].empty()) {
      filtersStr = make_shared<string>(boost::any_cast<string>(m["filtersStr"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("rulesStr") != m.end() && !m["rulesStr"].empty()) {
      rulesStr = make_shared<string>(boost::any_cast<string>(m["rulesStr"]));
    }
    if (m.find("runTask") != m.end() && !m["runTask"].empty()) {
      runTask = make_shared<bool>(boost::any_cast<bool>(m["runTask"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("taskName") != m.end() && !m["taskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["taskName"]));
    }
  }


  virtual ~CreateSimulationTaskRequest() = default;
};
class CreateSimulationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateSimulationTaskResponseBody() {}

  explicit CreateSimulationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateSimulationTaskResponseBody() = default;
};
class CreateSimulationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSimulationTaskResponseBody> body{};

  CreateSimulationTaskResponse() {}

  explicit CreateSimulationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSimulationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSimulationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSimulationTaskResponse() = default;
};
class CreateTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientFileName{};
  shared_ptr<string> clientPath{};
  shared_ptr<string> describe{};
  shared_ptr<string> lang{};
  shared_ptr<string> sceneName{};
  shared_ptr<string> regId{};

  CreateTaskRequest() {}

  explicit CreateTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientFileName) {
      res["ClientFileName"] = boost::any(*clientFileName);
    }
    if (clientPath) {
      res["ClientPath"] = boost::any(*clientPath);
    }
    if (describe) {
      res["Describe"] = boost::any(*describe);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sceneName) {
      res["SceneName"] = boost::any(*sceneName);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientFileName") != m.end() && !m["ClientFileName"].empty()) {
      clientFileName = make_shared<string>(boost::any_cast<string>(m["ClientFileName"]));
    }
    if (m.find("ClientPath") != m.end() && !m["ClientPath"].empty()) {
      clientPath = make_shared<string>(boost::any_cast<string>(m["ClientPath"]));
    }
    if (m.find("Describe") != m.end() && !m["Describe"].empty()) {
      describe = make_shared<string>(boost::any_cast<string>(m["Describe"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SceneName") != m.end() && !m["SceneName"].empty()) {
      sceneName = make_shared<string>(boost::any_cast<string>(m["SceneName"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~CreateTaskRequest() = default;
};
class CreateTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  CreateTaskResponseBody() {}

  explicit CreateTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~CreateTaskResponseBody() = default;
};
class CreateTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTaskResponseBody> body{};

  CreateTaskResponse() {}

  explicit CreateTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTaskResponse() = default;
};
class CreateTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> logicExpression{};
  shared_ptr<string> memo{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleActions{};
  shared_ptr<string> ruleExpressions{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};

  CreateTemplateRequest() {}

  explicit CreateTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (logicExpression) {
      res["logicExpression"] = boost::any(*logicExpression);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleActions) {
      res["ruleActions"] = boost::any(*ruleActions);
    }
    if (ruleExpressions) {
      res["ruleExpressions"] = boost::any(*ruleExpressions);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("logicExpression") != m.end() && !m["logicExpression"].empty()) {
      logicExpression = make_shared<string>(boost::any_cast<string>(m["logicExpression"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleActions") != m.end() && !m["ruleActions"].empty()) {
      ruleActions = make_shared<string>(boost::any_cast<string>(m["ruleActions"]));
    }
    if (m.find("ruleExpressions") != m.end() && !m["ruleExpressions"].empty()) {
      ruleExpressions = make_shared<string>(boost::any_cast<string>(m["ruleExpressions"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
  }


  virtual ~CreateTemplateRequest() = default;
};
class CreateTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  CreateTemplateResponseBody() {}

  explicit CreateTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~CreateTemplateResponseBody() = default;
};
class CreateTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTemplateResponseBody> body{};

  CreateTemplateResponse() {}

  explicit CreateTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTemplateResponse() = default;
};
class DeleteAnalysisConditionFavoriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  DeleteAnalysisConditionFavoriteRequest() {}

  explicit DeleteAnalysisConditionFavoriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DeleteAnalysisConditionFavoriteRequest() = default;
};
class DeleteAnalysisConditionFavoriteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DeleteAnalysisConditionFavoriteResponseBody() {}

  explicit DeleteAnalysisConditionFavoriteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DeleteAnalysisConditionFavoriteResponseBody() = default;
};
class DeleteAnalysisConditionFavoriteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAnalysisConditionFavoriteResponseBody> body{};

  DeleteAnalysisConditionFavoriteResponse() {}

  explicit DeleteAnalysisConditionFavoriteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAnalysisConditionFavoriteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAnalysisConditionFavoriteResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAnalysisConditionFavoriteResponse() = default;
};
class DeleteAuthUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> eventCode{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  DeleteAuthUserRequest() {}

  explicit DeleteAuthUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DeleteAuthUserRequest() = default;
};
class DeleteAuthUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DeleteAuthUserResponseBody() {}

  explicit DeleteAuthUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DeleteAuthUserResponseBody() = default;
};
class DeleteAuthUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAuthUserResponseBody> body{};

  DeleteAuthUserResponse() {}

  explicit DeleteAuthUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAuthUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAuthUserResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAuthUserResponse() = default;
};
class DeleteByPassShuntEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> eventId{};
  shared_ptr<string> regId{};

  DeleteByPassShuntEventRequest() {}

  explicit DeleteByPassShuntEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventId) {
      res["eventId"] = boost::any(*eventId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventId") != m.end() && !m["eventId"].empty()) {
      eventId = make_shared<long>(boost::any_cast<long>(m["eventId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DeleteByPassShuntEventRequest() = default;
};
class DeleteByPassShuntEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};
  shared_ptr<bool> success{};

  DeleteByPassShuntEventResponseBody() {}

  explicit DeleteByPassShuntEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteByPassShuntEventResponseBody() = default;
};
class DeleteByPassShuntEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteByPassShuntEventResponseBody> body{};

  DeleteByPassShuntEventResponse() {}

  explicit DeleteByPassShuntEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteByPassShuntEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteByPassShuntEventResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteByPassShuntEventResponse() = default;
};
class DeleteCustVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<long> dataVersion{};
  shared_ptr<string> regId{};
  shared_ptr<string> variableId{};

  DeleteCustVariableRequest() {}

  explicit DeleteCustVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (dataVersion) {
      res["dataVersion"] = boost::any(*dataVersion);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (variableId) {
      res["variableId"] = boost::any(*variableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("dataVersion") != m.end() && !m["dataVersion"].empty()) {
      dataVersion = make_shared<long>(boost::any_cast<long>(m["dataVersion"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("variableId") != m.end() && !m["variableId"].empty()) {
      variableId = make_shared<string>(boost::any_cast<string>(m["variableId"]));
    }
  }


  virtual ~DeleteCustVariableRequest() = default;
};
class DeleteCustVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DeleteCustVariableResponseBody() {}

  explicit DeleteCustVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DeleteCustVariableResponseBody() = default;
};
class DeleteCustVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustVariableResponseBody> body{};

  DeleteCustVariableResponse() {}

  explicit DeleteCustVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustVariableResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustVariableResponse() = default;
};
class DeleteDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  DeleteDataSourceRequest() {}

  explicit DeleteDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DeleteDataSourceRequest() = default;
};
class DeleteDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DeleteDataSourceResponseBody() {}

  explicit DeleteDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DeleteDataSourceResponseBody() = default;
};
class DeleteDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataSourceResponseBody> body{};

  DeleteDataSourceResponse() {}

  explicit DeleteDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataSourceResponse() = default;
};
class DeleteExpressionVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> dataVersion{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  DeleteExpressionVariableRequest() {}

  explicit DeleteExpressionVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (dataVersion) {
      res["dataVersion"] = boost::any(*dataVersion);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("dataVersion") != m.end() && !m["dataVersion"].empty()) {
      dataVersion = make_shared<long>(boost::any_cast<long>(m["dataVersion"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DeleteExpressionVariableRequest() = default;
};
class DeleteExpressionVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DeleteExpressionVariableResponseBody() {}

  explicit DeleteExpressionVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DeleteExpressionVariableResponseBody() = default;
};
class DeleteExpressionVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteExpressionVariableResponseBody> body{};

  DeleteExpressionVariableResponse() {}

  explicit DeleteExpressionVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteExpressionVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteExpressionVariableResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteExpressionVariableResponse() = default;
};
class DeleteFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> regId{};

  DeleteFieldRequest() {}

  explicit DeleteFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DeleteFieldRequest() = default;
};
class DeleteFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DeleteFieldResponseBody() {}

  explicit DeleteFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DeleteFieldResponseBody() = default;
};
class DeleteFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFieldResponseBody> body{};

  DeleteFieldResponse() {}

  explicit DeleteFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFieldResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFieldResponse() = default;
};
class DeleteNameListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> ids{};
  shared_ptr<string> regId{};

  DeleteNameListRequest() {}

  explicit DeleteNameListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (ids) {
      res["ids"] = boost::any(*ids);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ids") != m.end() && !m["ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["ids"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DeleteNameListRequest() = default;
};
class DeleteNameListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DeleteNameListResponseBody() {}

  explicit DeleteNameListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DeleteNameListResponseBody() = default;
};
class DeleteNameListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNameListResponseBody> body{};

  DeleteNameListResponse() {}

  explicit DeleteNameListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNameListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNameListResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNameListResponse() = default;
};
class DeleteNameListDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> variableId{};

  DeleteNameListDataRequest() {}

  explicit DeleteNameListDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (variableId) {
      res["variableId"] = boost::any(*variableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("variableId") != m.end() && !m["variableId"].empty()) {
      variableId = make_shared<string>(boost::any_cast<string>(m["variableId"]));
    }
  }


  virtual ~DeleteNameListDataRequest() = default;
};
class DeleteNameListDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DeleteNameListDataResponseBody() {}

  explicit DeleteNameListDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DeleteNameListDataResponseBody() = default;
};
class DeleteNameListDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNameListDataResponseBody> body{};

  DeleteNameListDataResponse() {}

  explicit DeleteNameListDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNameListDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNameListDataResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNameListDataResponse() = default;
};
class DeleteQueryVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  DeleteQueryVariableRequest() {}

  explicit DeleteQueryVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DeleteQueryVariableRequest() = default;
};
class DeleteQueryVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DeleteQueryVariableResponseBody() {}

  explicit DeleteQueryVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DeleteQueryVariableResponseBody() = default;
};
class DeleteQueryVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteQueryVariableResponseBody> body{};

  DeleteQueryVariableResponse() {}

  explicit DeleteQueryVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteQueryVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteQueryVariableResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteQueryVariableResponse() = default;
};
class DeleteRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> consoleRuleId{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleId{};
  shared_ptr<long> ruleVersionId{};

  DeleteRuleRequest() {}

  explicit DeleteRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleVersionId) {
      res["ruleVersionId"] = boost::any(*ruleVersionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleVersionId") != m.end() && !m["ruleVersionId"].empty()) {
      ruleVersionId = make_shared<long>(boost::any_cast<long>(m["ruleVersionId"]));
    }
  }


  virtual ~DeleteRuleRequest() = default;
};
class DeleteRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DeleteRuleResponseBody() {}

  explicit DeleteRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DeleteRuleResponseBody() = default;
};
class DeleteRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRuleResponseBody> body{};

  DeleteRuleResponse() {}

  explicit DeleteRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRuleResponse() = default;
};
class DeleteSampleBatchRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> ids{};
  shared_ptr<string> regId{};
  shared_ptr<string> versions{};

  DeleteSampleBatchRequest() {}

  explicit DeleteSampleBatchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (ids) {
      res["ids"] = boost::any(*ids);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (versions) {
      res["versions"] = boost::any(*versions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ids") != m.end() && !m["ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["ids"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("versions") != m.end() && !m["versions"].empty()) {
      versions = make_shared<string>(boost::any_cast<string>(m["versions"]));
    }
  }


  virtual ~DeleteSampleBatchRequest() = default;
};
class DeleteSampleBatchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  DeleteSampleBatchResponseBody() {}

  explicit DeleteSampleBatchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~DeleteSampleBatchResponseBody() = default;
};
class DeleteSampleBatchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSampleBatchResponseBody> body{};

  DeleteSampleBatchResponse() {}

  explicit DeleteSampleBatchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSampleBatchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSampleBatchResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSampleBatchResponse() = default;
};
class DeleteSampleDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> id{};
  shared_ptr<string> regId{};

  DeleteSampleDataRequest() {}

  explicit DeleteSampleDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DeleteSampleDataRequest() = default;
};
class DeleteSampleDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DeleteSampleDataResponseBody() {}

  explicit DeleteSampleDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DeleteSampleDataResponseBody() = default;
};
class DeleteSampleDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSampleDataResponseBody> body{};

  DeleteSampleDataResponse() {}

  explicit DeleteSampleDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSampleDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSampleDataResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSampleDataResponse() = default;
};
class DeleteTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> taskId{};
  shared_ptr<string> regId{};

  DeleteTaskRequest() {}

  explicit DeleteTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DeleteTaskRequest() = default;
};
class DeleteTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  DeleteTaskResponseBody() {}

  explicit DeleteTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~DeleteTaskResponseBody() = default;
};
class DeleteTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTaskResponseBody> body{};

  DeleteTaskResponse() {}

  explicit DeleteTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTaskResponse() = default;
};
class DescribeAdvanceSearchLeftVariableListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> regId{};
  shared_ptr<string> scene{};

  DescribeAdvanceSearchLeftVariableListRequest() {}

  explicit DescribeAdvanceSearchLeftVariableListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["scene"]));
    }
  }


  virtual ~DescribeAdvanceSearchLeftVariableListRequest() = default;
};
class DescribeAdvanceSearchLeftVariableListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  DescribeAdvanceSearchLeftVariableListResponseBodyResultObject() {}

  explicit DescribeAdvanceSearchLeftVariableListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeAdvanceSearchLeftVariableListResponseBodyResultObject() = default;
};
class DescribeAdvanceSearchLeftVariableListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAdvanceSearchLeftVariableListResponseBodyResultObject>> resultObject{};

  DescribeAdvanceSearchLeftVariableListResponseBody() {}

  explicit DescribeAdvanceSearchLeftVariableListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeAdvanceSearchLeftVariableListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAdvanceSearchLeftVariableListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeAdvanceSearchLeftVariableListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeAdvanceSearchLeftVariableListResponseBody() = default;
};
class DescribeAdvanceSearchLeftVariableListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAdvanceSearchLeftVariableListResponseBody> body{};

  DescribeAdvanceSearchLeftVariableListResponse() {}

  explicit DescribeAdvanceSearchLeftVariableListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAdvanceSearchLeftVariableListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAdvanceSearchLeftVariableListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAdvanceSearchLeftVariableListResponse() = default;
};
class DescribeAdvanceSearchPageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> condition{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> eventBeginTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<long> eventEndTime{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};

  DescribeAdvanceSearchPageListRequest() {}

  explicit DescribeAdvanceSearchPageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (eventBeginTime) {
      res["eventBeginTime"] = boost::any(*eventBeginTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (eventEndTime) {
      res["eventEndTime"] = boost::any(*eventEndTime);
    }
    if (fieldName) {
      res["fieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("eventBeginTime") != m.end() && !m["eventBeginTime"].empty()) {
      eventBeginTime = make_shared<long>(boost::any_cast<long>(m["eventBeginTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("eventEndTime") != m.end() && !m["eventEndTime"].empty()) {
      eventEndTime = make_shared<long>(boost::any_cast<long>(m["eventEndTime"]));
    }
    if (m.find("fieldName") != m.end() && !m["fieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["fieldName"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAdvanceSearchPageListRequest() = default;
};
class DescribeAdvanceSearchPageListResponseBodyResultObjectHeader : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldTitle{};
  shared_ptr<bool> isDefault{};

  DescribeAdvanceSearchPageListResponseBodyResultObjectHeader() {}

  explicit DescribeAdvanceSearchPageListResponseBodyResultObjectHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["fieldName"] = boost::any(*fieldName);
    }
    if (fieldTitle) {
      res["fieldTitle"] = boost::any(*fieldTitle);
    }
    if (isDefault) {
      res["isDefault"] = boost::any(*isDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldName") != m.end() && !m["fieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["fieldName"]));
    }
    if (m.find("fieldTitle") != m.end() && !m["fieldTitle"].empty()) {
      fieldTitle = make_shared<string>(boost::any_cast<string>(m["fieldTitle"]));
    }
    if (m.find("isDefault") != m.end() && !m["isDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["isDefault"]));
    }
  }


  virtual ~DescribeAdvanceSearchPageListResponseBodyResultObjectHeader() = default;
};
class DescribeAdvanceSearchPageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<map<string, boost::any>>> data{};
  shared_ptr<vector<DescribeAdvanceSearchPageListResponseBodyResultObjectHeader>> header{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeAdvanceSearchPageListResponseBodyResultObject() {}

  explicit DescribeAdvanceSearchPageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (header) {
      vector<boost::any> temp1;
      for(auto item1:*header){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["header"] = boost::any(temp1);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      data = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("header") != m.end() && !m["header"].empty()) {
      if (typeid(vector<boost::any>) == m["header"].type()) {
        vector<DescribeAdvanceSearchPageListResponseBodyResultObjectHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["header"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAdvanceSearchPageListResponseBodyResultObjectHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        header = make_shared<vector<DescribeAdvanceSearchPageListResponseBodyResultObjectHeader>>(expect1);
      }
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeAdvanceSearchPageListResponseBodyResultObject() = default;
};
class DescribeAdvanceSearchPageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAdvanceSearchPageListResponseBodyResultObject> resultObject{};

  DescribeAdvanceSearchPageListResponseBody() {}

  explicit DescribeAdvanceSearchPageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeAdvanceSearchPageListResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeAdvanceSearchPageListResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeAdvanceSearchPageListResponseBody() = default;
};
class DescribeAdvanceSearchPageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAdvanceSearchPageListResponseBody> body{};

  DescribeAdvanceSearchPageListResponse() {}

  explicit DescribeAdvanceSearchPageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAdvanceSearchPageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAdvanceSearchPageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAdvanceSearchPageListResponse() = default;
};
class DescribeAllDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeAllDataSourceRequest() {}

  explicit DescribeAllDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAllDataSourceRequest() = default;
};
class DescribeAllDataSourceResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<long> id{};

  DescribeAllDataSourceResponseBodyResultObject() {}

  explicit DescribeAllDataSourceResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
  }


  virtual ~DescribeAllDataSourceResponseBodyResultObject() = default;
};
class DescribeAllDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAllDataSourceResponseBodyResultObject>> resultObject{};

  DescribeAllDataSourceResponseBody() {}

  explicit DescribeAllDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeAllDataSourceResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAllDataSourceResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeAllDataSourceResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeAllDataSourceResponseBody() = default;
};
class DescribeAllDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAllDataSourceResponseBody> body{};

  DescribeAllDataSourceResponse() {}

  explicit DescribeAllDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAllDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAllDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAllDataSourceResponse() = default;
};
class DescribeAllEventNameAndCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> regId{};

  DescribeAllEventNameAndCodeRequest() {}

  explicit DescribeAllEventNameAndCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAllEventNameAndCodeRequest() = default;
};
class DescribeAllEventNameAndCodeResponseBodyResultObjectChildren : public Darabonba::Model {
public:
  shared_ptr<string> createType{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};

  DescribeAllEventNameAndCodeResponseBodyResultObjectChildren() {}

  explicit DescribeAllEventNameAndCodeResponseBodyResultObjectChildren(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
  }


  virtual ~DescribeAllEventNameAndCodeResponseBodyResultObjectChildren() = default;
};
class DescribeAllEventNameAndCodeResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAllEventNameAndCodeResponseBodyResultObjectChildren>> children{};
  shared_ptr<string> createType{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};

  DescribeAllEventNameAndCodeResponseBodyResultObject() {}

  explicit DescribeAllEventNameAndCodeResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (children) {
      vector<boost::any> temp1;
      for(auto item1:*children){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["children"] = boost::any(temp1);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("children") != m.end() && !m["children"].empty()) {
      if (typeid(vector<boost::any>) == m["children"].type()) {
        vector<DescribeAllEventNameAndCodeResponseBodyResultObjectChildren> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["children"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAllEventNameAndCodeResponseBodyResultObjectChildren model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        children = make_shared<vector<DescribeAllEventNameAndCodeResponseBodyResultObjectChildren>>(expect1);
      }
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
  }


  virtual ~DescribeAllEventNameAndCodeResponseBodyResultObject() = default;
};
class DescribeAllEventNameAndCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAllEventNameAndCodeResponseBodyResultObject>> resultObject{};
  shared_ptr<bool> success{};

  DescribeAllEventNameAndCodeResponseBody() {}

  explicit DescribeAllEventNameAndCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeAllEventNameAndCodeResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAllEventNameAndCodeResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeAllEventNameAndCodeResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeAllEventNameAndCodeResponseBody() = default;
};
class DescribeAllEventNameAndCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAllEventNameAndCodeResponseBody> body{};

  DescribeAllEventNameAndCodeResponse() {}

  explicit DescribeAllEventNameAndCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAllEventNameAndCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAllEventNameAndCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAllEventNameAndCodeResponse() = default;
};
class DescribeAllRootVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> deviceVariableIds{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> expressionVariableIds{};
  shared_ptr<long> id{};
  shared_ptr<string> nativeVariableIds{};
  shared_ptr<string> queryVariableIds{};
  shared_ptr<string> regId{};
  shared_ptr<string> velocityVariableIds{};

  DescribeAllRootVariableRequest() {}

  explicit DescribeAllRootVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (deviceVariableIds) {
      res["deviceVariableIds"] = boost::any(*deviceVariableIds);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (expressionVariableIds) {
      res["expressionVariableIds"] = boost::any(*expressionVariableIds);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (nativeVariableIds) {
      res["nativeVariableIds"] = boost::any(*nativeVariableIds);
    }
    if (queryVariableIds) {
      res["queryVariableIds"] = boost::any(*queryVariableIds);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (velocityVariableIds) {
      res["velocityVariableIds"] = boost::any(*velocityVariableIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("deviceVariableIds") != m.end() && !m["deviceVariableIds"].empty()) {
      deviceVariableIds = make_shared<string>(boost::any_cast<string>(m["deviceVariableIds"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("expressionVariableIds") != m.end() && !m["expressionVariableIds"].empty()) {
      expressionVariableIds = make_shared<string>(boost::any_cast<string>(m["expressionVariableIds"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("nativeVariableIds") != m.end() && !m["nativeVariableIds"].empty()) {
      nativeVariableIds = make_shared<string>(boost::any_cast<string>(m["nativeVariableIds"]));
    }
    if (m.find("queryVariableIds") != m.end() && !m["queryVariableIds"].empty()) {
      queryVariableIds = make_shared<string>(boost::any_cast<string>(m["queryVariableIds"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("velocityVariableIds") != m.end() && !m["velocityVariableIds"].empty()) {
      velocityVariableIds = make_shared<string>(boost::any_cast<string>(m["velocityVariableIds"]));
    }
  }


  virtual ~DescribeAllRootVariableRequest() = default;
};
class DescribeAllRootVariableResponseBodyResultObjectOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeAllRootVariableResponseBodyResultObjectOutputThreshold() {}

  explicit DescribeAllRootVariableResponseBodyResultObjectOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeAllRootVariableResponseBodyResultObjectOutputThreshold() = default;
};
class DescribeAllRootVariableResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<DescribeAllRootVariableResponseBodyResultObjectOutputThreshold> outputThreshold{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  DescribeAllRootVariableResponseBodyResultObject() {}

  explicit DescribeAllRootVariableResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeAllRootVariableResponseBodyResultObjectOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeAllRootVariableResponseBodyResultObjectOutputThreshold>(model1);
      }
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeAllRootVariableResponseBodyResultObject() = default;
};
class DescribeAllRootVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAllRootVariableResponseBodyResultObject>> resultObject{};

  DescribeAllRootVariableResponseBody() {}

  explicit DescribeAllRootVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeAllRootVariableResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAllRootVariableResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeAllRootVariableResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeAllRootVariableResponseBody() = default;
};
class DescribeAllRootVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAllRootVariableResponseBody> body{};

  DescribeAllRootVariableResponse() {}

  explicit DescribeAllRootVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAllRootVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAllRootVariableResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAllRootVariableResponse() = default;
};
class DescribeAnalysisColumnFieldListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeAnalysisColumnFieldListRequest() {}

  explicit DescribeAnalysisColumnFieldListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAnalysisColumnFieldListRequest() = default;
};
class DescribeAnalysisColumnFieldListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeAnalysisColumnFieldListResponseBody() {}

  explicit DescribeAnalysisColumnFieldListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeAnalysisColumnFieldListResponseBody() = default;
};
class DescribeAnalysisColumnFieldListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAnalysisColumnFieldListResponseBody> body{};

  DescribeAnalysisColumnFieldListResponse() {}

  explicit DescribeAnalysisColumnFieldListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAnalysisColumnFieldListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAnalysisColumnFieldListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAnalysisColumnFieldListResponse() = default;
};
class DescribeAnalysisColumnListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeAnalysisColumnListRequest() {}

  explicit DescribeAnalysisColumnListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAnalysisColumnListRequest() = default;
};
class DescribeAnalysisColumnListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> variableName{};
  shared_ptr<string> variableTitle{};
  shared_ptr<string> variableType{};

  DescribeAnalysisColumnListResponseBodyResultObject() {}

  explicit DescribeAnalysisColumnListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (isDefault) {
      res["isDefault"] = boost::any(*isDefault);
    }
    if (variableName) {
      res["variableName"] = boost::any(*variableName);
    }
    if (variableTitle) {
      res["variableTitle"] = boost::any(*variableTitle);
    }
    if (variableType) {
      res["variableType"] = boost::any(*variableType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("isDefault") != m.end() && !m["isDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["isDefault"]));
    }
    if (m.find("variableName") != m.end() && !m["variableName"].empty()) {
      variableName = make_shared<string>(boost::any_cast<string>(m["variableName"]));
    }
    if (m.find("variableTitle") != m.end() && !m["variableTitle"].empty()) {
      variableTitle = make_shared<string>(boost::any_cast<string>(m["variableTitle"]));
    }
    if (m.find("variableType") != m.end() && !m["variableType"].empty()) {
      variableType = make_shared<string>(boost::any_cast<string>(m["variableType"]));
    }
  }


  virtual ~DescribeAnalysisColumnListResponseBodyResultObject() = default;
};
class DescribeAnalysisColumnListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAnalysisColumnListResponseBodyResultObject>> resultObject{};

  DescribeAnalysisColumnListResponseBody() {}

  explicit DescribeAnalysisColumnListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeAnalysisColumnListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAnalysisColumnListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeAnalysisColumnListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeAnalysisColumnListResponseBody() = default;
};
class DescribeAnalysisColumnListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAnalysisColumnListResponseBody> body{};

  DescribeAnalysisColumnListResponse() {}

  explicit DescribeAnalysisColumnListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAnalysisColumnListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAnalysisColumnListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAnalysisColumnListResponse() = default;
};
class DescribeAnalysisConditionFavoriteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeAnalysisConditionFavoriteListRequest() {}

  explicit DescribeAnalysisConditionFavoriteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAnalysisConditionFavoriteListRequest() = default;
};
class DescribeAnalysisConditionFavoriteListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<long> eventBeginTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<long> eventEndTime{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  DescribeAnalysisConditionFavoriteListResponseBodyResultObject() {}

  explicit DescribeAnalysisConditionFavoriteListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (eventBeginTime) {
      res["eventBeginTime"] = boost::any(*eventBeginTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (eventEndTime) {
      res["eventEndTime"] = boost::any(*eventEndTime);
    }
    if (fieldName) {
      res["fieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("eventBeginTime") != m.end() && !m["eventBeginTime"].empty()) {
      eventBeginTime = make_shared<long>(boost::any_cast<long>(m["eventBeginTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("eventEndTime") != m.end() && !m["eventEndTime"].empty()) {
      eventEndTime = make_shared<long>(boost::any_cast<long>(m["eventEndTime"]));
    }
    if (m.find("fieldName") != m.end() && !m["fieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["fieldName"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeAnalysisConditionFavoriteListResponseBodyResultObject() = default;
};
class DescribeAnalysisConditionFavoriteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAnalysisConditionFavoriteListResponseBodyResultObject>> resultObject{};

  DescribeAnalysisConditionFavoriteListResponseBody() {}

  explicit DescribeAnalysisConditionFavoriteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeAnalysisConditionFavoriteListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAnalysisConditionFavoriteListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeAnalysisConditionFavoriteListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeAnalysisConditionFavoriteListResponseBody() = default;
};
class DescribeAnalysisConditionFavoriteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAnalysisConditionFavoriteListResponseBody> body{};

  DescribeAnalysisConditionFavoriteListResponse() {}

  explicit DescribeAnalysisConditionFavoriteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAnalysisConditionFavoriteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAnalysisConditionFavoriteListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAnalysisConditionFavoriteListResponse() = default;
};
class DescribeAnalysisExportTaskDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeAnalysisExportTaskDownloadUrlRequest() {}

  explicit DescribeAnalysisExportTaskDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAnalysisExportTaskDownloadUrlRequest() = default;
};
class DescribeAnalysisExportTaskDownloadUrlResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> downloadFileUrl{};
  shared_ptr<long> executeTime{};
  shared_ptr<string> status{};

  DescribeAnalysisExportTaskDownloadUrlResponseBodyResultObject() {}

  explicit DescribeAnalysisExportTaskDownloadUrlResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadFileUrl) {
      res["downloadFileUrl"] = boost::any(*downloadFileUrl);
    }
    if (executeTime) {
      res["executeTime"] = boost::any(*executeTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("downloadFileUrl") != m.end() && !m["downloadFileUrl"].empty()) {
      downloadFileUrl = make_shared<string>(boost::any_cast<string>(m["downloadFileUrl"]));
    }
    if (m.find("executeTime") != m.end() && !m["executeTime"].empty()) {
      executeTime = make_shared<long>(boost::any_cast<long>(m["executeTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~DescribeAnalysisExportTaskDownloadUrlResponseBodyResultObject() = default;
};
class DescribeAnalysisExportTaskDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAnalysisExportTaskDownloadUrlResponseBodyResultObject> resultObject{};

  DescribeAnalysisExportTaskDownloadUrlResponseBody() {}

  explicit DescribeAnalysisExportTaskDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeAnalysisExportTaskDownloadUrlResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeAnalysisExportTaskDownloadUrlResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeAnalysisExportTaskDownloadUrlResponseBody() = default;
};
class DescribeAnalysisExportTaskDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAnalysisExportTaskDownloadUrlResponseBody> body{};

  DescribeAnalysisExportTaskDownloadUrlResponse() {}

  explicit DescribeAnalysisExportTaskDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAnalysisExportTaskDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAnalysisExportTaskDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAnalysisExportTaskDownloadUrlResponse() = default;
};
class DescribeApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiRegionId{};
  shared_ptr<string> apiType{};
  shared_ptr<string> regId{};

  DescribeApiRequest() {}

  explicit DescribeApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (apiId) {
      res["apiId"] = boost::any(*apiId);
    }
    if (apiRegionId) {
      res["apiRegionId"] = boost::any(*apiRegionId);
    }
    if (apiType) {
      res["apiType"] = boost::any(*apiType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("apiId") != m.end() && !m["apiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["apiId"]));
    }
    if (m.find("apiRegionId") != m.end() && !m["apiRegionId"].empty()) {
      apiRegionId = make_shared<string>(boost::any_cast<string>(m["apiRegionId"]));
    }
    if (m.find("apiType") != m.end() && !m["apiType"].empty()) {
      apiType = make_shared<string>(boost::any_cast<string>(m["apiType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeApiRequest() = default;
};
class DescribeApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeApiResponseBody() {}

  explicit DescribeApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeApiResponseBody() = default;
};
class DescribeApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiResponseBody> body{};

  DescribeApiResponse() {}

  explicit DescribeApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiResponse() = default;
};
class DescribeApiGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> apiRegionId{};
  shared_ptr<string> regId{};

  DescribeApiGroupsRequest() {}

  explicit DescribeApiGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (apiRegionId) {
      res["apiRegionId"] = boost::any(*apiRegionId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("apiRegionId") != m.end() && !m["apiRegionId"].empty()) {
      apiRegionId = make_shared<string>(boost::any_cast<string>(m["apiRegionId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeApiGroupsRequest() = default;
};
class DescribeApiGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeApiGroupsResponseBody() {}

  explicit DescribeApiGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeApiGroupsResponseBody() = default;
};
class DescribeApiGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiGroupsResponseBody> body{};

  DescribeApiGroupsResponse() {}

  explicit DescribeApiGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiGroupsResponse() = default;
};
class DescribeApiLimitRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeApiLimitRequest() {}

  explicit DescribeApiLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeApiLimitRequest() = default;
};
class DescribeApiLimitResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<bool> limit{};
  shared_ptr<long> maxTotalItem{};
  shared_ptr<long> totalItem{};

  DescribeApiLimitResponseBodyResultObject() {}

  explicit DescribeApiLimitResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (limit) {
      res["limit"] = boost::any(*limit);
    }
    if (maxTotalItem) {
      res["maxTotalItem"] = boost::any(*maxTotalItem);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("limit") != m.end() && !m["limit"].empty()) {
      limit = make_shared<bool>(boost::any_cast<bool>(m["limit"]));
    }
    if (m.find("maxTotalItem") != m.end() && !m["maxTotalItem"].empty()) {
      maxTotalItem = make_shared<long>(boost::any_cast<long>(m["maxTotalItem"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
  }


  virtual ~DescribeApiLimitResponseBodyResultObject() = default;
};
class DescribeApiLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiLimitResponseBodyResultObject> resultObject{};

  DescribeApiLimitResponseBody() {}

  explicit DescribeApiLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeApiLimitResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeApiLimitResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeApiLimitResponseBody() = default;
};
class DescribeApiLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiLimitResponseBody> body{};

  DescribeApiLimitResponse() {}

  explicit DescribeApiLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiLimitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiLimitResponse() = default;
};
class DescribeApiNameListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeApiNameListRequest() {}

  explicit DescribeApiNameListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeApiNameListRequest() = default;
};
class DescribeApiNameListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};

  DescribeApiNameListResponseBodyResultObject() {}

  explicit DescribeApiNameListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["apiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["apiName"] = boost::any(*apiName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apiId") != m.end() && !m["apiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["apiId"]));
    }
    if (m.find("apiName") != m.end() && !m["apiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["apiName"]));
    }
  }


  virtual ~DescribeApiNameListResponseBodyResultObject() = default;
};
class DescribeApiNameListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeApiNameListResponseBodyResultObject>> resultObject{};

  DescribeApiNameListResponseBody() {}

  explicit DescribeApiNameListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeApiNameListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiNameListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeApiNameListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeApiNameListResponseBody() = default;
};
class DescribeApiNameListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiNameListResponseBody> body{};

  DescribeApiNameListResponse() {}

  explicit DescribeApiNameListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiNameListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiNameListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiNameListResponse() = default;
};
class DescribeApiVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> id{};
  shared_ptr<string> regId{};

  DescribeApiVariableRequest() {}

  explicit DescribeApiVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeApiVariableRequest() = default;
};
class DescribeApiVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeApiVariableResponseBody() {}

  explicit DescribeApiVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeApiVariableResponseBody() = default;
};
class DescribeApiVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiVariableResponseBody> body{};

  DescribeApiVariableResponse() {}

  explicit DescribeApiVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiVariableResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiVariableResponse() = default;
};
class DescribeApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> apiGroupId{};
  shared_ptr<string> apiRegionId{};
  shared_ptr<string> apiType{};
  shared_ptr<string> regId{};

  DescribeApisRequest() {}

  explicit DescribeApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (apiGroupId) {
      res["apiGroupId"] = boost::any(*apiGroupId);
    }
    if (apiRegionId) {
      res["apiRegionId"] = boost::any(*apiRegionId);
    }
    if (apiType) {
      res["apiType"] = boost::any(*apiType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("apiGroupId") != m.end() && !m["apiGroupId"].empty()) {
      apiGroupId = make_shared<string>(boost::any_cast<string>(m["apiGroupId"]));
    }
    if (m.find("apiRegionId") != m.end() && !m["apiRegionId"].empty()) {
      apiRegionId = make_shared<string>(boost::any_cast<string>(m["apiRegionId"]));
    }
    if (m.find("apiType") != m.end() && !m["apiType"].empty()) {
      apiType = make_shared<string>(boost::any_cast<string>(m["apiType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeApisRequest() = default;
};
class DescribeApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeApisResponseBody() {}

  explicit DescribeApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeApisResponseBody() = default;
};
class DescribeApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisResponseBody> body{};

  DescribeApisResponse() {}

  explicit DescribeApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisResponse() = default;
};
class DescribeAppKeyPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};

  DescribeAppKeyPageRequest() {}

  explicit DescribeAppKeyPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAppKeyPageRequest() = default;
};
class DescribeAppKeyPageResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> androidSdkUrl{};
  shared_ptr<string> androidSdkVersion{};
  shared_ptr<string> appKey{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> iosSdkUrl{};
  shared_ptr<string> iosSdkVersion{};
  shared_ptr<string> memo{};
  shared_ptr<string> sdkItems{};
  shared_ptr<string> used{};

  DescribeAppKeyPageResponseBodyResultObject() {}

  explicit DescribeAppKeyPageResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (androidSdkUrl) {
      res["androidSdkUrl"] = boost::any(*androidSdkUrl);
    }
    if (androidSdkVersion) {
      res["androidSdkVersion"] = boost::any(*androidSdkVersion);
    }
    if (appKey) {
      res["appKey"] = boost::any(*appKey);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (iosSdkUrl) {
      res["iosSdkUrl"] = boost::any(*iosSdkUrl);
    }
    if (iosSdkVersion) {
      res["iosSdkVersion"] = boost::any(*iosSdkVersion);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (sdkItems) {
      res["sdkItems"] = boost::any(*sdkItems);
    }
    if (used) {
      res["used"] = boost::any(*used);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("androidSdkUrl") != m.end() && !m["androidSdkUrl"].empty()) {
      androidSdkUrl = make_shared<string>(boost::any_cast<string>(m["androidSdkUrl"]));
    }
    if (m.find("androidSdkVersion") != m.end() && !m["androidSdkVersion"].empty()) {
      androidSdkVersion = make_shared<string>(boost::any_cast<string>(m["androidSdkVersion"]));
    }
    if (m.find("appKey") != m.end() && !m["appKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["appKey"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("iosSdkUrl") != m.end() && !m["iosSdkUrl"].empty()) {
      iosSdkUrl = make_shared<string>(boost::any_cast<string>(m["iosSdkUrl"]));
    }
    if (m.find("iosSdkVersion") != m.end() && !m["iosSdkVersion"].empty()) {
      iosSdkVersion = make_shared<string>(boost::any_cast<string>(m["iosSdkVersion"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("sdkItems") != m.end() && !m["sdkItems"].empty()) {
      sdkItems = make_shared<string>(boost::any_cast<string>(m["sdkItems"]));
    }
    if (m.find("used") != m.end() && !m["used"].empty()) {
      used = make_shared<string>(boost::any_cast<string>(m["used"]));
    }
  }


  virtual ~DescribeAppKeyPageResponseBodyResultObject() = default;
};
class DescribeAppKeyPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeAppKeyPageResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeAppKeyPageResponseBody() {}

  explicit DescribeAppKeyPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeAppKeyPageResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppKeyPageResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeAppKeyPageResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeAppKeyPageResponseBody() = default;
};
class DescribeAppKeyPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppKeyPageResponseBody> body{};

  DescribeAppKeyPageResponse() {}

  explicit DescribeAppKeyPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppKeyPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppKeyPageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppKeyPageResponse() = default;
};
class DescribeAuditConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> auditRelationType{};
  shared_ptr<string> regId{};

  DescribeAuditConfigRequest() {}

  explicit DescribeAuditConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (auditRelationType) {
      res["auditRelationType"] = boost::any(*auditRelationType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("auditRelationType") != m.end() && !m["auditRelationType"].empty()) {
      auditRelationType = make_shared<string>(boost::any_cast<string>(m["auditRelationType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAuditConfigRequest() = default;
};
class DescribeAuditConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<bool> resultObject{};
  shared_ptr<bool> success{};

  DescribeAuditConfigResponseBody() {}

  explicit DescribeAuditConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeAuditConfigResponseBody() = default;
};
class DescribeAuditConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAuditConfigResponseBody> body{};

  DescribeAuditConfigResponse() {}

  explicit DescribeAuditConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAuditConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAuditConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAuditConfigResponse() = default;
};
class DescribeAuditDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  DescribeAuditDetailsRequest() {}

  explicit DescribeAuditDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAuditDetailsRequest() = default;
};
class DescribeAuditDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<bool> resultObject{};
  shared_ptr<bool> success{};

  DescribeAuditDetailsResponseBody() {}

  explicit DescribeAuditDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeAuditDetailsResponseBody() = default;
};
class DescribeAuditDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAuditDetailsResponseBody> body{};

  DescribeAuditDetailsResponse() {}

  explicit DescribeAuditDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAuditDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAuditDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAuditDetailsResponse() = default;
};
class DescribeAuditPageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> auditStatus{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleName{};

  DescribeAuditPageListRequest() {}

  explicit DescribeAuditPageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (auditStatus) {
      res["auditStatus"] = boost::any(*auditStatus);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("auditStatus") != m.end() && !m["auditStatus"].empty()) {
      auditStatus = make_shared<string>(boost::any_cast<string>(m["auditStatus"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
  }


  virtual ~DescribeAuditPageListRequest() = default;
};
class DescribeAuditPageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeAuditPageListResponseBody() {}

  explicit DescribeAuditPageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeAuditPageListResponseBody() = default;
};
class DescribeAuditPageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAuditPageListResponseBody> body{};

  DescribeAuditPageListResponse() {}

  explicit DescribeAuditPageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAuditPageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAuditPageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAuditPageListResponse() = default;
};
class DescribeAuthEventNameListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeAuthEventNameListRequest() {}

  explicit DescribeAuthEventNameListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAuthEventNameListRequest() = default;
};
class DescribeAuthEventNameListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeAuthEventNameListResponseBody() {}

  explicit DescribeAuthEventNameListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeAuthEventNameListResponseBody() = default;
};
class DescribeAuthEventNameListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAuthEventNameListResponseBody> body{};

  DescribeAuthEventNameListResponse() {}

  explicit DescribeAuthEventNameListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAuthEventNameListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAuthEventNameListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAuthEventNameListResponse() = default;
};
class DescribeAuthRulePageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> status{};

  DescribeAuthRulePageListRequest() {}

  explicit DescribeAuthRulePageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~DescribeAuthRulePageListRequest() = default;
};
class DescribeAuthRulePageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> consoleRuleId{};
  shared_ptr<string> createType{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> memo{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> ruleVersionId{};
  shared_ptr<string> status{};
  shared_ptr<long> version{};

  DescribeAuthRulePageListResponseBodyResultObject() {}

  explicit DescribeAuthRulePageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleVersionId) {
      res["ruleVersionId"] = boost::any(*ruleVersionId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleVersionId") != m.end() && !m["ruleVersionId"].empty()) {
      ruleVersionId = make_shared<long>(boost::any_cast<long>(m["ruleVersionId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~DescribeAuthRulePageListResponseBodyResultObject() = default;
};
class DescribeAuthRulePageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeAuthRulePageListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeAuthRulePageListResponseBody() {}

  explicit DescribeAuthRulePageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeAuthRulePageListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAuthRulePageListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeAuthRulePageListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeAuthRulePageListResponseBody() = default;
};
class DescribeAuthRulePageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAuthRulePageListResponseBody> body{};

  DescribeAuthRulePageListResponse() {}

  explicit DescribeAuthRulePageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAuthRulePageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAuthRulePageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAuthRulePageListResponse() = default;
};
class DescribeAuthSceneListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeAuthSceneListRequest() {}

  explicit DescribeAuthSceneListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAuthSceneListRequest() = default;
};
class DescribeAuthSceneListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> serviceCode{};

  DescribeAuthSceneListResponseBodyResultObject() {}

  explicit DescribeAuthSceneListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceCode) {
      res["serviceCode"] = boost::any(*serviceCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceCode") != m.end() && !m["serviceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["serviceCode"]));
    }
  }


  virtual ~DescribeAuthSceneListResponseBodyResultObject() = default;
};
class DescribeAuthSceneListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAuthSceneListResponseBodyResultObject>> resultObject{};

  DescribeAuthSceneListResponseBody() {}

  explicit DescribeAuthSceneListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeAuthSceneListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAuthSceneListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeAuthSceneListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeAuthSceneListResponseBody() = default;
};
class DescribeAuthSceneListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAuthSceneListResponseBody> body{};

  DescribeAuthSceneListResponse() {}

  explicit DescribeAuthSceneListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAuthSceneListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAuthSceneListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAuthSceneListResponse() = default;
};
class DescribeAuthScenePageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> sceneName{};

  DescribeAuthScenePageListRequest() {}

  explicit DescribeAuthScenePageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (sceneName) {
      res["sceneName"] = boost::any(*sceneName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("sceneName") != m.end() && !m["sceneName"].empty()) {
      sceneName = make_shared<string>(boost::any_cast<string>(m["sceneName"]));
    }
  }


  virtual ~DescribeAuthScenePageListRequest() = default;
};
class DescribeAuthScenePageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> commonRuleCount{};
  shared_ptr<long> customRuleCount{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> sceneName{};
  shared_ptr<string> serverName{};

  DescribeAuthScenePageListResponseBodyResultObject() {}

  explicit DescribeAuthScenePageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonRuleCount) {
      res["commonRuleCount"] = boost::any(*commonRuleCount);
    }
    if (customRuleCount) {
      res["customRuleCount"] = boost::any(*customRuleCount);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (sceneName) {
      res["sceneName"] = boost::any(*sceneName);
    }
    if (serverName) {
      res["serverName"] = boost::any(*serverName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonRuleCount") != m.end() && !m["commonRuleCount"].empty()) {
      commonRuleCount = make_shared<long>(boost::any_cast<long>(m["commonRuleCount"]));
    }
    if (m.find("customRuleCount") != m.end() && !m["customRuleCount"].empty()) {
      customRuleCount = make_shared<long>(boost::any_cast<long>(m["customRuleCount"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("sceneName") != m.end() && !m["sceneName"].empty()) {
      sceneName = make_shared<string>(boost::any_cast<string>(m["sceneName"]));
    }
    if (m.find("serverName") != m.end() && !m["serverName"].empty()) {
      serverName = make_shared<string>(boost::any_cast<string>(m["serverName"]));
    }
  }


  virtual ~DescribeAuthScenePageListResponseBodyResultObject() = default;
};
class DescribeAuthScenePageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeAuthScenePageListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeAuthScenePageListResponseBody() {}

  explicit DescribeAuthScenePageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeAuthScenePageListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAuthScenePageListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeAuthScenePageListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeAuthScenePageListResponseBody() = default;
};
class DescribeAuthScenePageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAuthScenePageListResponseBody> body{};

  DescribeAuthScenePageListResponse() {}

  explicit DescribeAuthScenePageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAuthScenePageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAuthScenePageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAuthScenePageListResponse() = default;
};
class DescribeAuthStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeAuthStatusRequest() {}

  explicit DescribeAuthStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAuthStatusRequest() = default;
};
class DescribeAuthStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeAuthStatusResponseBody() {}

  explicit DescribeAuthStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeAuthStatusResponseBody() = default;
};
class DescribeAuthStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAuthStatusResponseBody> body{};

  DescribeAuthStatusResponse() {}

  explicit DescribeAuthStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAuthStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAuthStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAuthStatusResponse() = default;
};
class DescribeAvgExecuteCostReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeAvgExecuteCostReportRequest() {}

  explicit DescribeAvgExecuteCostReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeAvgExecuteCostReportRequest() = default;
};
class DescribeAvgExecuteCostReportResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> ratio{};
  shared_ptr<string> value{};

  DescribeAvgExecuteCostReportResponseBodyResultObject() {}

  explicit DescribeAvgExecuteCostReportResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ratio) {
      res["ratio"] = boost::any(*ratio);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ratio") != m.end() && !m["ratio"].empty()) {
      ratio = make_shared<string>(boost::any_cast<string>(m["ratio"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeAvgExecuteCostReportResponseBodyResultObject() = default;
};
class DescribeAvgExecuteCostReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAvgExecuteCostReportResponseBodyResultObject>> resultObject{};
  shared_ptr<bool> success{};

  DescribeAvgExecuteCostReportResponseBody() {}

  explicit DescribeAvgExecuteCostReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeAvgExecuteCostReportResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvgExecuteCostReportResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeAvgExecuteCostReportResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeAvgExecuteCostReportResponseBody() = default;
};
class DescribeAvgExecuteCostReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAvgExecuteCostReportResponseBody> body{};

  DescribeAvgExecuteCostReportResponse() {}

  explicit DescribeAvgExecuteCostReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvgExecuteCostReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvgExecuteCostReportResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvgExecuteCostReportResponse() = default;
};
class DescribeBasicSearchPageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> eventBeginTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<long> eventEndTime{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};

  DescribeBasicSearchPageListRequest() {}

  explicit DescribeBasicSearchPageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (eventBeginTime) {
      res["eventBeginTime"] = boost::any(*eventBeginTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (eventEndTime) {
      res["eventEndTime"] = boost::any(*eventEndTime);
    }
    if (fieldName) {
      res["fieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("eventBeginTime") != m.end() && !m["eventBeginTime"].empty()) {
      eventBeginTime = make_shared<long>(boost::any_cast<long>(m["eventBeginTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("eventEndTime") != m.end() && !m["eventEndTime"].empty()) {
      eventEndTime = make_shared<long>(boost::any_cast<long>(m["eventEndTime"]));
    }
    if (m.find("fieldName") != m.end() && !m["fieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["fieldName"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeBasicSearchPageListRequest() = default;
};
class DescribeBasicSearchPageListResponseBodyResultObjectHeader : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldTitle{};
  shared_ptr<bool> isDefault{};

  DescribeBasicSearchPageListResponseBodyResultObjectHeader() {}

  explicit DescribeBasicSearchPageListResponseBodyResultObjectHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["fieldName"] = boost::any(*fieldName);
    }
    if (fieldTitle) {
      res["fieldTitle"] = boost::any(*fieldTitle);
    }
    if (isDefault) {
      res["isDefault"] = boost::any(*isDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldName") != m.end() && !m["fieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["fieldName"]));
    }
    if (m.find("fieldTitle") != m.end() && !m["fieldTitle"].empty()) {
      fieldTitle = make_shared<string>(boost::any_cast<string>(m["fieldTitle"]));
    }
    if (m.find("isDefault") != m.end() && !m["isDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["isDefault"]));
    }
  }


  virtual ~DescribeBasicSearchPageListResponseBodyResultObjectHeader() = default;
};
class DescribeBasicSearchPageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<map<string, boost::any>>> data{};
  shared_ptr<vector<DescribeBasicSearchPageListResponseBodyResultObjectHeader>> header{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeBasicSearchPageListResponseBodyResultObject() {}

  explicit DescribeBasicSearchPageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (header) {
      vector<boost::any> temp1;
      for(auto item1:*header){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["header"] = boost::any(temp1);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      data = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("header") != m.end() && !m["header"].empty()) {
      if (typeid(vector<boost::any>) == m["header"].type()) {
        vector<DescribeBasicSearchPageListResponseBodyResultObjectHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["header"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBasicSearchPageListResponseBodyResultObjectHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        header = make_shared<vector<DescribeBasicSearchPageListResponseBodyResultObjectHeader>>(expect1);
      }
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeBasicSearchPageListResponseBodyResultObject() = default;
};
class DescribeBasicSearchPageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBasicSearchPageListResponseBodyResultObject> resultObject{};

  DescribeBasicSearchPageListResponseBody() {}

  explicit DescribeBasicSearchPageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeBasicSearchPageListResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeBasicSearchPageListResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeBasicSearchPageListResponseBody() = default;
};
class DescribeBasicSearchPageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBasicSearchPageListResponseBody> body{};

  DescribeBasicSearchPageListResponse() {}

  explicit DescribeBasicSearchPageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBasicSearchPageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBasicSearchPageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBasicSearchPageListResponse() = default;
};
class DescribeBasicStartRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> endDs{};
  shared_ptr<string> regId{};
  shared_ptr<string> service{};
  shared_ptr<string> startDs{};

  DescribeBasicStartRequest() {}

  explicit DescribeBasicStartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["appKey"] = boost::any(*appKey);
    }
    if (endDs) {
      res["endDs"] = boost::any(*endDs);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (service) {
      res["service"] = boost::any(*service);
    }
    if (startDs) {
      res["startDs"] = boost::any(*startDs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appKey") != m.end() && !m["appKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["appKey"]));
    }
    if (m.find("endDs") != m.end() && !m["endDs"].empty()) {
      endDs = make_shared<string>(boost::any_cast<string>(m["endDs"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("service") != m.end() && !m["service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["service"]));
    }
    if (m.find("startDs") != m.end() && !m["startDs"].empty()) {
      startDs = make_shared<string>(boost::any_cast<string>(m["startDs"]));
    }
  }


  virtual ~DescribeBasicStartRequest() = default;
};
class DescribeBasicStartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};
  shared_ptr<bool> success{};

  DescribeBasicStartResponseBody() {}

  explicit DescribeBasicStartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeBasicStartResponseBody() = default;
};
class DescribeBasicStartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBasicStartResponseBody> body{};

  DescribeBasicStartResponse() {}

  explicit DescribeBasicStartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBasicStartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBasicStartResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBasicStartResponse() = default;
};
class DescribeByPassShuntEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> eventId{};
  shared_ptr<string> regId{};

  DescribeByPassShuntEventRequest() {}

  explicit DescribeByPassShuntEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventId) {
      res["eventId"] = boost::any(*eventId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventId") != m.end() && !m["eventId"].empty()) {
      eventId = make_shared<long>(boost::any_cast<long>(m["eventId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeByPassShuntEventRequest() = default;
};
class DescribeByPassShuntEventResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};

  DescribeByPassShuntEventResponseBodyResultObject() {}

  explicit DescribeByPassShuntEventResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
  }


  virtual ~DescribeByPassShuntEventResponseBodyResultObject() = default;
};
class DescribeByPassShuntEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeByPassShuntEventResponseBodyResultObject> resultObject{};
  shared_ptr<bool> success{};

  DescribeByPassShuntEventResponseBody() {}

  explicit DescribeByPassShuntEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeByPassShuntEventResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeByPassShuntEventResponseBodyResultObject>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeByPassShuntEventResponseBody() = default;
};
class DescribeByPassShuntEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeByPassShuntEventResponseBody> body{};

  DescribeByPassShuntEventResponse() {}

  explicit DescribeByPassShuntEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeByPassShuntEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeByPassShuntEventResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeByPassShuntEventResponse() = default;
};
class DescribeCustVariableConfigListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> bizType{};
  shared_ptr<string> regId{};
  shared_ptr<string> timeType{};

  DescribeCustVariableConfigListRequest() {}

  explicit DescribeCustVariableConfigListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (bizType) {
      res["bizType"] = boost::any(*bizType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (timeType) {
      res["timeType"] = boost::any(*timeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("bizType") != m.end() && !m["bizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["bizType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("timeType") != m.end() && !m["timeType"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["timeType"]));
    }
  }


  virtual ~DescribeCustVariableConfigListRequest() = default;
};
class DescribeCustVariableConfigListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};

  DescribeCustVariableConfigListResponseBodyResultObject() {}

  explicit DescribeCustVariableConfigListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configKey) {
      res["configKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["configValue"] = boost::any(*configValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("configKey") != m.end() && !m["configKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["configKey"]));
    }
    if (m.find("configValue") != m.end() && !m["configValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["configValue"]));
    }
  }


  virtual ~DescribeCustVariableConfigListResponseBodyResultObject() = default;
};
class DescribeCustVariableConfigListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeCustVariableConfigListResponseBodyResultObject>> resultObject{};

  DescribeCustVariableConfigListResponseBody() {}

  explicit DescribeCustVariableConfigListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeCustVariableConfigListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustVariableConfigListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeCustVariableConfigListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeCustVariableConfigListResponseBody() = default;
};
class DescribeCustVariableConfigListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustVariableConfigListResponseBody> body{};

  DescribeCustVariableConfigListResponse() {}

  explicit DescribeCustVariableConfigListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustVariableConfigListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustVariableConfigListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustVariableConfigListResponse() = default;
};
class DescribeCustVariableDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  DescribeCustVariableDetailRequest() {}

  explicit DescribeCustVariableDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeCustVariableDetailRequest() = default;
};
class DescribeCustVariableDetailResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<long> dataVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> historyValueType{};
  shared_ptr<long> id{};
  shared_ptr<string> object{};
  shared_ptr<string> outputs{};
  shared_ptr<string> subject{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};
  shared_ptr<string> twCount{};
  shared_ptr<string> velocityFC{};
  shared_ptr<string> velocityTW{};

  DescribeCustVariableDetailResponseBodyResultObject() {}

  explicit DescribeCustVariableDetailResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (dataVersion) {
      res["dataVersion"] = boost::any(*dataVersion);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (historyValueType) {
      res["historyValueType"] = boost::any(*historyValueType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (object) {
      res["object"] = boost::any(*object);
    }
    if (outputs) {
      res["outputs"] = boost::any(*outputs);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (timeType) {
      res["timeType"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (twCount) {
      res["twCount"] = boost::any(*twCount);
    }
    if (velocityFC) {
      res["velocityFC"] = boost::any(*velocityFC);
    }
    if (velocityTW) {
      res["velocityTW"] = boost::any(*velocityTW);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("dataVersion") != m.end() && !m["dataVersion"].empty()) {
      dataVersion = make_shared<long>(boost::any_cast<long>(m["dataVersion"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("historyValueType") != m.end() && !m["historyValueType"].empty()) {
      historyValueType = make_shared<string>(boost::any_cast<string>(m["historyValueType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("object") != m.end() && !m["object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["object"]));
    }
    if (m.find("outputs") != m.end() && !m["outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["outputs"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("timeType") != m.end() && !m["timeType"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["timeType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("twCount") != m.end() && !m["twCount"].empty()) {
      twCount = make_shared<string>(boost::any_cast<string>(m["twCount"]));
    }
    if (m.find("velocityFC") != m.end() && !m["velocityFC"].empty()) {
      velocityFC = make_shared<string>(boost::any_cast<string>(m["velocityFC"]));
    }
    if (m.find("velocityTW") != m.end() && !m["velocityTW"].empty()) {
      velocityTW = make_shared<string>(boost::any_cast<string>(m["velocityTW"]));
    }
  }


  virtual ~DescribeCustVariableDetailResponseBodyResultObject() = default;
};
class DescribeCustVariableDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeCustVariableDetailResponseBodyResultObject>> resultObject{};

  DescribeCustVariableDetailResponseBody() {}

  explicit DescribeCustVariableDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeCustVariableDetailResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustVariableDetailResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeCustVariableDetailResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeCustVariableDetailResponseBody() = default;
};
class DescribeCustVariableDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustVariableDetailResponseBody> body{};

  DescribeCustVariableDetailResponse() {}

  explicit DescribeCustVariableDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustVariableDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustVariableDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustVariableDetailResponse() = default;
};
class DescribeCustVariablePageRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> description{};
  shared_ptr<string> eventCode{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};

  DescribeCustVariablePageRequest() {}

  explicit DescribeCustVariablePageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeCustVariablePageRequest() = default;
};
class DescribeCustVariablePageResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> dataVersion{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};

  DescribeCustVariablePageResponseBodyResultObject() {}

  explicit DescribeCustVariablePageResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataVersion) {
      res["dataVersion"] = boost::any(*dataVersion);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataVersion") != m.end() && !m["dataVersion"].empty()) {
      dataVersion = make_shared<long>(boost::any_cast<long>(m["dataVersion"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~DescribeCustVariablePageResponseBodyResultObject() = default;
};
class DescribeCustVariablePageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeCustVariablePageResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeCustVariablePageResponseBody() {}

  explicit DescribeCustVariablePageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeCustVariablePageResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustVariablePageResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeCustVariablePageResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeCustVariablePageResponseBody() = default;
};
class DescribeCustVariablePageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustVariablePageResponseBody> body{};

  DescribeCustVariablePageResponse() {}

  explicit DescribeCustVariablePageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustVariablePageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustVariablePageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustVariablePageResponse() = default;
};
class DescribeDataSourceDataDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> regId{};

  DescribeDataSourceDataDownloadUrlRequest() {}

  explicit DescribeDataSourceDataDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (dataSourceId) {
      res["dataSourceId"] = boost::any(*dataSourceId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("dataSourceId") != m.end() && !m["dataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["dataSourceId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeDataSourceDataDownloadUrlRequest() = default;
};
class DescribeDataSourceDataDownloadUrlResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> downloadFileUrl{};

  DescribeDataSourceDataDownloadUrlResponseBodyResultObject() {}

  explicit DescribeDataSourceDataDownloadUrlResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadFileUrl) {
      res["downloadFileUrl"] = boost::any(*downloadFileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("downloadFileUrl") != m.end() && !m["downloadFileUrl"].empty()) {
      downloadFileUrl = make_shared<string>(boost::any_cast<string>(m["downloadFileUrl"]));
    }
  }


  virtual ~DescribeDataSourceDataDownloadUrlResponseBodyResultObject() = default;
};
class DescribeDataSourceDataDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDataSourceDataDownloadUrlResponseBodyResultObject> resultObject{};

  DescribeDataSourceDataDownloadUrlResponseBody() {}

  explicit DescribeDataSourceDataDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeDataSourceDataDownloadUrlResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeDataSourceDataDownloadUrlResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeDataSourceDataDownloadUrlResponseBody() = default;
};
class DescribeDataSourceDataDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDataSourceDataDownloadUrlResponseBody> body{};

  DescribeDataSourceDataDownloadUrlResponse() {}

  explicit DescribeDataSourceDataDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDataSourceDataDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDataSourceDataDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDataSourceDataDownloadUrlResponse() = default;
};
class DescribeDataSourceFieldsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> dataSourceCode{};
  shared_ptr<string> regId{};

  DescribeDataSourceFieldsRequest() {}

  explicit DescribeDataSourceFieldsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (dataSourceCode) {
      res["dataSourceCode"] = boost::any(*dataSourceCode);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("dataSourceCode") != m.end() && !m["dataSourceCode"].empty()) {
      dataSourceCode = make_shared<string>(boost::any_cast<string>(m["dataSourceCode"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeDataSourceFieldsRequest() = default;
};
class DescribeDataSourceFieldsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeDataSourceFieldsResponseBody() {}

  explicit DescribeDataSourceFieldsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeDataSourceFieldsResponseBody() = default;
};
class DescribeDataSourceFieldsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDataSourceFieldsResponseBody> body{};

  DescribeDataSourceFieldsResponse() {}

  explicit DescribeDataSourceFieldsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDataSourceFieldsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDataSourceFieldsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDataSourceFieldsResponse() = default;
};
class DescribeDataSourcePageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> type{};

  DescribeDataSourcePageListRequest() {}

  explicit DescribeDataSourcePageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeDataSourcePageListRequest() = default;
};
class DescribeDataSourcePageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};

  DescribeDataSourcePageListResponseBodyResultObject() {}

  explicit DescribeDataSourcePageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeDataSourcePageListResponseBodyResultObject() = default;
};
class DescribeDataSourcePageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeDataSourcePageListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeDataSourcePageListResponseBody() {}

  explicit DescribeDataSourcePageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeDataSourcePageListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataSourcePageListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeDataSourcePageListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeDataSourcePageListResponseBody() = default;
};
class DescribeDataSourcePageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDataSourcePageListResponseBody> body{};

  DescribeDataSourcePageListResponse() {}

  explicit DescribeDataSourcePageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDataSourcePageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDataSourcePageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDataSourcePageListResponse() = default;
};
class DescribeDecisionResultFluctuationRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> regId{};

  DescribeDecisionResultFluctuationRequest() {}

  explicit DescribeDecisionResultFluctuationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeDecisionResultFluctuationRequest() = default;
};
class DescribeDecisionResultFluctuationResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> todayNum{};
  shared_ptr<string> withinSevenDayNum{};
  shared_ptr<string> withinThirtyDayNum{};
  shared_ptr<string> withinThreeDayNum{};
  shared_ptr<long> yesterdayNum{};

  DescribeDecisionResultFluctuationResponseBodyResultObject() {}

  explicit DescribeDecisionResultFluctuationResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (todayNum) {
      res["todayNum"] = boost::any(*todayNum);
    }
    if (withinSevenDayNum) {
      res["withinSevenDayNum"] = boost::any(*withinSevenDayNum);
    }
    if (withinThirtyDayNum) {
      res["withinThirtyDayNum"] = boost::any(*withinThirtyDayNum);
    }
    if (withinThreeDayNum) {
      res["withinThreeDayNum"] = boost::any(*withinThreeDayNum);
    }
    if (yesterdayNum) {
      res["yesterdayNum"] = boost::any(*yesterdayNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("todayNum") != m.end() && !m["todayNum"].empty()) {
      todayNum = make_shared<long>(boost::any_cast<long>(m["todayNum"]));
    }
    if (m.find("withinSevenDayNum") != m.end() && !m["withinSevenDayNum"].empty()) {
      withinSevenDayNum = make_shared<string>(boost::any_cast<string>(m["withinSevenDayNum"]));
    }
    if (m.find("withinThirtyDayNum") != m.end() && !m["withinThirtyDayNum"].empty()) {
      withinThirtyDayNum = make_shared<string>(boost::any_cast<string>(m["withinThirtyDayNum"]));
    }
    if (m.find("withinThreeDayNum") != m.end() && !m["withinThreeDayNum"].empty()) {
      withinThreeDayNum = make_shared<string>(boost::any_cast<string>(m["withinThreeDayNum"]));
    }
    if (m.find("yesterdayNum") != m.end() && !m["yesterdayNum"].empty()) {
      yesterdayNum = make_shared<long>(boost::any_cast<long>(m["yesterdayNum"]));
    }
  }


  virtual ~DescribeDecisionResultFluctuationResponseBodyResultObject() = default;
};
class DescribeDecisionResultFluctuationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDecisionResultFluctuationResponseBodyResultObject>> resultObject{};
  shared_ptr<bool> success{};

  DescribeDecisionResultFluctuationResponseBody() {}

  explicit DescribeDecisionResultFluctuationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeDecisionResultFluctuationResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDecisionResultFluctuationResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeDecisionResultFluctuationResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeDecisionResultFluctuationResponseBody() = default;
};
class DescribeDecisionResultFluctuationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDecisionResultFluctuationResponseBody> body{};

  DescribeDecisionResultFluctuationResponse() {}

  explicit DescribeDecisionResultFluctuationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDecisionResultFluctuationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDecisionResultFluctuationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDecisionResultFluctuationResponse() = default;
};
class DescribeDecisionResultTrendRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> regId{};

  DescribeDecisionResultTrendRequest() {}

  explicit DescribeDecisionResultTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeDecisionResultTrendRequest() = default;
};
class DescribeDecisionResultTrendResponseBodyResultObjectSeriesData : public Darabonba::Model {
public:
  shared_ptr<long> num{};
  shared_ptr<string> scale{};

  DescribeDecisionResultTrendResponseBodyResultObjectSeriesData() {}

  explicit DescribeDecisionResultTrendResponseBodyResultObjectSeriesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (num) {
      res["num"] = boost::any(*num);
    }
    if (scale) {
      res["scale"] = boost::any(*scale);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("num") != m.end() && !m["num"].empty()) {
      num = make_shared<long>(boost::any_cast<long>(m["num"]));
    }
    if (m.find("scale") != m.end() && !m["scale"].empty()) {
      scale = make_shared<string>(boost::any_cast<string>(m["scale"]));
    }
  }


  virtual ~DescribeDecisionResultTrendResponseBodyResultObjectSeriesData() = default;
};
class DescribeDecisionResultTrendResponseBodyResultObjectSeries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDecisionResultTrendResponseBodyResultObjectSeriesData>> data{};
  shared_ptr<string> name{};

  DescribeDecisionResultTrendResponseBodyResultObjectSeries() {}

  explicit DescribeDecisionResultTrendResponseBodyResultObjectSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<DescribeDecisionResultTrendResponseBodyResultObjectSeriesData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDecisionResultTrendResponseBodyResultObjectSeriesData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeDecisionResultTrendResponseBodyResultObjectSeriesData>>(expect1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeDecisionResultTrendResponseBodyResultObjectSeries() = default;
};
class DescribeDecisionResultTrendResponseBodyResultObjectXaxis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};

  DescribeDecisionResultTrendResponseBodyResultObjectXaxis() {}

  explicit DescribeDecisionResultTrendResponseBodyResultObjectXaxis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDecisionResultTrendResponseBodyResultObjectXaxis() = default;
};
class DescribeDecisionResultTrendResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDecisionResultTrendResponseBodyResultObjectSeries>> series{};
  shared_ptr<DescribeDecisionResultTrendResponseBodyResultObjectXaxis> xaxis{};

  DescribeDecisionResultTrendResponseBodyResultObject() {}

  explicit DescribeDecisionResultTrendResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    if (xaxis) {
      res["xaxis"] = xaxis ? boost::any(xaxis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeDecisionResultTrendResponseBodyResultObjectSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDecisionResultTrendResponseBodyResultObjectSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeDecisionResultTrendResponseBodyResultObjectSeries>>(expect1);
      }
    }
    if (m.find("xaxis") != m.end() && !m["xaxis"].empty()) {
      if (typeid(map<string, boost::any>) == m["xaxis"].type()) {
        DescribeDecisionResultTrendResponseBodyResultObjectXaxis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["xaxis"]));
        xaxis = make_shared<DescribeDecisionResultTrendResponseBodyResultObjectXaxis>(model1);
      }
    }
  }


  virtual ~DescribeDecisionResultTrendResponseBodyResultObject() = default;
};
class DescribeDecisionResultTrendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDecisionResultTrendResponseBodyResultObject> resultObject{};
  shared_ptr<bool> success{};

  DescribeDecisionResultTrendResponseBody() {}

  explicit DescribeDecisionResultTrendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeDecisionResultTrendResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeDecisionResultTrendResponseBodyResultObject>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeDecisionResultTrendResponseBody() = default;
};
class DescribeDecisionResultTrendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDecisionResultTrendResponseBody> body{};

  DescribeDecisionResultTrendResponse() {}

  explicit DescribeDecisionResultTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDecisionResultTrendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDecisionResultTrendResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDecisionResultTrendResponse() = default;
};
class DescribeDetailStartRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> endDs{};
  shared_ptr<string> regId{};
  shared_ptr<string> service{};
  shared_ptr<string> startDs{};

  DescribeDetailStartRequest() {}

  explicit DescribeDetailStartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["appKey"] = boost::any(*appKey);
    }
    if (endDs) {
      res["endDs"] = boost::any(*endDs);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (service) {
      res["service"] = boost::any(*service);
    }
    if (startDs) {
      res["startDs"] = boost::any(*startDs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appKey") != m.end() && !m["appKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["appKey"]));
    }
    if (m.find("endDs") != m.end() && !m["endDs"].empty()) {
      endDs = make_shared<string>(boost::any_cast<string>(m["endDs"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("service") != m.end() && !m["service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["service"]));
    }
    if (m.find("startDs") != m.end() && !m["startDs"].empty()) {
      startDs = make_shared<string>(boost::any_cast<string>(m["startDs"]));
    }
  }


  virtual ~DescribeDetailStartRequest() = default;
};
class DescribeDetailStartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};
  shared_ptr<bool> success{};

  DescribeDetailStartResponseBody() {}

  explicit DescribeDetailStartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeDetailStartResponseBody() = default;
};
class DescribeDetailStartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDetailStartResponseBody> body{};

  DescribeDetailStartResponse() {}

  explicit DescribeDetailStartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDetailStartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDetailStartResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDetailStartResponse() = default;
};
class DescribeDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileType{};
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<long> taskId{};
  shared_ptr<string> type{};

  DescribeDownloadUrlRequest() {}

  explicit DescribeDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["RegId"] = boost::any(*regId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RegId") != m.end() && !m["RegId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["RegId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDownloadUrlRequest() = default;
};
class DescribeDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultObject{};

  DescribeDownloadUrlResponseBody() {}

  explicit DescribeDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<string>(boost::any_cast<string>(m["resultObject"]));
    }
  }


  virtual ~DescribeDownloadUrlResponseBody() = default;
};
class DescribeDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDownloadUrlResponseBody> body{};

  DescribeDownloadUrlResponse() {}

  explicit DescribeDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDownloadUrlResponse() = default;
};
class DescribeEventBaseInfoByEventCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> regId{};

  DescribeEventBaseInfoByEventCodeRequest() {}

  explicit DescribeEventBaseInfoByEventCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeEventBaseInfoByEventCodeRequest() = default;
};
class DescribeEventBaseInfoByEventCodeResponseBodyResultObjectInputFields : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> fieldCode{};
  shared_ptr<string> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<string> title{};

  DescribeEventBaseInfoByEventCodeResponseBodyResultObjectInputFields() {}

  explicit DescribeEventBaseInfoByEventCodeResponseBodyResultObjectInputFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (fieldCode) {
      res["fieldCode"] = boost::any(*fieldCode);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("fieldCode") != m.end() && !m["fieldCode"].empty()) {
      fieldCode = make_shared<string>(boost::any_cast<string>(m["fieldCode"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<string>(boost::any_cast<string>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~DescribeEventBaseInfoByEventCodeResponseBodyResultObjectInputFields() = default;
};
class DescribeEventBaseInfoByEventCodeResponseBodyResultObjectRuleDetails : public Darabonba::Model {
public:
  shared_ptr<string> logicExpression{};
  shared_ptr<string> memo{};
  shared_ptr<string> ruleActions{};
  shared_ptr<string> ruleAuthType{};
  shared_ptr<string> ruleExpressions{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};

  DescribeEventBaseInfoByEventCodeResponseBodyResultObjectRuleDetails() {}

  explicit DescribeEventBaseInfoByEventCodeResponseBodyResultObjectRuleDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicExpression) {
      res["logicExpression"] = boost::any(*logicExpression);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (ruleActions) {
      res["ruleActions"] = boost::any(*ruleActions);
    }
    if (ruleAuthType) {
      res["ruleAuthType"] = boost::any(*ruleAuthType);
    }
    if (ruleExpressions) {
      res["ruleExpressions"] = boost::any(*ruleExpressions);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logicExpression") != m.end() && !m["logicExpression"].empty()) {
      logicExpression = make_shared<string>(boost::any_cast<string>(m["logicExpression"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("ruleActions") != m.end() && !m["ruleActions"].empty()) {
      ruleActions = make_shared<string>(boost::any_cast<string>(m["ruleActions"]));
    }
    if (m.find("ruleAuthType") != m.end() && !m["ruleAuthType"].empty()) {
      ruleAuthType = make_shared<string>(boost::any_cast<string>(m["ruleAuthType"]));
    }
    if (m.find("ruleExpressions") != m.end() && !m["ruleExpressions"].empty()) {
      ruleExpressions = make_shared<string>(boost::any_cast<string>(m["ruleExpressions"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
  }


  virtual ~DescribeEventBaseInfoByEventCodeResponseBodyResultObjectRuleDetails() = default;
};
class DescribeEventBaseInfoByEventCodeResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> bizVersion{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventStauts{};
  shared_ptr<vector<DescribeEventBaseInfoByEventCodeResponseBodyResultObjectInputFields>> inputFields{};
  shared_ptr<string> memo{};
  shared_ptr<vector<DescribeEventBaseInfoByEventCodeResponseBodyResultObjectRuleDetails>> ruleDetails{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};

  DescribeEventBaseInfoByEventCodeResponseBodyResultObject() {}

  explicit DescribeEventBaseInfoByEventCodeResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizVersion) {
      res["bizVersion"] = boost::any(*bizVersion);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (eventStauts) {
      res["eventStauts"] = boost::any(*eventStauts);
    }
    if (inputFields) {
      vector<boost::any> temp1;
      for(auto item1:*inputFields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["inputFields"] = boost::any(temp1);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (ruleDetails) {
      vector<boost::any> temp1;
      for(auto item1:*ruleDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ruleDetails"] = boost::any(temp1);
    }
    if (templateCode) {
      res["templateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["templateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["templateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizVersion") != m.end() && !m["bizVersion"].empty()) {
      bizVersion = make_shared<long>(boost::any_cast<long>(m["bizVersion"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("eventStauts") != m.end() && !m["eventStauts"].empty()) {
      eventStauts = make_shared<string>(boost::any_cast<string>(m["eventStauts"]));
    }
    if (m.find("inputFields") != m.end() && !m["inputFields"].empty()) {
      if (typeid(vector<boost::any>) == m["inputFields"].type()) {
        vector<DescribeEventBaseInfoByEventCodeResponseBodyResultObjectInputFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["inputFields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventBaseInfoByEventCodeResponseBodyResultObjectInputFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputFields = make_shared<vector<DescribeEventBaseInfoByEventCodeResponseBodyResultObjectInputFields>>(expect1);
      }
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("ruleDetails") != m.end() && !m["ruleDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ruleDetails"].type()) {
        vector<DescribeEventBaseInfoByEventCodeResponseBodyResultObjectRuleDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ruleDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventBaseInfoByEventCodeResponseBodyResultObjectRuleDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleDetails = make_shared<vector<DescribeEventBaseInfoByEventCodeResponseBodyResultObjectRuleDetails>>(expect1);
      }
    }
    if (m.find("templateCode") != m.end() && !m["templateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["templateCode"]));
    }
    if (m.find("templateName") != m.end() && !m["templateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["templateName"]));
    }
    if (m.find("templateType") != m.end() && !m["templateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["templateType"]));
    }
  }


  virtual ~DescribeEventBaseInfoByEventCodeResponseBodyResultObject() = default;
};
class DescribeEventBaseInfoByEventCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEventBaseInfoByEventCodeResponseBodyResultObject> resultObject{};

  DescribeEventBaseInfoByEventCodeResponseBody() {}

  explicit DescribeEventBaseInfoByEventCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeEventBaseInfoByEventCodeResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeEventBaseInfoByEventCodeResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeEventBaseInfoByEventCodeResponseBody() = default;
};
class DescribeEventBaseInfoByEventCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventBaseInfoByEventCodeResponseBody> body{};

  DescribeEventBaseInfoByEventCodeResponse() {}

  explicit DescribeEventBaseInfoByEventCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventBaseInfoByEventCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventBaseInfoByEventCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventBaseInfoByEventCodeResponse() = default;
};
class DescribeEventCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> regId{};

  DescribeEventCountRequest() {}

  explicit DescribeEventCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeEventCountRequest() = default;
};
class DescribeEventCountResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<bool> limit{};
  shared_ptr<long> maxTotalItem{};
  shared_ptr<long> totalItem{};

  DescribeEventCountResponseBodyResultObject() {}

  explicit DescribeEventCountResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (limit) {
      res["limit"] = boost::any(*limit);
    }
    if (maxTotalItem) {
      res["maxTotalItem"] = boost::any(*maxTotalItem);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("limit") != m.end() && !m["limit"].empty()) {
      limit = make_shared<bool>(boost::any_cast<bool>(m["limit"]));
    }
    if (m.find("maxTotalItem") != m.end() && !m["maxTotalItem"].empty()) {
      maxTotalItem = make_shared<long>(boost::any_cast<long>(m["maxTotalItem"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
  }


  virtual ~DescribeEventCountResponseBodyResultObject() = default;
};
class DescribeEventCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEventCountResponseBodyResultObject> resultObject{};
  shared_ptr<bool> success{};

  DescribeEventCountResponseBody() {}

  explicit DescribeEventCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeEventCountResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeEventCountResponseBodyResultObject>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeEventCountResponseBody() = default;
};
class DescribeEventCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventCountResponseBody> body{};

  DescribeEventCountResponse() {}

  explicit DescribeEventCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventCountResponse() = default;
};
class DescribeEventDetailByRequestIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventCode{};
  shared_ptr<long> eventTime{};
  shared_ptr<string> regId{};
  shared_ptr<string> sRequestId{};

  DescribeEventDetailByRequestIdRequest() {}

  explicit DescribeEventDetailByRequestIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventTime) {
      res["eventTime"] = boost::any(*eventTime);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (sRequestId) {
      res["sRequestId"] = boost::any(*sRequestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventTime") != m.end() && !m["eventTime"].empty()) {
      eventTime = make_shared<long>(boost::any_cast<long>(m["eventTime"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("sRequestId") != m.end() && !m["sRequestId"].empty()) {
      sRequestId = make_shared<string>(boost::any_cast<string>(m["sRequestId"]));
    }
  }


  virtual ~DescribeEventDetailByRequestIdRequest() = default;
};
class DescribeEventDetailByRequestIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeEventDetailByRequestIdResponseBody() {}

  explicit DescribeEventDetailByRequestIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeEventDetailByRequestIdResponseBody() = default;
};
class DescribeEventDetailByRequestIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventDetailByRequestIdResponseBody> body{};

  DescribeEventDetailByRequestIdResponse() {}

  explicit DescribeEventDetailByRequestIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventDetailByRequestIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventDetailByRequestIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventDetailByRequestIdResponse() = default;
};
class DescribeEventLogDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> reqIdByLog{};

  DescribeEventLogDetailRequest() {}

  explicit DescribeEventLogDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (reqIdByLog) {
      res["reqIdByLog"] = boost::any(*reqIdByLog);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("reqIdByLog") != m.end() && !m["reqIdByLog"].empty()) {
      reqIdByLog = make_shared<string>(boost::any_cast<string>(m["reqIdByLog"]));
    }
  }


  virtual ~DescribeEventLogDetailRequest() = default;
};
class DescribeEventLogDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeEventLogDetailResponseBody() {}

  explicit DescribeEventLogDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeEventLogDetailResponseBody() = default;
};
class DescribeEventLogDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventLogDetailResponseBody> body{};

  DescribeEventLogDetailResponse() {}

  explicit DescribeEventLogDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventLogDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventLogDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventLogDetailResponse() = default;
};
class DescribeEventLogPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> accountIdPRP{};
  shared_ptr<long> beginTime{};
  shared_ptr<string> condition1AL{};
  shared_ptr<string> condition2AL{};
  shared_ptr<string> condition3AL{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> deviceTypeLRP{};
  shared_ptr<string> emailPRP{};
  shared_ptr<long> endTime{};
  shared_ptr<string> failReasonLRP{};
  shared_ptr<string> ipPRP{};
  shared_ptr<string> loginResultARP{};
  shared_ptr<string> loginTypeLRP{};
  shared_ptr<string> macPRP{};
  shared_ptr<string> mobilePRP{};
  shared_ptr<string> nickNamePRP{};
  shared_ptr<string> operateSourceLRP{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> referPRP{};
  shared_ptr<string> regId{};
  shared_ptr<string> registerIpPRP{};
  shared_ptr<string> reqIdPBS{};
  shared_ptr<long> scoreEBS{};
  shared_ptr<long> scoreSBS{};
  shared_ptr<string> serviceABS{};
  shared_ptr<string> tagsLBS{};
  shared_ptr<string> umidPDI{};
  shared_ptr<string> userAgentPRP{};
  shared_ptr<string> userNameTypeLRP{};

  DescribeEventLogPageRequest() {}

  explicit DescribeEventLogPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (accountIdPRP) {
      res["accountIdPRP"] = boost::any(*accountIdPRP);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (condition1AL) {
      res["condition1AL"] = boost::any(*condition1AL);
    }
    if (condition2AL) {
      res["condition2AL"] = boost::any(*condition2AL);
    }
    if (condition3AL) {
      res["condition3AL"] = boost::any(*condition3AL);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (deviceTypeLRP) {
      res["deviceTypeLRP"] = boost::any(*deviceTypeLRP);
    }
    if (emailPRP) {
      res["emailPRP"] = boost::any(*emailPRP);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (failReasonLRP) {
      res["failReasonLRP"] = boost::any(*failReasonLRP);
    }
    if (ipPRP) {
      res["ipPRP"] = boost::any(*ipPRP);
    }
    if (loginResultARP) {
      res["loginResultARP"] = boost::any(*loginResultARP);
    }
    if (loginTypeLRP) {
      res["loginTypeLRP"] = boost::any(*loginTypeLRP);
    }
    if (macPRP) {
      res["macPRP"] = boost::any(*macPRP);
    }
    if (mobilePRP) {
      res["mobilePRP"] = boost::any(*mobilePRP);
    }
    if (nickNamePRP) {
      res["nickNamePRP"] = boost::any(*nickNamePRP);
    }
    if (operateSourceLRP) {
      res["operateSourceLRP"] = boost::any(*operateSourceLRP);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (referPRP) {
      res["referPRP"] = boost::any(*referPRP);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (registerIpPRP) {
      res["registerIpPRP"] = boost::any(*registerIpPRP);
    }
    if (reqIdPBS) {
      res["reqIdPBS"] = boost::any(*reqIdPBS);
    }
    if (scoreEBS) {
      res["scoreEBS"] = boost::any(*scoreEBS);
    }
    if (scoreSBS) {
      res["scoreSBS"] = boost::any(*scoreSBS);
    }
    if (serviceABS) {
      res["serviceABS"] = boost::any(*serviceABS);
    }
    if (tagsLBS) {
      res["tagsLBS"] = boost::any(*tagsLBS);
    }
    if (umidPDI) {
      res["umidPDI"] = boost::any(*umidPDI);
    }
    if (userAgentPRP) {
      res["userAgentPRP"] = boost::any(*userAgentPRP);
    }
    if (userNameTypeLRP) {
      res["userNameTypeLRP"] = boost::any(*userNameTypeLRP);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("accountIdPRP") != m.end() && !m["accountIdPRP"].empty()) {
      accountIdPRP = make_shared<string>(boost::any_cast<string>(m["accountIdPRP"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("condition1AL") != m.end() && !m["condition1AL"].empty()) {
      condition1AL = make_shared<string>(boost::any_cast<string>(m["condition1AL"]));
    }
    if (m.find("condition2AL") != m.end() && !m["condition2AL"].empty()) {
      condition2AL = make_shared<string>(boost::any_cast<string>(m["condition2AL"]));
    }
    if (m.find("condition3AL") != m.end() && !m["condition3AL"].empty()) {
      condition3AL = make_shared<string>(boost::any_cast<string>(m["condition3AL"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("deviceTypeLRP") != m.end() && !m["deviceTypeLRP"].empty()) {
      deviceTypeLRP = make_shared<string>(boost::any_cast<string>(m["deviceTypeLRP"]));
    }
    if (m.find("emailPRP") != m.end() && !m["emailPRP"].empty()) {
      emailPRP = make_shared<string>(boost::any_cast<string>(m["emailPRP"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("failReasonLRP") != m.end() && !m["failReasonLRP"].empty()) {
      failReasonLRP = make_shared<string>(boost::any_cast<string>(m["failReasonLRP"]));
    }
    if (m.find("ipPRP") != m.end() && !m["ipPRP"].empty()) {
      ipPRP = make_shared<string>(boost::any_cast<string>(m["ipPRP"]));
    }
    if (m.find("loginResultARP") != m.end() && !m["loginResultARP"].empty()) {
      loginResultARP = make_shared<string>(boost::any_cast<string>(m["loginResultARP"]));
    }
    if (m.find("loginTypeLRP") != m.end() && !m["loginTypeLRP"].empty()) {
      loginTypeLRP = make_shared<string>(boost::any_cast<string>(m["loginTypeLRP"]));
    }
    if (m.find("macPRP") != m.end() && !m["macPRP"].empty()) {
      macPRP = make_shared<string>(boost::any_cast<string>(m["macPRP"]));
    }
    if (m.find("mobilePRP") != m.end() && !m["mobilePRP"].empty()) {
      mobilePRP = make_shared<string>(boost::any_cast<string>(m["mobilePRP"]));
    }
    if (m.find("nickNamePRP") != m.end() && !m["nickNamePRP"].empty()) {
      nickNamePRP = make_shared<string>(boost::any_cast<string>(m["nickNamePRP"]));
    }
    if (m.find("operateSourceLRP") != m.end() && !m["operateSourceLRP"].empty()) {
      operateSourceLRP = make_shared<string>(boost::any_cast<string>(m["operateSourceLRP"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("referPRP") != m.end() && !m["referPRP"].empty()) {
      referPRP = make_shared<string>(boost::any_cast<string>(m["referPRP"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("registerIpPRP") != m.end() && !m["registerIpPRP"].empty()) {
      registerIpPRP = make_shared<string>(boost::any_cast<string>(m["registerIpPRP"]));
    }
    if (m.find("reqIdPBS") != m.end() && !m["reqIdPBS"].empty()) {
      reqIdPBS = make_shared<string>(boost::any_cast<string>(m["reqIdPBS"]));
    }
    if (m.find("scoreEBS") != m.end() && !m["scoreEBS"].empty()) {
      scoreEBS = make_shared<long>(boost::any_cast<long>(m["scoreEBS"]));
    }
    if (m.find("scoreSBS") != m.end() && !m["scoreSBS"].empty()) {
      scoreSBS = make_shared<long>(boost::any_cast<long>(m["scoreSBS"]));
    }
    if (m.find("serviceABS") != m.end() && !m["serviceABS"].empty()) {
      serviceABS = make_shared<string>(boost::any_cast<string>(m["serviceABS"]));
    }
    if (m.find("tagsLBS") != m.end() && !m["tagsLBS"].empty()) {
      tagsLBS = make_shared<string>(boost::any_cast<string>(m["tagsLBS"]));
    }
    if (m.find("umidPDI") != m.end() && !m["umidPDI"].empty()) {
      umidPDI = make_shared<string>(boost::any_cast<string>(m["umidPDI"]));
    }
    if (m.find("userAgentPRP") != m.end() && !m["userAgentPRP"].empty()) {
      userAgentPRP = make_shared<string>(boost::any_cast<string>(m["userAgentPRP"]));
    }
    if (m.find("userNameTypeLRP") != m.end() && !m["userNameTypeLRP"].empty()) {
      userNameTypeLRP = make_shared<string>(boost::any_cast<string>(m["userNameTypeLRP"]));
    }
  }


  virtual ~DescribeEventLogPageRequest() = default;
};
class DescribeEventLogPageResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> email{};
  shared_ptr<string> ip{};
  shared_ptr<string> mobile{};
  shared_ptr<string> nickName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> score{};
  shared_ptr<string> service{};
  shared_ptr<string> tags{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> umid{};

  DescribeEventLogPageResponseBodyResultObject() {}

  explicit DescribeEventLogPageResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (mobile) {
      res["mobile"] = boost::any(*mobile);
    }
    if (nickName) {
      res["nickName"] = boost::any(*nickName);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (score) {
      res["score"] = boost::any(*score);
    }
    if (service) {
      res["service"] = boost::any(*service);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    if (umid) {
      res["umid"] = boost::any(*umid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("mobile") != m.end() && !m["mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["mobile"]));
    }
    if (m.find("nickName") != m.end() && !m["nickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["nickName"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("score") != m.end() && !m["score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["score"]));
    }
    if (m.find("service") != m.end() && !m["service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["service"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["tags"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["timestamp"]));
    }
    if (m.find("umid") != m.end() && !m["umid"].empty()) {
      umid = make_shared<string>(boost::any_cast<string>(m["umid"]));
    }
  }


  virtual ~DescribeEventLogPageResponseBodyResultObject() = default;
};
class DescribeEventLogPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeEventLogPageResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeEventLogPageResponseBody() {}

  explicit DescribeEventLogPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeEventLogPageResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventLogPageResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeEventLogPageResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeEventLogPageResponseBody() = default;
};
class DescribeEventLogPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventLogPageResponseBody> body{};

  DescribeEventLogPageResponse() {}

  explicit DescribeEventLogPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventLogPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventLogPageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventLogPageResponse() = default;
};
class DescribeEventPageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventStatus{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};

  DescribeEventPageListRequest() {}

  explicit DescribeEventPageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (eventStatus) {
      res["eventStatus"] = boost::any(*eventStatus);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("eventStatus") != m.end() && !m["eventStatus"].empty()) {
      eventStatus = make_shared<string>(boost::any_cast<string>(m["eventStatus"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeEventPageListRequest() = default;
};
class DescribeEventPageListResponseBodyResultObjectChildren : public Darabonba::Model {
public:
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventStatus{};
  shared_ptr<string> eventType{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> ruleCount{};

  DescribeEventPageListResponseBodyResultObjectChildren() {}

  explicit DescribeEventPageListResponseBodyResultObjectChildren(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (eventStatus) {
      res["eventStatus"] = boost::any(*eventStatus);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (ruleCount) {
      res["ruleCount"] = boost::any(*ruleCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("eventStatus") != m.end() && !m["eventStatus"].empty()) {
      eventStatus = make_shared<string>(boost::any_cast<string>(m["eventStatus"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("ruleCount") != m.end() && !m["ruleCount"].empty()) {
      ruleCount = make_shared<long>(boost::any_cast<long>(m["ruleCount"]));
    }
  }


  virtual ~DescribeEventPageListResponseBodyResultObjectChildren() = default;
};
class DescribeEventPageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventPageListResponseBodyResultObjectChildren>> children{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventStatus{};
  shared_ptr<string> eventType{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> ruleCount{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};
  shared_ptr<long> userCount{};

  DescribeEventPageListResponseBodyResultObject() {}

  explicit DescribeEventPageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (children) {
      vector<boost::any> temp1;
      for(auto item1:*children){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["children"] = boost::any(temp1);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (eventStatus) {
      res["eventStatus"] = boost::any(*eventStatus);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (ruleCount) {
      res["ruleCount"] = boost::any(*ruleCount);
    }
    if (templateCode) {
      res["templateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["templateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["templateType"] = boost::any(*templateType);
    }
    if (userCount) {
      res["userCount"] = boost::any(*userCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("children") != m.end() && !m["children"].empty()) {
      if (typeid(vector<boost::any>) == m["children"].type()) {
        vector<DescribeEventPageListResponseBodyResultObjectChildren> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["children"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventPageListResponseBodyResultObjectChildren model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        children = make_shared<vector<DescribeEventPageListResponseBodyResultObjectChildren>>(expect1);
      }
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("eventStatus") != m.end() && !m["eventStatus"].empty()) {
      eventStatus = make_shared<string>(boost::any_cast<string>(m["eventStatus"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("ruleCount") != m.end() && !m["ruleCount"].empty()) {
      ruleCount = make_shared<long>(boost::any_cast<long>(m["ruleCount"]));
    }
    if (m.find("templateCode") != m.end() && !m["templateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["templateCode"]));
    }
    if (m.find("templateName") != m.end() && !m["templateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["templateName"]));
    }
    if (m.find("templateType") != m.end() && !m["templateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["templateType"]));
    }
    if (m.find("userCount") != m.end() && !m["userCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["userCount"]));
    }
  }


  virtual ~DescribeEventPageListResponseBodyResultObject() = default;
};
class DescribeEventPageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeEventPageListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeEventPageListResponseBody() {}

  explicit DescribeEventPageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeEventPageListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventPageListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeEventPageListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeEventPageListResponseBody() = default;
};
class DescribeEventPageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventPageListResponseBody> body{};

  DescribeEventPageListResponse() {}

  explicit DescribeEventPageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventPageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventPageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventPageListResponse() = default;
};
class DescribeEventResultBarChartRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> regId{};

  DescribeEventResultBarChartRequest() {}

  explicit DescribeEventResultBarChartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeEventResultBarChartRequest() = default;
};
class DescribeEventResultBarChartResponseBodyResultObjectSeriesData : public Darabonba::Model {
public:
  shared_ptr<long> num{};
  shared_ptr<string> scale{};

  DescribeEventResultBarChartResponseBodyResultObjectSeriesData() {}

  explicit DescribeEventResultBarChartResponseBodyResultObjectSeriesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (num) {
      res["num"] = boost::any(*num);
    }
    if (scale) {
      res["scale"] = boost::any(*scale);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("num") != m.end() && !m["num"].empty()) {
      num = make_shared<long>(boost::any_cast<long>(m["num"]));
    }
    if (m.find("scale") != m.end() && !m["scale"].empty()) {
      scale = make_shared<string>(boost::any_cast<string>(m["scale"]));
    }
  }


  virtual ~DescribeEventResultBarChartResponseBodyResultObjectSeriesData() = default;
};
class DescribeEventResultBarChartResponseBodyResultObjectSeries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventResultBarChartResponseBodyResultObjectSeriesData>> data{};
  shared_ptr<string> name{};
  shared_ptr<string> stack{};

  DescribeEventResultBarChartResponseBodyResultObjectSeries() {}

  explicit DescribeEventResultBarChartResponseBodyResultObjectSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (stack) {
      res["stack"] = boost::any(*stack);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<DescribeEventResultBarChartResponseBodyResultObjectSeriesData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventResultBarChartResponseBodyResultObjectSeriesData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeEventResultBarChartResponseBodyResultObjectSeriesData>>(expect1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("stack") != m.end() && !m["stack"].empty()) {
      stack = make_shared<string>(boost::any_cast<string>(m["stack"]));
    }
  }


  virtual ~DescribeEventResultBarChartResponseBodyResultObjectSeries() = default;
};
class DescribeEventResultBarChartResponseBodyResultObjectXaxis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};

  DescribeEventResultBarChartResponseBodyResultObjectXaxis() {}

  explicit DescribeEventResultBarChartResponseBodyResultObjectXaxis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEventResultBarChartResponseBodyResultObjectXaxis() = default;
};
class DescribeEventResultBarChartResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventResultBarChartResponseBodyResultObjectSeries>> series{};
  shared_ptr<DescribeEventResultBarChartResponseBodyResultObjectXaxis> xaxis{};

  DescribeEventResultBarChartResponseBodyResultObject() {}

  explicit DescribeEventResultBarChartResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    if (xaxis) {
      res["xaxis"] = xaxis ? boost::any(xaxis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeEventResultBarChartResponseBodyResultObjectSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventResultBarChartResponseBodyResultObjectSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeEventResultBarChartResponseBodyResultObjectSeries>>(expect1);
      }
    }
    if (m.find("xaxis") != m.end() && !m["xaxis"].empty()) {
      if (typeid(map<string, boost::any>) == m["xaxis"].type()) {
        DescribeEventResultBarChartResponseBodyResultObjectXaxis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["xaxis"]));
        xaxis = make_shared<DescribeEventResultBarChartResponseBodyResultObjectXaxis>(model1);
      }
    }
  }


  virtual ~DescribeEventResultBarChartResponseBodyResultObject() = default;
};
class DescribeEventResultBarChartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEventResultBarChartResponseBodyResultObject> resultObject{};
  shared_ptr<bool> success{};

  DescribeEventResultBarChartResponseBody() {}

  explicit DescribeEventResultBarChartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeEventResultBarChartResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeEventResultBarChartResponseBodyResultObject>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeEventResultBarChartResponseBody() = default;
};
class DescribeEventResultBarChartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventResultBarChartResponseBody> body{};

  DescribeEventResultBarChartResponse() {}

  explicit DescribeEventResultBarChartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventResultBarChartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventResultBarChartResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventResultBarChartResponse() = default;
};
class DescribeEventResultListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};

  DescribeEventResultListRequest() {}

  explicit DescribeEventResultListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeEventResultListRequest() = default;
};
class DescribeEventResultListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<long> passNum{};
  shared_ptr<long> pendingNum{};
  shared_ptr<long> rejectNum{};
  shared_ptr<long> totalNum{};

  DescribeEventResultListResponseBodyResultObject() {}

  explicit DescribeEventResultListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (passNum) {
      res["passNum"] = boost::any(*passNum);
    }
    if (pendingNum) {
      res["pendingNum"] = boost::any(*pendingNum);
    }
    if (rejectNum) {
      res["rejectNum"] = boost::any(*rejectNum);
    }
    if (totalNum) {
      res["totalNum"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("passNum") != m.end() && !m["passNum"].empty()) {
      passNum = make_shared<long>(boost::any_cast<long>(m["passNum"]));
    }
    if (m.find("pendingNum") != m.end() && !m["pendingNum"].empty()) {
      pendingNum = make_shared<long>(boost::any_cast<long>(m["pendingNum"]));
    }
    if (m.find("rejectNum") != m.end() && !m["rejectNum"].empty()) {
      rejectNum = make_shared<long>(boost::any_cast<long>(m["rejectNum"]));
    }
    if (m.find("totalNum") != m.end() && !m["totalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["totalNum"]));
    }
  }


  virtual ~DescribeEventResultListResponseBodyResultObject() = default;
};
class DescribeEventResultListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEventResultListResponseBodyResultObject>> resultObject{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeEventResultListResponseBody() {}

  explicit DescribeEventResultListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeEventResultListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventResultListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeEventResultListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeEventResultListResponseBody() = default;
};
class DescribeEventResultListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventResultListResponseBody> body{};

  DescribeEventResultListResponse() {}

  explicit DescribeEventResultListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventResultListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventResultListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventResultListResponse() = default;
};
class DescribeEventTaskHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeEventTaskHistoryRequest() {}

  explicit DescribeEventTaskHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeEventTaskHistoryRequest() = default;
};
class DescribeEventTaskHistoryResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> taskCode{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> url{};

  DescribeEventTaskHistoryResponseBodyResultObject() {}

  explicit DescribeEventTaskHistoryResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskCode) {
      res["taskCode"] = boost::any(*taskCode);
    }
    if (taskName) {
      res["taskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["taskStatus"] = boost::any(*taskStatus);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("taskCode") != m.end() && !m["taskCode"].empty()) {
      taskCode = make_shared<string>(boost::any_cast<string>(m["taskCode"]));
    }
    if (m.find("taskName") != m.end() && !m["taskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["taskName"]));
    }
    if (m.find("taskStatus") != m.end() && !m["taskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["taskStatus"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~DescribeEventTaskHistoryResponseBodyResultObject() = default;
};
class DescribeEventTaskHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEventTaskHistoryResponseBodyResultObject>> resultObject{};

  DescribeEventTaskHistoryResponseBody() {}

  explicit DescribeEventTaskHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeEventTaskHistoryResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventTaskHistoryResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeEventTaskHistoryResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeEventTaskHistoryResponseBody() = default;
};
class DescribeEventTaskHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventTaskHistoryResponseBody> body{};

  DescribeEventTaskHistoryResponse() {}

  explicit DescribeEventTaskHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventTaskHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventTaskHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventTaskHistoryResponse() = default;
};
class DescribeEventTotalCountReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeEventTotalCountReportRequest() {}

  explicit DescribeEventTotalCountReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeEventTotalCountReportRequest() = default;
};
class DescribeEventTotalCountReportResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> ratio{};
  shared_ptr<string> value{};

  DescribeEventTotalCountReportResponseBodyResultObject() {}

  explicit DescribeEventTotalCountReportResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ratio) {
      res["ratio"] = boost::any(*ratio);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ratio") != m.end() && !m["ratio"].empty()) {
      ratio = make_shared<string>(boost::any_cast<string>(m["ratio"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeEventTotalCountReportResponseBodyResultObject() = default;
};
class DescribeEventTotalCountReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEventTotalCountReportResponseBodyResultObject> resultObject{};
  shared_ptr<bool> success{};

  DescribeEventTotalCountReportResponseBody() {}

  explicit DescribeEventTotalCountReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeEventTotalCountReportResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeEventTotalCountReportResponseBodyResultObject>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeEventTotalCountReportResponseBody() = default;
};
class DescribeEventTotalCountReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventTotalCountReportResponseBody> body{};

  DescribeEventTotalCountReportResponse() {}

  explicit DescribeEventTotalCountReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventTotalCountReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventTotalCountReportResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventTotalCountReportResponse() = default;
};
class DescribeEventUploadPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeEventUploadPolicyRequest() {}

  explicit DescribeEventUploadPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeEventUploadPolicyRequest() = default;
};
class DescribeEventUploadPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<string> host{};
  shared_ptr<string> key{};
  shared_ptr<string> policy{};
  shared_ptr<string> requestId{};
  shared_ptr<string> signature{};
  shared_ptr<string> stsToken{};

  DescribeEventUploadPolicyResponseBody() {}

  explicit DescribeEventUploadPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (stsToken) {
      res["StsToken"] = boost::any(*stsToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("StsToken") != m.end() && !m["StsToken"].empty()) {
      stsToken = make_shared<string>(boost::any_cast<string>(m["StsToken"]));
    }
  }


  virtual ~DescribeEventUploadPolicyResponseBody() = default;
};
class DescribeEventUploadPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventUploadPolicyResponseBody> body{};

  DescribeEventUploadPolicyResponse() {}

  explicit DescribeEventUploadPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventUploadPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventUploadPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventUploadPolicyResponse() = default;
};
class DescribeEventVariableListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> filterDTO{};
  shared_ptr<string> refObjId{};
  shared_ptr<string> refObjType{};
  shared_ptr<string> regId{};
  shared_ptr<string> type{};

  DescribeEventVariableListRequest() {}

  explicit DescribeEventVariableListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (filterDTO) {
      res["filterDTO"] = boost::any(*filterDTO);
    }
    if (refObjId) {
      res["refObjId"] = boost::any(*refObjId);
    }
    if (refObjType) {
      res["refObjType"] = boost::any(*refObjType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("filterDTO") != m.end() && !m["filterDTO"].empty()) {
      filterDTO = make_shared<string>(boost::any_cast<string>(m["filterDTO"]));
    }
    if (m.find("refObjId") != m.end() && !m["refObjId"].empty()) {
      refObjId = make_shared<string>(boost::any_cast<string>(m["refObjId"]));
    }
    if (m.find("refObjType") != m.end() && !m["refObjType"].empty()) {
      refObjType = make_shared<string>(boost::any_cast<string>(m["refObjType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeEventVariableListRequest() = default;
};
class DescribeEventVariableListResponseBodyResultObjectActionsOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeEventVariableListResponseBodyResultObjectActionsOutputThreshold() {}

  explicit DescribeEventVariableListResponseBodyResultObjectActionsOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectActionsOutputThreshold() = default;
};
class DescribeEventVariableListResponseBodyResultObjectActionsVariableVelocity : public Darabonba::Model {
public:
  shared_ptr<string> iv{};

  DescribeEventVariableListResponseBodyResultObjectActionsVariableVelocity() {}

  explicit DescribeEventVariableListResponseBodyResultObjectActionsVariableVelocity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iv) {
      res["iv"] = boost::any(*iv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("iv") != m.end() && !m["iv"].empty()) {
      iv = make_shared<string>(boost::any_cast<string>(m["iv"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectActionsVariableVelocity() = default;
};
class DescribeEventVariableListResponseBodyResultObjectActions : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<string> fieldDetail{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<string> outlier{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectActionsOutputThreshold> outputThreshold{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectActionsVariableVelocity> variableVelocity{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeEventVariableListResponseBodyResultObjectActions() {}

  explicit DescribeEventVariableListResponseBodyResultObjectActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldDetail) {
      res["fieldDetail"] = boost::any(*fieldDetail);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (variableVelocity) {
      res["variableVelocity"] = variableVelocity ? boost::any(variableVelocity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldDetail") != m.end() && !m["fieldDetail"].empty()) {
      fieldDetail = make_shared<string>(boost::any_cast<string>(m["fieldDetail"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeEventVariableListResponseBodyResultObjectActionsOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeEventVariableListResponseBodyResultObjectActionsOutputThreshold>(model1);
      }
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("variableVelocity") != m.end() && !m["variableVelocity"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableVelocity"].type()) {
        DescribeEventVariableListResponseBodyResultObjectActionsVariableVelocity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableVelocity"]));
        variableVelocity = make_shared<DescribeEventVariableListResponseBodyResultObjectActionsVariableVelocity>(model1);
      }
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectActions() = default;
};
class DescribeEventVariableListResponseBodyResultObjectDeviceVariablesOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeEventVariableListResponseBodyResultObjectDeviceVariablesOutputThreshold() {}

  explicit DescribeEventVariableListResponseBodyResultObjectDeviceVariablesOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectDeviceVariablesOutputThreshold() = default;
};
class DescribeEventVariableListResponseBodyResultObjectDeviceVariablesVariableVelocity : public Darabonba::Model {
public:
  shared_ptr<string> iv{};

  DescribeEventVariableListResponseBodyResultObjectDeviceVariablesVariableVelocity() {}

  explicit DescribeEventVariableListResponseBodyResultObjectDeviceVariablesVariableVelocity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iv) {
      res["iv"] = boost::any(*iv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("iv") != m.end() && !m["iv"].empty()) {
      iv = make_shared<string>(boost::any_cast<string>(m["iv"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectDeviceVariablesVariableVelocity() = default;
};
class DescribeEventVariableListResponseBodyResultObjectDeviceVariables : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<string> fieldDetail{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<string> outlier{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectDeviceVariablesOutputThreshold> outputThreshold{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectDeviceVariablesVariableVelocity> variableVelocity{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeEventVariableListResponseBodyResultObjectDeviceVariables() {}

  explicit DescribeEventVariableListResponseBodyResultObjectDeviceVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldDetail) {
      res["fieldDetail"] = boost::any(*fieldDetail);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (variableVelocity) {
      res["variableVelocity"] = variableVelocity ? boost::any(variableVelocity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldDetail") != m.end() && !m["fieldDetail"].empty()) {
      fieldDetail = make_shared<string>(boost::any_cast<string>(m["fieldDetail"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeEventVariableListResponseBodyResultObjectDeviceVariablesOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeEventVariableListResponseBodyResultObjectDeviceVariablesOutputThreshold>(model1);
      }
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("variableVelocity") != m.end() && !m["variableVelocity"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableVelocity"].type()) {
        DescribeEventVariableListResponseBodyResultObjectDeviceVariablesVariableVelocity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableVelocity"]));
        variableVelocity = make_shared<DescribeEventVariableListResponseBodyResultObjectDeviceVariablesVariableVelocity>(model1);
      }
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectDeviceVariables() = default;
};
class DescribeEventVariableListResponseBodyResultObjectExpressionVariablesOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeEventVariableListResponseBodyResultObjectExpressionVariablesOutputThreshold() {}

  explicit DescribeEventVariableListResponseBodyResultObjectExpressionVariablesOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectExpressionVariablesOutputThreshold() = default;
};
class DescribeEventVariableListResponseBodyResultObjectExpressionVariablesVariableVelocity : public Darabonba::Model {
public:
  shared_ptr<string> iv{};

  DescribeEventVariableListResponseBodyResultObjectExpressionVariablesVariableVelocity() {}

  explicit DescribeEventVariableListResponseBodyResultObjectExpressionVariablesVariableVelocity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iv) {
      res["iv"] = boost::any(*iv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("iv") != m.end() && !m["iv"].empty()) {
      iv = make_shared<string>(boost::any_cast<string>(m["iv"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectExpressionVariablesVariableVelocity() = default;
};
class DescribeEventVariableListResponseBodyResultObjectExpressionVariables : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<string> fieldDetail{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<string> outlier{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectExpressionVariablesOutputThreshold> outputThreshold{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectExpressionVariablesVariableVelocity> variableVelocity{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeEventVariableListResponseBodyResultObjectExpressionVariables() {}

  explicit DescribeEventVariableListResponseBodyResultObjectExpressionVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldDetail) {
      res["fieldDetail"] = boost::any(*fieldDetail);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (variableVelocity) {
      res["variableVelocity"] = variableVelocity ? boost::any(variableVelocity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldDetail") != m.end() && !m["fieldDetail"].empty()) {
      fieldDetail = make_shared<string>(boost::any_cast<string>(m["fieldDetail"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeEventVariableListResponseBodyResultObjectExpressionVariablesOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeEventVariableListResponseBodyResultObjectExpressionVariablesOutputThreshold>(model1);
      }
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("variableVelocity") != m.end() && !m["variableVelocity"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableVelocity"].type()) {
        DescribeEventVariableListResponseBodyResultObjectExpressionVariablesVariableVelocity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableVelocity"]));
        variableVelocity = make_shared<DescribeEventVariableListResponseBodyResultObjectExpressionVariablesVariableVelocity>(model1);
      }
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectExpressionVariables() = default;
};
class DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesOutputThreshold() {}

  explicit DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesOutputThreshold() = default;
};
class DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesVariableVelocity : public Darabonba::Model {
public:
  shared_ptr<string> iv{};

  DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesVariableVelocity() {}

  explicit DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesVariableVelocity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iv) {
      res["iv"] = boost::any(*iv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("iv") != m.end() && !m["iv"].empty()) {
      iv = make_shared<string>(boost::any_cast<string>(m["iv"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesVariableVelocity() = default;
};
class DescribeEventVariableListResponseBodyResultObjectFavoriteVariables : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<string> fieldDetail{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<string> outlier{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesOutputThreshold> outputThreshold{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesVariableVelocity> variableVelocity{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeEventVariableListResponseBodyResultObjectFavoriteVariables() {}

  explicit DescribeEventVariableListResponseBodyResultObjectFavoriteVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldDetail) {
      res["fieldDetail"] = boost::any(*fieldDetail);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (variableVelocity) {
      res["variableVelocity"] = variableVelocity ? boost::any(variableVelocity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldDetail") != m.end() && !m["fieldDetail"].empty()) {
      fieldDetail = make_shared<string>(boost::any_cast<string>(m["fieldDetail"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesOutputThreshold>(model1);
      }
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("variableVelocity") != m.end() && !m["variableVelocity"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableVelocity"].type()) {
        DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesVariableVelocity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableVelocity"]));
        variableVelocity = make_shared<DescribeEventVariableListResponseBodyResultObjectFavoriteVariablesVariableVelocity>(model1);
      }
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectFavoriteVariables() = default;
};
class DescribeEventVariableListResponseBodyResultObjectMiddleVariablesOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeEventVariableListResponseBodyResultObjectMiddleVariablesOutputThreshold() {}

  explicit DescribeEventVariableListResponseBodyResultObjectMiddleVariablesOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectMiddleVariablesOutputThreshold() = default;
};
class DescribeEventVariableListResponseBodyResultObjectMiddleVariablesVariableVelocity : public Darabonba::Model {
public:
  shared_ptr<string> iv{};

  DescribeEventVariableListResponseBodyResultObjectMiddleVariablesVariableVelocity() {}

  explicit DescribeEventVariableListResponseBodyResultObjectMiddleVariablesVariableVelocity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iv) {
      res["iv"] = boost::any(*iv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("iv") != m.end() && !m["iv"].empty()) {
      iv = make_shared<string>(boost::any_cast<string>(m["iv"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectMiddleVariablesVariableVelocity() = default;
};
class DescribeEventVariableListResponseBodyResultObjectMiddleVariables : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<string> fieldDetail{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<string> outlier{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectMiddleVariablesOutputThreshold> outputThreshold{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectMiddleVariablesVariableVelocity> variableVelocity{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeEventVariableListResponseBodyResultObjectMiddleVariables() {}

  explicit DescribeEventVariableListResponseBodyResultObjectMiddleVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldDetail) {
      res["fieldDetail"] = boost::any(*fieldDetail);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (variableVelocity) {
      res["variableVelocity"] = variableVelocity ? boost::any(variableVelocity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldDetail") != m.end() && !m["fieldDetail"].empty()) {
      fieldDetail = make_shared<string>(boost::any_cast<string>(m["fieldDetail"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeEventVariableListResponseBodyResultObjectMiddleVariablesOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeEventVariableListResponseBodyResultObjectMiddleVariablesOutputThreshold>(model1);
      }
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("variableVelocity") != m.end() && !m["variableVelocity"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableVelocity"].type()) {
        DescribeEventVariableListResponseBodyResultObjectMiddleVariablesVariableVelocity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableVelocity"]));
        variableVelocity = make_shared<DescribeEventVariableListResponseBodyResultObjectMiddleVariablesVariableVelocity>(model1);
      }
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectMiddleVariables() = default;
};
class DescribeEventVariableListResponseBodyResultObjectModelVariablesOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeEventVariableListResponseBodyResultObjectModelVariablesOutputThreshold() {}

  explicit DescribeEventVariableListResponseBodyResultObjectModelVariablesOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectModelVariablesOutputThreshold() = default;
};
class DescribeEventVariableListResponseBodyResultObjectModelVariablesVariableVelocity : public Darabonba::Model {
public:
  shared_ptr<string> iv{};

  DescribeEventVariableListResponseBodyResultObjectModelVariablesVariableVelocity() {}

  explicit DescribeEventVariableListResponseBodyResultObjectModelVariablesVariableVelocity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iv) {
      res["iv"] = boost::any(*iv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("iv") != m.end() && !m["iv"].empty()) {
      iv = make_shared<string>(boost::any_cast<string>(m["iv"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectModelVariablesVariableVelocity() = default;
};
class DescribeEventVariableListResponseBodyResultObjectModelVariables : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<string> fieldDetail{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<string> outlier{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectModelVariablesOutputThreshold> outputThreshold{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectModelVariablesVariableVelocity> variableVelocity{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeEventVariableListResponseBodyResultObjectModelVariables() {}

  explicit DescribeEventVariableListResponseBodyResultObjectModelVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldDetail) {
      res["fieldDetail"] = boost::any(*fieldDetail);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (variableVelocity) {
      res["variableVelocity"] = variableVelocity ? boost::any(variableVelocity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldDetail") != m.end() && !m["fieldDetail"].empty()) {
      fieldDetail = make_shared<string>(boost::any_cast<string>(m["fieldDetail"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeEventVariableListResponseBodyResultObjectModelVariablesOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeEventVariableListResponseBodyResultObjectModelVariablesOutputThreshold>(model1);
      }
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("variableVelocity") != m.end() && !m["variableVelocity"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableVelocity"].type()) {
        DescribeEventVariableListResponseBodyResultObjectModelVariablesVariableVelocity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableVelocity"]));
        variableVelocity = make_shared<DescribeEventVariableListResponseBodyResultObjectModelVariablesVariableVelocity>(model1);
      }
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectModelVariables() = default;
};
class DescribeEventVariableListResponseBodyResultObjectNameListOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeEventVariableListResponseBodyResultObjectNameListOutputThreshold() {}

  explicit DescribeEventVariableListResponseBodyResultObjectNameListOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectNameListOutputThreshold() = default;
};
class DescribeEventVariableListResponseBodyResultObjectNameListVariableVelocity : public Darabonba::Model {
public:
  shared_ptr<string> iv{};

  DescribeEventVariableListResponseBodyResultObjectNameListVariableVelocity() {}

  explicit DescribeEventVariableListResponseBodyResultObjectNameListVariableVelocity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iv) {
      res["iv"] = boost::any(*iv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("iv") != m.end() && !m["iv"].empty()) {
      iv = make_shared<string>(boost::any_cast<string>(m["iv"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectNameListVariableVelocity() = default;
};
class DescribeEventVariableListResponseBodyResultObjectNameList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<string> fieldDetail{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<string> outlier{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectNameListOutputThreshold> outputThreshold{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectNameListVariableVelocity> variableVelocity{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeEventVariableListResponseBodyResultObjectNameList() {}

  explicit DescribeEventVariableListResponseBodyResultObjectNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldDetail) {
      res["fieldDetail"] = boost::any(*fieldDetail);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (variableVelocity) {
      res["variableVelocity"] = variableVelocity ? boost::any(variableVelocity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldDetail") != m.end() && !m["fieldDetail"].empty()) {
      fieldDetail = make_shared<string>(boost::any_cast<string>(m["fieldDetail"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeEventVariableListResponseBodyResultObjectNameListOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeEventVariableListResponseBodyResultObjectNameListOutputThreshold>(model1);
      }
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("variableVelocity") != m.end() && !m["variableVelocity"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableVelocity"].type()) {
        DescribeEventVariableListResponseBodyResultObjectNameListVariableVelocity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableVelocity"]));
        variableVelocity = make_shared<DescribeEventVariableListResponseBodyResultObjectNameListVariableVelocity>(model1);
      }
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectNameList() = default;
};
class DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsOutputThreshold() {}

  explicit DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsOutputThreshold() = default;
};
class DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsVariableVelocity : public Darabonba::Model {
public:
  shared_ptr<string> iv{};

  DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsVariableVelocity() {}

  explicit DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsVariableVelocity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iv) {
      res["iv"] = boost::any(*iv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("iv") != m.end() && !m["iv"].empty()) {
      iv = make_shared<string>(boost::any_cast<string>(m["iv"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsVariableVelocity() = default;
};
class DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctions : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<string> fieldDetail{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<string> outlier{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsOutputThreshold> outputThreshold{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsVariableVelocity> variableVelocity{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctions() {}

  explicit DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldDetail) {
      res["fieldDetail"] = boost::any(*fieldDetail);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (variableVelocity) {
      res["variableVelocity"] = variableVelocity ? boost::any(variableVelocity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldDetail") != m.end() && !m["fieldDetail"].empty()) {
      fieldDetail = make_shared<string>(boost::any_cast<string>(m["fieldDetail"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsOutputThreshold>(model1);
      }
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("variableVelocity") != m.end() && !m["variableVelocity"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableVelocity"].type()) {
        DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsVariableVelocity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableVelocity"]));
        variableVelocity = make_shared<DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctionsVariableVelocity>(model1);
      }
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctions() = default;
};
class DescribeEventVariableListResponseBodyResultObjectNativeVariablesOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeEventVariableListResponseBodyResultObjectNativeVariablesOutputThreshold() {}

  explicit DescribeEventVariableListResponseBodyResultObjectNativeVariablesOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectNativeVariablesOutputThreshold() = default;
};
class DescribeEventVariableListResponseBodyResultObjectNativeVariablesVariableVelocity : public Darabonba::Model {
public:
  shared_ptr<string> iv{};

  DescribeEventVariableListResponseBodyResultObjectNativeVariablesVariableVelocity() {}

  explicit DescribeEventVariableListResponseBodyResultObjectNativeVariablesVariableVelocity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iv) {
      res["iv"] = boost::any(*iv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("iv") != m.end() && !m["iv"].empty()) {
      iv = make_shared<string>(boost::any_cast<string>(m["iv"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectNativeVariablesVariableVelocity() = default;
};
class DescribeEventVariableListResponseBodyResultObjectNativeVariables : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<string> fieldDetail{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<string> outlier{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectNativeVariablesOutputThreshold> outputThreshold{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectNativeVariablesVariableVelocity> variableVelocity{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeEventVariableListResponseBodyResultObjectNativeVariables() {}

  explicit DescribeEventVariableListResponseBodyResultObjectNativeVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldDetail) {
      res["fieldDetail"] = boost::any(*fieldDetail);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (variableVelocity) {
      res["variableVelocity"] = variableVelocity ? boost::any(variableVelocity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldDetail") != m.end() && !m["fieldDetail"].empty()) {
      fieldDetail = make_shared<string>(boost::any_cast<string>(m["fieldDetail"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeEventVariableListResponseBodyResultObjectNativeVariablesOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeEventVariableListResponseBodyResultObjectNativeVariablesOutputThreshold>(model1);
      }
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("variableVelocity") != m.end() && !m["variableVelocity"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableVelocity"].type()) {
        DescribeEventVariableListResponseBodyResultObjectNativeVariablesVariableVelocity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableVelocity"]));
        variableVelocity = make_shared<DescribeEventVariableListResponseBodyResultObjectNativeVariablesVariableVelocity>(model1);
      }
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectNativeVariables() = default;
};
class DescribeEventVariableListResponseBodyResultObjectQueryVariablesOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeEventVariableListResponseBodyResultObjectQueryVariablesOutputThreshold() {}

  explicit DescribeEventVariableListResponseBodyResultObjectQueryVariablesOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectQueryVariablesOutputThreshold() = default;
};
class DescribeEventVariableListResponseBodyResultObjectQueryVariablesVariableVelocity : public Darabonba::Model {
public:
  shared_ptr<string> iv{};

  DescribeEventVariableListResponseBodyResultObjectQueryVariablesVariableVelocity() {}

  explicit DescribeEventVariableListResponseBodyResultObjectQueryVariablesVariableVelocity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iv) {
      res["iv"] = boost::any(*iv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("iv") != m.end() && !m["iv"].empty()) {
      iv = make_shared<string>(boost::any_cast<string>(m["iv"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectQueryVariablesVariableVelocity() = default;
};
class DescribeEventVariableListResponseBodyResultObjectQueryVariables : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<string> fieldDetail{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<string> outlier{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectQueryVariablesOutputThreshold> outputThreshold{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectQueryVariablesVariableVelocity> variableVelocity{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeEventVariableListResponseBodyResultObjectQueryVariables() {}

  explicit DescribeEventVariableListResponseBodyResultObjectQueryVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldDetail) {
      res["fieldDetail"] = boost::any(*fieldDetail);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (variableVelocity) {
      res["variableVelocity"] = variableVelocity ? boost::any(variableVelocity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldDetail") != m.end() && !m["fieldDetail"].empty()) {
      fieldDetail = make_shared<string>(boost::any_cast<string>(m["fieldDetail"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeEventVariableListResponseBodyResultObjectQueryVariablesOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeEventVariableListResponseBodyResultObjectQueryVariablesOutputThreshold>(model1);
      }
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("variableVelocity") != m.end() && !m["variableVelocity"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableVelocity"].type()) {
        DescribeEventVariableListResponseBodyResultObjectQueryVariablesVariableVelocity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableVelocity"]));
        variableVelocity = make_shared<DescribeEventVariableListResponseBodyResultObjectQueryVariablesVariableVelocity>(model1);
      }
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectQueryVariables() = default;
};
class DescribeEventVariableListResponseBodyResultObjectSelfVariablesOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeEventVariableListResponseBodyResultObjectSelfVariablesOutputThreshold() {}

  explicit DescribeEventVariableListResponseBodyResultObjectSelfVariablesOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectSelfVariablesOutputThreshold() = default;
};
class DescribeEventVariableListResponseBodyResultObjectSelfVariablesVariableVelocity : public Darabonba::Model {
public:
  shared_ptr<string> iv{};

  DescribeEventVariableListResponseBodyResultObjectSelfVariablesVariableVelocity() {}

  explicit DescribeEventVariableListResponseBodyResultObjectSelfVariablesVariableVelocity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iv) {
      res["iv"] = boost::any(*iv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("iv") != m.end() && !m["iv"].empty()) {
      iv = make_shared<string>(boost::any_cast<string>(m["iv"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectSelfVariablesVariableVelocity() = default;
};
class DescribeEventVariableListResponseBodyResultObjectSelfVariables : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<string> fieldDetail{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<string> outlier{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectSelfVariablesOutputThreshold> outputThreshold{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectSelfVariablesVariableVelocity> variableVelocity{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeEventVariableListResponseBodyResultObjectSelfVariables() {}

  explicit DescribeEventVariableListResponseBodyResultObjectSelfVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldDetail) {
      res["fieldDetail"] = boost::any(*fieldDetail);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (variableVelocity) {
      res["variableVelocity"] = variableVelocity ? boost::any(variableVelocity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldDetail") != m.end() && !m["fieldDetail"].empty()) {
      fieldDetail = make_shared<string>(boost::any_cast<string>(m["fieldDetail"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeEventVariableListResponseBodyResultObjectSelfVariablesOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeEventVariableListResponseBodyResultObjectSelfVariablesOutputThreshold>(model1);
      }
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("variableVelocity") != m.end() && !m["variableVelocity"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableVelocity"].type()) {
        DescribeEventVariableListResponseBodyResultObjectSelfVariablesVariableVelocity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableVelocity"]));
        variableVelocity = make_shared<DescribeEventVariableListResponseBodyResultObjectSelfVariablesVariableVelocity>(model1);
      }
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectSelfVariables() = default;
};
class DescribeEventVariableListResponseBodyResultObjectSysVariablesOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeEventVariableListResponseBodyResultObjectSysVariablesOutputThreshold() {}

  explicit DescribeEventVariableListResponseBodyResultObjectSysVariablesOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectSysVariablesOutputThreshold() = default;
};
class DescribeEventVariableListResponseBodyResultObjectSysVariablesVariableVelocity : public Darabonba::Model {
public:
  shared_ptr<string> iv{};

  DescribeEventVariableListResponseBodyResultObjectSysVariablesVariableVelocity() {}

  explicit DescribeEventVariableListResponseBodyResultObjectSysVariablesVariableVelocity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iv) {
      res["iv"] = boost::any(*iv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("iv") != m.end() && !m["iv"].empty()) {
      iv = make_shared<string>(boost::any_cast<string>(m["iv"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectSysVariablesVariableVelocity() = default;
};
class DescribeEventVariableListResponseBodyResultObjectSysVariables : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<string> fieldDetail{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<string> outlier{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectSysVariablesOutputThreshold> outputThreshold{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectSysVariablesVariableVelocity> variableVelocity{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeEventVariableListResponseBodyResultObjectSysVariables() {}

  explicit DescribeEventVariableListResponseBodyResultObjectSysVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldDetail) {
      res["fieldDetail"] = boost::any(*fieldDetail);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (variableVelocity) {
      res["variableVelocity"] = variableVelocity ? boost::any(variableVelocity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldDetail") != m.end() && !m["fieldDetail"].empty()) {
      fieldDetail = make_shared<string>(boost::any_cast<string>(m["fieldDetail"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeEventVariableListResponseBodyResultObjectSysVariablesOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeEventVariableListResponseBodyResultObjectSysVariablesOutputThreshold>(model1);
      }
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("variableVelocity") != m.end() && !m["variableVelocity"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableVelocity"].type()) {
        DescribeEventVariableListResponseBodyResultObjectSysVariablesVariableVelocity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableVelocity"]));
        variableVelocity = make_shared<DescribeEventVariableListResponseBodyResultObjectSysVariablesVariableVelocity>(model1);
      }
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectSysVariables() = default;
};
class DescribeEventVariableListResponseBodyResultObjectVelocityVariablesOutputThreshold : public Darabonba::Model {
public:
  shared_ptr<double> maxValue{};
  shared_ptr<double> minValue{};

  DescribeEventVariableListResponseBodyResultObjectVelocityVariablesOutputThreshold() {}

  explicit DescribeEventVariableListResponseBodyResultObjectVelocityVariablesOutputThreshold(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxValue) {
      res["maxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["minValue"] = boost::any(*minValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxValue") != m.end() && !m["maxValue"].empty()) {
      maxValue = make_shared<double>(boost::any_cast<double>(m["maxValue"]));
    }
    if (m.find("minValue") != m.end() && !m["minValue"].empty()) {
      minValue = make_shared<double>(boost::any_cast<double>(m["minValue"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectVelocityVariablesOutputThreshold() = default;
};
class DescribeEventVariableListResponseBodyResultObjectVelocityVariablesVariableVelocity : public Darabonba::Model {
public:
  shared_ptr<string> iv{};

  DescribeEventVariableListResponseBodyResultObjectVelocityVariablesVariableVelocity() {}

  explicit DescribeEventVariableListResponseBodyResultObjectVelocityVariablesVariableVelocity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iv) {
      res["iv"] = boost::any(*iv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("iv") != m.end() && !m["iv"].empty()) {
      iv = make_shared<string>(boost::any_cast<string>(m["iv"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectVelocityVariablesVariableVelocity() = default;
};
class DescribeEventVariableListResponseBodyResultObjectVelocityVariables : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayType{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<bool> favoriteFlag{};
  shared_ptr<string> fieldDetail{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> inputFieldType{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> name{};
  shared_ptr<string> outlier{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectVelocityVariablesOutputThreshold> outputThreshold{};
  shared_ptr<string> parentName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObjectVelocityVariablesVariableVelocity> variableVelocity{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeEventVariableListResponseBodyResultObjectVelocityVariables() {}

  explicit DescribeEventVariableListResponseBodyResultObjectVelocityVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayType) {
      res["displayType"] = boost::any(*displayType);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (favoriteFlag) {
      res["favoriteFlag"] = boost::any(*favoriteFlag);
    }
    if (fieldDetail) {
      res["fieldDetail"] = boost::any(*fieldDetail);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputFieldType) {
      res["inputFieldType"] = boost::any(*inputFieldType);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputThreshold) {
      res["outputThreshold"] = outputThreshold ? boost::any(outputThreshold->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentName) {
      res["parentName"] = boost::any(*parentName);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (variableVelocity) {
      res["variableVelocity"] = variableVelocity ? boost::any(variableVelocity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayType") != m.end() && !m["displayType"].empty()) {
      displayType = make_shared<string>(boost::any_cast<string>(m["displayType"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("favoriteFlag") != m.end() && !m["favoriteFlag"].empty()) {
      favoriteFlag = make_shared<bool>(boost::any_cast<bool>(m["favoriteFlag"]));
    }
    if (m.find("fieldDetail") != m.end() && !m["fieldDetail"].empty()) {
      fieldDetail = make_shared<string>(boost::any_cast<string>(m["fieldDetail"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputFieldType") != m.end() && !m["inputFieldType"].empty()) {
      inputFieldType = make_shared<string>(boost::any_cast<string>(m["inputFieldType"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputThreshold") != m.end() && !m["outputThreshold"].empty()) {
      if (typeid(map<string, boost::any>) == m["outputThreshold"].type()) {
        DescribeEventVariableListResponseBodyResultObjectVelocityVariablesOutputThreshold model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["outputThreshold"]));
        outputThreshold = make_shared<DescribeEventVariableListResponseBodyResultObjectVelocityVariablesOutputThreshold>(model1);
      }
    }
    if (m.find("parentName") != m.end() && !m["parentName"].empty()) {
      parentName = make_shared<string>(boost::any_cast<string>(m["parentName"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("variableVelocity") != m.end() && !m["variableVelocity"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableVelocity"].type()) {
        DescribeEventVariableListResponseBodyResultObjectVelocityVariablesVariableVelocity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableVelocity"]));
        variableVelocity = make_shared<DescribeEventVariableListResponseBodyResultObjectVelocityVariablesVariableVelocity>(model1);
      }
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObjectVelocityVariables() = default;
};
class DescribeEventVariableListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventVariableListResponseBodyResultObjectActions>> actions{};
  shared_ptr<vector<DescribeEventVariableListResponseBodyResultObjectDeviceVariables>> deviceVariables{};
  shared_ptr<vector<DescribeEventVariableListResponseBodyResultObjectExpressionVariables>> expressionVariables{};
  shared_ptr<vector<DescribeEventVariableListResponseBodyResultObjectFavoriteVariables>> favoriteVariables{};
  shared_ptr<vector<DescribeEventVariableListResponseBodyResultObjectMiddleVariables>> middleVariables{};
  shared_ptr<vector<DescribeEventVariableListResponseBodyResultObjectModelVariables>> modelVariables{};
  shared_ptr<vector<DescribeEventVariableListResponseBodyResultObjectNameList>> nameList{};
  shared_ptr<vector<DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctions>> nativeVariableFunctions{};
  shared_ptr<vector<DescribeEventVariableListResponseBodyResultObjectNativeVariables>> nativeVariables{};
  shared_ptr<vector<DescribeEventVariableListResponseBodyResultObjectQueryVariables>> queryVariables{};
  shared_ptr<vector<DescribeEventVariableListResponseBodyResultObjectSelfVariables>> selfVariables{};
  shared_ptr<vector<DescribeEventVariableListResponseBodyResultObjectSysVariables>> sysVariables{};
  shared_ptr<map<string, boost::any>> thirdVariables{};
  shared_ptr<vector<DescribeEventVariableListResponseBodyResultObjectVelocityVariables>> velocityVariables{};

  DescribeEventVariableListResponseBodyResultObject() {}

  explicit DescribeEventVariableListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actions) {
      vector<boost::any> temp1;
      for(auto item1:*actions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["actions"] = boost::any(temp1);
    }
    if (deviceVariables) {
      vector<boost::any> temp1;
      for(auto item1:*deviceVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["deviceVariables"] = boost::any(temp1);
    }
    if (expressionVariables) {
      vector<boost::any> temp1;
      for(auto item1:*expressionVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["expressionVariables"] = boost::any(temp1);
    }
    if (favoriteVariables) {
      vector<boost::any> temp1;
      for(auto item1:*favoriteVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["favoriteVariables"] = boost::any(temp1);
    }
    if (middleVariables) {
      vector<boost::any> temp1;
      for(auto item1:*middleVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["middleVariables"] = boost::any(temp1);
    }
    if (modelVariables) {
      vector<boost::any> temp1;
      for(auto item1:*modelVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["modelVariables"] = boost::any(temp1);
    }
    if (nameList) {
      vector<boost::any> temp1;
      for(auto item1:*nameList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["nameList"] = boost::any(temp1);
    }
    if (nativeVariableFunctions) {
      vector<boost::any> temp1;
      for(auto item1:*nativeVariableFunctions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["nativeVariableFunctions"] = boost::any(temp1);
    }
    if (nativeVariables) {
      vector<boost::any> temp1;
      for(auto item1:*nativeVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["nativeVariables"] = boost::any(temp1);
    }
    if (queryVariables) {
      vector<boost::any> temp1;
      for(auto item1:*queryVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["queryVariables"] = boost::any(temp1);
    }
    if (selfVariables) {
      vector<boost::any> temp1;
      for(auto item1:*selfVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["selfVariables"] = boost::any(temp1);
    }
    if (sysVariables) {
      vector<boost::any> temp1;
      for(auto item1:*sysVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["sysVariables"] = boost::any(temp1);
    }
    if (thirdVariables) {
      res["thirdVariables"] = boost::any(*thirdVariables);
    }
    if (velocityVariables) {
      vector<boost::any> temp1;
      for(auto item1:*velocityVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["velocityVariables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actions") != m.end() && !m["actions"].empty()) {
      if (typeid(vector<boost::any>) == m["actions"].type()) {
        vector<DescribeEventVariableListResponseBodyResultObjectActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["actions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableListResponseBodyResultObjectActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actions = make_shared<vector<DescribeEventVariableListResponseBodyResultObjectActions>>(expect1);
      }
    }
    if (m.find("deviceVariables") != m.end() && !m["deviceVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["deviceVariables"].type()) {
        vector<DescribeEventVariableListResponseBodyResultObjectDeviceVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["deviceVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableListResponseBodyResultObjectDeviceVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceVariables = make_shared<vector<DescribeEventVariableListResponseBodyResultObjectDeviceVariables>>(expect1);
      }
    }
    if (m.find("expressionVariables") != m.end() && !m["expressionVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["expressionVariables"].type()) {
        vector<DescribeEventVariableListResponseBodyResultObjectExpressionVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["expressionVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableListResponseBodyResultObjectExpressionVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expressionVariables = make_shared<vector<DescribeEventVariableListResponseBodyResultObjectExpressionVariables>>(expect1);
      }
    }
    if (m.find("favoriteVariables") != m.end() && !m["favoriteVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["favoriteVariables"].type()) {
        vector<DescribeEventVariableListResponseBodyResultObjectFavoriteVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["favoriteVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableListResponseBodyResultObjectFavoriteVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        favoriteVariables = make_shared<vector<DescribeEventVariableListResponseBodyResultObjectFavoriteVariables>>(expect1);
      }
    }
    if (m.find("middleVariables") != m.end() && !m["middleVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["middleVariables"].type()) {
        vector<DescribeEventVariableListResponseBodyResultObjectMiddleVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["middleVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableListResponseBodyResultObjectMiddleVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        middleVariables = make_shared<vector<DescribeEventVariableListResponseBodyResultObjectMiddleVariables>>(expect1);
      }
    }
    if (m.find("modelVariables") != m.end() && !m["modelVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["modelVariables"].type()) {
        vector<DescribeEventVariableListResponseBodyResultObjectModelVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["modelVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableListResponseBodyResultObjectModelVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modelVariables = make_shared<vector<DescribeEventVariableListResponseBodyResultObjectModelVariables>>(expect1);
      }
    }
    if (m.find("nameList") != m.end() && !m["nameList"].empty()) {
      if (typeid(vector<boost::any>) == m["nameList"].type()) {
        vector<DescribeEventVariableListResponseBodyResultObjectNameList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["nameList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableListResponseBodyResultObjectNameList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nameList = make_shared<vector<DescribeEventVariableListResponseBodyResultObjectNameList>>(expect1);
      }
    }
    if (m.find("nativeVariableFunctions") != m.end() && !m["nativeVariableFunctions"].empty()) {
      if (typeid(vector<boost::any>) == m["nativeVariableFunctions"].type()) {
        vector<DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["nativeVariableFunctions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nativeVariableFunctions = make_shared<vector<DescribeEventVariableListResponseBodyResultObjectNativeVariableFunctions>>(expect1);
      }
    }
    if (m.find("nativeVariables") != m.end() && !m["nativeVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["nativeVariables"].type()) {
        vector<DescribeEventVariableListResponseBodyResultObjectNativeVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["nativeVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableListResponseBodyResultObjectNativeVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nativeVariables = make_shared<vector<DescribeEventVariableListResponseBodyResultObjectNativeVariables>>(expect1);
      }
    }
    if (m.find("queryVariables") != m.end() && !m["queryVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["queryVariables"].type()) {
        vector<DescribeEventVariableListResponseBodyResultObjectQueryVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["queryVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableListResponseBodyResultObjectQueryVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        queryVariables = make_shared<vector<DescribeEventVariableListResponseBodyResultObjectQueryVariables>>(expect1);
      }
    }
    if (m.find("selfVariables") != m.end() && !m["selfVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["selfVariables"].type()) {
        vector<DescribeEventVariableListResponseBodyResultObjectSelfVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["selfVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableListResponseBodyResultObjectSelfVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        selfVariables = make_shared<vector<DescribeEventVariableListResponseBodyResultObjectSelfVariables>>(expect1);
      }
    }
    if (m.find("sysVariables") != m.end() && !m["sysVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["sysVariables"].type()) {
        vector<DescribeEventVariableListResponseBodyResultObjectSysVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["sysVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableListResponseBodyResultObjectSysVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sysVariables = make_shared<vector<DescribeEventVariableListResponseBodyResultObjectSysVariables>>(expect1);
      }
    }
    if (m.find("thirdVariables") != m.end() && !m["thirdVariables"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["thirdVariables"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      thirdVariables = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("velocityVariables") != m.end() && !m["velocityVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["velocityVariables"].type()) {
        vector<DescribeEventVariableListResponseBodyResultObjectVelocityVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["velocityVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableListResponseBodyResultObjectVelocityVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        velocityVariables = make_shared<vector<DescribeEventVariableListResponseBodyResultObjectVelocityVariables>>(expect1);
      }
    }
  }


  virtual ~DescribeEventVariableListResponseBodyResultObject() = default;
};
class DescribeEventVariableListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEventVariableListResponseBodyResultObject> resultObject{};

  DescribeEventVariableListResponseBody() {}

  explicit DescribeEventVariableListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeEventVariableListResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeEventVariableListResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeEventVariableListResponseBody() = default;
};
class DescribeEventVariableListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventVariableListResponseBody> body{};

  DescribeEventVariableListResponse() {}

  explicit DescribeEventVariableListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventVariableListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventVariableListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventVariableListResponse() = default;
};
class DescribeEventVariableTemplateBindRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> inputs{};
  shared_ptr<string> regId{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> type{};

  DescribeEventVariableTemplateBindRequest() {}

  explicit DescribeEventVariableTemplateBindRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (templateCode) {
      res["templateCode"] = boost::any(*templateCode);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("templateCode") != m.end() && !m["templateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["templateCode"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeEventVariableTemplateBindRequest() = default;
};
class DescribeEventVariableTemplateBindResponseBodyResultObjectChargeVariables : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  DescribeEventVariableTemplateBindResponseBodyResultObjectChargeVariables() {}

  explicit DescribeEventVariableTemplateBindResponseBodyResultObjectChargeVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeEventVariableTemplateBindResponseBodyResultObjectChargeVariables() = default;
};
class DescribeEventVariableTemplateBindResponseBodyResultObjectFreeVariables : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  DescribeEventVariableTemplateBindResponseBodyResultObjectFreeVariables() {}

  explicit DescribeEventVariableTemplateBindResponseBodyResultObjectFreeVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeEventVariableTemplateBindResponseBodyResultObjectFreeVariables() = default;
};
class DescribeEventVariableTemplateBindResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventVariableTemplateBindResponseBodyResultObjectChargeVariables>> chargeVariables{};
  shared_ptr<vector<DescribeEventVariableTemplateBindResponseBodyResultObjectFreeVariables>> freeVariables{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> totalCount{};

  DescribeEventVariableTemplateBindResponseBodyResultObject() {}

  explicit DescribeEventVariableTemplateBindResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeVariables) {
      vector<boost::any> temp1;
      for(auto item1:*chargeVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["chargeVariables"] = boost::any(temp1);
    }
    if (freeVariables) {
      vector<boost::any> temp1;
      for(auto item1:*freeVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["freeVariables"] = boost::any(temp1);
    }
    if (templateCode) {
      res["templateCode"] = boost::any(*templateCode);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("chargeVariables") != m.end() && !m["chargeVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["chargeVariables"].type()) {
        vector<DescribeEventVariableTemplateBindResponseBodyResultObjectChargeVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["chargeVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableTemplateBindResponseBodyResultObjectChargeVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        chargeVariables = make_shared<vector<DescribeEventVariableTemplateBindResponseBodyResultObjectChargeVariables>>(expect1);
      }
    }
    if (m.find("freeVariables") != m.end() && !m["freeVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["freeVariables"].type()) {
        vector<DescribeEventVariableTemplateBindResponseBodyResultObjectFreeVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["freeVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableTemplateBindResponseBodyResultObjectFreeVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        freeVariables = make_shared<vector<DescribeEventVariableTemplateBindResponseBodyResultObjectFreeVariables>>(expect1);
      }
    }
    if (m.find("templateCode") != m.end() && !m["templateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["templateCode"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["totalCount"]));
    }
  }


  virtual ~DescribeEventVariableTemplateBindResponseBodyResultObject() = default;
};
class DescribeEventVariableTemplateBindResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEventVariableTemplateBindResponseBodyResultObject> resultObject{};

  DescribeEventVariableTemplateBindResponseBody() {}

  explicit DescribeEventVariableTemplateBindResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeEventVariableTemplateBindResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeEventVariableTemplateBindResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeEventVariableTemplateBindResponseBody() = default;
};
class DescribeEventVariableTemplateBindResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventVariableTemplateBindResponseBody> body{};

  DescribeEventVariableTemplateBindResponse() {}

  explicit DescribeEventVariableTemplateBindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventVariableTemplateBindResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventVariableTemplateBindResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventVariableTemplateBindResponse() = default;
};
class DescribeEventVariableTemplateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> inputs{};
  shared_ptr<string> regId{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> type{};

  DescribeEventVariableTemplateListRequest() {}

  explicit DescribeEventVariableTemplateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (templateCode) {
      res["templateCode"] = boost::any(*templateCode);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("templateCode") != m.end() && !m["templateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["templateCode"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeEventVariableTemplateListRequest() = default;
};
class DescribeEventVariableTemplateListResponseBodyResultObjectVariables : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  DescribeEventVariableTemplateListResponseBodyResultObjectVariables() {}

  explicit DescribeEventVariableTemplateListResponseBodyResultObjectVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeEventVariableTemplateListResponseBodyResultObjectVariables() = default;
};
class DescribeEventVariableTemplateListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};
  shared_ptr<vector<DescribeEventVariableTemplateListResponseBodyResultObjectVariables>> variables{};

  DescribeEventVariableTemplateListResponseBodyResultObject() {}

  explicit DescribeEventVariableTemplateListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateCode) {
      res["templateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["templateName"] = boost::any(*templateName);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("templateCode") != m.end() && !m["templateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["templateCode"]));
    }
    if (m.find("templateName") != m.end() && !m["templateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["templateName"]));
    }
    if (m.find("variables") != m.end() && !m["variables"].empty()) {
      if (typeid(vector<boost::any>) == m["variables"].type()) {
        vector<DescribeEventVariableTemplateListResponseBodyResultObjectVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableTemplateListResponseBodyResultObjectVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<DescribeEventVariableTemplateListResponseBodyResultObjectVariables>>(expect1);
      }
    }
  }


  virtual ~DescribeEventVariableTemplateListResponseBodyResultObject() = default;
};
class DescribeEventVariableTemplateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEventVariableTemplateListResponseBodyResultObject>> resultObject{};

  DescribeEventVariableTemplateListResponseBody() {}

  explicit DescribeEventVariableTemplateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeEventVariableTemplateListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventVariableTemplateListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeEventVariableTemplateListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeEventVariableTemplateListResponseBody() = default;
};
class DescribeEventVariableTemplateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventVariableTemplateListResponseBody> body{};

  DescribeEventVariableTemplateListResponse() {}

  explicit DescribeEventVariableTemplateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventVariableTemplateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventVariableTemplateListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventVariableTemplateListResponse() = default;
};
class DescribeEventsVariableListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> filterDTO{};
  shared_ptr<string> regId{};
  shared_ptr<string> scene{};

  DescribeEventsVariableListRequest() {}

  explicit DescribeEventsVariableListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (filterDTO) {
      res["filterDTO"] = boost::any(*filterDTO);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("filterDTO") != m.end() && !m["filterDTO"].empty()) {
      filterDTO = make_shared<string>(boost::any_cast<string>(m["filterDTO"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["scene"]));
    }
  }


  virtual ~DescribeEventsVariableListRequest() = default;
};
class DescribeEventsVariableListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeEventsVariableListResponseBody() {}

  explicit DescribeEventsVariableListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeEventsVariableListResponseBody() = default;
};
class DescribeEventsVariableListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventsVariableListResponseBody> body{};

  DescribeEventsVariableListResponse() {}

  explicit DescribeEventsVariableListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventsVariableListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventsVariableListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventsVariableListResponse() = default;
};
class DescribeExcuteNumRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> degree{};
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> startDate{};

  DescribeExcuteNumRequest() {}

  explicit DescribeExcuteNumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (degree) {
      res["Degree"] = boost::any(*degree);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Degree") != m.end() && !m["Degree"].empty()) {
      degree = make_shared<string>(boost::any_cast<string>(m["Degree"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~DescribeExcuteNumRequest() = default;
};
class DescribeExcuteNumResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> categories{};
  shared_ptr<vector<string>> data{};
  shared_ptr<string> requestId{};

  DescribeExcuteNumResponseBody() {}

  explicit DescribeExcuteNumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeExcuteNumResponseBody() = default;
};
class DescribeExcuteNumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExcuteNumResponseBody> body{};

  DescribeExcuteNumResponse() {}

  explicit DescribeExcuteNumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExcuteNumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExcuteNumResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExcuteNumResponse() = default;
};
class DescribeExistNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> name{};
  shared_ptr<string> regId{};

  DescribeExistNameRequest() {}

  explicit DescribeExistNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeExistNameRequest() = default;
};
class DescribeExistNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeExistNameResponseBody() {}

  explicit DescribeExistNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeExistNameResponseBody() = default;
};
class DescribeExistNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExistNameResponseBody> body{};

  DescribeExistNameResponse() {}

  explicit DescribeExistNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExistNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExistNameResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExistNameResponse() = default;
};
class DescribeExistSceneRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> sceneName{};
  shared_ptr<string> regId{};

  DescribeExistSceneRequest() {}

  explicit DescribeExistSceneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sceneName) {
      res["SceneName"] = boost::any(*sceneName);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SceneName") != m.end() && !m["SceneName"].empty()) {
      sceneName = make_shared<string>(boost::any_cast<string>(m["SceneName"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeExistSceneRequest() = default;
};
class DescribeExistSceneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  DescribeExistSceneResponseBody() {}

  explicit DescribeExistSceneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~DescribeExistSceneResponseBody() = default;
};
class DescribeExistSceneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExistSceneResponseBody> body{};

  DescribeExistSceneResponse() {}

  explicit DescribeExistSceneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExistSceneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExistSceneResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExistSceneResponse() = default;
};
class DescribeExpressionVariableDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  DescribeExpressionVariableDetailRequest() {}

  explicit DescribeExpressionVariableDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeExpressionVariableDetailRequest() = default;
};
class DescribeExpressionVariableDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, boost::any>> resultObject{};

  DescribeExpressionVariableDetailResponseBody() {}

  explicit DescribeExpressionVariableDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["resultObject"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      resultObject = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeExpressionVariableDetailResponseBody() = default;
};
class DescribeExpressionVariableDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExpressionVariableDetailResponseBody> body{};

  DescribeExpressionVariableDetailResponse() {}

  explicit DescribeExpressionVariableDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExpressionVariableDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExpressionVariableDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExpressionVariableDetailResponse() = default;
};
class DescribeExpressionVariableFunctionListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeExpressionVariableFunctionListRequest() {}

  explicit DescribeExpressionVariableFunctionListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeExpressionVariableFunctionListRequest() = default;
};
class DescribeExpressionVariableFunctionListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> key{};
  shared_ptr<long> maxParamSize{};
  shared_ptr<long> minParamSize{};
  shared_ptr<string> paramTypes{};
  shared_ptr<bool> redirect{};
  shared_ptr<string> returnTypes{};
  shared_ptr<string> value{};

  DescribeExpressionVariableFunctionListResponseBodyResultObject() {}

  explicit DescribeExpressionVariableFunctionListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (maxParamSize) {
      res["maxParamSize"] = boost::any(*maxParamSize);
    }
    if (minParamSize) {
      res["minParamSize"] = boost::any(*minParamSize);
    }
    if (paramTypes) {
      res["paramTypes"] = boost::any(*paramTypes);
    }
    if (redirect) {
      res["redirect"] = boost::any(*redirect);
    }
    if (returnTypes) {
      res["returnTypes"] = boost::any(*returnTypes);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("maxParamSize") != m.end() && !m["maxParamSize"].empty()) {
      maxParamSize = make_shared<long>(boost::any_cast<long>(m["maxParamSize"]));
    }
    if (m.find("minParamSize") != m.end() && !m["minParamSize"].empty()) {
      minParamSize = make_shared<long>(boost::any_cast<long>(m["minParamSize"]));
    }
    if (m.find("paramTypes") != m.end() && !m["paramTypes"].empty()) {
      paramTypes = make_shared<string>(boost::any_cast<string>(m["paramTypes"]));
    }
    if (m.find("redirect") != m.end() && !m["redirect"].empty()) {
      redirect = make_shared<bool>(boost::any_cast<bool>(m["redirect"]));
    }
    if (m.find("returnTypes") != m.end() && !m["returnTypes"].empty()) {
      returnTypes = make_shared<string>(boost::any_cast<string>(m["returnTypes"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeExpressionVariableFunctionListResponseBodyResultObject() = default;
};
class DescribeExpressionVariableFunctionListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeExpressionVariableFunctionListResponseBodyResultObject>> resultObject{};

  DescribeExpressionVariableFunctionListResponseBody() {}

  explicit DescribeExpressionVariableFunctionListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeExpressionVariableFunctionListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExpressionVariableFunctionListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeExpressionVariableFunctionListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeExpressionVariableFunctionListResponseBody() = default;
};
class DescribeExpressionVariableFunctionListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExpressionVariableFunctionListResponseBody> body{};

  DescribeExpressionVariableFunctionListResponse() {}

  explicit DescribeExpressionVariableFunctionListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExpressionVariableFunctionListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExpressionVariableFunctionListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExpressionVariableFunctionListResponse() = default;
};
class DescribeExpressionVariablePageRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> outputs{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> status{};
  shared_ptr<string> value{};

  DescribeExpressionVariablePageRequest() {}

  explicit DescribeExpressionVariablePageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (outputs) {
      res["outputs"] = boost::any(*outputs);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("outputs") != m.end() && !m["outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["outputs"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeExpressionVariablePageRequest() = default;
};
class DescribeExpressionVariablePageResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> eventName{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> outputs{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<long> version{};

  DescribeExpressionVariablePageResponseBodyResultObject() {}

  explicit DescribeExpressionVariablePageResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (outputs) {
      res["outputs"] = boost::any(*outputs);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("outputs") != m.end() && !m["outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["outputs"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~DescribeExpressionVariablePageResponseBodyResultObject() = default;
};
class DescribeExpressionVariablePageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeExpressionVariablePageResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeExpressionVariablePageResponseBody() {}

  explicit DescribeExpressionVariablePageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeExpressionVariablePageResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExpressionVariablePageResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeExpressionVariablePageResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeExpressionVariablePageResponseBody() = default;
};
class DescribeExpressionVariablePageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExpressionVariablePageResponseBody> body{};

  DescribeExpressionVariablePageResponse() {}

  explicit DescribeExpressionVariablePageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExpressionVariablePageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExpressionVariablePageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExpressionVariablePageResponse() = default;
};
class DescribeFieldByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  DescribeFieldByIdRequest() {}

  explicit DescribeFieldByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeFieldByIdRequest() = default;
};
class DescribeFieldByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeFieldByIdResponseBody() {}

  explicit DescribeFieldByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeFieldByIdResponseBody() = default;
};
class DescribeFieldByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFieldByIdResponseBody> body{};

  DescribeFieldByIdResponse() {}

  explicit DescribeFieldByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFieldByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFieldByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFieldByIdResponse() = default;
};
class DescribeFieldListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> condition{};
  shared_ptr<string> inputs{};
  shared_ptr<string> regId{};

  DescribeFieldListRequest() {}

  explicit DescribeFieldListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeFieldListRequest() = default;
};
class DescribeFieldListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> classify{};
  shared_ptr<string> description{};
  shared_ptr<string> enumData{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> source{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  DescribeFieldListResponseBodyResultObject() {}

  explicit DescribeFieldListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classify) {
      res["classify"] = boost::any(*classify);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (enumData) {
      res["enumData"] = boost::any(*enumData);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("classify") != m.end() && !m["classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["classify"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("enumData") != m.end() && !m["enumData"].empty()) {
      enumData = make_shared<string>(boost::any_cast<string>(m["enumData"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeFieldListResponseBodyResultObject() = default;
};
class DescribeFieldListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeFieldListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeFieldListResponseBody() {}

  explicit DescribeFieldListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeFieldListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFieldListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeFieldListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeFieldListResponseBody() = default;
};
class DescribeFieldListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFieldListResponseBody> body{};

  DescribeFieldListResponse() {}

  explicit DescribeFieldListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFieldListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFieldListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFieldListResponse() = default;
};
class DescribeFieldPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> classify{};
  shared_ptr<string> condition{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> name{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> source{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  DescribeFieldPageRequest() {}

  explicit DescribeFieldPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (classify) {
      res["classify"] = boost::any(*classify);
    }
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("classify") != m.end() && !m["classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["classify"]));
    }
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeFieldPageRequest() = default;
};
class DescribeFieldPageResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> classify{};
  shared_ptr<string> description{};
  shared_ptr<string> enumData{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> source{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  DescribeFieldPageResponseBodyResultObject() {}

  explicit DescribeFieldPageResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classify) {
      res["classify"] = boost::any(*classify);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (enumData) {
      res["enumData"] = boost::any(*enumData);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("classify") != m.end() && !m["classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["classify"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("enumData") != m.end() && !m["enumData"].empty()) {
      enumData = make_shared<string>(boost::any_cast<string>(m["enumData"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeFieldPageResponseBodyResultObject() = default;
};
class DescribeFieldPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeFieldPageResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeFieldPageResponseBody() {}

  explicit DescribeFieldPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeFieldPageResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFieldPageResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeFieldPageResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeFieldPageResponseBody() = default;
};
class DescribeFieldPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFieldPageResponseBody> body{};

  DescribeFieldPageResponse() {}

  explicit DescribeFieldPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFieldPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFieldPageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFieldPageResponse() = default;
};
class DescribeGroupAccountPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> communityNo{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> direction{};
  shared_ptr<string> fieldKey{};
  shared_ptr<string> fieldVal{};
  shared_ptr<bool> isPage{};
  shared_ptr<string> order{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> taskId{};

  DescribeGroupAccountPageRequest() {}

  explicit DescribeGroupAccountPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (communityNo) {
      res["communityNo"] = boost::any(*communityNo);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (direction) {
      res["direction"] = boost::any(*direction);
    }
    if (fieldKey) {
      res["fieldKey"] = boost::any(*fieldKey);
    }
    if (fieldVal) {
      res["fieldVal"] = boost::any(*fieldVal);
    }
    if (isPage) {
      res["isPage"] = boost::any(*isPage);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("communityNo") != m.end() && !m["communityNo"].empty()) {
      communityNo = make_shared<string>(boost::any_cast<string>(m["communityNo"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("direction") != m.end() && !m["direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["direction"]));
    }
    if (m.find("fieldKey") != m.end() && !m["fieldKey"].empty()) {
      fieldKey = make_shared<string>(boost::any_cast<string>(m["fieldKey"]));
    }
    if (m.find("fieldVal") != m.end() && !m["fieldVal"].empty()) {
      fieldVal = make_shared<string>(boost::any_cast<string>(m["fieldVal"]));
    }
    if (m.find("isPage") != m.end() && !m["isPage"].empty()) {
      isPage = make_shared<bool>(boost::any_cast<bool>(m["isPage"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["order"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~DescribeGroupAccountPageRequest() = default;
};
class DescribeGroupAccountPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<bool> data{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeGroupAccountPageResponseBody() {}

  explicit DescribeGroupAccountPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeGroupAccountPageResponseBody() = default;
};
class DescribeGroupAccountPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupAccountPageResponseBody> body{};

  DescribeGroupAccountPageResponse() {}

  explicit DescribeGroupAccountPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupAccountPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupAccountPageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupAccountPageResponse() = default;
};
class DescribeGroupConditionListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeGroupConditionListRequest() {}

  explicit DescribeGroupConditionListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeGroupConditionListRequest() = default;
};
class DescribeGroupConditionListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> fieldKey{};
  shared_ptr<string> fieldValue{};

  DescribeGroupConditionListResponseBodyResultObject() {}

  explicit DescribeGroupConditionListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldKey) {
      res["fieldKey"] = boost::any(*fieldKey);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldKey") != m.end() && !m["fieldKey"].empty()) {
      fieldKey = make_shared<string>(boost::any_cast<string>(m["fieldKey"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
  }


  virtual ~DescribeGroupConditionListResponseBodyResultObject() = default;
};
class DescribeGroupConditionListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeGroupConditionListResponseBodyResultObject>> resultObject{};

  DescribeGroupConditionListResponseBody() {}

  explicit DescribeGroupConditionListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeGroupConditionListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupConditionListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeGroupConditionListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeGroupConditionListResponseBody() = default;
};
class DescribeGroupConditionListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupConditionListResponseBody> body{};

  DescribeGroupConditionListResponse() {}

  explicit DescribeGroupConditionListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupConditionListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupConditionListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupConditionListResponse() = default;
};
class DescribeGroupPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> direction{};
  shared_ptr<string> order{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> timeType{};

  DescribeGroupPageRequest() {}

  explicit DescribeGroupPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (direction) {
      res["direction"] = boost::any(*direction);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (timeType) {
      res["timeType"] = boost::any(*timeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("direction") != m.end() && !m["direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["direction"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["order"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
    if (m.find("timeType") != m.end() && !m["timeType"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["timeType"]));
    }
  }


  virtual ~DescribeGroupPageRequest() = default;
};
class DescribeGroupPageResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> communityNo{};
  shared_ptr<long> createTime{};
  shared_ptr<string> groupRisk{};
  shared_ptr<string> groupScale{};
  shared_ptr<long> id{};
  shared_ptr<string> sceneName{};
  shared_ptr<long> taskId{};
  shared_ptr<string> userId{};

  DescribeGroupPageResponseBodyResultObject() {}

  explicit DescribeGroupPageResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (communityNo) {
      res["communityNo"] = boost::any(*communityNo);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (groupRisk) {
      res["groupRisk"] = boost::any(*groupRisk);
    }
    if (groupScale) {
      res["groupScale"] = boost::any(*groupScale);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (sceneName) {
      res["sceneName"] = boost::any(*sceneName);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("communityNo") != m.end() && !m["communityNo"].empty()) {
      communityNo = make_shared<string>(boost::any_cast<string>(m["communityNo"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("groupRisk") != m.end() && !m["groupRisk"].empty()) {
      groupRisk = make_shared<string>(boost::any_cast<string>(m["groupRisk"]));
    }
    if (m.find("groupScale") != m.end() && !m["groupScale"].empty()) {
      groupScale = make_shared<string>(boost::any_cast<string>(m["groupScale"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("sceneName") != m.end() && !m["sceneName"].empty()) {
      sceneName = make_shared<string>(boost::any_cast<string>(m["sceneName"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["taskId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~DescribeGroupPageResponseBodyResultObject() = default;
};
class DescribeGroupPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeGroupPageResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeGroupPageResponseBody() {}

  explicit DescribeGroupPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeGroupPageResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupPageResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeGroupPageResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeGroupPageResponseBody() = default;
};
class DescribeGroupPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupPageResponseBody> body{};

  DescribeGroupPageResponse() {}

  explicit DescribeGroupPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupPageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupPageResponse() = default;
};
class DescribeGroupStatisticsByTodayRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeGroupStatisticsByTodayRequest() {}

  explicit DescribeGroupStatisticsByTodayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeGroupStatisticsByTodayRequest() = default;
};
class DescribeGroupStatisticsByTodayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  DescribeGroupStatisticsByTodayResponseBody() {}

  explicit DescribeGroupStatisticsByTodayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~DescribeGroupStatisticsByTodayResponseBody() = default;
};
class DescribeGroupStatisticsByTodayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupStatisticsByTodayResponseBody> body{};

  DescribeGroupStatisticsByTodayResponse() {}

  explicit DescribeGroupStatisticsByTodayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupStatisticsByTodayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupStatisticsByTodayResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupStatisticsByTodayResponse() = default;
};
class DescribeGroupTrendRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> day{};
  shared_ptr<string> regId{};

  DescribeGroupTrendRequest() {}

  explicit DescribeGroupTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (day) {
      res["day"] = boost::any(*day);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("day") != m.end() && !m["day"].empty()) {
      day = make_shared<string>(boost::any_cast<string>(m["day"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeGroupTrendRequest() = default;
};
class DescribeGroupTrendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  DescribeGroupTrendResponseBody() {}

  explicit DescribeGroupTrendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~DescribeGroupTrendResponseBody() = default;
};
class DescribeGroupTrendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupTrendResponseBody> body{};

  DescribeGroupTrendResponse() {}

  explicit DescribeGroupTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupTrendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupTrendResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupTrendResponse() = default;
};
class DescribeHasRuleNameByEventCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> excludeRuleId{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleName{};

  DescribeHasRuleNameByEventCodeRequest() {}

  explicit DescribeHasRuleNameByEventCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (excludeRuleId) {
      res["excludeRuleId"] = boost::any(*excludeRuleId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("excludeRuleId") != m.end() && !m["excludeRuleId"].empty()) {
      excludeRuleId = make_shared<string>(boost::any_cast<string>(m["excludeRuleId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
  }


  virtual ~DescribeHasRuleNameByEventCodeRequest() = default;
};
class DescribeHasRuleNameByEventCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeHasRuleNameByEventCodeResponseBody() {}

  explicit DescribeHasRuleNameByEventCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeHasRuleNameByEventCodeResponseBody() = default;
};
class DescribeHasRuleNameByEventCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHasRuleNameByEventCodeResponseBody> body{};

  DescribeHasRuleNameByEventCodeResponse() {}

  explicit DescribeHasRuleNameByEventCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHasRuleNameByEventCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHasRuleNameByEventCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHasRuleNameByEventCodeResponse() = default;
};
class DescribeHighRiskPieChartRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> regId{};

  DescribeHighRiskPieChartRequest() {}

  explicit DescribeHighRiskPieChartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeHighRiskPieChartRequest() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCityGrid : public Darabonba::Model {
public:
  shared_ptr<bool> show{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCityGrid() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCityGrid(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (show) {
      res["show"] = boost::any(*show);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("show") != m.end() && !m["show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["show"]));
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCityGrid() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeriesData : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeriesData() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeriesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeriesData() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeriesData>> data{};
  shared_ptr<string> name{};
  shared_ptr<string> roseType{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeries() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (roseType) {
      res["roseType"] = boost::any(*roseType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeriesData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeriesData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeriesData>>(expect1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("roseType") != m.end() && !m["roseType"].empty()) {
      roseType = make_shared<string>(boost::any_cast<string>(m["roseType"]));
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeries() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCity : public Darabonba::Model {
public:
  shared_ptr<bool> animation{};
  shared_ptr<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCityGrid> grid{};
  shared_ptr<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeries>> series{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCity() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (animation) {
      res["animation"] = boost::any(*animation);
    }
    if (grid) {
      res["grid"] = grid ? boost::any(grid->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("animation") != m.end() && !m["animation"].empty()) {
      animation = make_shared<bool>(boost::any_cast<bool>(m["animation"]));
    }
    if (m.find("grid") != m.end() && !m["grid"].empty()) {
      if (typeid(map<string, boost::any>) == m["grid"].type()) {
        DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCityGrid model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["grid"]));
        grid = make_shared<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCityGrid>(model1);
      }
    }
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCitySeries>>(expect1);
      }
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCity() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceGrid : public Darabonba::Model {
public:
  shared_ptr<bool> show{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceGrid() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceGrid(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (show) {
      res["show"] = boost::any(*show);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("show") != m.end() && !m["show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["show"]));
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceGrid() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeriesData : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeriesData() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeriesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeriesData() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeriesData>> data{};
  shared_ptr<string> name{};
  shared_ptr<string> roseType{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeries() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (roseType) {
      res["roseType"] = boost::any(*roseType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeriesData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeriesData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeriesData>>(expect1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("roseType") != m.end() && !m["roseType"].empty()) {
      roseType = make_shared<string>(boost::any_cast<string>(m["roseType"]));
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeries() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvince : public Darabonba::Model {
public:
  shared_ptr<bool> animation{};
  shared_ptr<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceGrid> grid{};
  shared_ptr<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeries>> series{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvince() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvince(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (animation) {
      res["animation"] = boost::any(*animation);
    }
    if (grid) {
      res["grid"] = grid ? boost::any(grid->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("animation") != m.end() && !m["animation"].empty()) {
      animation = make_shared<bool>(boost::any_cast<bool>(m["animation"]));
    }
    if (m.find("grid") != m.end() && !m["grid"].empty()) {
      if (typeid(map<string, boost::any>) == m["grid"].type()) {
        DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceGrid model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["grid"]));
        grid = make_shared<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceGrid>(model1);
      }
    }
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvinceSeries>>(expect1);
      }
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvince() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCityGrid : public Darabonba::Model {
public:
  shared_ptr<bool> show{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCityGrid() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCityGrid(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (show) {
      res["show"] = boost::any(*show);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("show") != m.end() && !m["show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["show"]));
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCityGrid() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeriesData : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeriesData() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeriesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeriesData() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeriesData>> data{};
  shared_ptr<string> name{};
  shared_ptr<string> roseType{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeries() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (roseType) {
      res["roseType"] = boost::any(*roseType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeriesData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeriesData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeriesData>>(expect1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("roseType") != m.end() && !m["roseType"].empty()) {
      roseType = make_shared<string>(boost::any_cast<string>(m["roseType"]));
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeries() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCity : public Darabonba::Model {
public:
  shared_ptr<bool> animation{};
  shared_ptr<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCityGrid> grid{};
  shared_ptr<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeries>> series{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCity() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (animation) {
      res["animation"] = boost::any(*animation);
    }
    if (grid) {
      res["grid"] = grid ? boost::any(grid->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("animation") != m.end() && !m["animation"].empty()) {
      animation = make_shared<bool>(boost::any_cast<bool>(m["animation"]));
    }
    if (m.find("grid") != m.end() && !m["grid"].empty()) {
      if (typeid(map<string, boost::any>) == m["grid"].type()) {
        DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCityGrid model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["grid"]));
        grid = make_shared<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCityGrid>(model1);
      }
    }
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCitySeries>>(expect1);
      }
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCity() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceGrid : public Darabonba::Model {
public:
  shared_ptr<bool> show{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceGrid() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceGrid(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (show) {
      res["show"] = boost::any(*show);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("show") != m.end() && !m["show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["show"]));
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceGrid() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeriesData : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeriesData() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeriesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeriesData() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeriesData>> data{};
  shared_ptr<string> name{};
  shared_ptr<string> roseType{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeries() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (roseType) {
      res["roseType"] = boost::any(*roseType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeriesData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeriesData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeriesData>>(expect1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("roseType") != m.end() && !m["roseType"].empty()) {
      roseType = make_shared<string>(boost::any_cast<string>(m["roseType"]));
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeries() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvince : public Darabonba::Model {
public:
  shared_ptr<bool> animation{};
  shared_ptr<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceGrid> grid{};
  shared_ptr<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeries>> series{};

  DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvince() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvince(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (animation) {
      res["animation"] = boost::any(*animation);
    }
    if (grid) {
      res["grid"] = grid ? boost::any(grid->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("animation") != m.end() && !m["animation"].empty()) {
      animation = make_shared<bool>(boost::any_cast<bool>(m["animation"]));
    }
    if (m.find("grid") != m.end() && !m["grid"].empty()) {
      if (typeid(map<string, boost::any>) == m["grid"].type()) {
        DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceGrid model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["grid"]));
        grid = make_shared<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceGrid>(model1);
      }
    }
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvinceSeries>>(expect1);
      }
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvince() = default;
};
class DescribeHighRiskPieChartResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCity> highRiskIPCity{};
  shared_ptr<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvince> highRiskIPProvince{};
  shared_ptr<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCity> highRiskMobileCity{};
  shared_ptr<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvince> highRiskMobileProvince{};

  DescribeHighRiskPieChartResponseBodyResultObject() {}

  explicit DescribeHighRiskPieChartResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (highRiskIPCity) {
      res["highRiskIPCity"] = highRiskIPCity ? boost::any(highRiskIPCity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (highRiskIPProvince) {
      res["highRiskIPProvince"] = highRiskIPProvince ? boost::any(highRiskIPProvince->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (highRiskMobileCity) {
      res["highRiskMobileCity"] = highRiskMobileCity ? boost::any(highRiskMobileCity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (highRiskMobileProvince) {
      res["highRiskMobileProvince"] = highRiskMobileProvince ? boost::any(highRiskMobileProvince->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("highRiskIPCity") != m.end() && !m["highRiskIPCity"].empty()) {
      if (typeid(map<string, boost::any>) == m["highRiskIPCity"].type()) {
        DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["highRiskIPCity"]));
        highRiskIPCity = make_shared<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPCity>(model1);
      }
    }
    if (m.find("highRiskIPProvince") != m.end() && !m["highRiskIPProvince"].empty()) {
      if (typeid(map<string, boost::any>) == m["highRiskIPProvince"].type()) {
        DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvince model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["highRiskIPProvince"]));
        highRiskIPProvince = make_shared<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskIPProvince>(model1);
      }
    }
    if (m.find("highRiskMobileCity") != m.end() && !m["highRiskMobileCity"].empty()) {
      if (typeid(map<string, boost::any>) == m["highRiskMobileCity"].type()) {
        DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["highRiskMobileCity"]));
        highRiskMobileCity = make_shared<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileCity>(model1);
      }
    }
    if (m.find("highRiskMobileProvince") != m.end() && !m["highRiskMobileProvince"].empty()) {
      if (typeid(map<string, boost::any>) == m["highRiskMobileProvince"].type()) {
        DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvince model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["highRiskMobileProvince"]));
        highRiskMobileProvince = make_shared<DescribeHighRiskPieChartResponseBodyResultObjectHighRiskMobileProvince>(model1);
      }
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBodyResultObject() = default;
};
class DescribeHighRiskPieChartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeHighRiskPieChartResponseBodyResultObject> resultObject{};
  shared_ptr<bool> success{};

  DescribeHighRiskPieChartResponseBody() {}

  explicit DescribeHighRiskPieChartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeHighRiskPieChartResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeHighRiskPieChartResponseBodyResultObject>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeHighRiskPieChartResponseBody() = default;
};
class DescribeHighRiskPieChartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHighRiskPieChartResponseBody> body{};

  DescribeHighRiskPieChartResponse() {}

  explicit DescribeHighRiskPieChartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHighRiskPieChartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHighRiskPieChartResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHighRiskPieChartResponse() = default;
};
class DescribeHitRuleFluctuationRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleStatus{};

  DescribeHitRuleFluctuationRequest() {}

  explicit DescribeHitRuleFluctuationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
  }


  virtual ~DescribeHitRuleFluctuationRequest() = default;
};
class DescribeHitRuleFluctuationResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> todayNum{};
  shared_ptr<string> withinSevenDayNum{};
  shared_ptr<string> withinThirtyDayNum{};
  shared_ptr<string> withinThreeDayNum{};
  shared_ptr<long> yesterdayNum{};

  DescribeHitRuleFluctuationResponseBodyResultObject() {}

  explicit DescribeHitRuleFluctuationResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (todayNum) {
      res["todayNum"] = boost::any(*todayNum);
    }
    if (withinSevenDayNum) {
      res["withinSevenDayNum"] = boost::any(*withinSevenDayNum);
    }
    if (withinThirtyDayNum) {
      res["withinThirtyDayNum"] = boost::any(*withinThirtyDayNum);
    }
    if (withinThreeDayNum) {
      res["withinThreeDayNum"] = boost::any(*withinThreeDayNum);
    }
    if (yesterdayNum) {
      res["yesterdayNum"] = boost::any(*yesterdayNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("todayNum") != m.end() && !m["todayNum"].empty()) {
      todayNum = make_shared<long>(boost::any_cast<long>(m["todayNum"]));
    }
    if (m.find("withinSevenDayNum") != m.end() && !m["withinSevenDayNum"].empty()) {
      withinSevenDayNum = make_shared<string>(boost::any_cast<string>(m["withinSevenDayNum"]));
    }
    if (m.find("withinThirtyDayNum") != m.end() && !m["withinThirtyDayNum"].empty()) {
      withinThirtyDayNum = make_shared<string>(boost::any_cast<string>(m["withinThirtyDayNum"]));
    }
    if (m.find("withinThreeDayNum") != m.end() && !m["withinThreeDayNum"].empty()) {
      withinThreeDayNum = make_shared<string>(boost::any_cast<string>(m["withinThreeDayNum"]));
    }
    if (m.find("yesterdayNum") != m.end() && !m["yesterdayNum"].empty()) {
      yesterdayNum = make_shared<long>(boost::any_cast<long>(m["yesterdayNum"]));
    }
  }


  virtual ~DescribeHitRuleFluctuationResponseBodyResultObject() = default;
};
class DescribeHitRuleFluctuationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeHitRuleFluctuationResponseBodyResultObject>> resultObject{};
  shared_ptr<bool> success{};

  DescribeHitRuleFluctuationResponseBody() {}

  explicit DescribeHitRuleFluctuationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeHitRuleFluctuationResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHitRuleFluctuationResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeHitRuleFluctuationResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeHitRuleFluctuationResponseBody() = default;
};
class DescribeHitRuleFluctuationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHitRuleFluctuationResponseBody> body{};

  DescribeHitRuleFluctuationResponse() {}

  explicit DescribeHitRuleFluctuationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHitRuleFluctuationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHitRuleFluctuationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHitRuleFluctuationResponse() = default;
};
class DescribeHitRuleListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> eventType{};
  shared_ptr<string> regId{};

  DescribeHitRuleListRequest() {}

  explicit DescribeHitRuleListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeHitRuleListRequest() = default;
};
class DescribeHitRuleListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> hitCount{};
  shared_ptr<string> ruleName{};

  DescribeHitRuleListResponseBodyResultObject() {}

  explicit DescribeHitRuleListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hitCount) {
      res["hitCount"] = boost::any(*hitCount);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hitCount") != m.end() && !m["hitCount"].empty()) {
      hitCount = make_shared<long>(boost::any_cast<long>(m["hitCount"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
  }


  virtual ~DescribeHitRuleListResponseBodyResultObject() = default;
};
class DescribeHitRuleListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeHitRuleListResponseBodyResultObject>> resultObject{};

  DescribeHitRuleListResponseBody() {}

  explicit DescribeHitRuleListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeHitRuleListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHitRuleListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeHitRuleListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeHitRuleListResponseBody() = default;
};
class DescribeHitRuleListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHitRuleListResponseBody> body{};

  DescribeHitRuleListResponse() {}

  explicit DescribeHitRuleListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHitRuleListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHitRuleListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHitRuleListResponse() = default;
};
class DescribeHitRuleTrendRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleStatus{};

  DescribeHitRuleTrendRequest() {}

  explicit DescribeHitRuleTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
  }


  virtual ~DescribeHitRuleTrendRequest() = default;
};
class DescribeHitRuleTrendResponseBodyResultObjectSeriesData : public Darabonba::Model {
public:
  shared_ptr<long> num{};
  shared_ptr<string> scale{};

  DescribeHitRuleTrendResponseBodyResultObjectSeriesData() {}

  explicit DescribeHitRuleTrendResponseBodyResultObjectSeriesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (num) {
      res["num"] = boost::any(*num);
    }
    if (scale) {
      res["scale"] = boost::any(*scale);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("num") != m.end() && !m["num"].empty()) {
      num = make_shared<long>(boost::any_cast<long>(m["num"]));
    }
    if (m.find("scale") != m.end() && !m["scale"].empty()) {
      scale = make_shared<string>(boost::any_cast<string>(m["scale"]));
    }
  }


  virtual ~DescribeHitRuleTrendResponseBodyResultObjectSeriesData() = default;
};
class DescribeHitRuleTrendResponseBodyResultObjectSeries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHitRuleTrendResponseBodyResultObjectSeriesData>> data{};
  shared_ptr<string> name{};

  DescribeHitRuleTrendResponseBodyResultObjectSeries() {}

  explicit DescribeHitRuleTrendResponseBodyResultObjectSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<DescribeHitRuleTrendResponseBodyResultObjectSeriesData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHitRuleTrendResponseBodyResultObjectSeriesData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeHitRuleTrendResponseBodyResultObjectSeriesData>>(expect1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeHitRuleTrendResponseBodyResultObjectSeries() = default;
};
class DescribeHitRuleTrendResponseBodyResultObjectXaxis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};

  DescribeHitRuleTrendResponseBodyResultObjectXaxis() {}

  explicit DescribeHitRuleTrendResponseBodyResultObjectXaxis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeHitRuleTrendResponseBodyResultObjectXaxis() = default;
};
class DescribeHitRuleTrendResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHitRuleTrendResponseBodyResultObjectSeries>> series{};
  shared_ptr<DescribeHitRuleTrendResponseBodyResultObjectXaxis> xaxis{};

  DescribeHitRuleTrendResponseBodyResultObject() {}

  explicit DescribeHitRuleTrendResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    if (xaxis) {
      res["xaxis"] = xaxis ? boost::any(xaxis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeHitRuleTrendResponseBodyResultObjectSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHitRuleTrendResponseBodyResultObjectSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeHitRuleTrendResponseBodyResultObjectSeries>>(expect1);
      }
    }
    if (m.find("xaxis") != m.end() && !m["xaxis"].empty()) {
      if (typeid(map<string, boost::any>) == m["xaxis"].type()) {
        DescribeHitRuleTrendResponseBodyResultObjectXaxis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["xaxis"]));
        xaxis = make_shared<DescribeHitRuleTrendResponseBodyResultObjectXaxis>(model1);
      }
    }
  }


  virtual ~DescribeHitRuleTrendResponseBodyResultObject() = default;
};
class DescribeHitRuleTrendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeHitRuleTrendResponseBodyResultObject> resultObject{};
  shared_ptr<bool> success{};

  DescribeHitRuleTrendResponseBody() {}

  explicit DescribeHitRuleTrendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeHitRuleTrendResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeHitRuleTrendResponseBodyResultObject>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeHitRuleTrendResponseBody() = default;
};
class DescribeHitRuleTrendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHitRuleTrendResponseBody> body{};

  DescribeHitRuleTrendResponse() {}

  explicit DescribeHitRuleTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHitRuleTrendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHitRuleTrendResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHitRuleTrendResponse() = default;
};
class DescribeInputFeildCountByEventCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> regId{};

  DescribeInputFeildCountByEventCodeRequest() {}

  explicit DescribeInputFeildCountByEventCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeInputFeildCountByEventCodeRequest() = default;
};
class DescribeInputFeildCountByEventCodeResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<bool> limit{};
  shared_ptr<long> maxTotalItem{};
  shared_ptr<long> totalItem{};

  DescribeInputFeildCountByEventCodeResponseBodyResultObject() {}

  explicit DescribeInputFeildCountByEventCodeResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (limit) {
      res["limit"] = boost::any(*limit);
    }
    if (maxTotalItem) {
      res["maxTotalItem"] = boost::any(*maxTotalItem);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("limit") != m.end() && !m["limit"].empty()) {
      limit = make_shared<bool>(boost::any_cast<bool>(m["limit"]));
    }
    if (m.find("maxTotalItem") != m.end() && !m["maxTotalItem"].empty()) {
      maxTotalItem = make_shared<long>(boost::any_cast<long>(m["maxTotalItem"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
  }


  virtual ~DescribeInputFeildCountByEventCodeResponseBodyResultObject() = default;
};
class DescribeInputFeildCountByEventCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeInputFeildCountByEventCodeResponseBodyResultObject> resultObject{};

  DescribeInputFeildCountByEventCodeResponseBody() {}

  explicit DescribeInputFeildCountByEventCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeInputFeildCountByEventCodeResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeInputFeildCountByEventCodeResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeInputFeildCountByEventCodeResponseBody() = default;
};
class DescribeInputFeildCountByEventCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInputFeildCountByEventCodeResponseBody> body{};

  DescribeInputFeildCountByEventCodeResponse() {}

  explicit DescribeInputFeildCountByEventCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInputFeildCountByEventCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInputFeildCountByEventCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInputFeildCountByEventCodeResponse() = default;
};
class DescribeListPocRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> type{};

  DescribeListPocRequest() {}

  explicit DescribeListPocRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["RegId"] = boost::any(*regId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegId") != m.end() && !m["RegId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["RegId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeListPocRequest() = default;
};
class DescribeListPocResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};
  shared_ptr<string> totalItem{};
  shared_ptr<string> totalPage{};

  DescribeListPocResponseBody() {}

  explicit DescribeListPocResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["ResultObject"] = boost::any(*resultObject);
    }
    if (totalItem) {
      res["TotalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultObject") != m.end() && !m["ResultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["ResultObject"]));
    }
    if (m.find("TotalItem") != m.end() && !m["TotalItem"].empty()) {
      totalItem = make_shared<string>(boost::any_cast<string>(m["TotalItem"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<string>(boost::any_cast<string>(m["TotalPage"]));
    }
  }


  virtual ~DescribeListPocResponseBody() = default;
};
class DescribeListPocResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeListPocResponseBody> body{};

  DescribeListPocResponse() {}

  explicit DescribeListPocResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeListPocResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeListPocResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeListPocResponse() = default;
};
class DescribeLoanExecListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> batchNo{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> monitorObj{};
  shared_ptr<string> monitorStatus{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};

  DescribeLoanExecListRequest() {}

  explicit DescribeLoanExecListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (batchNo) {
      res["batchNo"] = boost::any(*batchNo);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (monitorObj) {
      res["monitorObj"] = boost::any(*monitorObj);
    }
    if (monitorStatus) {
      res["monitorStatus"] = boost::any(*monitorStatus);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("batchNo") != m.end() && !m["batchNo"].empty()) {
      batchNo = make_shared<string>(boost::any_cast<string>(m["batchNo"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("monitorObj") != m.end() && !m["monitorObj"].empty()) {
      monitorObj = make_shared<string>(boost::any_cast<string>(m["monitorObj"]));
    }
    if (m.find("monitorStatus") != m.end() && !m["monitorStatus"].empty()) {
      monitorStatus = make_shared<string>(boost::any_cast<string>(m["monitorStatus"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeLoanExecListRequest() = default;
};
class DescribeLoanExecListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeLoanExecListResponseBody() {}

  explicit DescribeLoanExecListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeLoanExecListResponseBody() = default;
};
class DescribeLoanExecListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLoanExecListResponseBody> body{};

  DescribeLoanExecListResponse() {}

  explicit DescribeLoanExecListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoanExecListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoanExecListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoanExecListResponse() = default;
};
class DescribeLoanTaskListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> batchNo{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> monitorStatus{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};

  DescribeLoanTaskListRequest() {}

  explicit DescribeLoanTaskListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (batchNo) {
      res["batchNo"] = boost::any(*batchNo);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (monitorStatus) {
      res["monitorStatus"] = boost::any(*monitorStatus);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("batchNo") != m.end() && !m["batchNo"].empty()) {
      batchNo = make_shared<string>(boost::any_cast<string>(m["batchNo"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("monitorStatus") != m.end() && !m["monitorStatus"].empty()) {
      monitorStatus = make_shared<string>(boost::any_cast<string>(m["monitorStatus"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeLoanTaskListRequest() = default;
};
class DescribeLoanTaskListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeLoanTaskListResponseBody() {}

  explicit DescribeLoanTaskListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeLoanTaskListResponseBody() = default;
};
class DescribeLoanTaskListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLoanTaskListResponseBody> body{};

  DescribeLoanTaskListResponse() {}

  explicit DescribeLoanTaskListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoanTaskListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoanTaskListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoanTaskListResponse() = default;
};
class DescribeMarkPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> direction{};
  shared_ptr<bool> isPage{};
  shared_ptr<string> order{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> taskLogId{};

  DescribeMarkPageRequest() {}

  explicit DescribeMarkPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (direction) {
      res["direction"] = boost::any(*direction);
    }
    if (isPage) {
      res["isPage"] = boost::any(*isPage);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (taskLogId) {
      res["taskLogId"] = boost::any(*taskLogId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("direction") != m.end() && !m["direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["direction"]));
    }
    if (m.find("isPage") != m.end() && !m["isPage"].empty()) {
      isPage = make_shared<bool>(boost::any_cast<bool>(m["isPage"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["order"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("taskLogId") != m.end() && !m["taskLogId"].empty()) {
      taskLogId = make_shared<string>(boost::any_cast<string>(m["taskLogId"]));
    }
  }


  virtual ~DescribeMarkPageRequest() = default;
};
class DescribeMarkPageResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<long> id{};
  shared_ptr<string> markType{};

  DescribeMarkPageResponseBodyResultObject() {}

  explicit DescribeMarkPageResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["fieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (markType) {
      res["markType"] = boost::any(*markType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldName") != m.end() && !m["fieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["fieldName"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("markType") != m.end() && !m["markType"].empty()) {
      markType = make_shared<string>(boost::any_cast<string>(m["markType"]));
    }
  }


  virtual ~DescribeMarkPageResponseBodyResultObject() = default;
};
class DescribeMarkPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeMarkPageResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeMarkPageResponseBody() {}

  explicit DescribeMarkPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeMarkPageResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMarkPageResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeMarkPageResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeMarkPageResponseBody() = default;
};
class DescribeMarkPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMarkPageResponseBody> body{};

  DescribeMarkPageResponse() {}

  explicit DescribeMarkPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMarkPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMarkPageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMarkPageResponse() = default;
};
class DescribeMenuPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> permissionType{};
  shared_ptr<string> regId{};

  DescribeMenuPermissionRequest() {}

  explicit DescribeMenuPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (permissionType) {
      res["permissionType"] = boost::any(*permissionType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("permissionType") != m.end() && !m["permissionType"].empty()) {
      permissionType = make_shared<string>(boost::any_cast<string>(m["permissionType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeMenuPermissionRequest() = default;
};
class DescribeMenuPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeMenuPermissionResponseBody() {}

  explicit DescribeMenuPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeMenuPermissionResponseBody() = default;
};
class DescribeMenuPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMenuPermissionResponseBody> body{};

  DescribeMenuPermissionResponse() {}

  explicit DescribeMenuPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMenuPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMenuPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMenuPermissionResponse() = default;
};
class DescribeMonitorTaskLimitRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeMonitorTaskLimitRequest() {}

  explicit DescribeMonitorTaskLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeMonitorTaskLimitRequest() = default;
};
class DescribeMonitorTaskLimitResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<bool> limit{};
  shared_ptr<long> maxTotalItem{};
  shared_ptr<long> totalItem{};

  DescribeMonitorTaskLimitResponseBodyResultObject() {}

  explicit DescribeMonitorTaskLimitResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (limit) {
      res["limit"] = boost::any(*limit);
    }
    if (maxTotalItem) {
      res["maxTotalItem"] = boost::any(*maxTotalItem);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("limit") != m.end() && !m["limit"].empty()) {
      limit = make_shared<bool>(boost::any_cast<bool>(m["limit"]));
    }
    if (m.find("maxTotalItem") != m.end() && !m["maxTotalItem"].empty()) {
      maxTotalItem = make_shared<long>(boost::any_cast<long>(m["maxTotalItem"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
  }


  virtual ~DescribeMonitorTaskLimitResponseBodyResultObject() = default;
};
class DescribeMonitorTaskLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMonitorTaskLimitResponseBodyResultObject> resultObject{};

  DescribeMonitorTaskLimitResponseBody() {}

  explicit DescribeMonitorTaskLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeMonitorTaskLimitResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeMonitorTaskLimitResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeMonitorTaskLimitResponseBody() = default;
};
class DescribeMonitorTaskLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitorTaskLimitResponseBody> body{};

  DescribeMonitorTaskLimitResponse() {}

  explicit DescribeMonitorTaskLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitorTaskLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitorTaskLimitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitorTaskLimitResponse() = default;
};
class DescribeNameListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> value{};
  shared_ptr<string> variableId{};

  DescribeNameListRequest() {}

  explicit DescribeNameListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (variableId) {
      res["variableId"] = boost::any(*variableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
    if (m.find("variableId") != m.end() && !m["variableId"].empty()) {
      variableId = make_shared<string>(boost::any_cast<string>(m["variableId"]));
    }
  }


  virtual ~DescribeNameListRequest() = default;
};
class DescribeNameListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> identifier{};
  shared_ptr<string> title{};
  shared_ptr<string> value{};
  shared_ptr<long> variableId{};

  DescribeNameListResponseBodyResultObject() {}

  explicit DescribeNameListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (variableId) {
      res["variableId"] = boost::any(*variableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
    if (m.find("variableId") != m.end() && !m["variableId"].empty()) {
      variableId = make_shared<long>(boost::any_cast<long>(m["variableId"]));
    }
  }


  virtual ~DescribeNameListResponseBodyResultObject() = default;
};
class DescribeNameListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeNameListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeNameListResponseBody() {}

  explicit DescribeNameListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeNameListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNameListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeNameListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeNameListResponseBody() = default;
};
class DescribeNameListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNameListResponseBody> body{};

  DescribeNameListResponse() {}

  explicit DescribeNameListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNameListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNameListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNameListResponse() = default;
};
class DescribeNameListDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<long> variableId{};

  DescribeNameListDownloadUrlRequest() {}

  explicit DescribeNameListDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (variableId) {
      res["variableId"] = boost::any(*variableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("variableId") != m.end() && !m["variableId"].empty()) {
      variableId = make_shared<long>(boost::any_cast<long>(m["variableId"]));
    }
  }


  virtual ~DescribeNameListDownloadUrlRequest() = default;
};
class DescribeNameListDownloadUrlResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> downloadFileUrl{};

  DescribeNameListDownloadUrlResponseBodyResultObject() {}

  explicit DescribeNameListDownloadUrlResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadFileUrl) {
      res["downloadFileUrl"] = boost::any(*downloadFileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("downloadFileUrl") != m.end() && !m["downloadFileUrl"].empty()) {
      downloadFileUrl = make_shared<string>(boost::any_cast<string>(m["downloadFileUrl"]));
    }
  }


  virtual ~DescribeNameListDownloadUrlResponseBodyResultObject() = default;
};
class DescribeNameListDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeNameListDownloadUrlResponseBodyResultObject> resultObject{};

  DescribeNameListDownloadUrlResponseBody() {}

  explicit DescribeNameListDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeNameListDownloadUrlResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeNameListDownloadUrlResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeNameListDownloadUrlResponseBody() = default;
};
class DescribeNameListDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNameListDownloadUrlResponseBody> body{};

  DescribeNameListDownloadUrlResponse() {}

  explicit DescribeNameListDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNameListDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNameListDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNameListDownloadUrlResponse() = default;
};
class DescribeNameListLimitRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> regId{};

  DescribeNameListLimitRequest() {}

  explicit DescribeNameListLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeNameListLimitRequest() = default;
};
class DescribeNameListLimitResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<bool> limit{};
  shared_ptr<long> maxTotalItem{};
  shared_ptr<long> totalItem{};

  DescribeNameListLimitResponseBodyResultObject() {}

  explicit DescribeNameListLimitResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (limit) {
      res["limit"] = boost::any(*limit);
    }
    if (maxTotalItem) {
      res["maxTotalItem"] = boost::any(*maxTotalItem);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("limit") != m.end() && !m["limit"].empty()) {
      limit = make_shared<bool>(boost::any_cast<bool>(m["limit"]));
    }
    if (m.find("maxTotalItem") != m.end() && !m["maxTotalItem"].empty()) {
      maxTotalItem = make_shared<long>(boost::any_cast<long>(m["maxTotalItem"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
  }


  virtual ~DescribeNameListLimitResponseBodyResultObject() = default;
};
class DescribeNameListLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeNameListLimitResponseBodyResultObject> resultObject{};

  DescribeNameListLimitResponseBody() {}

  explicit DescribeNameListLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeNameListLimitResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeNameListLimitResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeNameListLimitResponseBody() = default;
};
class DescribeNameListLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNameListLimitResponseBody> body{};

  DescribeNameListLimitResponse() {}

  explicit DescribeNameListLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNameListLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNameListLimitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNameListLimitResponse() = default;
};
class DescribeNameListPageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<long> updateBeginTime{};
  shared_ptr<long> updateEndTime{};
  shared_ptr<string> value{};
  shared_ptr<long> variableId{};

  DescribeNameListPageListRequest() {}

  explicit DescribeNameListPageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (updateBeginTime) {
      res["updateBeginTime"] = boost::any(*updateBeginTime);
    }
    if (updateEndTime) {
      res["updateEndTime"] = boost::any(*updateEndTime);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (variableId) {
      res["variableId"] = boost::any(*variableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("updateBeginTime") != m.end() && !m["updateBeginTime"].empty()) {
      updateBeginTime = make_shared<long>(boost::any_cast<long>(m["updateBeginTime"]));
    }
    if (m.find("updateEndTime") != m.end() && !m["updateEndTime"].empty()) {
      updateEndTime = make_shared<long>(boost::any_cast<long>(m["updateEndTime"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
    if (m.find("variableId") != m.end() && !m["variableId"].empty()) {
      variableId = make_shared<long>(boost::any_cast<long>(m["variableId"]));
    }
  }


  virtual ~DescribeNameListPageListRequest() = default;
};
class DescribeNameListPageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> nameListType{};
  shared_ptr<string> title{};
  shared_ptr<string> userId{};
  shared_ptr<string> value{};
  shared_ptr<long> variableId{};

  DescribeNameListPageListResponseBodyResultObject() {}

  explicit DescribeNameListPageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameListType) {
      res["nameListType"] = boost::any(*nameListType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (variableId) {
      res["variableId"] = boost::any(*variableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameListType") != m.end() && !m["nameListType"].empty()) {
      nameListType = make_shared<string>(boost::any_cast<string>(m["nameListType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
    if (m.find("variableId") != m.end() && !m["variableId"].empty()) {
      variableId = make_shared<long>(boost::any_cast<long>(m["variableId"]));
    }
  }


  virtual ~DescribeNameListPageListResponseBodyResultObject() = default;
};
class DescribeNameListPageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> currentPage{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeNameListPageListResponseBodyResultObject>> resultObject{};
  shared_ptr<string> totalItem{};
  shared_ptr<string> totalPage{};

  DescribeNameListPageListResponseBody() {}

  explicit DescribeNameListPageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeNameListPageListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNameListPageListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeNameListPageListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<string>(boost::any_cast<string>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<string>(boost::any_cast<string>(m["totalPage"]));
    }
  }


  virtual ~DescribeNameListPageListResponseBody() = default;
};
class DescribeNameListPageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNameListPageListResponseBody> body{};

  DescribeNameListPageListResponse() {}

  explicit DescribeNameListPageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNameListPageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNameListPageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNameListPageListResponse() = default;
};
class DescribeNameListTypeListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeNameListTypeListRequest() {}

  explicit DescribeNameListTypeListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeNameListTypeListRequest() = default;
};
class DescribeNameListTypeListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeNameListTypeListResponseBodyResultObject() {}

  explicit DescribeNameListTypeListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeNameListTypeListResponseBodyResultObject() = default;
};
class DescribeNameListTypeListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeNameListTypeListResponseBodyResultObject>> resultObject{};

  DescribeNameListTypeListResponseBody() {}

  explicit DescribeNameListTypeListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeNameListTypeListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNameListTypeListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeNameListTypeListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeNameListTypeListResponseBody() = default;
};
class DescribeNameListTypeListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNameListTypeListResponseBody> body{};

  DescribeNameListTypeListResponse() {}

  explicit DescribeNameListTypeListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNameListTypeListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNameListTypeListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNameListTypeListResponse() = default;
};
class DescribeNameListVariablePageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> name{};
  shared_ptr<string> nameListType{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> value{};

  DescribeNameListVariablePageListRequest() {}

  explicit DescribeNameListVariablePageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameListType) {
      res["nameListType"] = boost::any(*nameListType);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameListType") != m.end() && !m["nameListType"].empty()) {
      nameListType = make_shared<string>(boost::any_cast<string>(m["nameListType"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeNameListVariablePageListRequest() = default;
};
class DescribeNameListVariablePageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> capacity{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> leftCapacity{};
  shared_ptr<string> name{};
  shared_ptr<string> nameListType{};
  shared_ptr<string> refObjId{};
  shared_ptr<long> refObjType{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<long> userId{};

  DescribeNameListVariablePageListResponseBodyResultObject() {}

  explicit DescribeNameListVariablePageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacity) {
      res["capacity"] = boost::any(*capacity);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (leftCapacity) {
      res["leftCapacity"] = boost::any(*leftCapacity);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameListType) {
      res["nameListType"] = boost::any(*nameListType);
    }
    if (refObjId) {
      res["refObjId"] = boost::any(*refObjId);
    }
    if (refObjType) {
      res["refObjType"] = boost::any(*refObjType);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("capacity") != m.end() && !m["capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["capacity"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("leftCapacity") != m.end() && !m["leftCapacity"].empty()) {
      leftCapacity = make_shared<long>(boost::any_cast<long>(m["leftCapacity"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameListType") != m.end() && !m["nameListType"].empty()) {
      nameListType = make_shared<string>(boost::any_cast<string>(m["nameListType"]));
    }
    if (m.find("refObjId") != m.end() && !m["refObjId"].empty()) {
      refObjId = make_shared<string>(boost::any_cast<string>(m["refObjId"]));
    }
    if (m.find("refObjType") != m.end() && !m["refObjType"].empty()) {
      refObjType = make_shared<long>(boost::any_cast<long>(m["refObjType"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~DescribeNameListVariablePageListResponseBodyResultObject() = default;
};
class DescribeNameListVariablePageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeNameListVariablePageListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeNameListVariablePageListResponseBody() {}

  explicit DescribeNameListVariablePageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeNameListVariablePageListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNameListVariablePageListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeNameListVariablePageListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeNameListVariablePageListResponseBody() = default;
};
class DescribeNameListVariablePageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNameListVariablePageListResponseBody> body{};

  DescribeNameListVariablePageListResponse() {}

  explicit DescribeNameListVariablePageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNameListVariablePageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNameListVariablePageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNameListVariablePageListResponse() = default;
};
class DescribeOperationLogPageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> endDate{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<long> startDate{};

  DescribeOperationLogPageListRequest() {}

  explicit DescribeOperationLogPageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (startDate) {
      res["startDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["endDate"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("startDate") != m.end() && !m["startDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["startDate"]));
    }
  }


  virtual ~DescribeOperationLogPageListRequest() = default;
};
class DescribeOperationLogPageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> clientIp{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> newContent{};
  shared_ptr<string> oldContent{};
  shared_ptr<string> operationSummary{};
  shared_ptr<string> operationType{};
  shared_ptr<string> userName{};

  DescribeOperationLogPageListResponseBodyResultObject() {}

  explicit DescribeOperationLogPageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIp) {
      res["clientIp"] = boost::any(*clientIp);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (newContent) {
      res["newContent"] = boost::any(*newContent);
    }
    if (oldContent) {
      res["oldContent"] = boost::any(*oldContent);
    }
    if (operationSummary) {
      res["operationSummary"] = boost::any(*operationSummary);
    }
    if (operationType) {
      res["operationType"] = boost::any(*operationType);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientIp") != m.end() && !m["clientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["clientIp"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("newContent") != m.end() && !m["newContent"].empty()) {
      newContent = make_shared<string>(boost::any_cast<string>(m["newContent"]));
    }
    if (m.find("oldContent") != m.end() && !m["oldContent"].empty()) {
      oldContent = make_shared<string>(boost::any_cast<string>(m["oldContent"]));
    }
    if (m.find("operationSummary") != m.end() && !m["operationSummary"].empty()) {
      operationSummary = make_shared<string>(boost::any_cast<string>(m["operationSummary"]));
    }
    if (m.find("operationType") != m.end() && !m["operationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["operationType"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~DescribeOperationLogPageListResponseBodyResultObject() = default;
};
class DescribeOperationLogPageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeOperationLogPageListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeOperationLogPageListResponseBody() {}

  explicit DescribeOperationLogPageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeOperationLogPageListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOperationLogPageListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeOperationLogPageListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeOperationLogPageListResponseBody() = default;
};
class DescribeOperationLogPageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOperationLogPageListResponseBody> body{};

  DescribeOperationLogPageListResponse() {}

  explicit DescribeOperationLogPageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOperationLogPageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOperationLogPageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOperationLogPageListResponse() = default;
};
class DescribeOperatorListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeOperatorListRequest() {}

  explicit DescribeOperatorListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeOperatorListRequest() = default;
};
class DescribeOperatorListResponseBodyResultObjectOperatorsRightVariables : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldType{};
  shared_ptr<string> fieldValue{};

  DescribeOperatorListResponseBodyResultObjectOperatorsRightVariables() {}

  explicit DescribeOperatorListResponseBodyResultObjectOperatorsRightVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["fieldName"] = boost::any(*fieldName);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldName") != m.end() && !m["fieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["fieldName"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
  }


  virtual ~DescribeOperatorListResponseBodyResultObjectOperatorsRightVariables() = default;
};
class DescribeOperatorListResponseBodyResultObjectOperators : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> hasRightVariable{};
  shared_ptr<string> memo{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeOperatorListResponseBodyResultObjectOperatorsRightVariables>> rightVariables{};

  DescribeOperatorListResponseBodyResultObjectOperators() {}

  explicit DescribeOperatorListResponseBodyResultObjectOperators(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (hasRightVariable) {
      res["hasRightVariable"] = boost::any(*hasRightVariable);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (rightVariables) {
      vector<boost::any> temp1;
      for(auto item1:*rightVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["rightVariables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("hasRightVariable") != m.end() && !m["hasRightVariable"].empty()) {
      hasRightVariable = make_shared<bool>(boost::any_cast<bool>(m["hasRightVariable"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("rightVariables") != m.end() && !m["rightVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["rightVariables"].type()) {
        vector<DescribeOperatorListResponseBodyResultObjectOperatorsRightVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["rightVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOperatorListResponseBodyResultObjectOperatorsRightVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rightVariables = make_shared<vector<DescribeOperatorListResponseBodyResultObjectOperatorsRightVariables>>(expect1);
      }
    }
  }


  virtual ~DescribeOperatorListResponseBodyResultObjectOperators() = default;
};
class DescribeOperatorListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> fieldType{};
  shared_ptr<vector<DescribeOperatorListResponseBodyResultObjectOperators>> operators{};

  DescribeOperatorListResponseBodyResultObject() {}

  explicit DescribeOperatorListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (operators) {
      vector<boost::any> temp1;
      for(auto item1:*operators){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["operators"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("operators") != m.end() && !m["operators"].empty()) {
      if (typeid(vector<boost::any>) == m["operators"].type()) {
        vector<DescribeOperatorListResponseBodyResultObjectOperators> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["operators"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOperatorListResponseBodyResultObjectOperators model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operators = make_shared<vector<DescribeOperatorListResponseBodyResultObjectOperators>>(expect1);
      }
    }
  }


  virtual ~DescribeOperatorListResponseBodyResultObject() = default;
};
class DescribeOperatorListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeOperatorListResponseBodyResultObject>> resultObject{};

  DescribeOperatorListResponseBody() {}

  explicit DescribeOperatorListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeOperatorListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOperatorListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeOperatorListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeOperatorListResponseBody() = default;
};
class DescribeOperatorListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOperatorListResponseBody> body{};

  DescribeOperatorListResponse() {}

  explicit DescribeOperatorListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOperatorListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOperatorListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOperatorListResponse() = default;
};
class DescribeOperatorListBySceneRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> scene{};

  DescribeOperatorListBySceneRequest() {}

  explicit DescribeOperatorListBySceneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["scene"]));
    }
  }


  virtual ~DescribeOperatorListBySceneRequest() = default;
};
class DescribeOperatorListBySceneResponseBodyResultObjectOperatorsRightVariables : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldType{};
  shared_ptr<string> fieldValue{};

  DescribeOperatorListBySceneResponseBodyResultObjectOperatorsRightVariables() {}

  explicit DescribeOperatorListBySceneResponseBodyResultObjectOperatorsRightVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["fieldName"] = boost::any(*fieldName);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldName") != m.end() && !m["fieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["fieldName"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
  }


  virtual ~DescribeOperatorListBySceneResponseBodyResultObjectOperatorsRightVariables() = default;
};
class DescribeOperatorListBySceneResponseBodyResultObjectOperators : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> hasRightVariable{};
  shared_ptr<string> memo{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeOperatorListBySceneResponseBodyResultObjectOperatorsRightVariables>> rightVariables{};

  DescribeOperatorListBySceneResponseBodyResultObjectOperators() {}

  explicit DescribeOperatorListBySceneResponseBodyResultObjectOperators(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (hasRightVariable) {
      res["hasRightVariable"] = boost::any(*hasRightVariable);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (rightVariables) {
      vector<boost::any> temp1;
      for(auto item1:*rightVariables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["rightVariables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("hasRightVariable") != m.end() && !m["hasRightVariable"].empty()) {
      hasRightVariable = make_shared<bool>(boost::any_cast<bool>(m["hasRightVariable"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("rightVariables") != m.end() && !m["rightVariables"].empty()) {
      if (typeid(vector<boost::any>) == m["rightVariables"].type()) {
        vector<DescribeOperatorListBySceneResponseBodyResultObjectOperatorsRightVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["rightVariables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOperatorListBySceneResponseBodyResultObjectOperatorsRightVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rightVariables = make_shared<vector<DescribeOperatorListBySceneResponseBodyResultObjectOperatorsRightVariables>>(expect1);
      }
    }
  }


  virtual ~DescribeOperatorListBySceneResponseBodyResultObjectOperators() = default;
};
class DescribeOperatorListBySceneResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> fieldType{};
  shared_ptr<vector<DescribeOperatorListBySceneResponseBodyResultObjectOperators>> operators{};

  DescribeOperatorListBySceneResponseBodyResultObject() {}

  explicit DescribeOperatorListBySceneResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (operators) {
      vector<boost::any> temp1;
      for(auto item1:*operators){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["operators"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("operators") != m.end() && !m["operators"].empty()) {
      if (typeid(vector<boost::any>) == m["operators"].type()) {
        vector<DescribeOperatorListBySceneResponseBodyResultObjectOperators> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["operators"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOperatorListBySceneResponseBodyResultObjectOperators model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operators = make_shared<vector<DescribeOperatorListBySceneResponseBodyResultObjectOperators>>(expect1);
      }
    }
  }


  virtual ~DescribeOperatorListBySceneResponseBodyResultObject() = default;
};
class DescribeOperatorListBySceneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeOperatorListBySceneResponseBodyResultObject>> resultObject{};

  DescribeOperatorListBySceneResponseBody() {}

  explicit DescribeOperatorListBySceneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeOperatorListBySceneResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOperatorListBySceneResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeOperatorListBySceneResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeOperatorListBySceneResponseBody() = default;
};
class DescribeOperatorListBySceneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOperatorListBySceneResponseBody> body{};

  DescribeOperatorListBySceneResponse() {}

  explicit DescribeOperatorListBySceneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOperatorListBySceneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOperatorListBySceneResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOperatorListBySceneResponse() = default;
};
class DescribeOperatorListByTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeOperatorListByTypeRequest() {}

  explicit DescribeOperatorListByTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeOperatorListByTypeRequest() = default;
};
class DescribeOperatorListByTypeResponseBodyResultObjectOperators : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> hasRightVariable{};
  shared_ptr<string> name{};

  DescribeOperatorListByTypeResponseBodyResultObjectOperators() {}

  explicit DescribeOperatorListByTypeResponseBodyResultObjectOperators(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (hasRightVariable) {
      res["hasRightVariable"] = boost::any(*hasRightVariable);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("hasRightVariable") != m.end() && !m["hasRightVariable"].empty()) {
      hasRightVariable = make_shared<bool>(boost::any_cast<bool>(m["hasRightVariable"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeOperatorListByTypeResponseBodyResultObjectOperators() = default;
};
class DescribeOperatorListByTypeResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> fieldType{};
  shared_ptr<vector<DescribeOperatorListByTypeResponseBodyResultObjectOperators>> operators{};

  DescribeOperatorListByTypeResponseBodyResultObject() {}

  explicit DescribeOperatorListByTypeResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (operators) {
      vector<boost::any> temp1;
      for(auto item1:*operators){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["operators"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("operators") != m.end() && !m["operators"].empty()) {
      if (typeid(vector<boost::any>) == m["operators"].type()) {
        vector<DescribeOperatorListByTypeResponseBodyResultObjectOperators> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["operators"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOperatorListByTypeResponseBodyResultObjectOperators model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operators = make_shared<vector<DescribeOperatorListByTypeResponseBodyResultObjectOperators>>(expect1);
      }
    }
  }


  virtual ~DescribeOperatorListByTypeResponseBodyResultObject() = default;
};
class DescribeOperatorListByTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeOperatorListByTypeResponseBodyResultObject>> resultObject{};

  DescribeOperatorListByTypeResponseBody() {}

  explicit DescribeOperatorListByTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeOperatorListByTypeResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOperatorListByTypeResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeOperatorListByTypeResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeOperatorListByTypeResponseBody() = default;
};
class DescribeOperatorListByTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOperatorListByTypeResponseBody> body{};

  DescribeOperatorListByTypeResponse() {}

  explicit DescribeOperatorListByTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOperatorListByTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOperatorListByTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOperatorListByTypeResponse() = default;
};
class DescribeOssAuthStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeOssAuthStatusRequest() {}

  explicit DescribeOssAuthStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeOssAuthStatusRequest() = default;
};
class DescribeOssAuthStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultObject{};

  DescribeOssAuthStatusResponseBody() {}

  explicit DescribeOssAuthStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<string>(boost::any_cast<string>(m["resultObject"]));
    }
  }


  virtual ~DescribeOssAuthStatusResponseBody() = default;
};
class DescribeOssAuthStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOssAuthStatusResponseBody> body{};

  DescribeOssAuthStatusResponse() {}

  explicit DescribeOssAuthStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOssAuthStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOssAuthStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOssAuthStatusResponse() = default;
};
class DescribeOssPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> scene{};

  DescribeOssPolicyRequest() {}

  explicit DescribeOssPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["scene"]));
    }
  }


  virtual ~DescribeOssPolicyRequest() = default;
};
class DescribeOssPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<string> host{};
  shared_ptr<string> key{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};
  shared_ptr<string> requestId{};

  DescribeOssPolicyResponseBody() {}

  explicit DescribeOssPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DescribeOssPolicyResponseBody() = default;
};
class DescribeOssPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOssPolicyResponseBody> body{};

  DescribeOssPolicyResponse() {}

  explicit DescribeOssPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOssPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOssPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOssPolicyResponse() = default;
};
class DescribeOssTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> fileName{};
  shared_ptr<string> regId{};
  shared_ptr<string> uploadType{};

  DescribeOssTokenRequest() {}

  explicit DescribeOssTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (uploadType) {
      res["uploadType"] = boost::any(*uploadType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("uploadType") != m.end() && !m["uploadType"].empty()) {
      uploadType = make_shared<string>(boost::any_cast<string>(m["uploadType"]));
    }
  }


  virtual ~DescribeOssTokenRequest() = default;
};
class DescribeOssTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<string> host{};
  shared_ptr<string> key{};
  shared_ptr<string> policy{};
  shared_ptr<string> requestId{};
  shared_ptr<string> signature{};
  shared_ptr<string> stsToken{};

  DescribeOssTokenResponseBody() {}

  explicit DescribeOssTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (stsToken) {
      res["StsToken"] = boost::any(*stsToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("StsToken") != m.end() && !m["StsToken"].empty()) {
      stsToken = make_shared<string>(boost::any_cast<string>(m["StsToken"]));
    }
  }


  virtual ~DescribeOssTokenResponseBody() = default;
};
class DescribeOssTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOssTokenResponseBody> body{};

  DescribeOssTokenResponse() {}

  explicit DescribeOssTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOssTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOssTokenResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOssTokenResponse() = default;
};
class DescribeParamByEventCodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> parma{};
  shared_ptr<string> regId{};

  DescribeParamByEventCodesRequest() {}

  explicit DescribeParamByEventCodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (parma) {
      res["parma"] = boost::any(*parma);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("parma") != m.end() && !m["parma"].empty()) {
      parma = make_shared<string>(boost::any_cast<string>(m["parma"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeParamByEventCodesRequest() = default;
};
class DescribeParamByEventCodesResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  DescribeParamByEventCodesResponseBodyResultObject() {}

  explicit DescribeParamByEventCodesResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeParamByEventCodesResponseBodyResultObject() = default;
};
class DescribeParamByEventCodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeParamByEventCodesResponseBodyResultObject>> resultObject{};

  DescribeParamByEventCodesResponseBody() {}

  explicit DescribeParamByEventCodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeParamByEventCodesResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeParamByEventCodesResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeParamByEventCodesResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeParamByEventCodesResponseBody() = default;
};
class DescribeParamByEventCodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeParamByEventCodesResponseBody> body{};

  DescribeParamByEventCodesResponse() {}

  explicit DescribeParamByEventCodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeParamByEventCodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeParamByEventCodesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeParamByEventCodesResponse() = default;
};
class DescribeParamListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> regId{};
  shared_ptr<string> serviceCode{};

  DescribeParamListRequest() {}

  explicit DescribeParamListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (fileUrl) {
      res["fileUrl"] = boost::any(*fileUrl);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (serviceCode) {
      res["serviceCode"] = boost::any(*serviceCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("fileUrl") != m.end() && !m["fileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["fileUrl"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("serviceCode") != m.end() && !m["serviceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["serviceCode"]));
    }
  }


  virtual ~DescribeParamListRequest() = default;
};
class DescribeParamListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeParamListResponseBody() {}

  explicit DescribeParamListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeParamListResponseBody() = default;
};
class DescribeParamListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeParamListResponseBody> body{};

  DescribeParamListResponse() {}

  explicit DescribeParamListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeParamListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeParamListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeParamListResponse() = default;
};
class DescribePocDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> type{};

  DescribePocDetailRequest() {}

  explicit DescribePocDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribePocDetailRequest() = default;
};
class DescribePocDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribePocDetailResponseBody() {}

  explicit DescribePocDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribePocDetailResponseBody() = default;
};
class DescribePocDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePocDetailResponseBody> body{};

  DescribePocDetailResponse() {}

  explicit DescribePocDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePocDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePocDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePocDetailResponse() = default;
};
class DescribePocOssTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribePocOssTokenRequest() {}

  explicit DescribePocOssTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribePocOssTokenRequest() = default;
};
class DescribePocOssTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<string> host{};
  shared_ptr<string> key{};
  shared_ptr<string> policy{};
  shared_ptr<string> requestId{};
  shared_ptr<string> signature{};
  shared_ptr<bool> resultObject{};

  DescribePocOssTokenResponseBody() {}

  explicit DescribePocOssTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribePocOssTokenResponseBody() = default;
};
class DescribePocOssTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePocOssTokenResponseBody> body{};

  DescribePocOssTokenResponse() {}

  explicit DescribePocOssTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePocOssTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePocOssTokenResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePocOssTokenResponse() = default;
};
class DescribePocTaskListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> type{};

  DescribePocTaskListRequest() {}

  explicit DescribePocTaskListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribePocTaskListRequest() = default;
};
class DescribePocTaskListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> fileType{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> updateTime{};

  DescribePocTaskListResponseBodyResultObject() {}

  explicit DescribePocTaskListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (downloadUrl) {
      res["downloadUrl"] = boost::any(*downloadUrl);
    }
    if (fileType) {
      res["fileType"] = boost::any(*fileType);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["taskName"] = boost::any(*taskName);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("downloadUrl") != m.end() && !m["downloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["downloadUrl"]));
    }
    if (m.find("fileType") != m.end() && !m["fileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["fileType"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
    if (m.find("taskName") != m.end() && !m["taskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["taskName"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~DescribePocTaskListResponseBodyResultObject() = default;
};
class DescribePocTaskListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribePocTaskListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribePocTaskListResponseBody() {}

  explicit DescribePocTaskListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribePocTaskListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePocTaskListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribePocTaskListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribePocTaskListResponseBody() = default;
};
class DescribePocTaskListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePocTaskListResponseBody> body{};

  DescribePocTaskListResponse() {}

  explicit DescribePocTaskListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePocTaskListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePocTaskListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePocTaskListResponse() = default;
};
class DescribePrivateStackRequest : public Darabonba::Model {
public:
  shared_ptr<string> regId{};

  DescribePrivateStackRequest() {}

  explicit DescribePrivateStackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribePrivateStackRequest() = default;
};
class DescribePrivateStackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribePrivateStackResponseBody() {}

  explicit DescribePrivateStackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribePrivateStackResponseBody() = default;
};
class DescribePrivateStackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePrivateStackResponseBody> body{};

  DescribePrivateStackResponse() {}

  explicit DescribePrivateStackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePrivateStackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePrivateStackResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePrivateStackResponse() = default;
};
class DescribeQueryVariableDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  DescribeQueryVariableDetailRequest() {}

  explicit DescribeQueryVariableDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeQueryVariableDetailRequest() = default;
};
class DescribeQueryVariableDetailResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceCode{};
  shared_ptr<string> dataSourceName{};
  shared_ptr<string> description{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> expression{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<string> expressionVariable{};
  shared_ptr<long> id{};
  shared_ptr<string> outlier{};
  shared_ptr<string> outputs{};
  shared_ptr<string> title{};

  DescribeQueryVariableDetailResponseBodyResultObject() {}

  explicit DescribeQueryVariableDetailResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceCode) {
      res["dataSourceCode"] = boost::any(*dataSourceCode);
    }
    if (dataSourceName) {
      res["dataSourceName"] = boost::any(*dataSourceName);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (expression) {
      res["expression"] = boost::any(*expression);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (expressionVariable) {
      res["expressionVariable"] = boost::any(*expressionVariable);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputs) {
      res["outputs"] = boost::any(*outputs);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataSourceCode") != m.end() && !m["dataSourceCode"].empty()) {
      dataSourceCode = make_shared<long>(boost::any_cast<long>(m["dataSourceCode"]));
    }
    if (m.find("dataSourceName") != m.end() && !m["dataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["dataSourceName"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("expression") != m.end() && !m["expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["expression"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("expressionVariable") != m.end() && !m["expressionVariable"].empty()) {
      expressionVariable = make_shared<string>(boost::any_cast<string>(m["expressionVariable"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputs") != m.end() && !m["outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["outputs"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~DescribeQueryVariableDetailResponseBodyResultObject() = default;
};
class DescribeQueryVariableDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeQueryVariableDetailResponseBodyResultObject> resultObject{};

  DescribeQueryVariableDetailResponseBody() {}

  explicit DescribeQueryVariableDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeQueryVariableDetailResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeQueryVariableDetailResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeQueryVariableDetailResponseBody() = default;
};
class DescribeQueryVariableDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeQueryVariableDetailResponseBody> body{};

  DescribeQueryVariableDetailResponse() {}

  explicit DescribeQueryVariableDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeQueryVariableDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeQueryVariableDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeQueryVariableDetailResponse() = default;
};
class DescribeQueryVariablePageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> dataSourceCode{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};

  DescribeQueryVariablePageListRequest() {}

  explicit DescribeQueryVariablePageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (dataSourceCode) {
      res["dataSourceCode"] = boost::any(*dataSourceCode);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("dataSourceCode") != m.end() && !m["dataSourceCode"].empty()) {
      dataSourceCode = make_shared<string>(boost::any_cast<string>(m["dataSourceCode"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeQueryVariablePageListRequest() = default;
};
class DescribeQueryVariablePageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceCode{};
  shared_ptr<string> dataSourceName{};
  shared_ptr<string> description{};
  shared_ptr<string> eventName{};
  shared_ptr<string> fieldType{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<long> total{};
  shared_ptr<long> version{};

  DescribeQueryVariablePageListResponseBodyResultObject() {}

  explicit DescribeQueryVariablePageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceCode) {
      res["dataSourceCode"] = boost::any(*dataSourceCode);
    }
    if (dataSourceName) {
      res["dataSourceName"] = boost::any(*dataSourceName);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataSourceCode") != m.end() && !m["dataSourceCode"].empty()) {
      dataSourceCode = make_shared<long>(boost::any_cast<long>(m["dataSourceCode"]));
    }
    if (m.find("dataSourceName") != m.end() && !m["dataSourceName"].empty()) {
      dataSourceName = make_shared<string>(boost::any_cast<string>(m["dataSourceName"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~DescribeQueryVariablePageListResponseBodyResultObject() = default;
};
class DescribeQueryVariablePageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeQueryVariablePageListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeQueryVariablePageListResponseBody() {}

  explicit DescribeQueryVariablePageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeQueryVariablePageListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeQueryVariablePageListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeQueryVariablePageListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeQueryVariablePageListResponseBody() = default;
};
class DescribeQueryVariablePageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeQueryVariablePageListResponseBody> body{};

  DescribeQueryVariablePageListResponse() {}

  explicit DescribeQueryVariablePageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeQueryVariablePageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeQueryVariablePageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeQueryVariablePageListResponse() = default;
};
class DescribeRecommendSceneVariablesRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<long> sampleId{};

  DescribeRecommendSceneVariablesRequest() {}

  explicit DescribeRecommendSceneVariablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (sampleId) {
      res["sampleId"] = boost::any(*sampleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("sampleId") != m.end() && !m["sampleId"].empty()) {
      sampleId = make_shared<long>(boost::any_cast<long>(m["sampleId"]));
    }
  }


  virtual ~DescribeRecommendSceneVariablesRequest() = default;
};
class DescribeRecommendSceneVariablesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeRecommendSceneVariablesResponseBody() {}

  explicit DescribeRecommendSceneVariablesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeRecommendSceneVariablesResponseBody() = default;
};
class DescribeRecommendSceneVariablesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRecommendSceneVariablesResponseBody> body{};

  DescribeRecommendSceneVariablesResponse() {}

  explicit DescribeRecommendSceneVariablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecommendSceneVariablesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecommendSceneVariablesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecommendSceneVariablesResponse() = default;
};
class DescribeRecommendTaskDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<long> taskId{};

  DescribeRecommendTaskDetailRequest() {}

  explicit DescribeRecommendTaskDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["taskId"]));
    }
  }


  virtual ~DescribeRecommendTaskDetailRequest() = default;
};
class DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOsRecommendRules : public Darabonba::Model {
public:
  shared_ptr<string> left{};
  shared_ptr<string> operator_{};
  shared_ptr<string> right{};

  DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOsRecommendRules() {}

  explicit DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOsRecommendRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (left) {
      res["left"] = boost::any(*left);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (right) {
      res["right"] = boost::any(*right);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("left") != m.end() && !m["left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["left"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("right") != m.end() && !m["right"].empty()) {
      right = make_shared<string>(boost::any_cast<string>(m["right"]));
    }
  }


  virtual ~DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOsRecommendRules() = default;
};
class DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOs : public Darabonba::Model {
public:
  shared_ptr<string> computeExpression{};
  shared_ptr<long> hitSample{};
  shared_ptr<long> id{};
  shared_ptr<long> notHitSample{};
  shared_ptr<vector<DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOsRecommendRules>> recommendRules{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> status{};
  shared_ptr<string> velocities{};

  DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOs() {}

  explicit DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (computeExpression) {
      res["computeExpression"] = boost::any(*computeExpression);
    }
    if (hitSample) {
      res["hitSample"] = boost::any(*hitSample);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (notHitSample) {
      res["notHitSample"] = boost::any(*notHitSample);
    }
    if (recommendRules) {
      vector<boost::any> temp1;
      for(auto item1:*recommendRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["recommendRules"] = boost::any(temp1);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (velocities) {
      res["velocities"] = boost::any(*velocities);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("computeExpression") != m.end() && !m["computeExpression"].empty()) {
      computeExpression = make_shared<string>(boost::any_cast<string>(m["computeExpression"]));
    }
    if (m.find("hitSample") != m.end() && !m["hitSample"].empty()) {
      hitSample = make_shared<long>(boost::any_cast<long>(m["hitSample"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("notHitSample") != m.end() && !m["notHitSample"].empty()) {
      notHitSample = make_shared<long>(boost::any_cast<long>(m["notHitSample"]));
    }
    if (m.find("recommendRules") != m.end() && !m["recommendRules"].empty()) {
      if (typeid(vector<boost::any>) == m["recommendRules"].type()) {
        vector<DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOsRecommendRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["recommendRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOsRecommendRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommendRules = make_shared<vector<DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOsRecommendRules>>(expect1);
      }
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("velocities") != m.end() && !m["velocities"].empty()) {
      velocities = make_shared<string>(boost::any_cast<string>(m["velocities"]));
    }
  }


  virtual ~DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOs() = default;
};
class DescribeRecommendTaskDetailResponseBodyResultObjectRecommendVariableDTOs : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  DescribeRecommendTaskDetailResponseBodyResultObjectRecommendVariableDTOs() {}

  explicit DescribeRecommendTaskDetailResponseBodyResultObjectRecommendVariableDTOs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~DescribeRecommendTaskDetailResponseBodyResultObjectRecommendVariableDTOs() = default;
};
class DescribeRecommendTaskDetailResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<vector<string>> expectVelocities{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> normalSize{};
  shared_ptr<vector<DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOs>> recommendRuleDTOs{};
  shared_ptr<vector<DescribeRecommendTaskDetailResponseBodyResultObjectRecommendVariableDTOs>> recommendVariableDTOs{};
  shared_ptr<long> riskSize{};
  shared_ptr<string> sampleName{};
  shared_ptr<string> sampleScene{};
  shared_ptr<string> sampleSceneName{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskStatus{};

  DescribeRecommendTaskDetailResponseBodyResultObject() {}

  explicit DescribeRecommendTaskDetailResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (expectVelocities) {
      res["expectVelocities"] = boost::any(*expectVelocities);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (normalSize) {
      res["normalSize"] = boost::any(*normalSize);
    }
    if (recommendRuleDTOs) {
      vector<boost::any> temp1;
      for(auto item1:*recommendRuleDTOs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["recommendRuleDTOs"] = boost::any(temp1);
    }
    if (recommendVariableDTOs) {
      vector<boost::any> temp1;
      for(auto item1:*recommendVariableDTOs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["recommendVariableDTOs"] = boost::any(temp1);
    }
    if (riskSize) {
      res["riskSize"] = boost::any(*riskSize);
    }
    if (sampleName) {
      res["sampleName"] = boost::any(*sampleName);
    }
    if (sampleScene) {
      res["sampleScene"] = boost::any(*sampleScene);
    }
    if (sampleSceneName) {
      res["sampleSceneName"] = boost::any(*sampleSceneName);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["taskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["taskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    vector<string> toVec1;
    if (typeid(vector<boost::any>) == m["expectVelocities"].type()) {
      vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["expectVelocities"]);
      for (auto item:vec1) {
         toVec1.push_back(boost::any_cast<string>(item));
      }
    }
    expectVelocities = make_shared<vector<string>>(toVec1);
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("normalSize") != m.end() && !m["normalSize"].empty()) {
      normalSize = make_shared<long>(boost::any_cast<long>(m["normalSize"]));
    }
    if (m.find("recommendRuleDTOs") != m.end() && !m["recommendRuleDTOs"].empty()) {
      if (typeid(vector<boost::any>) == m["recommendRuleDTOs"].type()) {
        vector<DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["recommendRuleDTOs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommendRuleDTOs = make_shared<vector<DescribeRecommendTaskDetailResponseBodyResultObjectRecommendRuleDTOs>>(expect1);
      }
    }
    if (m.find("recommendVariableDTOs") != m.end() && !m["recommendVariableDTOs"].empty()) {
      if (typeid(vector<boost::any>) == m["recommendVariableDTOs"].type()) {
        vector<DescribeRecommendTaskDetailResponseBodyResultObjectRecommendVariableDTOs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["recommendVariableDTOs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecommendTaskDetailResponseBodyResultObjectRecommendVariableDTOs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommendVariableDTOs = make_shared<vector<DescribeRecommendTaskDetailResponseBodyResultObjectRecommendVariableDTOs>>(expect1);
      }
    }
    if (m.find("riskSize") != m.end() && !m["riskSize"].empty()) {
      riskSize = make_shared<long>(boost::any_cast<long>(m["riskSize"]));
    }
    if (m.find("sampleName") != m.end() && !m["sampleName"].empty()) {
      sampleName = make_shared<string>(boost::any_cast<string>(m["sampleName"]));
    }
    if (m.find("sampleScene") != m.end() && !m["sampleScene"].empty()) {
      sampleScene = make_shared<string>(boost::any_cast<string>(m["sampleScene"]));
    }
    if (m.find("sampleSceneName") != m.end() && !m["sampleSceneName"].empty()) {
      sampleSceneName = make_shared<string>(boost::any_cast<string>(m["sampleSceneName"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["taskId"]));
    }
    if (m.find("taskName") != m.end() && !m["taskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["taskName"]));
    }
    if (m.find("taskStatus") != m.end() && !m["taskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["taskStatus"]));
    }
  }


  virtual ~DescribeRecommendTaskDetailResponseBodyResultObject() = default;
};
class DescribeRecommendTaskDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRecommendTaskDetailResponseBodyResultObject> resultObject{};

  DescribeRecommendTaskDetailResponseBody() {}

  explicit DescribeRecommendTaskDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeRecommendTaskDetailResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeRecommendTaskDetailResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeRecommendTaskDetailResponseBody() = default;
};
class DescribeRecommendTaskDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRecommendTaskDetailResponseBody> body{};

  DescribeRecommendTaskDetailResponse() {}

  explicit DescribeRecommendTaskDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecommendTaskDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecommendTaskDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecommendTaskDetailResponse() = default;
};
class DescribeRecommendTaskPageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> taskName{};

  DescribeRecommendTaskPageListRequest() {}

  explicit DescribeRecommendTaskPageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (taskName) {
      res["taskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("taskName") != m.end() && !m["taskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["taskName"]));
    }
  }


  virtual ~DescribeRecommendTaskPageListRequest() = default;
};
class DescribeRecommendTaskPageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<string>> expectVelocities{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> normalCount{};
  shared_ptr<long> normalSize{};
  shared_ptr<long> riskCount{};
  shared_ptr<long> riskSize{};
  shared_ptr<string> sampleName{};
  shared_ptr<string> sampleScene{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskStatus{};

  DescribeRecommendTaskPageListResponseBodyResultObject() {}

  explicit DescribeRecommendTaskPageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expectVelocities) {
      res["expectVelocities"] = boost::any(*expectVelocities);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (normalCount) {
      res["normalCount"] = boost::any(*normalCount);
    }
    if (normalSize) {
      res["normalSize"] = boost::any(*normalSize);
    }
    if (riskCount) {
      res["riskCount"] = boost::any(*riskCount);
    }
    if (riskSize) {
      res["riskSize"] = boost::any(*riskSize);
    }
    if (sampleName) {
      res["sampleName"] = boost::any(*sampleName);
    }
    if (sampleScene) {
      res["sampleScene"] = boost::any(*sampleScene);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["taskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["taskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    vector<string> toVec1;
    if (typeid(vector<boost::any>) == m["expectVelocities"].type()) {
      vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["expectVelocities"]);
      for (auto item:vec1) {
         toVec1.push_back(boost::any_cast<string>(item));
      }
    }
    expectVelocities = make_shared<vector<string>>(toVec1);
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("normalCount") != m.end() && !m["normalCount"].empty()) {
      normalCount = make_shared<long>(boost::any_cast<long>(m["normalCount"]));
    }
    if (m.find("normalSize") != m.end() && !m["normalSize"].empty()) {
      normalSize = make_shared<long>(boost::any_cast<long>(m["normalSize"]));
    }
    if (m.find("riskCount") != m.end() && !m["riskCount"].empty()) {
      riskCount = make_shared<long>(boost::any_cast<long>(m["riskCount"]));
    }
    if (m.find("riskSize") != m.end() && !m["riskSize"].empty()) {
      riskSize = make_shared<long>(boost::any_cast<long>(m["riskSize"]));
    }
    if (m.find("sampleName") != m.end() && !m["sampleName"].empty()) {
      sampleName = make_shared<string>(boost::any_cast<string>(m["sampleName"]));
    }
    if (m.find("sampleScene") != m.end() && !m["sampleScene"].empty()) {
      sampleScene = make_shared<string>(boost::any_cast<string>(m["sampleScene"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["taskId"]));
    }
    if (m.find("taskName") != m.end() && !m["taskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["taskName"]));
    }
    if (m.find("taskStatus") != m.end() && !m["taskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["taskStatus"]));
    }
  }


  virtual ~DescribeRecommendTaskPageListResponseBodyResultObject() = default;
};
class DescribeRecommendTaskPageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeRecommendTaskPageListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeRecommendTaskPageListResponseBody() {}

  explicit DescribeRecommendTaskPageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeRecommendTaskPageListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecommendTaskPageListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeRecommendTaskPageListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeRecommendTaskPageListResponseBody() = default;
};
class DescribeRecommendTaskPageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRecommendTaskPageListResponseBody> body{};

  DescribeRecommendTaskPageListResponse() {}

  explicit DescribeRecommendTaskPageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecommendTaskPageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecommendTaskPageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecommendTaskPageListResponse() = default;
};
class DescribeRecommendVariablesVelocityRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<long> taskId{};
  shared_ptr<string> variableIdsStr{};

  DescribeRecommendVariablesVelocityRequest() {}

  explicit DescribeRecommendVariablesVelocityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (variableIdsStr) {
      res["variableIdsStr"] = boost::any(*variableIdsStr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["taskId"]));
    }
    if (m.find("variableIdsStr") != m.end() && !m["variableIdsStr"].empty()) {
      variableIdsStr = make_shared<string>(boost::any_cast<string>(m["variableIdsStr"]));
    }
  }


  virtual ~DescribeRecommendVariablesVelocityRequest() = default;
};
class DescribeRecommendVariablesVelocityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeRecommendVariablesVelocityResponseBody() {}

  explicit DescribeRecommendVariablesVelocityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeRecommendVariablesVelocityResponseBody() = default;
};
class DescribeRecommendVariablesVelocityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRecommendVariablesVelocityResponseBody> body{};

  DescribeRecommendVariablesVelocityResponse() {}

  explicit DescribeRecommendVariablesVelocityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecommendVariablesVelocityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecommendVariablesVelocityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecommendVariablesVelocityResponse() = default;
};
class DescribeRecommendVelocitiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> code{};
  shared_ptr<string> regId{};
  shared_ptr<string> type{};

  DescribeRecommendVelocitiesRequest() {}

  explicit DescribeRecommendVelocitiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeRecommendVelocitiesRequest() = default;
};
class DescribeRecommendVelocitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeRecommendVelocitiesResponseBody() {}

  explicit DescribeRecommendVelocitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeRecommendVelocitiesResponseBody() = default;
};
class DescribeRecommendVelocitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRecommendVelocitiesResponseBody> body{};

  DescribeRecommendVelocitiesResponse() {}

  explicit DescribeRecommendVelocitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecommendVelocitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecommendVelocitiesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecommendVelocitiesResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeRequestHitRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> sRequestId{};

  DescribeRequestHitRequest() {}

  explicit DescribeRequestHitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (sRequestId) {
      res["sRequestId"] = boost::any(*sRequestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("sRequestId") != m.end() && !m["sRequestId"].empty()) {
      sRequestId = make_shared<string>(boost::any_cast<string>(m["sRequestId"]));
    }
  }


  virtual ~DescribeRequestHitRequest() = default;
};
class DescribeRequestHitResponseBodyResultObjectRuleHitRecords : public Darabonba::Model {
public:
  shared_ptr<long> cost{};
  shared_ptr<bool> hitSuccessful{};
  shared_ptr<bool> isShowDetail{};
  shared_ptr<long> order{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleSnapshotId{};
  shared_ptr<string> ruleStatus{};

  DescribeRequestHitResponseBodyResultObjectRuleHitRecords() {}

  explicit DescribeRequestHitResponseBodyResultObjectRuleHitRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (hitSuccessful) {
      res["hitSuccessful"] = boost::any(*hitSuccessful);
    }
    if (isShowDetail) {
      res["isShowDetail"] = boost::any(*isShowDetail);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleSnapshotId) {
      res["ruleSnapshotId"] = boost::any(*ruleSnapshotId);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("hitSuccessful") != m.end() && !m["hitSuccessful"].empty()) {
      hitSuccessful = make_shared<bool>(boost::any_cast<bool>(m["hitSuccessful"]));
    }
    if (m.find("isShowDetail") != m.end() && !m["isShowDetail"].empty()) {
      isShowDetail = make_shared<bool>(boost::any_cast<bool>(m["isShowDetail"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["order"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleSnapshotId") != m.end() && !m["ruleSnapshotId"].empty()) {
      ruleSnapshotId = make_shared<string>(boost::any_cast<string>(m["ruleSnapshotId"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
  }


  virtual ~DescribeRequestHitResponseBodyResultObjectRuleHitRecords() = default;
};
class DescribeRequestHitResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> inputs{};
  shared_ptr<string> outputs{};
  shared_ptr<long> requestTime{};
  shared_ptr<vector<DescribeRequestHitResponseBodyResultObjectRuleHitRecords>> ruleHitRecords{};
  shared_ptr<string> sRequestId{};
  shared_ptr<long> totalCost{};

  DescribeRequestHitResponseBodyResultObject() {}

  explicit DescribeRequestHitResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (outputs) {
      res["outputs"] = boost::any(*outputs);
    }
    if (requestTime) {
      res["requestTime"] = boost::any(*requestTime);
    }
    if (ruleHitRecords) {
      vector<boost::any> temp1;
      for(auto item1:*ruleHitRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ruleHitRecords"] = boost::any(temp1);
    }
    if (sRequestId) {
      res["sRequestId"] = boost::any(*sRequestId);
    }
    if (totalCost) {
      res["totalCost"] = boost::any(*totalCost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("outputs") != m.end() && !m["outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["outputs"]));
    }
    if (m.find("requestTime") != m.end() && !m["requestTime"].empty()) {
      requestTime = make_shared<long>(boost::any_cast<long>(m["requestTime"]));
    }
    if (m.find("ruleHitRecords") != m.end() && !m["ruleHitRecords"].empty()) {
      if (typeid(vector<boost::any>) == m["ruleHitRecords"].type()) {
        vector<DescribeRequestHitResponseBodyResultObjectRuleHitRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ruleHitRecords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRequestHitResponseBodyResultObjectRuleHitRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleHitRecords = make_shared<vector<DescribeRequestHitResponseBodyResultObjectRuleHitRecords>>(expect1);
      }
    }
    if (m.find("sRequestId") != m.end() && !m["sRequestId"].empty()) {
      sRequestId = make_shared<string>(boost::any_cast<string>(m["sRequestId"]));
    }
    if (m.find("totalCost") != m.end() && !m["totalCost"].empty()) {
      totalCost = make_shared<long>(boost::any_cast<long>(m["totalCost"]));
    }
  }


  virtual ~DescribeRequestHitResponseBodyResultObject() = default;
};
class DescribeRequestHitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRequestHitResponseBodyResultObject> resultObject{};

  DescribeRequestHitResponseBody() {}

  explicit DescribeRequestHitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeRequestHitResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeRequestHitResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeRequestHitResponseBody() = default;
};
class DescribeRequestHitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRequestHitResponseBody> body{};

  DescribeRequestHitResponse() {}

  explicit DescribeRequestHitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRequestHitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRequestHitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRequestHitResponse() = default;
};
class DescribeRequestPeakReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeRequestPeakReportRequest() {}

  explicit DescribeRequestPeakReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeRequestPeakReportRequest() = default;
};
class DescribeRequestPeakReportResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> ratio{};
  shared_ptr<string> value{};

  DescribeRequestPeakReportResponseBodyResultObject() {}

  explicit DescribeRequestPeakReportResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ratio) {
      res["ratio"] = boost::any(*ratio);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ratio") != m.end() && !m["ratio"].empty()) {
      ratio = make_shared<string>(boost::any_cast<string>(m["ratio"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeRequestPeakReportResponseBodyResultObject() = default;
};
class DescribeRequestPeakReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRequestPeakReportResponseBodyResultObject>> resultObject{};
  shared_ptr<bool> success{};

  DescribeRequestPeakReportResponseBody() {}

  explicit DescribeRequestPeakReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeRequestPeakReportResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRequestPeakReportResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeRequestPeakReportResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeRequestPeakReportResponseBody() = default;
};
class DescribeRequestPeakReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRequestPeakReportResponseBody> body{};

  DescribeRequestPeakReportResponse() {}

  explicit DescribeRequestPeakReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRequestPeakReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRequestPeakReportResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRequestPeakReportResponse() = default;
};
class DescribeResultCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> regId{};

  DescribeResultCountRequest() {}

  explicit DescribeResultCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeResultCountRequest() = default;
};
class DescribeResultCountResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> result{};
  shared_ptr<string> total{};

  DescribeResultCountResponseBodyResultObject() {}

  explicit DescribeResultCountResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<string>(boost::any_cast<string>(m["total"]));
    }
  }


  virtual ~DescribeResultCountResponseBodyResultObject() = default;
};
class DescribeResultCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeResultCountResponseBodyResultObject>> resultObject{};
  shared_ptr<bool> success{};

  DescribeResultCountResponseBody() {}

  explicit DescribeResultCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeResultCountResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResultCountResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeResultCountResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeResultCountResponseBody() = default;
};
class DescribeResultCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResultCountResponseBody> body{};

  DescribeResultCountResponse() {}

  explicit DescribeResultCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResultCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResultCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResultCountResponse() = default;
};
class DescribeRiskLineChartRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> regId{};

  DescribeRiskLineChartRequest() {}

  explicit DescribeRiskLineChartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeRiskLineChartRequest() = default;
};
class DescribeRiskLineChartResponseBodyResultObjectSeries : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};
  shared_ptr<string> name{};

  DescribeRiskLineChartResponseBodyResultObjectSeries() {}

  explicit DescribeRiskLineChartResponseBodyResultObjectSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeRiskLineChartResponseBodyResultObjectSeries() = default;
};
class DescribeRiskLineChartResponseBodyResultObjectXaxis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};

  DescribeRiskLineChartResponseBodyResultObjectXaxis() {}

  explicit DescribeRiskLineChartResponseBodyResultObjectXaxis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRiskLineChartResponseBodyResultObjectXaxis() = default;
};
class DescribeRiskLineChartResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRiskLineChartResponseBodyResultObjectSeries>> series{};
  shared_ptr<DescribeRiskLineChartResponseBodyResultObjectXaxis> xaxis{};

  DescribeRiskLineChartResponseBodyResultObject() {}

  explicit DescribeRiskLineChartResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    if (xaxis) {
      res["xaxis"] = xaxis ? boost::any(xaxis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeRiskLineChartResponseBodyResultObjectSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskLineChartResponseBodyResultObjectSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeRiskLineChartResponseBodyResultObjectSeries>>(expect1);
      }
    }
    if (m.find("xaxis") != m.end() && !m["xaxis"].empty()) {
      if (typeid(map<string, boost::any>) == m["xaxis"].type()) {
        DescribeRiskLineChartResponseBodyResultObjectXaxis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["xaxis"]));
        xaxis = make_shared<DescribeRiskLineChartResponseBodyResultObjectXaxis>(model1);
      }
    }
  }


  virtual ~DescribeRiskLineChartResponseBodyResultObject() = default;
};
class DescribeRiskLineChartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRiskLineChartResponseBodyResultObject> resultObject{};
  shared_ptr<bool> success{};

  DescribeRiskLineChartResponseBody() {}

  explicit DescribeRiskLineChartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeRiskLineChartResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeRiskLineChartResponseBodyResultObject>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeRiskLineChartResponseBody() = default;
};
class DescribeRiskLineChartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRiskLineChartResponseBody> body{};

  DescribeRiskLineChartResponse() {}

  explicit DescribeRiskLineChartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRiskLineChartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRiskLineChartResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRiskLineChartResponse() = default;
};
class DescribeRuleBarChartRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> regId{};

  DescribeRuleBarChartRequest() {}

  explicit DescribeRuleBarChartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeRuleBarChartRequest() = default;
};
class DescribeRuleBarChartResponseBodyResultObjectSeriesData : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<long> num{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> status{};

  DescribeRuleBarChartResponseBodyResultObjectSeriesData() {}

  explicit DescribeRuleBarChartResponseBodyResultObjectSeriesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (num) {
      res["num"] = boost::any(*num);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("num") != m.end() && !m["num"].empty()) {
      num = make_shared<long>(boost::any_cast<long>(m["num"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~DescribeRuleBarChartResponseBodyResultObjectSeriesData() = default;
};
class DescribeRuleBarChartResponseBodyResultObjectSeries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRuleBarChartResponseBodyResultObjectSeriesData>> data{};
  shared_ptr<string> type{};

  DescribeRuleBarChartResponseBodyResultObjectSeries() {}

  explicit DescribeRuleBarChartResponseBodyResultObjectSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<DescribeRuleBarChartResponseBodyResultObjectSeriesData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRuleBarChartResponseBodyResultObjectSeriesData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeRuleBarChartResponseBodyResultObjectSeriesData>>(expect1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeRuleBarChartResponseBodyResultObjectSeries() = default;
};
class DescribeRuleBarChartResponseBodyResultObjectYaxis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};

  DescribeRuleBarChartResponseBodyResultObjectYaxis() {}

  explicit DescribeRuleBarChartResponseBodyResultObjectYaxis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRuleBarChartResponseBodyResultObjectYaxis() = default;
};
class DescribeRuleBarChartResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRuleBarChartResponseBodyResultObjectSeries>> series{};
  shared_ptr<DescribeRuleBarChartResponseBodyResultObjectYaxis> yaxis{};

  DescribeRuleBarChartResponseBodyResultObject() {}

  explicit DescribeRuleBarChartResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    if (yaxis) {
      res["yaxis"] = yaxis ? boost::any(yaxis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeRuleBarChartResponseBodyResultObjectSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRuleBarChartResponseBodyResultObjectSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeRuleBarChartResponseBodyResultObjectSeries>>(expect1);
      }
    }
    if (m.find("yaxis") != m.end() && !m["yaxis"].empty()) {
      if (typeid(map<string, boost::any>) == m["yaxis"].type()) {
        DescribeRuleBarChartResponseBodyResultObjectYaxis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["yaxis"]));
        yaxis = make_shared<DescribeRuleBarChartResponseBodyResultObjectYaxis>(model1);
      }
    }
  }


  virtual ~DescribeRuleBarChartResponseBodyResultObject() = default;
};
class DescribeRuleBarChartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRuleBarChartResponseBodyResultObject> resultObject{};
  shared_ptr<bool> success{};

  DescribeRuleBarChartResponseBody() {}

  explicit DescribeRuleBarChartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeRuleBarChartResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeRuleBarChartResponseBodyResultObject>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeRuleBarChartResponseBody() = default;
};
class DescribeRuleBarChartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleBarChartResponseBody> body{};

  DescribeRuleBarChartResponse() {}

  explicit DescribeRuleBarChartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleBarChartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleBarChartResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleBarChartResponse() = default;
};
class DescribeRuleCountByUserIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> regId{};

  DescribeRuleCountByUserIdRequest() {}

  explicit DescribeRuleCountByUserIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeRuleCountByUserIdRequest() = default;
};
class DescribeRuleCountByUserIdResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<bool> limit{};
  shared_ptr<long> maxTotalItem{};
  shared_ptr<long> totalItem{};

  DescribeRuleCountByUserIdResponseBodyResultObject() {}

  explicit DescribeRuleCountByUserIdResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (limit) {
      res["limit"] = boost::any(*limit);
    }
    if (maxTotalItem) {
      res["maxTotalItem"] = boost::any(*maxTotalItem);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("limit") != m.end() && !m["limit"].empty()) {
      limit = make_shared<bool>(boost::any_cast<bool>(m["limit"]));
    }
    if (m.find("maxTotalItem") != m.end() && !m["maxTotalItem"].empty()) {
      maxTotalItem = make_shared<long>(boost::any_cast<long>(m["maxTotalItem"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
  }


  virtual ~DescribeRuleCountByUserIdResponseBodyResultObject() = default;
};
class DescribeRuleCountByUserIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRuleCountByUserIdResponseBodyResultObject> resultObject{};

  DescribeRuleCountByUserIdResponseBody() {}

  explicit DescribeRuleCountByUserIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeRuleCountByUserIdResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeRuleCountByUserIdResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeRuleCountByUserIdResponseBody() = default;
};
class DescribeRuleCountByUserIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleCountByUserIdResponseBody> body{};

  DescribeRuleCountByUserIdResponse() {}

  explicit DescribeRuleCountByUserIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleCountByUserIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleCountByUserIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleCountByUserIdResponse() = default;
};
class DescribeRuleDetailByRuleIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> consoleRuleId{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleId{};
  shared_ptr<long> ruleVersionId{};

  DescribeRuleDetailByRuleIdRequest() {}

  explicit DescribeRuleDetailByRuleIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleVersionId) {
      res["ruleVersionId"] = boost::any(*ruleVersionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleVersionId") != m.end() && !m["ruleVersionId"].empty()) {
      ruleVersionId = make_shared<long>(boost::any_cast<long>(m["ruleVersionId"]));
    }
  }


  virtual ~DescribeRuleDetailByRuleIdRequest() = default;
};
class DescribeRuleDetailByRuleIdResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> bizVersion{};
  shared_ptr<long> consoleRuleId{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> logicExpression{};
  shared_ptr<string> mainEventCode{};
  shared_ptr<string> memo{};
  shared_ptr<map<string, boost::any>> ruleActionMap{};
  shared_ptr<string> ruleActions{};
  shared_ptr<string> ruleExpressions{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};
  shared_ptr<long> ruleVersionId{};

  DescribeRuleDetailByRuleIdResponseBodyResultObject() {}

  explicit DescribeRuleDetailByRuleIdResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizVersion) {
      res["bizVersion"] = boost::any(*bizVersion);
    }
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (logicExpression) {
      res["logicExpression"] = boost::any(*logicExpression);
    }
    if (mainEventCode) {
      res["mainEventCode"] = boost::any(*mainEventCode);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (ruleActionMap) {
      res["ruleActionMap"] = boost::any(*ruleActionMap);
    }
    if (ruleActions) {
      res["ruleActions"] = boost::any(*ruleActions);
    }
    if (ruleExpressions) {
      res["ruleExpressions"] = boost::any(*ruleExpressions);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    if (ruleVersionId) {
      res["ruleVersionId"] = boost::any(*ruleVersionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizVersion") != m.end() && !m["bizVersion"].empty()) {
      bizVersion = make_shared<string>(boost::any_cast<string>(m["bizVersion"]));
    }
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("logicExpression") != m.end() && !m["logicExpression"].empty()) {
      logicExpression = make_shared<string>(boost::any_cast<string>(m["logicExpression"]));
    }
    if (m.find("mainEventCode") != m.end() && !m["mainEventCode"].empty()) {
      mainEventCode = make_shared<string>(boost::any_cast<string>(m["mainEventCode"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("ruleActionMap") != m.end() && !m["ruleActionMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ruleActionMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      ruleActionMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ruleActions") != m.end() && !m["ruleActions"].empty()) {
      ruleActions = make_shared<string>(boost::any_cast<string>(m["ruleActions"]));
    }
    if (m.find("ruleExpressions") != m.end() && !m["ruleExpressions"].empty()) {
      ruleExpressions = make_shared<string>(boost::any_cast<string>(m["ruleExpressions"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
    if (m.find("ruleVersionId") != m.end() && !m["ruleVersionId"].empty()) {
      ruleVersionId = make_shared<long>(boost::any_cast<long>(m["ruleVersionId"]));
    }
  }


  virtual ~DescribeRuleDetailByRuleIdResponseBodyResultObject() = default;
};
class DescribeRuleDetailByRuleIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRuleDetailByRuleIdResponseBodyResultObject> resultObject{};

  DescribeRuleDetailByRuleIdResponseBody() {}

  explicit DescribeRuleDetailByRuleIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeRuleDetailByRuleIdResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeRuleDetailByRuleIdResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeRuleDetailByRuleIdResponseBody() = default;
};
class DescribeRuleDetailByRuleIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleDetailByRuleIdResponseBody> body{};

  DescribeRuleDetailByRuleIdResponse() {}

  explicit DescribeRuleDetailByRuleIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleDetailByRuleIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleDetailByRuleIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleDetailByRuleIdResponse() = default;
};
class DescribeRuleHitRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleSnapshotId{};
  shared_ptr<string> sRequestId{};

  DescribeRuleHitRequest() {}

  explicit DescribeRuleHitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleSnapshotId) {
      res["ruleSnapshotId"] = boost::any(*ruleSnapshotId);
    }
    if (sRequestId) {
      res["sRequestId"] = boost::any(*sRequestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleSnapshotId") != m.end() && !m["ruleSnapshotId"].empty()) {
      ruleSnapshotId = make_shared<string>(boost::any_cast<string>(m["ruleSnapshotId"]));
    }
    if (m.find("sRequestId") != m.end() && !m["sRequestId"].empty()) {
      sRequestId = make_shared<string>(boost::any_cast<string>(m["sRequestId"]));
    }
  }


  virtual ~DescribeRuleHitRequest() = default;
};
class DescribeRuleHitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, boost::any>> resultObject{};

  DescribeRuleHitResponseBody() {}

  explicit DescribeRuleHitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["resultObject"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      resultObject = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeRuleHitResponseBody() = default;
};
class DescribeRuleHitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleHitResponseBody> body{};

  DescribeRuleHitResponse() {}

  explicit DescribeRuleHitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleHitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleHitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleHitResponse() = default;
};
class DescribeRuleListByEventCodesListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> regId{};

  DescribeRuleListByEventCodesListRequest() {}

  explicit DescribeRuleListByEventCodesListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeRuleListByEventCodesListRequest() = default;
};
class DescribeRuleListByEventCodesListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};

  DescribeRuleListByEventCodesListResponseBodyResultObject() {}

  explicit DescribeRuleListByEventCodesListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
  }


  virtual ~DescribeRuleListByEventCodesListResponseBodyResultObject() = default;
};
class DescribeRuleListByEventCodesListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRuleListByEventCodesListResponseBodyResultObject>> resultObject{};

  DescribeRuleListByEventCodesListResponseBody() {}

  explicit DescribeRuleListByEventCodesListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeRuleListByEventCodesListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRuleListByEventCodesListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeRuleListByEventCodesListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeRuleListByEventCodesListResponseBody() = default;
};
class DescribeRuleListByEventCodesListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleListByEventCodesListResponseBody> body{};

  DescribeRuleListByEventCodesListResponse() {}

  explicit DescribeRuleListByEventCodesListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleListByEventCodesListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleListByEventCodesListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleListByEventCodesListResponse() = default;
};
class DescribeRulePageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleAuthType{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};

  DescribeRulePageListRequest() {}

  explicit DescribeRulePageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleAuthType) {
      res["ruleAuthType"] = boost::any(*ruleAuthType);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleAuthType") != m.end() && !m["ruleAuthType"].empty()) {
      ruleAuthType = make_shared<string>(boost::any_cast<string>(m["ruleAuthType"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
  }


  virtual ~DescribeRulePageListRequest() = default;
};
class DescribeRulePageListResponseBodyResultObjectConsoleAudit : public Darabonba::Model {
public:
  shared_ptr<string> applyUserId{};
  shared_ptr<string> applyUserName{};
  shared_ptr<string> auditMsg{};
  shared_ptr<string> auditRealUserId{};
  shared_ptr<string> auditRealUserName{};
  shared_ptr<string> auditRemark{};
  shared_ptr<string> auditStatus{};
  shared_ptr<long> auditTime{};
  shared_ptr<string> auditUserId{};
  shared_ptr<string> auditUserName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> id{};
  shared_ptr<string> relationExt{};
  shared_ptr<long> relationId{};
  shared_ptr<string> relationName{};
  shared_ptr<string> relationType{};

  DescribeRulePageListResponseBodyResultObjectConsoleAudit() {}

  explicit DescribeRulePageListResponseBodyResultObjectConsoleAudit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyUserId) {
      res["applyUserId"] = boost::any(*applyUserId);
    }
    if (applyUserName) {
      res["applyUserName"] = boost::any(*applyUserName);
    }
    if (auditMsg) {
      res["auditMsg"] = boost::any(*auditMsg);
    }
    if (auditRealUserId) {
      res["auditRealUserId"] = boost::any(*auditRealUserId);
    }
    if (auditRealUserName) {
      res["auditRealUserName"] = boost::any(*auditRealUserName);
    }
    if (auditRemark) {
      res["auditRemark"] = boost::any(*auditRemark);
    }
    if (auditStatus) {
      res["auditStatus"] = boost::any(*auditStatus);
    }
    if (auditTime) {
      res["auditTime"] = boost::any(*auditTime);
    }
    if (auditUserId) {
      res["auditUserId"] = boost::any(*auditUserId);
    }
    if (auditUserName) {
      res["auditUserName"] = boost::any(*auditUserName);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (relationExt) {
      res["relationExt"] = boost::any(*relationExt);
    }
    if (relationId) {
      res["relationId"] = boost::any(*relationId);
    }
    if (relationName) {
      res["relationName"] = boost::any(*relationName);
    }
    if (relationType) {
      res["relationType"] = boost::any(*relationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applyUserId") != m.end() && !m["applyUserId"].empty()) {
      applyUserId = make_shared<string>(boost::any_cast<string>(m["applyUserId"]));
    }
    if (m.find("applyUserName") != m.end() && !m["applyUserName"].empty()) {
      applyUserName = make_shared<string>(boost::any_cast<string>(m["applyUserName"]));
    }
    if (m.find("auditMsg") != m.end() && !m["auditMsg"].empty()) {
      auditMsg = make_shared<string>(boost::any_cast<string>(m["auditMsg"]));
    }
    if (m.find("auditRealUserId") != m.end() && !m["auditRealUserId"].empty()) {
      auditRealUserId = make_shared<string>(boost::any_cast<string>(m["auditRealUserId"]));
    }
    if (m.find("auditRealUserName") != m.end() && !m["auditRealUserName"].empty()) {
      auditRealUserName = make_shared<string>(boost::any_cast<string>(m["auditRealUserName"]));
    }
    if (m.find("auditRemark") != m.end() && !m["auditRemark"].empty()) {
      auditRemark = make_shared<string>(boost::any_cast<string>(m["auditRemark"]));
    }
    if (m.find("auditStatus") != m.end() && !m["auditStatus"].empty()) {
      auditStatus = make_shared<string>(boost::any_cast<string>(m["auditStatus"]));
    }
    if (m.find("auditTime") != m.end() && !m["auditTime"].empty()) {
      auditTime = make_shared<long>(boost::any_cast<long>(m["auditTime"]));
    }
    if (m.find("auditUserId") != m.end() && !m["auditUserId"].empty()) {
      auditUserId = make_shared<string>(boost::any_cast<string>(m["auditUserId"]));
    }
    if (m.find("auditUserName") != m.end() && !m["auditUserName"].empty()) {
      auditUserName = make_shared<string>(boost::any_cast<string>(m["auditUserName"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("relationExt") != m.end() && !m["relationExt"].empty()) {
      relationExt = make_shared<string>(boost::any_cast<string>(m["relationExt"]));
    }
    if (m.find("relationId") != m.end() && !m["relationId"].empty()) {
      relationId = make_shared<long>(boost::any_cast<long>(m["relationId"]));
    }
    if (m.find("relationName") != m.end() && !m["relationName"].empty()) {
      relationName = make_shared<string>(boost::any_cast<string>(m["relationName"]));
    }
    if (m.find("relationType") != m.end() && !m["relationType"].empty()) {
      relationType = make_shared<string>(boost::any_cast<string>(m["relationType"]));
    }
  }


  virtual ~DescribeRulePageListResponseBodyResultObjectConsoleAudit() = default;
};
class DescribeRulePageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> authType{};
  shared_ptr<DescribeRulePageListResponseBodyResultObjectConsoleAudit> consoleAudit{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};
  shared_ptr<string> externalRuleName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> mainRuleId{};
  shared_ptr<long> priority{};
  shared_ptr<string> ruleAuthType{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleMemo{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};
  shared_ptr<long> ruleVersionId{};
  shared_ptr<long> templateId{};
  shared_ptr<long> version{};

  DescribeRulePageListResponseBodyResultObject() {}

  explicit DescribeRulePageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authType) {
      res["authType"] = boost::any(*authType);
    }
    if (consoleAudit) {
      res["consoleAudit"] = consoleAudit ? boost::any(consoleAudit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    if (externalRuleName) {
      res["externalRuleName"] = boost::any(*externalRuleName);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (mainRuleId) {
      res["mainRuleId"] = boost::any(*mainRuleId);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (ruleAuthType) {
      res["ruleAuthType"] = boost::any(*ruleAuthType);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleMemo) {
      res["ruleMemo"] = boost::any(*ruleMemo);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    if (ruleVersionId) {
      res["ruleVersionId"] = boost::any(*ruleVersionId);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("authType") != m.end() && !m["authType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["authType"]));
    }
    if (m.find("consoleAudit") != m.end() && !m["consoleAudit"].empty()) {
      if (typeid(map<string, boost::any>) == m["consoleAudit"].type()) {
        DescribeRulePageListResponseBodyResultObjectConsoleAudit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["consoleAudit"]));
        consoleAudit = make_shared<DescribeRulePageListResponseBodyResultObjectConsoleAudit>(model1);
      }
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
    if (m.find("externalRuleName") != m.end() && !m["externalRuleName"].empty()) {
      externalRuleName = make_shared<string>(boost::any_cast<string>(m["externalRuleName"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("mainRuleId") != m.end() && !m["mainRuleId"].empty()) {
      mainRuleId = make_shared<string>(boost::any_cast<string>(m["mainRuleId"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("ruleAuthType") != m.end() && !m["ruleAuthType"].empty()) {
      ruleAuthType = make_shared<string>(boost::any_cast<string>(m["ruleAuthType"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleMemo") != m.end() && !m["ruleMemo"].empty()) {
      ruleMemo = make_shared<string>(boost::any_cast<string>(m["ruleMemo"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
    if (m.find("ruleVersionId") != m.end() && !m["ruleVersionId"].empty()) {
      ruleVersionId = make_shared<long>(boost::any_cast<long>(m["ruleVersionId"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["templateId"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~DescribeRulePageListResponseBodyResultObject() = default;
};
class DescribeRulePageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRulePageListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeRulePageListResponseBody() {}

  explicit DescribeRulePageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeRulePageListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRulePageListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeRulePageListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeRulePageListResponseBody() = default;
};
class DescribeRulePageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRulePageListResponseBody> body{};

  DescribeRulePageListResponse() {}

  explicit DescribeRulePageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRulePageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRulePageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRulePageListResponse() = default;
};
class DescribeRuleSnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> snapshotVersion{};

  DescribeRuleSnapshotRequest() {}

  explicit DescribeRuleSnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (snapshotVersion) {
      res["snapshotVersion"] = boost::any(*snapshotVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("snapshotVersion") != m.end() && !m["snapshotVersion"].empty()) {
      snapshotVersion = make_shared<string>(boost::any_cast<string>(m["snapshotVersion"]));
    }
  }


  virtual ~DescribeRuleSnapshotRequest() = default;
};
class DescribeRuleSnapshotResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> bizVersion{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> logicExpression{};
  shared_ptr<string> memo{};
  shared_ptr<string> ruleActions{};
  shared_ptr<string> ruleExpressions{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};

  DescribeRuleSnapshotResponseBodyResultObject() {}

  explicit DescribeRuleSnapshotResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizVersion) {
      res["bizVersion"] = boost::any(*bizVersion);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (logicExpression) {
      res["logicExpression"] = boost::any(*logicExpression);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (ruleActions) {
      res["ruleActions"] = boost::any(*ruleActions);
    }
    if (ruleExpressions) {
      res["ruleExpressions"] = boost::any(*ruleExpressions);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizVersion") != m.end() && !m["bizVersion"].empty()) {
      bizVersion = make_shared<string>(boost::any_cast<string>(m["bizVersion"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("logicExpression") != m.end() && !m["logicExpression"].empty()) {
      logicExpression = make_shared<string>(boost::any_cast<string>(m["logicExpression"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("ruleActions") != m.end() && !m["ruleActions"].empty()) {
      ruleActions = make_shared<string>(boost::any_cast<string>(m["ruleActions"]));
    }
    if (m.find("ruleExpressions") != m.end() && !m["ruleExpressions"].empty()) {
      ruleExpressions = make_shared<string>(boost::any_cast<string>(m["ruleExpressions"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
  }


  virtual ~DescribeRuleSnapshotResponseBodyResultObject() = default;
};
class DescribeRuleSnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRuleSnapshotResponseBodyResultObject> resultObject{};

  DescribeRuleSnapshotResponseBody() {}

  explicit DescribeRuleSnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeRuleSnapshotResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeRuleSnapshotResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeRuleSnapshotResponseBody() = default;
};
class DescribeRuleSnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleSnapshotResponseBody> body{};

  DescribeRuleSnapshotResponse() {}

  explicit DescribeRuleSnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleSnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleSnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleSnapshotResponse() = default;
};
class DescribeRuleVersionListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> consoleRuleId{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleId{};

  DescribeRuleVersionListRequest() {}

  explicit DescribeRuleVersionListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
  }


  virtual ~DescribeRuleVersionListRequest() = default;
};
class DescribeRuleVersionListResponseBodyResultObjectConsoleAudit : public Darabonba::Model {
public:
  shared_ptr<string> applyUserId{};
  shared_ptr<string> applyUserName{};
  shared_ptr<string> auditMsg{};
  shared_ptr<string> auditRealUserId{};
  shared_ptr<string> auditRealUserName{};
  shared_ptr<string> auditRemark{};
  shared_ptr<string> auditStatus{};
  shared_ptr<long> auditTime{};
  shared_ptr<string> auditUserId{};
  shared_ptr<string> auditUserName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> id{};
  shared_ptr<string> relationExt{};
  shared_ptr<long> relationId{};
  shared_ptr<string> relationName{};
  shared_ptr<string> relationType{};

  DescribeRuleVersionListResponseBodyResultObjectConsoleAudit() {}

  explicit DescribeRuleVersionListResponseBodyResultObjectConsoleAudit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyUserId) {
      res["applyUserId"] = boost::any(*applyUserId);
    }
    if (applyUserName) {
      res["applyUserName"] = boost::any(*applyUserName);
    }
    if (auditMsg) {
      res["auditMsg"] = boost::any(*auditMsg);
    }
    if (auditRealUserId) {
      res["auditRealUserId"] = boost::any(*auditRealUserId);
    }
    if (auditRealUserName) {
      res["auditRealUserName"] = boost::any(*auditRealUserName);
    }
    if (auditRemark) {
      res["auditRemark"] = boost::any(*auditRemark);
    }
    if (auditStatus) {
      res["auditStatus"] = boost::any(*auditStatus);
    }
    if (auditTime) {
      res["auditTime"] = boost::any(*auditTime);
    }
    if (auditUserId) {
      res["auditUserId"] = boost::any(*auditUserId);
    }
    if (auditUserName) {
      res["auditUserName"] = boost::any(*auditUserName);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (relationExt) {
      res["relationExt"] = boost::any(*relationExt);
    }
    if (relationId) {
      res["relationId"] = boost::any(*relationId);
    }
    if (relationName) {
      res["relationName"] = boost::any(*relationName);
    }
    if (relationType) {
      res["relationType"] = boost::any(*relationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applyUserId") != m.end() && !m["applyUserId"].empty()) {
      applyUserId = make_shared<string>(boost::any_cast<string>(m["applyUserId"]));
    }
    if (m.find("applyUserName") != m.end() && !m["applyUserName"].empty()) {
      applyUserName = make_shared<string>(boost::any_cast<string>(m["applyUserName"]));
    }
    if (m.find("auditMsg") != m.end() && !m["auditMsg"].empty()) {
      auditMsg = make_shared<string>(boost::any_cast<string>(m["auditMsg"]));
    }
    if (m.find("auditRealUserId") != m.end() && !m["auditRealUserId"].empty()) {
      auditRealUserId = make_shared<string>(boost::any_cast<string>(m["auditRealUserId"]));
    }
    if (m.find("auditRealUserName") != m.end() && !m["auditRealUserName"].empty()) {
      auditRealUserName = make_shared<string>(boost::any_cast<string>(m["auditRealUserName"]));
    }
    if (m.find("auditRemark") != m.end() && !m["auditRemark"].empty()) {
      auditRemark = make_shared<string>(boost::any_cast<string>(m["auditRemark"]));
    }
    if (m.find("auditStatus") != m.end() && !m["auditStatus"].empty()) {
      auditStatus = make_shared<string>(boost::any_cast<string>(m["auditStatus"]));
    }
    if (m.find("auditTime") != m.end() && !m["auditTime"].empty()) {
      auditTime = make_shared<long>(boost::any_cast<long>(m["auditTime"]));
    }
    if (m.find("auditUserId") != m.end() && !m["auditUserId"].empty()) {
      auditUserId = make_shared<string>(boost::any_cast<string>(m["auditUserId"]));
    }
    if (m.find("auditUserName") != m.end() && !m["auditUserName"].empty()) {
      auditUserName = make_shared<string>(boost::any_cast<string>(m["auditUserName"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("relationExt") != m.end() && !m["relationExt"].empty()) {
      relationExt = make_shared<string>(boost::any_cast<string>(m["relationExt"]));
    }
    if (m.find("relationId") != m.end() && !m["relationId"].empty()) {
      relationId = make_shared<long>(boost::any_cast<long>(m["relationId"]));
    }
    if (m.find("relationName") != m.end() && !m["relationName"].empty()) {
      relationName = make_shared<string>(boost::any_cast<string>(m["relationName"]));
    }
    if (m.find("relationType") != m.end() && !m["relationType"].empty()) {
      relationType = make_shared<string>(boost::any_cast<string>(m["relationType"]));
    }
  }


  virtual ~DescribeRuleVersionListResponseBodyResultObjectConsoleAudit() = default;
};
class DescribeRuleVersionListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<DescribeRuleVersionListResponseBodyResultObjectConsoleAudit> consoleAudit{};
  shared_ptr<long> consoleRuleId{};
  shared_ptr<string> consoleRuleMemo{};
  shared_ptr<string> consoleRuleName{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventType{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> lastOperator{};
  shared_ptr<long> priority{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleStatus{};
  shared_ptr<long> version{};

  DescribeRuleVersionListResponseBodyResultObject() {}

  explicit DescribeRuleVersionListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleAudit) {
      res["consoleAudit"] = consoleAudit ? boost::any(consoleAudit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (consoleRuleMemo) {
      res["consoleRuleMemo"] = boost::any(*consoleRuleMemo);
    }
    if (consoleRuleName) {
      res["consoleRuleName"] = boost::any(*consoleRuleName);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastOperator) {
      res["lastOperator"] = boost::any(*lastOperator);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("consoleAudit") != m.end() && !m["consoleAudit"].empty()) {
      if (typeid(map<string, boost::any>) == m["consoleAudit"].type()) {
        DescribeRuleVersionListResponseBodyResultObjectConsoleAudit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["consoleAudit"]));
        consoleAudit = make_shared<DescribeRuleVersionListResponseBodyResultObjectConsoleAudit>(model1);
      }
    }
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("consoleRuleMemo") != m.end() && !m["consoleRuleMemo"].empty()) {
      consoleRuleMemo = make_shared<string>(boost::any_cast<string>(m["consoleRuleMemo"]));
    }
    if (m.find("consoleRuleName") != m.end() && !m["consoleRuleName"].empty()) {
      consoleRuleName = make_shared<string>(boost::any_cast<string>(m["consoleRuleName"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("lastOperator") != m.end() && !m["lastOperator"].empty()) {
      lastOperator = make_shared<string>(boost::any_cast<string>(m["lastOperator"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~DescribeRuleVersionListResponseBodyResultObject() = default;
};
class DescribeRuleVersionListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRuleVersionListResponseBodyResultObject>> resultObject{};

  DescribeRuleVersionListResponseBody() {}

  explicit DescribeRuleVersionListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeRuleVersionListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRuleVersionListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeRuleVersionListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeRuleVersionListResponseBody() = default;
};
class DescribeRuleVersionListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleVersionListResponseBody> body{};

  DescribeRuleVersionListResponse() {}

  explicit DescribeRuleVersionListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleVersionListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleVersionListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleVersionListResponse() = default;
};
class DescribeSDKDownloadListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> listType{};
  shared_ptr<string> regId{};

  DescribeSDKDownloadListRequest() {}

  explicit DescribeSDKDownloadListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (deviceType) {
      res["deviceType"] = boost::any(*deviceType);
    }
    if (listType) {
      res["listType"] = boost::any(*listType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("deviceType") != m.end() && !m["deviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["deviceType"]));
    }
    if (m.find("listType") != m.end() && !m["listType"].empty()) {
      listType = make_shared<string>(boost::any_cast<string>(m["listType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeSDKDownloadListRequest() = default;
};
class DescribeSDKDownloadListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> developer{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> md5{};
  shared_ptr<string> packageName{};
  shared_ptr<string> privacyLink{};
  shared_ptr<string> pushTime{};
  shared_ptr<string> sdkVersion{};
  shared_ptr<string> size{};

  DescribeSDKDownloadListResponseBodyResultObject() {}

  explicit DescribeSDKDownloadListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (developer) {
      res["developer"] = boost::any(*developer);
    }
    if (deviceType) {
      res["deviceType"] = boost::any(*deviceType);
    }
    if (downloadUrl) {
      res["downloadUrl"] = boost::any(*downloadUrl);
    }
    if (md5) {
      res["md5"] = boost::any(*md5);
    }
    if (packageName) {
      res["packageName"] = boost::any(*packageName);
    }
    if (privacyLink) {
      res["privacyLink"] = boost::any(*privacyLink);
    }
    if (pushTime) {
      res["pushTime"] = boost::any(*pushTime);
    }
    if (sdkVersion) {
      res["sdkVersion"] = boost::any(*sdkVersion);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("developer") != m.end() && !m["developer"].empty()) {
      developer = make_shared<string>(boost::any_cast<string>(m["developer"]));
    }
    if (m.find("deviceType") != m.end() && !m["deviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["deviceType"]));
    }
    if (m.find("downloadUrl") != m.end() && !m["downloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["downloadUrl"]));
    }
    if (m.find("md5") != m.end() && !m["md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["md5"]));
    }
    if (m.find("packageName") != m.end() && !m["packageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["packageName"]));
    }
    if (m.find("privacyLink") != m.end() && !m["privacyLink"].empty()) {
      privacyLink = make_shared<string>(boost::any_cast<string>(m["privacyLink"]));
    }
    if (m.find("pushTime") != m.end() && !m["pushTime"].empty()) {
      pushTime = make_shared<string>(boost::any_cast<string>(m["pushTime"]));
    }
    if (m.find("sdkVersion") != m.end() && !m["sdkVersion"].empty()) {
      sdkVersion = make_shared<string>(boost::any_cast<string>(m["sdkVersion"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["size"]));
    }
  }


  virtual ~DescribeSDKDownloadListResponseBodyResultObject() = default;
};
class DescribeSDKDownloadListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSDKDownloadListResponseBodyResultObject>> resultObject{};

  DescribeSDKDownloadListResponseBody() {}

  explicit DescribeSDKDownloadListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeSDKDownloadListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSDKDownloadListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeSDKDownloadListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeSDKDownloadListResponseBody() = default;
};
class DescribeSDKDownloadListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSDKDownloadListResponseBody> body{};

  DescribeSDKDownloadListResponse() {}

  explicit DescribeSDKDownloadListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSDKDownloadListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSDKDownloadListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSDKDownloadListResponse() = default;
};
class DescribeSafConsoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> content{};
  shared_ptr<string> service{};

  DescribeSafConsoleRequest() {}

  explicit DescribeSafConsoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (service) {
      res["service"] = boost::any(*service);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("service") != m.end() && !m["service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["service"]));
    }
  }


  virtual ~DescribeSafConsoleRequest() = default;
};
class DescribeSafConsoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> bizData{};

  DescribeSafConsoleResponseBody() {}

  explicit DescribeSafConsoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (bizData) {
      res["bizData"] = boost::any(*bizData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("bizData") != m.end() && !m["bizData"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["bizData"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["bizData"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bizData = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSafConsoleResponseBody() = default;
};
class DescribeSafConsoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSafConsoleResponseBody> body{};

  DescribeSafConsoleResponse() {}

  explicit DescribeSafConsoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSafConsoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSafConsoleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSafConsoleResponse() = default;
};
class DescribeSafDeOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> endDate{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> startDate{};

  DescribeSafDeOrderRequest() {}

  explicit DescribeSafDeOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (startDate) {
      res["startDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["endDate"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("startDate") != m.end() && !m["startDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["startDate"]));
    }
  }


  virtual ~DescribeSafDeOrderRequest() = default;
};
class DescribeSafDeOrderResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> expirationDate{};
  shared_ptr<long> openUserType{};

  DescribeSafDeOrderResponseBodyResultObject() {}

  explicit DescribeSafDeOrderResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expirationDate) {
      res["expirationDate"] = boost::any(*expirationDate);
    }
    if (openUserType) {
      res["openUserType"] = boost::any(*openUserType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expirationDate") != m.end() && !m["expirationDate"].empty()) {
      expirationDate = make_shared<long>(boost::any_cast<long>(m["expirationDate"]));
    }
    if (m.find("openUserType") != m.end() && !m["openUserType"].empty()) {
      openUserType = make_shared<long>(boost::any_cast<long>(m["openUserType"]));
    }
  }


  virtual ~DescribeSafDeOrderResponseBodyResultObject() = default;
};
class DescribeSafDeOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSafDeOrderResponseBodyResultObject> resultObject{};

  DescribeSafDeOrderResponseBody() {}

  explicit DescribeSafDeOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeSafDeOrderResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeSafDeOrderResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeSafDeOrderResponseBody() = default;
};
class DescribeSafDeOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSafDeOrderResponseBody> body{};

  DescribeSafDeOrderResponse() {}

  explicit DescribeSafDeOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSafDeOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSafDeOrderResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSafDeOrderResponse() = default;
};
class DescribeSafOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> endDate{};
  shared_ptr<string> exactProductCode{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> startDate{};

  DescribeSafOrderRequest() {}

  explicit DescribeSafOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    if (exactProductCode) {
      res["exactProductCode"] = boost::any(*exactProductCode);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (startDate) {
      res["startDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["endDate"]));
    }
    if (m.find("exactProductCode") != m.end() && !m["exactProductCode"].empty()) {
      exactProductCode = make_shared<string>(boost::any_cast<string>(m["exactProductCode"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("startDate") != m.end() && !m["startDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["startDate"]));
    }
  }


  virtual ~DescribeSafOrderRequest() = default;
};
class DescribeSafOrderResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> expirationDate{};

  DescribeSafOrderResponseBodyResultObject() {}

  explicit DescribeSafOrderResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expirationDate) {
      res["expirationDate"] = boost::any(*expirationDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expirationDate") != m.end() && !m["expirationDate"].empty()) {
      expirationDate = make_shared<long>(boost::any_cast<long>(m["expirationDate"]));
    }
  }


  virtual ~DescribeSafOrderResponseBodyResultObject() = default;
};
class DescribeSafOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSafOrderResponseBodyResultObject> resultObject{};

  DescribeSafOrderResponseBody() {}

  explicit DescribeSafOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeSafOrderResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeSafOrderResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeSafOrderResponseBody() = default;
};
class DescribeSafOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSafOrderResponseBody> body{};

  DescribeSafOrderResponse() {}

  explicit DescribeSafOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSafOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSafOrderResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSafOrderResponse() = default;
};
class DescribeSafStartConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeSafStartConfigRequest() {}

  explicit DescribeSafStartConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeSafStartConfigRequest() = default;
};
class DescribeSafStartConfigResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceTypes{};
  shared_ptr<vector<string>> eventCodes{};
  shared_ptr<vector<string>> languages{};
  shared_ptr<vector<string>> serverRegions{};

  DescribeSafStartConfigResponseBodyResultObject() {}

  explicit DescribeSafStartConfigResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceTypes) {
      res["deviceTypes"] = boost::any(*deviceTypes);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (languages) {
      res["languages"] = boost::any(*languages);
    }
    if (serverRegions) {
      res["serverRegions"] = boost::any(*serverRegions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deviceTypes") != m.end() && !m["deviceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["deviceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["deviceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["eventCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["eventCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("languages") != m.end() && !m["languages"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["languages"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["languages"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      languages = make_shared<vector<string>>(toVec1);
    }
    if (m.find("serverRegions") != m.end() && !m["serverRegions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["serverRegions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["serverRegions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serverRegions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSafStartConfigResponseBodyResultObject() = default;
};
class DescribeSafStartConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSafStartConfigResponseBodyResultObject> resultObject{};

  DescribeSafStartConfigResponseBody() {}

  explicit DescribeSafStartConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeSafStartConfigResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeSafStartConfigResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeSafStartConfigResponseBody() = default;
};
class DescribeSafStartConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSafStartConfigResponseBody> body{};

  DescribeSafStartConfigResponse() {}

  explicit DescribeSafStartConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSafStartConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSafStartConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSafStartConfigResponse() = default;
};
class DescribeSafStartStepsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<bool> aliyunServer{};
  shared_ptr<string> deviceTypesStr{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> language{};
  shared_ptr<string> regId{};
  shared_ptr<string> serverRegion{};

  DescribeSafStartStepsRequest() {}

  explicit DescribeSafStartStepsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (aliyunServer) {
      res["aliyunServer"] = boost::any(*aliyunServer);
    }
    if (deviceTypesStr) {
      res["deviceTypesStr"] = boost::any(*deviceTypesStr);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (language) {
      res["language"] = boost::any(*language);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (serverRegion) {
      res["serverRegion"] = boost::any(*serverRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("aliyunServer") != m.end() && !m["aliyunServer"].empty()) {
      aliyunServer = make_shared<bool>(boost::any_cast<bool>(m["aliyunServer"]));
    }
    if (m.find("deviceTypesStr") != m.end() && !m["deviceTypesStr"].empty()) {
      deviceTypesStr = make_shared<string>(boost::any_cast<string>(m["deviceTypesStr"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("language") != m.end() && !m["language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["language"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("serverRegion") != m.end() && !m["serverRegion"].empty()) {
      serverRegion = make_shared<string>(boost::any_cast<string>(m["serverRegion"]));
    }
  }


  virtual ~DescribeSafStartStepsRequest() = default;
};
class DescribeSafStartStepsResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  DescribeSafStartStepsResponseBodyResultObject() {}

  explicit DescribeSafStartStepsResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeSafStartStepsResponseBodyResultObject() = default;
};
class DescribeSafStartStepsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSafStartStepsResponseBodyResultObject>> resultObject{};

  DescribeSafStartStepsResponseBody() {}

  explicit DescribeSafStartStepsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeSafStartStepsResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSafStartStepsResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeSafStartStepsResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeSafStartStepsResponseBody() = default;
};
class DescribeSafStartStepsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSafStartStepsResponseBody> body{};

  DescribeSafStartStepsResponse() {}

  explicit DescribeSafStartStepsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSafStartStepsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSafStartStepsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSafStartStepsResponse() = default;
};
class DescribeSafTagListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> apiId{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};

  DescribeSafTagListRequest() {}

  explicit DescribeSafTagListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (apiId) {
      res["apiId"] = boost::any(*apiId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("apiId") != m.end() && !m["apiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["apiId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeSafTagListRequest() = default;
};
class DescribeSafTagListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> tagDesc{};
  shared_ptr<string> tagMean{};
  shared_ptr<string> tagName{};
  shared_ptr<string> tagState{};
  shared_ptr<string> tagType{};
  shared_ptr<string> tagUid{};
  shared_ptr<string> updateTime{};

  DescribeSafTagListResponseBodyResultObject() {}

  explicit DescribeSafTagListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagDesc) {
      res["tagDesc"] = boost::any(*tagDesc);
    }
    if (tagMean) {
      res["tagMean"] = boost::any(*tagMean);
    }
    if (tagName) {
      res["tagName"] = boost::any(*tagName);
    }
    if (tagState) {
      res["tagState"] = boost::any(*tagState);
    }
    if (tagType) {
      res["tagType"] = boost::any(*tagType);
    }
    if (tagUid) {
      res["tagUid"] = boost::any(*tagUid);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tagDesc") != m.end() && !m["tagDesc"].empty()) {
      tagDesc = make_shared<string>(boost::any_cast<string>(m["tagDesc"]));
    }
    if (m.find("tagMean") != m.end() && !m["tagMean"].empty()) {
      tagMean = make_shared<string>(boost::any_cast<string>(m["tagMean"]));
    }
    if (m.find("tagName") != m.end() && !m["tagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["tagName"]));
    }
    if (m.find("tagState") != m.end() && !m["tagState"].empty()) {
      tagState = make_shared<string>(boost::any_cast<string>(m["tagState"]));
    }
    if (m.find("tagType") != m.end() && !m["tagType"].empty()) {
      tagType = make_shared<string>(boost::any_cast<string>(m["tagType"]));
    }
    if (m.find("tagUid") != m.end() && !m["tagUid"].empty()) {
      tagUid = make_shared<string>(boost::any_cast<string>(m["tagUid"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~DescribeSafTagListResponseBodyResultObject() = default;
};
class DescribeSafTagListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeSafTagListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeSafTagListResponseBody() {}

  explicit DescribeSafTagListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeSafTagListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSafTagListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeSafTagListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeSafTagListResponseBody() = default;
};
class DescribeSafTagListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSafTagListResponseBody> body{};

  DescribeSafTagListResponse() {}

  explicit DescribeSafTagListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSafTagListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSafTagListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSafTagListResponse() = default;
};
class DescribeSampleDataListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> deleteTag{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> queryContent{};
  shared_ptr<string> regId{};
  shared_ptr<long> sampleId{};
  shared_ptr<string> scene{};
  shared_ptr<string> status{};

  DescribeSampleDataListRequest() {}

  explicit DescribeSampleDataListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (deleteTag) {
      res["deleteTag"] = boost::any(*deleteTag);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (queryContent) {
      res["queryContent"] = boost::any(*queryContent);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (sampleId) {
      res["sampleId"] = boost::any(*sampleId);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("deleteTag") != m.end() && !m["deleteTag"].empty()) {
      deleteTag = make_shared<string>(boost::any_cast<string>(m["deleteTag"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("queryContent") != m.end() && !m["queryContent"].empty()) {
      queryContent = make_shared<string>(boost::any_cast<string>(m["queryContent"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("sampleId") != m.end() && !m["sampleId"].empty()) {
      sampleId = make_shared<long>(boost::any_cast<long>(m["sampleId"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["scene"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~DescribeSampleDataListRequest() = default;
};
class DescribeSampleDataListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> classificationType{};
  shared_ptr<string> dataDistributed{};
  shared_ptr<string> dataTitle{};
  shared_ptr<string> deleteTag{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> normalSize{};
  shared_ptr<string> recallConfig{};
  shared_ptr<long> riskSize{};
  shared_ptr<string> riskValue{};
  shared_ptr<string> sampleLabelDetail{};
  shared_ptr<long> sampleSize{};
  shared_ptr<string> scene{};
  shared_ptr<string> status{};
  shared_ptr<string> storePath{};
  shared_ptr<string> storeType{};
  shared_ptr<string> supportRecall{};
  shared_ptr<long> userId{};
  shared_ptr<long> version{};

  DescribeSampleDataListResponseBodyResultObject() {}

  explicit DescribeSampleDataListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationType) {
      res["classificationType"] = boost::any(*classificationType);
    }
    if (dataDistributed) {
      res["dataDistributed"] = boost::any(*dataDistributed);
    }
    if (dataTitle) {
      res["dataTitle"] = boost::any(*dataTitle);
    }
    if (deleteTag) {
      res["deleteTag"] = boost::any(*deleteTag);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (normalSize) {
      res["normalSize"] = boost::any(*normalSize);
    }
    if (recallConfig) {
      res["recallConfig"] = boost::any(*recallConfig);
    }
    if (riskSize) {
      res["riskSize"] = boost::any(*riskSize);
    }
    if (riskValue) {
      res["riskValue"] = boost::any(*riskValue);
    }
    if (sampleLabelDetail) {
      res["sampleLabelDetail"] = boost::any(*sampleLabelDetail);
    }
    if (sampleSize) {
      res["sampleSize"] = boost::any(*sampleSize);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (storePath) {
      res["storePath"] = boost::any(*storePath);
    }
    if (storeType) {
      res["storeType"] = boost::any(*storeType);
    }
    if (supportRecall) {
      res["supportRecall"] = boost::any(*supportRecall);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("classificationType") != m.end() && !m["classificationType"].empty()) {
      classificationType = make_shared<string>(boost::any_cast<string>(m["classificationType"]));
    }
    if (m.find("dataDistributed") != m.end() && !m["dataDistributed"].empty()) {
      dataDistributed = make_shared<string>(boost::any_cast<string>(m["dataDistributed"]));
    }
    if (m.find("dataTitle") != m.end() && !m["dataTitle"].empty()) {
      dataTitle = make_shared<string>(boost::any_cast<string>(m["dataTitle"]));
    }
    if (m.find("deleteTag") != m.end() && !m["deleteTag"].empty()) {
      deleteTag = make_shared<string>(boost::any_cast<string>(m["deleteTag"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("normalSize") != m.end() && !m["normalSize"].empty()) {
      normalSize = make_shared<long>(boost::any_cast<long>(m["normalSize"]));
    }
    if (m.find("recallConfig") != m.end() && !m["recallConfig"].empty()) {
      recallConfig = make_shared<string>(boost::any_cast<string>(m["recallConfig"]));
    }
    if (m.find("riskSize") != m.end() && !m["riskSize"].empty()) {
      riskSize = make_shared<long>(boost::any_cast<long>(m["riskSize"]));
    }
    if (m.find("riskValue") != m.end() && !m["riskValue"].empty()) {
      riskValue = make_shared<string>(boost::any_cast<string>(m["riskValue"]));
    }
    if (m.find("sampleLabelDetail") != m.end() && !m["sampleLabelDetail"].empty()) {
      sampleLabelDetail = make_shared<string>(boost::any_cast<string>(m["sampleLabelDetail"]));
    }
    if (m.find("sampleSize") != m.end() && !m["sampleSize"].empty()) {
      sampleSize = make_shared<long>(boost::any_cast<long>(m["sampleSize"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["scene"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("storePath") != m.end() && !m["storePath"].empty()) {
      storePath = make_shared<string>(boost::any_cast<string>(m["storePath"]));
    }
    if (m.find("storeType") != m.end() && !m["storeType"].empty()) {
      storeType = make_shared<string>(boost::any_cast<string>(m["storeType"]));
    }
    if (m.find("supportRecall") != m.end() && !m["supportRecall"].empty()) {
      supportRecall = make_shared<string>(boost::any_cast<string>(m["supportRecall"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~DescribeSampleDataListResponseBodyResultObject() = default;
};
class DescribeSampleDataListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeSampleDataListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeSampleDataListResponseBody() {}

  explicit DescribeSampleDataListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeSampleDataListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSampleDataListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeSampleDataListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeSampleDataListResponseBody() = default;
};
class DescribeSampleDataListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSampleDataListResponseBody> body{};

  DescribeSampleDataListResponse() {}

  explicit DescribeSampleDataListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSampleDataListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSampleDataListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSampleDataListResponse() = default;
};
class DescribeSampleDemoDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> scene{};

  DescribeSampleDemoDownloadUrlRequest() {}

  explicit DescribeSampleDemoDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["scene"]));
    }
  }


  virtual ~DescribeSampleDemoDownloadUrlRequest() = default;
};
class DescribeSampleDemoDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeSampleDemoDownloadUrlResponseBody() {}

  explicit DescribeSampleDemoDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeSampleDemoDownloadUrlResponseBody() = default;
};
class DescribeSampleDemoDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSampleDemoDownloadUrlResponseBody> body{};

  DescribeSampleDemoDownloadUrlResponse() {}

  explicit DescribeSampleDemoDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSampleDemoDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSampleDemoDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSampleDemoDownloadUrlResponse() = default;
};
class DescribeSampleDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<long> sampleId{};

  DescribeSampleDownloadUrlRequest() {}

  explicit DescribeSampleDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (sampleId) {
      res["sampleId"] = boost::any(*sampleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("sampleId") != m.end() && !m["sampleId"].empty()) {
      sampleId = make_shared<long>(boost::any_cast<long>(m["sampleId"]));
    }
  }


  virtual ~DescribeSampleDownloadUrlRequest() = default;
};
class DescribeSampleDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeSampleDownloadUrlResponseBody() {}

  explicit DescribeSampleDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeSampleDownloadUrlResponseBody() = default;
};
class DescribeSampleDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSampleDownloadUrlResponseBody> body{};

  DescribeSampleDownloadUrlResponse() {}

  explicit DescribeSampleDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSampleDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSampleDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSampleDownloadUrlResponse() = default;
};
class DescribeSampleInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};
  shared_ptr<long> versions{};

  DescribeSampleInfoRequest() {}

  explicit DescribeSampleInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (versions) {
      res["versions"] = boost::any(*versions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("versions") != m.end() && !m["versions"].empty()) {
      versions = make_shared<long>(boost::any_cast<long>(m["versions"]));
    }
  }


  virtual ~DescribeSampleInfoRequest() = default;
};
class DescribeSampleInfoResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> sampleTags{};
  shared_ptr<string> sampleType{};
  shared_ptr<string> sampleValue{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> version{};

  DescribeSampleInfoResponseBodyResultObject() {}

  explicit DescribeSampleInfoResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (sampleTags) {
      res["sampleTags"] = boost::any(*sampleTags);
    }
    if (sampleType) {
      res["sampleType"] = boost::any(*sampleType);
    }
    if (sampleValue) {
      res["sampleValue"] = boost::any(*sampleValue);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("sampleTags") != m.end() && !m["sampleTags"].empty()) {
      sampleTags = make_shared<string>(boost::any_cast<string>(m["sampleTags"]));
    }
    if (m.find("sampleType") != m.end() && !m["sampleType"].empty()) {
      sampleType = make_shared<string>(boost::any_cast<string>(m["sampleType"]));
    }
    if (m.find("sampleValue") != m.end() && !m["sampleValue"].empty()) {
      sampleValue = make_shared<string>(boost::any_cast<string>(m["sampleValue"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~DescribeSampleInfoResponseBodyResultObject() = default;
};
class DescribeSampleInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSampleInfoResponseBodyResultObject> resultObject{};

  DescribeSampleInfoResponseBody() {}

  explicit DescribeSampleInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeSampleInfoResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeSampleInfoResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeSampleInfoResponseBody() = default;
};
class DescribeSampleInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSampleInfoResponseBody> body{};

  DescribeSampleInfoResponse() {}

  explicit DescribeSampleInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSampleInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSampleInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSampleInfoResponse() = default;
};
class DescribeSampleListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> sampleType{};
  shared_ptr<string> sampleValue{};

  DescribeSampleListRequest() {}

  explicit DescribeSampleListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (sampleType) {
      res["sampleType"] = boost::any(*sampleType);
    }
    if (sampleValue) {
      res["sampleValue"] = boost::any(*sampleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("sampleType") != m.end() && !m["sampleType"].empty()) {
      sampleType = make_shared<string>(boost::any_cast<string>(m["sampleType"]));
    }
    if (m.find("sampleValue") != m.end() && !m["sampleValue"].empty()) {
      sampleValue = make_shared<string>(boost::any_cast<string>(m["sampleValue"]));
    }
  }


  virtual ~DescribeSampleListRequest() = default;
};
class DescribeSampleListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> sampleTags{};
  shared_ptr<long> sampleType{};
  shared_ptr<string> sampleValue{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  DescribeSampleListResponseBodyResultObject() {}

  explicit DescribeSampleListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (sampleTags) {
      res["sampleTags"] = boost::any(*sampleTags);
    }
    if (sampleType) {
      res["sampleType"] = boost::any(*sampleType);
    }
    if (sampleValue) {
      res["sampleValue"] = boost::any(*sampleValue);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("sampleTags") != m.end() && !m["sampleTags"].empty()) {
      sampleTags = make_shared<string>(boost::any_cast<string>(m["sampleTags"]));
    }
    if (m.find("sampleType") != m.end() && !m["sampleType"].empty()) {
      sampleType = make_shared<long>(boost::any_cast<long>(m["sampleType"]));
    }
    if (m.find("sampleValue") != m.end() && !m["sampleValue"].empty()) {
      sampleValue = make_shared<string>(boost::any_cast<string>(m["sampleValue"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["updateTime"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~DescribeSampleListResponseBodyResultObject() = default;
};
class DescribeSampleListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeSampleListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeSampleListResponseBody() {}

  explicit DescribeSampleListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeSampleListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSampleListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeSampleListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeSampleListResponseBody() = default;
};
class DescribeSampleListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSampleListResponseBody> body{};

  DescribeSampleListResponse() {}

  explicit DescribeSampleListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSampleListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSampleListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSampleListResponse() = default;
};
class DescribeSampleSceneListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeSampleSceneListRequest() {}

  explicit DescribeSampleSceneListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeSampleSceneListRequest() = default;
};
class DescribeSampleSceneListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifiedOperator{};
  shared_ptr<string> status{};

  DescribeSampleSceneListResponseBodyResultObject() {}

  explicit DescribeSampleSceneListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["bizType"] = boost::any(*bizType);
    }
    if (configKey) {
      res["configKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["configValue"] = boost::any(*configValue);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastModifiedOperator) {
      res["lastModifiedOperator"] = boost::any(*lastModifiedOperator);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizType") != m.end() && !m["bizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["bizType"]));
    }
    if (m.find("configKey") != m.end() && !m["configKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["configKey"]));
    }
    if (m.find("configValue") != m.end() && !m["configValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["configValue"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("lastModifiedOperator") != m.end() && !m["lastModifiedOperator"].empty()) {
      lastModifiedOperator = make_shared<string>(boost::any_cast<string>(m["lastModifiedOperator"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~DescribeSampleSceneListResponseBodyResultObject() = default;
};
class DescribeSampleSceneListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeSampleSceneListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeSampleSceneListResponseBody() {}

  explicit DescribeSampleSceneListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeSampleSceneListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSampleSceneListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeSampleSceneListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeSampleSceneListResponseBody() = default;
};
class DescribeSampleSceneListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSampleSceneListResponseBody> body{};

  DescribeSampleSceneListResponse() {}

  explicit DescribeSampleSceneListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSampleSceneListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSampleSceneListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSampleSceneListResponse() = default;
};
class DescribeSampleTagListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeSampleTagListRequest() {}

  explicit DescribeSampleTagListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeSampleTagListRequest() = default;
};
class DescribeSampleTagListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeSampleTagListResponseBody() {}

  explicit DescribeSampleTagListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeSampleTagListResponseBody() = default;
};
class DescribeSampleTagListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSampleTagListResponseBody> body{};

  DescribeSampleTagListResponse() {}

  explicit DescribeSampleTagListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSampleTagListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSampleTagListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSampleTagListResponse() = default;
};
class DescribeSampleUploadPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeSampleUploadPolicyRequest() {}

  explicit DescribeSampleUploadPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeSampleUploadPolicyRequest() = default;
};
class DescribeSampleUploadPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<string> host{};
  shared_ptr<string> key{};
  shared_ptr<string> policy{};
  shared_ptr<string> requestId{};
  shared_ptr<string> signature{};
  shared_ptr<string> stsToken{};

  DescribeSampleUploadPolicyResponseBody() {}

  explicit DescribeSampleUploadPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (stsToken) {
      res["StsToken"] = boost::any(*stsToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("StsToken") != m.end() && !m["StsToken"].empty()) {
      stsToken = make_shared<string>(boost::any_cast<string>(m["StsToken"]));
    }
  }


  virtual ~DescribeSampleUploadPolicyResponseBody() = default;
};
class DescribeSampleUploadPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSampleUploadPolicyResponseBody> body{};

  DescribeSampleUploadPolicyResponse() {}

  explicit DescribeSampleUploadPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSampleUploadPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSampleUploadPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSampleUploadPolicyResponse() = default;
};
class DescribeSceneAllEventNameCodeListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> regId{};

  DescribeSceneAllEventNameCodeListRequest() {}

  explicit DescribeSceneAllEventNameCodeListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeSceneAllEventNameCodeListRequest() = default;
};
class DescribeSceneAllEventNameCodeListResponseBodyResultObjectChildren : public Darabonba::Model {
public:
  shared_ptr<string> createType{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};

  DescribeSceneAllEventNameCodeListResponseBodyResultObjectChildren() {}

  explicit DescribeSceneAllEventNameCodeListResponseBodyResultObjectChildren(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
  }


  virtual ~DescribeSceneAllEventNameCodeListResponseBodyResultObjectChildren() = default;
};
class DescribeSceneAllEventNameCodeListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSceneAllEventNameCodeListResponseBodyResultObjectChildren>> children{};
  shared_ptr<string> createType{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};

  DescribeSceneAllEventNameCodeListResponseBodyResultObject() {}

  explicit DescribeSceneAllEventNameCodeListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (children) {
      vector<boost::any> temp1;
      for(auto item1:*children){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["children"] = boost::any(temp1);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("children") != m.end() && !m["children"].empty()) {
      if (typeid(vector<boost::any>) == m["children"].type()) {
        vector<DescribeSceneAllEventNameCodeListResponseBodyResultObjectChildren> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["children"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSceneAllEventNameCodeListResponseBodyResultObjectChildren model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        children = make_shared<vector<DescribeSceneAllEventNameCodeListResponseBodyResultObjectChildren>>(expect1);
      }
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
  }


  virtual ~DescribeSceneAllEventNameCodeListResponseBodyResultObject() = default;
};
class DescribeSceneAllEventNameCodeListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSceneAllEventNameCodeListResponseBodyResultObject>> resultObject{};
  shared_ptr<bool> success{};

  DescribeSceneAllEventNameCodeListResponseBody() {}

  explicit DescribeSceneAllEventNameCodeListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeSceneAllEventNameCodeListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSceneAllEventNameCodeListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeSceneAllEventNameCodeListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeSceneAllEventNameCodeListResponseBody() = default;
};
class DescribeSceneAllEventNameCodeListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSceneAllEventNameCodeListResponseBody> body{};

  DescribeSceneAllEventNameCodeListResponse() {}

  explicit DescribeSceneAllEventNameCodeListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSceneAllEventNameCodeListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSceneAllEventNameCodeListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSceneAllEventNameCodeListResponse() = default;
};
class DescribeSceneEventPageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> nameOrCode{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};

  DescribeSceneEventPageListRequest() {}

  explicit DescribeSceneEventPageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (nameOrCode) {
      res["nameOrCode"] = boost::any(*nameOrCode);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("nameOrCode") != m.end() && !m["nameOrCode"].empty()) {
      nameOrCode = make_shared<string>(boost::any_cast<string>(m["nameOrCode"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeSceneEventPageListRequest() = default;
};
class DescribeSceneEventPageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> commonRuleCount{};
  shared_ptr<string> customRuleCount{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> modifier{};
  shared_ptr<string> normalRuleCount{};
  shared_ptr<string> service{};
  shared_ptr<string> useStatus{};
  shared_ptr<string> whiteBoxRuleCount{};

  DescribeSceneEventPageListResponseBodyResultObject() {}

  explicit DescribeSceneEventPageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonRuleCount) {
      res["commonRuleCount"] = boost::any(*commonRuleCount);
    }
    if (customRuleCount) {
      res["customRuleCount"] = boost::any(*customRuleCount);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (normalRuleCount) {
      res["normalRuleCount"] = boost::any(*normalRuleCount);
    }
    if (service) {
      res["service"] = boost::any(*service);
    }
    if (useStatus) {
      res["useStatus"] = boost::any(*useStatus);
    }
    if (whiteBoxRuleCount) {
      res["whiteBoxRuleCount"] = boost::any(*whiteBoxRuleCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonRuleCount") != m.end() && !m["commonRuleCount"].empty()) {
      commonRuleCount = make_shared<string>(boost::any_cast<string>(m["commonRuleCount"]));
    }
    if (m.find("customRuleCount") != m.end() && !m["customRuleCount"].empty()) {
      customRuleCount = make_shared<string>(boost::any_cast<string>(m["customRuleCount"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("normalRuleCount") != m.end() && !m["normalRuleCount"].empty()) {
      normalRuleCount = make_shared<string>(boost::any_cast<string>(m["normalRuleCount"]));
    }
    if (m.find("service") != m.end() && !m["service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["service"]));
    }
    if (m.find("useStatus") != m.end() && !m["useStatus"].empty()) {
      useStatus = make_shared<string>(boost::any_cast<string>(m["useStatus"]));
    }
    if (m.find("whiteBoxRuleCount") != m.end() && !m["whiteBoxRuleCount"].empty()) {
      whiteBoxRuleCount = make_shared<string>(boost::any_cast<string>(m["whiteBoxRuleCount"]));
    }
  }


  virtual ~DescribeSceneEventPageListResponseBodyResultObject() = default;
};
class DescribeSceneEventPageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSceneEventPageListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeSceneEventPageListResponseBody() {}

  explicit DescribeSceneEventPageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeSceneEventPageListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSceneEventPageListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeSceneEventPageListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeSceneEventPageListResponseBody() = default;
};
class DescribeSceneEventPageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSceneEventPageListResponseBody> body{};

  DescribeSceneEventPageListResponse() {}

  explicit DescribeSceneEventPageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSceneEventPageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSceneEventPageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSceneEventPageListResponse() = default;
};
class DescribeSceneRulePageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleAuthType{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};

  DescribeSceneRulePageListRequest() {}

  explicit DescribeSceneRulePageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleAuthType) {
      res["ruleAuthType"] = boost::any(*ruleAuthType);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleAuthType") != m.end() && !m["ruleAuthType"].empty()) {
      ruleAuthType = make_shared<string>(boost::any_cast<string>(m["ruleAuthType"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
  }


  virtual ~DescribeSceneRulePageListRequest() = default;
};
class DescribeSceneRulePageListResponseBodyResultObjectConsoleAudit : public Darabonba::Model {
public:
  shared_ptr<string> applyUserId{};
  shared_ptr<string> applyUserName{};
  shared_ptr<string> auditMsg{};
  shared_ptr<string> auditRealUserId{};
  shared_ptr<string> auditRealUserName{};
  shared_ptr<string> auditRemark{};
  shared_ptr<string> auditStatus{};
  shared_ptr<long> auditTime{};
  shared_ptr<string> auditUserId{};
  shared_ptr<string> auditUserName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> id{};
  shared_ptr<string> relationExt{};
  shared_ptr<long> relationId{};
  shared_ptr<string> relationName{};
  shared_ptr<string> relationType{};

  DescribeSceneRulePageListResponseBodyResultObjectConsoleAudit() {}

  explicit DescribeSceneRulePageListResponseBodyResultObjectConsoleAudit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyUserId) {
      res["applyUserId"] = boost::any(*applyUserId);
    }
    if (applyUserName) {
      res["applyUserName"] = boost::any(*applyUserName);
    }
    if (auditMsg) {
      res["auditMsg"] = boost::any(*auditMsg);
    }
    if (auditRealUserId) {
      res["auditRealUserId"] = boost::any(*auditRealUserId);
    }
    if (auditRealUserName) {
      res["auditRealUserName"] = boost::any(*auditRealUserName);
    }
    if (auditRemark) {
      res["auditRemark"] = boost::any(*auditRemark);
    }
    if (auditStatus) {
      res["auditStatus"] = boost::any(*auditStatus);
    }
    if (auditTime) {
      res["auditTime"] = boost::any(*auditTime);
    }
    if (auditUserId) {
      res["auditUserId"] = boost::any(*auditUserId);
    }
    if (auditUserName) {
      res["auditUserName"] = boost::any(*auditUserName);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (relationExt) {
      res["relationExt"] = boost::any(*relationExt);
    }
    if (relationId) {
      res["relationId"] = boost::any(*relationId);
    }
    if (relationName) {
      res["relationName"] = boost::any(*relationName);
    }
    if (relationType) {
      res["relationType"] = boost::any(*relationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applyUserId") != m.end() && !m["applyUserId"].empty()) {
      applyUserId = make_shared<string>(boost::any_cast<string>(m["applyUserId"]));
    }
    if (m.find("applyUserName") != m.end() && !m["applyUserName"].empty()) {
      applyUserName = make_shared<string>(boost::any_cast<string>(m["applyUserName"]));
    }
    if (m.find("auditMsg") != m.end() && !m["auditMsg"].empty()) {
      auditMsg = make_shared<string>(boost::any_cast<string>(m["auditMsg"]));
    }
    if (m.find("auditRealUserId") != m.end() && !m["auditRealUserId"].empty()) {
      auditRealUserId = make_shared<string>(boost::any_cast<string>(m["auditRealUserId"]));
    }
    if (m.find("auditRealUserName") != m.end() && !m["auditRealUserName"].empty()) {
      auditRealUserName = make_shared<string>(boost::any_cast<string>(m["auditRealUserName"]));
    }
    if (m.find("auditRemark") != m.end() && !m["auditRemark"].empty()) {
      auditRemark = make_shared<string>(boost::any_cast<string>(m["auditRemark"]));
    }
    if (m.find("auditStatus") != m.end() && !m["auditStatus"].empty()) {
      auditStatus = make_shared<string>(boost::any_cast<string>(m["auditStatus"]));
    }
    if (m.find("auditTime") != m.end() && !m["auditTime"].empty()) {
      auditTime = make_shared<long>(boost::any_cast<long>(m["auditTime"]));
    }
    if (m.find("auditUserId") != m.end() && !m["auditUserId"].empty()) {
      auditUserId = make_shared<string>(boost::any_cast<string>(m["auditUserId"]));
    }
    if (m.find("auditUserName") != m.end() && !m["auditUserName"].empty()) {
      auditUserName = make_shared<string>(boost::any_cast<string>(m["auditUserName"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("relationExt") != m.end() && !m["relationExt"].empty()) {
      relationExt = make_shared<string>(boost::any_cast<string>(m["relationExt"]));
    }
    if (m.find("relationId") != m.end() && !m["relationId"].empty()) {
      relationId = make_shared<long>(boost::any_cast<long>(m["relationId"]));
    }
    if (m.find("relationName") != m.end() && !m["relationName"].empty()) {
      relationName = make_shared<string>(boost::any_cast<string>(m["relationName"]));
    }
    if (m.find("relationType") != m.end() && !m["relationType"].empty()) {
      relationType = make_shared<string>(boost::any_cast<string>(m["relationType"]));
    }
  }


  virtual ~DescribeSceneRulePageListResponseBodyResultObjectConsoleAudit() = default;
};
class DescribeSceneRulePageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> authType{};
  shared_ptr<DescribeSceneRulePageListResponseBodyResultObjectConsoleAudit> consoleAudit{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};
  shared_ptr<string> externalRuleName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> mainRuleId{};
  shared_ptr<long> priority{};
  shared_ptr<string> ruleAuthType{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleMemo{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};
  shared_ptr<long> ruleVersionId{};
  shared_ptr<long> templateId{};
  shared_ptr<long> version{};

  DescribeSceneRulePageListResponseBodyResultObject() {}

  explicit DescribeSceneRulePageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authType) {
      res["authType"] = boost::any(*authType);
    }
    if (consoleAudit) {
      res["consoleAudit"] = consoleAudit ? boost::any(consoleAudit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    if (externalRuleName) {
      res["externalRuleName"] = boost::any(*externalRuleName);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (mainRuleId) {
      res["mainRuleId"] = boost::any(*mainRuleId);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (ruleAuthType) {
      res["ruleAuthType"] = boost::any(*ruleAuthType);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleMemo) {
      res["ruleMemo"] = boost::any(*ruleMemo);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    if (ruleVersionId) {
      res["ruleVersionId"] = boost::any(*ruleVersionId);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("authType") != m.end() && !m["authType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["authType"]));
    }
    if (m.find("consoleAudit") != m.end() && !m["consoleAudit"].empty()) {
      if (typeid(map<string, boost::any>) == m["consoleAudit"].type()) {
        DescribeSceneRulePageListResponseBodyResultObjectConsoleAudit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["consoleAudit"]));
        consoleAudit = make_shared<DescribeSceneRulePageListResponseBodyResultObjectConsoleAudit>(model1);
      }
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
    if (m.find("externalRuleName") != m.end() && !m["externalRuleName"].empty()) {
      externalRuleName = make_shared<string>(boost::any_cast<string>(m["externalRuleName"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("mainRuleId") != m.end() && !m["mainRuleId"].empty()) {
      mainRuleId = make_shared<string>(boost::any_cast<string>(m["mainRuleId"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("ruleAuthType") != m.end() && !m["ruleAuthType"].empty()) {
      ruleAuthType = make_shared<string>(boost::any_cast<string>(m["ruleAuthType"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleMemo") != m.end() && !m["ruleMemo"].empty()) {
      ruleMemo = make_shared<string>(boost::any_cast<string>(m["ruleMemo"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
    if (m.find("ruleVersionId") != m.end() && !m["ruleVersionId"].empty()) {
      ruleVersionId = make_shared<long>(boost::any_cast<long>(m["ruleVersionId"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["templateId"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~DescribeSceneRulePageListResponseBodyResultObject() = default;
};
class DescribeSceneRulePageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSceneRulePageListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeSceneRulePageListResponseBody() {}

  explicit DescribeSceneRulePageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeSceneRulePageListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSceneRulePageListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeSceneRulePageListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeSceneRulePageListResponseBody() = default;
};
class DescribeSceneRulePageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSceneRulePageListResponseBody> body{};

  DescribeSceneRulePageListResponse() {}

  explicit DescribeSceneRulePageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSceneRulePageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSceneRulePageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSceneRulePageListResponse() = default;
};
class DescribeScoreSectionNumLineChartRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> beginTime{};
  shared_ptr<string> byPassEventCodes{};
  shared_ptr<string> endTime{};
  shared_ptr<string> mainEventCodes{};
  shared_ptr<string> regId{};
  shared_ptr<string> shuntEventCodes{};

  DescribeScoreSectionNumLineChartRequest() {}

  explicit DescribeScoreSectionNumLineChartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (byPassEventCodes) {
      res["byPassEventCodes"] = boost::any(*byPassEventCodes);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (mainEventCodes) {
      res["mainEventCodes"] = boost::any(*mainEventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (shuntEventCodes) {
      res["shuntEventCodes"] = boost::any(*shuntEventCodes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["beginTime"]));
    }
    if (m.find("byPassEventCodes") != m.end() && !m["byPassEventCodes"].empty()) {
      byPassEventCodes = make_shared<string>(boost::any_cast<string>(m["byPassEventCodes"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("mainEventCodes") != m.end() && !m["mainEventCodes"].empty()) {
      mainEventCodes = make_shared<string>(boost::any_cast<string>(m["mainEventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("shuntEventCodes") != m.end() && !m["shuntEventCodes"].empty()) {
      shuntEventCodes = make_shared<string>(boost::any_cast<string>(m["shuntEventCodes"]));
    }
  }


  virtual ~DescribeScoreSectionNumLineChartRequest() = default;
};
class DescribeScoreSectionNumLineChartResponseBodyResultObjectSeries : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};
  shared_ptr<string> name{};

  DescribeScoreSectionNumLineChartResponseBodyResultObjectSeries() {}

  explicit DescribeScoreSectionNumLineChartResponseBodyResultObjectSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeScoreSectionNumLineChartResponseBodyResultObjectSeries() = default;
};
class DescribeScoreSectionNumLineChartResponseBodyResultObjectXaxis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};

  DescribeScoreSectionNumLineChartResponseBodyResultObjectXaxis() {}

  explicit DescribeScoreSectionNumLineChartResponseBodyResultObjectXaxis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeScoreSectionNumLineChartResponseBodyResultObjectXaxis() = default;
};
class DescribeScoreSectionNumLineChartResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeScoreSectionNumLineChartResponseBodyResultObjectSeries>> series{};
  shared_ptr<DescribeScoreSectionNumLineChartResponseBodyResultObjectXaxis> xaxis{};

  DescribeScoreSectionNumLineChartResponseBodyResultObject() {}

  explicit DescribeScoreSectionNumLineChartResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    if (xaxis) {
      res["xaxis"] = xaxis ? boost::any(xaxis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeScoreSectionNumLineChartResponseBodyResultObjectSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScoreSectionNumLineChartResponseBodyResultObjectSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeScoreSectionNumLineChartResponseBodyResultObjectSeries>>(expect1);
      }
    }
    if (m.find("xaxis") != m.end() && !m["xaxis"].empty()) {
      if (typeid(map<string, boost::any>) == m["xaxis"].type()) {
        DescribeScoreSectionNumLineChartResponseBodyResultObjectXaxis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["xaxis"]));
        xaxis = make_shared<DescribeScoreSectionNumLineChartResponseBodyResultObjectXaxis>(model1);
      }
    }
  }


  virtual ~DescribeScoreSectionNumLineChartResponseBodyResultObject() = default;
};
class DescribeScoreSectionNumLineChartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeScoreSectionNumLineChartResponseBodyResultObject> resultObject{};

  DescribeScoreSectionNumLineChartResponseBody() {}

  explicit DescribeScoreSectionNumLineChartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeScoreSectionNumLineChartResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeScoreSectionNumLineChartResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeScoreSectionNumLineChartResponseBody() = default;
};
class DescribeScoreSectionNumLineChartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScoreSectionNumLineChartResponseBody> body{};

  DescribeScoreSectionNumLineChartResponse() {}

  explicit DescribeScoreSectionNumLineChartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScoreSectionNumLineChartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScoreSectionNumLineChartResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScoreSectionNumLineChartResponse() = default;
};
class DescribeScoreSectionPieChartRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> eventType{};
  shared_ptr<string> regId{};

  DescribeScoreSectionPieChartRequest() {}

  explicit DescribeScoreSectionPieChartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeScoreSectionPieChartRequest() = default;
};
class DescribeScoreSectionPieChartResponseBodyResultObjectGrid : public Darabonba::Model {
public:
  shared_ptr<bool> show{};

  DescribeScoreSectionPieChartResponseBodyResultObjectGrid() {}

  explicit DescribeScoreSectionPieChartResponseBodyResultObjectGrid(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (show) {
      res["show"] = boost::any(*show);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("show") != m.end() && !m["show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["show"]));
    }
  }


  virtual ~DescribeScoreSectionPieChartResponseBodyResultObjectGrid() = default;
};
class DescribeScoreSectionPieChartResponseBodyResultObjectSeriesData : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeScoreSectionPieChartResponseBodyResultObjectSeriesData() {}

  explicit DescribeScoreSectionPieChartResponseBodyResultObjectSeriesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeScoreSectionPieChartResponseBodyResultObjectSeriesData() = default;
};
class DescribeScoreSectionPieChartResponseBodyResultObjectSeries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeScoreSectionPieChartResponseBodyResultObjectSeriesData>> data{};
  shared_ptr<string> name{};
  shared_ptr<bool> roseType{};

  DescribeScoreSectionPieChartResponseBodyResultObjectSeries() {}

  explicit DescribeScoreSectionPieChartResponseBodyResultObjectSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (roseType) {
      res["roseType"] = boost::any(*roseType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<DescribeScoreSectionPieChartResponseBodyResultObjectSeriesData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScoreSectionPieChartResponseBodyResultObjectSeriesData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeScoreSectionPieChartResponseBodyResultObjectSeriesData>>(expect1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("roseType") != m.end() && !m["roseType"].empty()) {
      roseType = make_shared<bool>(boost::any_cast<bool>(m["roseType"]));
    }
  }


  virtual ~DescribeScoreSectionPieChartResponseBodyResultObjectSeries() = default;
};
class DescribeScoreSectionPieChartResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<bool> animation{};
  shared_ptr<DescribeScoreSectionPieChartResponseBodyResultObjectGrid> grid{};
  shared_ptr<vector<DescribeScoreSectionPieChartResponseBodyResultObjectSeries>> series{};

  DescribeScoreSectionPieChartResponseBodyResultObject() {}

  explicit DescribeScoreSectionPieChartResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (animation) {
      res["animation"] = boost::any(*animation);
    }
    if (grid) {
      res["grid"] = grid ? boost::any(grid->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("animation") != m.end() && !m["animation"].empty()) {
      animation = make_shared<bool>(boost::any_cast<bool>(m["animation"]));
    }
    if (m.find("grid") != m.end() && !m["grid"].empty()) {
      if (typeid(map<string, boost::any>) == m["grid"].type()) {
        DescribeScoreSectionPieChartResponseBodyResultObjectGrid model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["grid"]));
        grid = make_shared<DescribeScoreSectionPieChartResponseBodyResultObjectGrid>(model1);
      }
    }
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeScoreSectionPieChartResponseBodyResultObjectSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScoreSectionPieChartResponseBodyResultObjectSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeScoreSectionPieChartResponseBodyResultObjectSeries>>(expect1);
      }
    }
  }


  virtual ~DescribeScoreSectionPieChartResponseBodyResultObject() = default;
};
class DescribeScoreSectionPieChartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeScoreSectionPieChartResponseBodyResultObject> resultObject{};

  DescribeScoreSectionPieChartResponseBody() {}

  explicit DescribeScoreSectionPieChartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeScoreSectionPieChartResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeScoreSectionPieChartResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeScoreSectionPieChartResponseBody() = default;
};
class DescribeScoreSectionPieChartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScoreSectionPieChartResponseBody> body{};

  DescribeScoreSectionPieChartResponse() {}

  explicit DescribeScoreSectionPieChartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScoreSectionPieChartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScoreSectionPieChartResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScoreSectionPieChartResponse() = default;
};
class DescribeScoreSectionRatioLineChartRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> beginTime{};
  shared_ptr<string> byPassEventCodes{};
  shared_ptr<string> endTime{};
  shared_ptr<string> mainEventCodes{};
  shared_ptr<string> regId{};
  shared_ptr<string> shuntEventCodes{};

  DescribeScoreSectionRatioLineChartRequest() {}

  explicit DescribeScoreSectionRatioLineChartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (byPassEventCodes) {
      res["byPassEventCodes"] = boost::any(*byPassEventCodes);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (mainEventCodes) {
      res["mainEventCodes"] = boost::any(*mainEventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (shuntEventCodes) {
      res["shuntEventCodes"] = boost::any(*shuntEventCodes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["beginTime"]));
    }
    if (m.find("byPassEventCodes") != m.end() && !m["byPassEventCodes"].empty()) {
      byPassEventCodes = make_shared<string>(boost::any_cast<string>(m["byPassEventCodes"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("mainEventCodes") != m.end() && !m["mainEventCodes"].empty()) {
      mainEventCodes = make_shared<string>(boost::any_cast<string>(m["mainEventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("shuntEventCodes") != m.end() && !m["shuntEventCodes"].empty()) {
      shuntEventCodes = make_shared<string>(boost::any_cast<string>(m["shuntEventCodes"]));
    }
  }


  virtual ~DescribeScoreSectionRatioLineChartRequest() = default;
};
class DescribeScoreSectionRatioLineChartResponseBodyResultObjectSeries : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};
  shared_ptr<string> name{};

  DescribeScoreSectionRatioLineChartResponseBodyResultObjectSeries() {}

  explicit DescribeScoreSectionRatioLineChartResponseBodyResultObjectSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeScoreSectionRatioLineChartResponseBodyResultObjectSeries() = default;
};
class DescribeScoreSectionRatioLineChartResponseBodyResultObjectXaxis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};

  DescribeScoreSectionRatioLineChartResponseBodyResultObjectXaxis() {}

  explicit DescribeScoreSectionRatioLineChartResponseBodyResultObjectXaxis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeScoreSectionRatioLineChartResponseBodyResultObjectXaxis() = default;
};
class DescribeScoreSectionRatioLineChartResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeScoreSectionRatioLineChartResponseBodyResultObjectSeries>> series{};
  shared_ptr<DescribeScoreSectionRatioLineChartResponseBodyResultObjectXaxis> xaxis{};

  DescribeScoreSectionRatioLineChartResponseBodyResultObject() {}

  explicit DescribeScoreSectionRatioLineChartResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    if (xaxis) {
      res["xaxis"] = xaxis ? boost::any(xaxis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeScoreSectionRatioLineChartResponseBodyResultObjectSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScoreSectionRatioLineChartResponseBodyResultObjectSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeScoreSectionRatioLineChartResponseBodyResultObjectSeries>>(expect1);
      }
    }
    if (m.find("xaxis") != m.end() && !m["xaxis"].empty()) {
      if (typeid(map<string, boost::any>) == m["xaxis"].type()) {
        DescribeScoreSectionRatioLineChartResponseBodyResultObjectXaxis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["xaxis"]));
        xaxis = make_shared<DescribeScoreSectionRatioLineChartResponseBodyResultObjectXaxis>(model1);
      }
    }
  }


  virtual ~DescribeScoreSectionRatioLineChartResponseBodyResultObject() = default;
};
class DescribeScoreSectionRatioLineChartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeScoreSectionRatioLineChartResponseBodyResultObject> resultObject{};

  DescribeScoreSectionRatioLineChartResponseBody() {}

  explicit DescribeScoreSectionRatioLineChartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeScoreSectionRatioLineChartResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeScoreSectionRatioLineChartResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeScoreSectionRatioLineChartResponseBody() = default;
};
class DescribeScoreSectionRatioLineChartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScoreSectionRatioLineChartResponseBody> body{};

  DescribeScoreSectionRatioLineChartResponse() {}

  explicit DescribeScoreSectionRatioLineChartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScoreSectionRatioLineChartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScoreSectionRatioLineChartResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScoreSectionRatioLineChartResponse() = default;
};
class DescribeSelectItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeSelectItemRequest() {}

  explicit DescribeSelectItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeSelectItemRequest() = default;
};
class DescribeSelectItemResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<string>> monitorStatusList{};
  shared_ptr<vector<string>> taskIdList{};

  DescribeSelectItemResponseBodyResultObject() {}

  explicit DescribeSelectItemResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorStatusList) {
      res["monitorStatusList"] = boost::any(*monitorStatusList);
    }
    if (taskIdList) {
      res["taskIdList"] = boost::any(*taskIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("monitorStatusList") != m.end() && !m["monitorStatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["monitorStatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["monitorStatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      monitorStatusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("taskIdList") != m.end() && !m["taskIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["taskIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["taskIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSelectItemResponseBodyResultObject() = default;
};
class DescribeSelectItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSelectItemResponseBodyResultObject> resultObject{};

  DescribeSelectItemResponseBody() {}

  explicit DescribeSelectItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeSelectItemResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeSelectItemResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeSelectItemResponseBody() = default;
};
class DescribeSelectItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSelectItemResponseBody> body{};

  DescribeSelectItemResponse() {}

  explicit DescribeSelectItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSelectItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSelectItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSelectItemResponse() = default;
};
class DescribeServiceAppKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> regId{};

  DescribeServiceAppKeyRequest() {}

  explicit DescribeServiceAppKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeServiceAppKeyRequest() = default;
};
class DescribeServiceAppKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};
  shared_ptr<bool> uccess{};

  DescribeServiceAppKeyResponseBody() {}

  explicit DescribeServiceAppKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (uccess) {
      res["uccess"] = boost::any(*uccess);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("uccess") != m.end() && !m["uccess"].empty()) {
      uccess = make_shared<bool>(boost::any_cast<bool>(m["uccess"]));
    }
  }


  virtual ~DescribeServiceAppKeyResponseBody() = default;
};
class DescribeServiceAppKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeServiceAppKeyResponseBody> body{};

  DescribeServiceAppKeyResponse() {}

  explicit DescribeServiceAppKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeServiceAppKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeServiceAppKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeServiceAppKeyResponse() = default;
};
class DescribeServiceConsumeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> endDate{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> serviceCode{};
  shared_ptr<string> startDate{};

  DescribeServiceConsumeRequest() {}

  explicit DescribeServiceConsumeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (serviceCode) {
      res["serviceCode"] = boost::any(*serviceCode);
    }
    if (startDate) {
      res["startDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["endDate"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("serviceCode") != m.end() && !m["serviceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["serviceCode"]));
    }
    if (m.find("startDate") != m.end() && !m["startDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["startDate"]));
    }
  }


  virtual ~DescribeServiceConsumeRequest() = default;
};
class DescribeServiceConsumeResponseBodyConsumeRecordsRecords : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> serviceCode{};

  DescribeServiceConsumeResponseBodyConsumeRecordsRecords() {}

  explicit DescribeServiceConsumeResponseBodyConsumeRecordsRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (serviceCode) {
      res["serviceCode"] = boost::any(*serviceCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("serviceCode") != m.end() && !m["serviceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["serviceCode"]));
    }
  }


  virtual ~DescribeServiceConsumeResponseBodyConsumeRecordsRecords() = default;
};
class DescribeServiceConsumeResponseBodyConsumeRecords : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<vector<DescribeServiceConsumeResponseBodyConsumeRecordsRecords>> records{};

  DescribeServiceConsumeResponseBodyConsumeRecords() {}

  explicit DescribeServiceConsumeResponseBodyConsumeRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["records"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("records") != m.end() && !m["records"].empty()) {
      if (typeid(vector<boost::any>) == m["records"].type()) {
        vector<DescribeServiceConsumeResponseBodyConsumeRecordsRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeServiceConsumeResponseBodyConsumeRecordsRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<DescribeServiceConsumeResponseBodyConsumeRecordsRecords>>(expect1);
      }
    }
  }


  virtual ~DescribeServiceConsumeResponseBodyConsumeRecords() = default;
};
class DescribeServiceConsumeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeServiceConsumeResponseBodyConsumeRecords>> consumeRecords{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeServiceConsumeResponseBody() {}

  explicit DescribeServiceConsumeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (consumeRecords) {
      vector<boost::any> temp1;
      for(auto item1:*consumeRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["consumeRecords"] = boost::any(temp1);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("consumeRecords") != m.end() && !m["consumeRecords"].empty()) {
      if (typeid(vector<boost::any>) == m["consumeRecords"].type()) {
        vector<DescribeServiceConsumeResponseBodyConsumeRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["consumeRecords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeServiceConsumeResponseBodyConsumeRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consumeRecords = make_shared<vector<DescribeServiceConsumeResponseBodyConsumeRecords>>(expect1);
      }
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeServiceConsumeResponseBody() = default;
};
class DescribeServiceConsumeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeServiceConsumeResponseBody> body{};

  DescribeServiceConsumeResponse() {}

  explicit DescribeServiceConsumeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeServiceConsumeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeServiceConsumeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeServiceConsumeResponse() = default;
};
class DescribeServiceConsumeDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> endDate{};
  shared_ptr<string> regId{};
  shared_ptr<string> serviceCode{};
  shared_ptr<string> startDate{};

  DescribeServiceConsumeDownloadUrlRequest() {}

  explicit DescribeServiceConsumeDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (serviceCode) {
      res["serviceCode"] = boost::any(*serviceCode);
    }
    if (startDate) {
      res["startDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["endDate"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("serviceCode") != m.end() && !m["serviceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["serviceCode"]));
    }
    if (m.find("startDate") != m.end() && !m["startDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["startDate"]));
    }
  }


  virtual ~DescribeServiceConsumeDownloadUrlRequest() = default;
};
class DescribeServiceConsumeDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> downloadFileUrl{};

  DescribeServiceConsumeDownloadUrlResponseBody() {}

  explicit DescribeServiceConsumeDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (downloadFileUrl) {
      res["downloadFileUrl"] = boost::any(*downloadFileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("downloadFileUrl") != m.end() && !m["downloadFileUrl"].empty()) {
      downloadFileUrl = make_shared<string>(boost::any_cast<string>(m["downloadFileUrl"]));
    }
  }


  virtual ~DescribeServiceConsumeDownloadUrlResponseBody() = default;
};
class DescribeServiceConsumeDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeServiceConsumeDownloadUrlResponseBody> body{};

  DescribeServiceConsumeDownloadUrlResponse() {}

  explicit DescribeServiceConsumeDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeServiceConsumeDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeServiceConsumeDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeServiceConsumeDownloadUrlResponse() = default;
};
class DescribeServiceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeServiceListRequest() {}

  explicit DescribeServiceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeServiceListRequest() = default;
};
class DescribeServiceListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> serviceCode{};
  shared_ptr<string> serviceName{};

  DescribeServiceListResponseBodyResultObject() {}

  explicit DescribeServiceListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceCode) {
      res["serviceCode"] = boost::any(*serviceCode);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceCode") != m.end() && !m["serviceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["serviceCode"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
  }


  virtual ~DescribeServiceListResponseBodyResultObject() = default;
};
class DescribeServiceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeServiceListResponseBodyResultObject>> resultObject{};

  DescribeServiceListResponseBody() {}

  explicit DescribeServiceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeServiceListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeServiceListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeServiceListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~DescribeServiceListResponseBody() = default;
};
class DescribeServiceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeServiceListResponseBody> body{};

  DescribeServiceListResponse() {}

  explicit DescribeServiceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeServiceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeServiceListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeServiceListResponse() = default;
};
class DescribeSimulationPreditInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> regId{};
  shared_ptr<string> rulesStr{};

  DescribeSimulationPreditInfoRequest() {}

  explicit DescribeSimulationPreditInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (rulesStr) {
      res["rulesStr"] = boost::any(*rulesStr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("rulesStr") != m.end() && !m["rulesStr"].empty()) {
      rulesStr = make_shared<string>(boost::any_cast<string>(m["rulesStr"]));
    }
  }


  virtual ~DescribeSimulationPreditInfoRequest() = default;
};
class DescribeSimulationPreditInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeSimulationPreditInfoResponseBody() {}

  explicit DescribeSimulationPreditInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeSimulationPreditInfoResponseBody() = default;
};
class DescribeSimulationPreditInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSimulationPreditInfoResponseBody> body{};

  DescribeSimulationPreditInfoResponse() {}

  explicit DescribeSimulationPreditInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSimulationPreditInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSimulationPreditInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSimulationPreditInfoResponse() = default;
};
class DescribeSimulationTaskCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> dataSourceConfig{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> filtersStr{};
  shared_ptr<string> regId{};
  shared_ptr<long> startTime{};

  DescribeSimulationTaskCountRequest() {}

  explicit DescribeSimulationTaskCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (dataSourceConfig) {
      res["dataSourceConfig"] = boost::any(*dataSourceConfig);
    }
    if (dataSourceType) {
      res["dataSourceType"] = boost::any(*dataSourceType);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (filtersStr) {
      res["filtersStr"] = boost::any(*filtersStr);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("dataSourceConfig") != m.end() && !m["dataSourceConfig"].empty()) {
      dataSourceConfig = make_shared<string>(boost::any_cast<string>(m["dataSourceConfig"]));
    }
    if (m.find("dataSourceType") != m.end() && !m["dataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["dataSourceType"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("filtersStr") != m.end() && !m["filtersStr"].empty()) {
      filtersStr = make_shared<string>(boost::any_cast<string>(m["filtersStr"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
  }


  virtual ~DescribeSimulationTaskCountRequest() = default;
};
class DescribeSimulationTaskCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeSimulationTaskCountResponseBody() {}

  explicit DescribeSimulationTaskCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeSimulationTaskCountResponseBody() = default;
};
class DescribeSimulationTaskCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSimulationTaskCountResponseBody> body{};

  DescribeSimulationTaskCountResponse() {}

  explicit DescribeSimulationTaskCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSimulationTaskCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSimulationTaskCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSimulationTaskCountResponse() = default;
};
class DescribeSimulationTaskListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> title{};

  DescribeSimulationTaskListRequest() {}

  explicit DescribeSimulationTaskListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~DescribeSimulationTaskListRequest() = default;
};
class DescribeSimulationTaskListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeSimulationTaskListResponseBody() {}

  explicit DescribeSimulationTaskListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeSimulationTaskListResponseBody() = default;
};
class DescribeSimulationTaskListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSimulationTaskListResponseBody> body{};

  DescribeSimulationTaskListResponse() {}

  explicit DescribeSimulationTaskListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSimulationTaskListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSimulationTaskListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSimulationTaskListResponse() = default;
};
class DescribeSlsUrlConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeSlsUrlConfigRequest() {}

  explicit DescribeSlsUrlConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeSlsUrlConfigRequest() = default;
};
class DescribeSlsUrlConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultObject{};

  DescribeSlsUrlConfigResponseBody() {}

  explicit DescribeSlsUrlConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<string>(boost::any_cast<string>(m["resultObject"]));
    }
  }


  virtual ~DescribeSlsUrlConfigResponseBody() = default;
};
class DescribeSlsUrlConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSlsUrlConfigResponseBody> body{};

  DescribeSlsUrlConfigResponse() {}

  explicit DescribeSlsUrlConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSlsUrlConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSlsUrlConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSlsUrlConfigResponse() = default;
};
class DescribeSupportRuleListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> regId{};

  DescribeSupportRuleListRequest() {}

  explicit DescribeSupportRuleListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeSupportRuleListRequest() = default;
};
class DescribeSupportRuleListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeSupportRuleListResponseBody() {}

  explicit DescribeSupportRuleListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeSupportRuleListResponseBody() = default;
};
class DescribeSupportRuleListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSupportRuleListResponseBody> body{};

  DescribeSupportRuleListResponse() {}

  explicit DescribeSupportRuleListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSupportRuleListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSupportRuleListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSupportRuleListResponse() = default;
};
class DescribeTagListRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeTagListRequest() {}

  explicit DescribeTagListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["RegId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RegId") != m.end() && !m["RegId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["RegId"]));
    }
  }


  virtual ~DescribeTagListRequest() = default;
};
class DescribeTagListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultObject{};

  DescribeTagListResponseBody() {}

  explicit DescribeTagListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["ResultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultObject") != m.end() && !m["ResultObject"].empty()) {
      resultObject = make_shared<string>(boost::any_cast<string>(m["ResultObject"]));
    }
  }


  virtual ~DescribeTagListResponseBody() = default;
};
class DescribeTagListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagListResponseBody> body{};

  DescribeTagListResponse() {}

  explicit DescribeTagListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagListResponse() = default;
};
class DescribeTagsBarChartRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> regId{};
  shared_ptr<string> result{};

  DescribeTagsBarChartRequest() {}

  explicit DescribeTagsBarChartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
  }


  virtual ~DescribeTagsBarChartRequest() = default;
};
class DescribeTagsBarChartResponseBodyResultObjectSeriesData : public Darabonba::Model {
public:
  shared_ptr<long> num{};
  shared_ptr<string> scale{};

  DescribeTagsBarChartResponseBodyResultObjectSeriesData() {}

  explicit DescribeTagsBarChartResponseBodyResultObjectSeriesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (num) {
      res["num"] = boost::any(*num);
    }
    if (scale) {
      res["scale"] = boost::any(*scale);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("num") != m.end() && !m["num"].empty()) {
      num = make_shared<long>(boost::any_cast<long>(m["num"]));
    }
    if (m.find("scale") != m.end() && !m["scale"].empty()) {
      scale = make_shared<string>(boost::any_cast<string>(m["scale"]));
    }
  }


  virtual ~DescribeTagsBarChartResponseBodyResultObjectSeriesData() = default;
};
class DescribeTagsBarChartResponseBodyResultObjectSeries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTagsBarChartResponseBodyResultObjectSeriesData>> data{};
  shared_ptr<string> name{};
  shared_ptr<string> stack{};

  DescribeTagsBarChartResponseBodyResultObjectSeries() {}

  explicit DescribeTagsBarChartResponseBodyResultObjectSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (stack) {
      res["stack"] = boost::any(*stack);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<DescribeTagsBarChartResponseBodyResultObjectSeriesData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagsBarChartResponseBodyResultObjectSeriesData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeTagsBarChartResponseBodyResultObjectSeriesData>>(expect1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("stack") != m.end() && !m["stack"].empty()) {
      stack = make_shared<string>(boost::any_cast<string>(m["stack"]));
    }
  }


  virtual ~DescribeTagsBarChartResponseBodyResultObjectSeries() = default;
};
class DescribeTagsBarChartResponseBodyResultObjectXaxis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};

  DescribeTagsBarChartResponseBodyResultObjectXaxis() {}

  explicit DescribeTagsBarChartResponseBodyResultObjectXaxis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeTagsBarChartResponseBodyResultObjectXaxis() = default;
};
class DescribeTagsBarChartResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTagsBarChartResponseBodyResultObjectSeries>> series{};
  shared_ptr<DescribeTagsBarChartResponseBodyResultObjectXaxis> xaxis{};

  DescribeTagsBarChartResponseBodyResultObject() {}

  explicit DescribeTagsBarChartResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    if (xaxis) {
      res["xaxis"] = xaxis ? boost::any(xaxis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeTagsBarChartResponseBodyResultObjectSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagsBarChartResponseBodyResultObjectSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeTagsBarChartResponseBodyResultObjectSeries>>(expect1);
      }
    }
    if (m.find("xaxis") != m.end() && !m["xaxis"].empty()) {
      if (typeid(map<string, boost::any>) == m["xaxis"].type()) {
        DescribeTagsBarChartResponseBodyResultObjectXaxis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["xaxis"]));
        xaxis = make_shared<DescribeTagsBarChartResponseBodyResultObjectXaxis>(model1);
      }
    }
  }


  virtual ~DescribeTagsBarChartResponseBodyResultObject() = default;
};
class DescribeTagsBarChartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTagsBarChartResponseBodyResultObject> resultObject{};
  shared_ptr<bool> success{};

  DescribeTagsBarChartResponseBody() {}

  explicit DescribeTagsBarChartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeTagsBarChartResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeTagsBarChartResponseBodyResultObject>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeTagsBarChartResponseBody() = default;
};
class DescribeTagsBarChartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagsBarChartResponseBody> body{};

  DescribeTagsBarChartResponse() {}

  explicit DescribeTagsBarChartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagsBarChartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagsBarChartResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagsBarChartResponse() = default;
};
class DescribeTagsFluctuationRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> regId{};

  DescribeTagsFluctuationRequest() {}

  explicit DescribeTagsFluctuationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeTagsFluctuationRequest() = default;
};
class DescribeTagsFluctuationResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<long> todayNum{};
  shared_ptr<string> withinSevenDayNum{};
  shared_ptr<string> withinThirtyDayNum{};
  shared_ptr<string> withinThreeDayNum{};
  shared_ptr<long> yesterdayNum{};

  DescribeTagsFluctuationResponseBodyResultObject() {}

  explicit DescribeTagsFluctuationResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["tableName"] = boost::any(*tableName);
    }
    if (todayNum) {
      res["todayNum"] = boost::any(*todayNum);
    }
    if (withinSevenDayNum) {
      res["withinSevenDayNum"] = boost::any(*withinSevenDayNum);
    }
    if (withinThirtyDayNum) {
      res["withinThirtyDayNum"] = boost::any(*withinThirtyDayNum);
    }
    if (withinThreeDayNum) {
      res["withinThreeDayNum"] = boost::any(*withinThreeDayNum);
    }
    if (yesterdayNum) {
      res["yesterdayNum"] = boost::any(*yesterdayNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tableName") != m.end() && !m["tableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["tableName"]));
    }
    if (m.find("todayNum") != m.end() && !m["todayNum"].empty()) {
      todayNum = make_shared<long>(boost::any_cast<long>(m["todayNum"]));
    }
    if (m.find("withinSevenDayNum") != m.end() && !m["withinSevenDayNum"].empty()) {
      withinSevenDayNum = make_shared<string>(boost::any_cast<string>(m["withinSevenDayNum"]));
    }
    if (m.find("withinThirtyDayNum") != m.end() && !m["withinThirtyDayNum"].empty()) {
      withinThirtyDayNum = make_shared<string>(boost::any_cast<string>(m["withinThirtyDayNum"]));
    }
    if (m.find("withinThreeDayNum") != m.end() && !m["withinThreeDayNum"].empty()) {
      withinThreeDayNum = make_shared<string>(boost::any_cast<string>(m["withinThreeDayNum"]));
    }
    if (m.find("yesterdayNum") != m.end() && !m["yesterdayNum"].empty()) {
      yesterdayNum = make_shared<long>(boost::any_cast<long>(m["yesterdayNum"]));
    }
  }


  virtual ~DescribeTagsFluctuationResponseBodyResultObject() = default;
};
class DescribeTagsFluctuationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTagsFluctuationResponseBodyResultObject>> resultObject{};
  shared_ptr<bool> success{};

  DescribeTagsFluctuationResponseBody() {}

  explicit DescribeTagsFluctuationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeTagsFluctuationResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagsFluctuationResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeTagsFluctuationResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeTagsFluctuationResponseBody() = default;
};
class DescribeTagsFluctuationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagsFluctuationResponseBody> body{};

  DescribeTagsFluctuationResponse() {}

  explicit DescribeTagsFluctuationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagsFluctuationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagsFluctuationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagsFluctuationResponse() = default;
};
class DescribeTagsListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeTagsListRequest() {}

  explicit DescribeTagsListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeTagsListRequest() = default;
};
class DescribeTagsListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeTagsListResponseBody() {}

  explicit DescribeTagsListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeTagsListResponseBody() = default;
};
class DescribeTagsListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagsListResponseBody> body{};

  DescribeTagsListResponse() {}

  explicit DescribeTagsListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagsListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagsListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagsListResponse() = default;
};
class DescribeTagsNumLineChartRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> beginTime{};
  shared_ptr<string> byPassEventCodes{};
  shared_ptr<string> endTime{};
  shared_ptr<string> mainEventCodes{};
  shared_ptr<string> regId{};
  shared_ptr<string> shuntEventCodes{};

  DescribeTagsNumLineChartRequest() {}

  explicit DescribeTagsNumLineChartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (byPassEventCodes) {
      res["byPassEventCodes"] = boost::any(*byPassEventCodes);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (mainEventCodes) {
      res["mainEventCodes"] = boost::any(*mainEventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (shuntEventCodes) {
      res["shuntEventCodes"] = boost::any(*shuntEventCodes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["beginTime"]));
    }
    if (m.find("byPassEventCodes") != m.end() && !m["byPassEventCodes"].empty()) {
      byPassEventCodes = make_shared<string>(boost::any_cast<string>(m["byPassEventCodes"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("mainEventCodes") != m.end() && !m["mainEventCodes"].empty()) {
      mainEventCodes = make_shared<string>(boost::any_cast<string>(m["mainEventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("shuntEventCodes") != m.end() && !m["shuntEventCodes"].empty()) {
      shuntEventCodes = make_shared<string>(boost::any_cast<string>(m["shuntEventCodes"]));
    }
  }


  virtual ~DescribeTagsNumLineChartRequest() = default;
};
class DescribeTagsNumLineChartResponseBodyResultObjectSeries : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};
  shared_ptr<string> name{};

  DescribeTagsNumLineChartResponseBodyResultObjectSeries() {}

  explicit DescribeTagsNumLineChartResponseBodyResultObjectSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeTagsNumLineChartResponseBodyResultObjectSeries() = default;
};
class DescribeTagsNumLineChartResponseBodyResultObjectXaxis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};

  DescribeTagsNumLineChartResponseBodyResultObjectXaxis() {}

  explicit DescribeTagsNumLineChartResponseBodyResultObjectXaxis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeTagsNumLineChartResponseBodyResultObjectXaxis() = default;
};
class DescribeTagsNumLineChartResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTagsNumLineChartResponseBodyResultObjectSeries>> series{};
  shared_ptr<DescribeTagsNumLineChartResponseBodyResultObjectXaxis> xaxis{};

  DescribeTagsNumLineChartResponseBodyResultObject() {}

  explicit DescribeTagsNumLineChartResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    if (xaxis) {
      res["xaxis"] = xaxis ? boost::any(xaxis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeTagsNumLineChartResponseBodyResultObjectSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagsNumLineChartResponseBodyResultObjectSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeTagsNumLineChartResponseBodyResultObjectSeries>>(expect1);
      }
    }
    if (m.find("xaxis") != m.end() && !m["xaxis"].empty()) {
      if (typeid(map<string, boost::any>) == m["xaxis"].type()) {
        DescribeTagsNumLineChartResponseBodyResultObjectXaxis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["xaxis"]));
        xaxis = make_shared<DescribeTagsNumLineChartResponseBodyResultObjectXaxis>(model1);
      }
    }
  }


  virtual ~DescribeTagsNumLineChartResponseBodyResultObject() = default;
};
class DescribeTagsNumLineChartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTagsNumLineChartResponseBodyResultObject> resultObject{};

  DescribeTagsNumLineChartResponseBody() {}

  explicit DescribeTagsNumLineChartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeTagsNumLineChartResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeTagsNumLineChartResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeTagsNumLineChartResponseBody() = default;
};
class DescribeTagsNumLineChartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagsNumLineChartResponseBody> body{};

  DescribeTagsNumLineChartResponse() {}

  explicit DescribeTagsNumLineChartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagsNumLineChartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagsNumLineChartResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagsNumLineChartResponse() = default;
};
class DescribeTagsRatioLineChartRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> beginTime{};
  shared_ptr<string> byPassEventCodes{};
  shared_ptr<long> endTime{};
  shared_ptr<string> mainEventCodes{};
  shared_ptr<string> regId{};
  shared_ptr<string> shuntEventCodes{};

  DescribeTagsRatioLineChartRequest() {}

  explicit DescribeTagsRatioLineChartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (byPassEventCodes) {
      res["byPassEventCodes"] = boost::any(*byPassEventCodes);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (mainEventCodes) {
      res["mainEventCodes"] = boost::any(*mainEventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (shuntEventCodes) {
      res["shuntEventCodes"] = boost::any(*shuntEventCodes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("byPassEventCodes") != m.end() && !m["byPassEventCodes"].empty()) {
      byPassEventCodes = make_shared<string>(boost::any_cast<string>(m["byPassEventCodes"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("mainEventCodes") != m.end() && !m["mainEventCodes"].empty()) {
      mainEventCodes = make_shared<string>(boost::any_cast<string>(m["mainEventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("shuntEventCodes") != m.end() && !m["shuntEventCodes"].empty()) {
      shuntEventCodes = make_shared<string>(boost::any_cast<string>(m["shuntEventCodes"]));
    }
  }


  virtual ~DescribeTagsRatioLineChartRequest() = default;
};
class DescribeTagsRatioLineChartResponseBodyResultObjectSeries : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};
  shared_ptr<string> name{};

  DescribeTagsRatioLineChartResponseBodyResultObjectSeries() {}

  explicit DescribeTagsRatioLineChartResponseBodyResultObjectSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeTagsRatioLineChartResponseBodyResultObjectSeries() = default;
};
class DescribeTagsRatioLineChartResponseBodyResultObjectXaxis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};

  DescribeTagsRatioLineChartResponseBodyResultObjectXaxis() {}

  explicit DescribeTagsRatioLineChartResponseBodyResultObjectXaxis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeTagsRatioLineChartResponseBodyResultObjectXaxis() = default;
};
class DescribeTagsRatioLineChartResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTagsRatioLineChartResponseBodyResultObjectSeries>> series{};
  shared_ptr<DescribeTagsRatioLineChartResponseBodyResultObjectXaxis> xaxis{};

  DescribeTagsRatioLineChartResponseBodyResultObject() {}

  explicit DescribeTagsRatioLineChartResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    if (xaxis) {
      res["xaxis"] = xaxis ? boost::any(xaxis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeTagsRatioLineChartResponseBodyResultObjectSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagsRatioLineChartResponseBodyResultObjectSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeTagsRatioLineChartResponseBodyResultObjectSeries>>(expect1);
      }
    }
    if (m.find("xaxis") != m.end() && !m["xaxis"].empty()) {
      if (typeid(map<string, boost::any>) == m["xaxis"].type()) {
        DescribeTagsRatioLineChartResponseBodyResultObjectXaxis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["xaxis"]));
        xaxis = make_shared<DescribeTagsRatioLineChartResponseBodyResultObjectXaxis>(model1);
      }
    }
  }


  virtual ~DescribeTagsRatioLineChartResponseBodyResultObject() = default;
};
class DescribeTagsRatioLineChartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTagsRatioLineChartResponseBodyResultObject> resultObject{};

  DescribeTagsRatioLineChartResponseBody() {}

  explicit DescribeTagsRatioLineChartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeTagsRatioLineChartResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeTagsRatioLineChartResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeTagsRatioLineChartResponseBody() = default;
};
class DescribeTagsRatioLineChartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagsRatioLineChartResponseBody> body{};

  DescribeTagsRatioLineChartResponse() {}

  explicit DescribeTagsRatioLineChartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagsRatioLineChartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagsRatioLineChartResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagsRatioLineChartResponse() = default;
};
class DescribeTagsTrendRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> regId{};
  shared_ptr<string> result{};

  DescribeTagsTrendRequest() {}

  explicit DescribeTagsTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
  }


  virtual ~DescribeTagsTrendRequest() = default;
};
class DescribeTagsTrendResponseBodyResultObjectSeriesData : public Darabonba::Model {
public:
  shared_ptr<long> num{};
  shared_ptr<string> scale{};

  DescribeTagsTrendResponseBodyResultObjectSeriesData() {}

  explicit DescribeTagsTrendResponseBodyResultObjectSeriesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (num) {
      res["num"] = boost::any(*num);
    }
    if (scale) {
      res["scale"] = boost::any(*scale);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("num") != m.end() && !m["num"].empty()) {
      num = make_shared<long>(boost::any_cast<long>(m["num"]));
    }
    if (m.find("scale") != m.end() && !m["scale"].empty()) {
      scale = make_shared<string>(boost::any_cast<string>(m["scale"]));
    }
  }


  virtual ~DescribeTagsTrendResponseBodyResultObjectSeriesData() = default;
};
class DescribeTagsTrendResponseBodyResultObjectSeries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTagsTrendResponseBodyResultObjectSeriesData>> data{};
  shared_ptr<string> name{};

  DescribeTagsTrendResponseBodyResultObjectSeries() {}

  explicit DescribeTagsTrendResponseBodyResultObjectSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<DescribeTagsTrendResponseBodyResultObjectSeriesData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagsTrendResponseBodyResultObjectSeriesData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeTagsTrendResponseBodyResultObjectSeriesData>>(expect1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeTagsTrendResponseBodyResultObjectSeries() = default;
};
class DescribeTagsTrendResponseBodyResultObjectXaxis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};

  DescribeTagsTrendResponseBodyResultObjectXaxis() {}

  explicit DescribeTagsTrendResponseBodyResultObjectXaxis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeTagsTrendResponseBodyResultObjectXaxis() = default;
};
class DescribeTagsTrendResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTagsTrendResponseBodyResultObjectSeries>> series{};
  shared_ptr<DescribeTagsTrendResponseBodyResultObjectXaxis> xaxis{};

  DescribeTagsTrendResponseBodyResultObject() {}

  explicit DescribeTagsTrendResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["series"] = boost::any(temp1);
    }
    if (xaxis) {
      res["xaxis"] = xaxis ? boost::any(xaxis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("series") != m.end() && !m["series"].empty()) {
      if (typeid(vector<boost::any>) == m["series"].type()) {
        vector<DescribeTagsTrendResponseBodyResultObjectSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagsTrendResponseBodyResultObjectSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<DescribeTagsTrendResponseBodyResultObjectSeries>>(expect1);
      }
    }
    if (m.find("xaxis") != m.end() && !m["xaxis"].empty()) {
      if (typeid(map<string, boost::any>) == m["xaxis"].type()) {
        DescribeTagsTrendResponseBodyResultObjectXaxis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["xaxis"]));
        xaxis = make_shared<DescribeTagsTrendResponseBodyResultObjectXaxis>(model1);
      }
    }
  }


  virtual ~DescribeTagsTrendResponseBodyResultObject() = default;
};
class DescribeTagsTrendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTagsTrendResponseBodyResultObject> resultObject{};
  shared_ptr<bool> success{};

  DescribeTagsTrendResponseBody() {}

  explicit DescribeTagsTrendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeTagsTrendResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeTagsTrendResponseBodyResultObject>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeTagsTrendResponseBody() = default;
};
class DescribeTagsTrendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagsTrendResponseBody> body{};

  DescribeTagsTrendResponse() {}

  explicit DescribeTagsTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagsTrendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagsTrendResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagsTrendResponse() = default;
};
class DescribeTaskListRequest : public Darabonba::Model {
public:
  shared_ptr<string> currentPage{};
  shared_ptr<bool> isPage{};
  shared_ptr<string> lang{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};

  DescribeTaskListRequest() {}

  explicit DescribeTaskListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (isPage) {
      res["IsPage"] = boost::any(*isPage);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("IsPage") != m.end() && !m["IsPage"].empty()) {
      isPage = make_shared<bool>(boost::any_cast<bool>(m["IsPage"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeTaskListRequest() = default;
};
class DescribeTaskListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> completionTime{};
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<long> mark{};
  shared_ptr<string> remark{};
  shared_ptr<string> sceneName{};
  shared_ptr<string> status{};
  shared_ptr<long> taskLogId{};
  shared_ptr<string> taskType{};

  DescribeTaskListResponseBodyResultObject() {}

  explicit DescribeTaskListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completionTime) {
      res["completionTime"] = boost::any(*completionTime);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (mark) {
      res["mark"] = boost::any(*mark);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (sceneName) {
      res["sceneName"] = boost::any(*sceneName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (taskLogId) {
      res["taskLogId"] = boost::any(*taskLogId);
    }
    if (taskType) {
      res["taskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("completionTime") != m.end() && !m["completionTime"].empty()) {
      completionTime = make_shared<long>(boost::any_cast<long>(m["completionTime"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("mark") != m.end() && !m["mark"].empty()) {
      mark = make_shared<long>(boost::any_cast<long>(m["mark"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("sceneName") != m.end() && !m["sceneName"].empty()) {
      sceneName = make_shared<string>(boost::any_cast<string>(m["sceneName"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("taskLogId") != m.end() && !m["taskLogId"].empty()) {
      taskLogId = make_shared<long>(boost::any_cast<long>(m["taskLogId"]));
    }
    if (m.find("taskType") != m.end() && !m["taskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["taskType"]));
    }
  }


  virtual ~DescribeTaskListResponseBodyResultObject() = default;
};
class DescribeTaskListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeTaskListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeTaskListResponseBody() {}

  explicit DescribeTaskListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeTaskListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTaskListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeTaskListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeTaskListResponseBody() = default;
};
class DescribeTaskListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTaskListResponseBody> body{};

  DescribeTaskListResponse() {}

  explicit DescribeTaskListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTaskListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTaskListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTaskListResponse() = default;
};
class DescribeTaskLogListRequest : public Darabonba::Model {
public:
  shared_ptr<string> currentPage{};
  shared_ptr<bool> isPage{};
  shared_ptr<string> lang{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskLogId{};
  shared_ptr<string> regId{};

  DescribeTaskLogListRequest() {}

  explicit DescribeTaskLogListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (isPage) {
      res["IsPage"] = boost::any(*isPage);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskLogId) {
      res["TaskLogId"] = boost::any(*taskLogId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("IsPage") != m.end() && !m["IsPage"].empty()) {
      isPage = make_shared<bool>(boost::any_cast<bool>(m["IsPage"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskLogId") != m.end() && !m["TaskLogId"].empty()) {
      taskLogId = make_shared<string>(boost::any_cast<string>(m["TaskLogId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeTaskLogListRequest() = default;
};
class DescribeTaskLogListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> completionTime{};
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<string> remark{};
  shared_ptr<string> sceneName{};
  shared_ptr<string> status{};
  shared_ptr<string> taskType{};

  DescribeTaskLogListResponseBodyResultObject() {}

  explicit DescribeTaskLogListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completionTime) {
      res["completionTime"] = boost::any(*completionTime);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (sceneName) {
      res["sceneName"] = boost::any(*sceneName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (taskType) {
      res["taskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("completionTime") != m.end() && !m["completionTime"].empty()) {
      completionTime = make_shared<long>(boost::any_cast<long>(m["completionTime"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("sceneName") != m.end() && !m["sceneName"].empty()) {
      sceneName = make_shared<string>(boost::any_cast<string>(m["sceneName"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("taskType") != m.end() && !m["taskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["taskType"]));
    }
  }


  virtual ~DescribeTaskLogListResponseBodyResultObject() = default;
};
class DescribeTaskLogListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeTaskLogListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeTaskLogListResponseBody() {}

  explicit DescribeTaskLogListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeTaskLogListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTaskLogListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeTaskLogListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeTaskLogListResponseBody() = default;
};
class DescribeTaskLogListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTaskLogListResponseBody> body{};

  DescribeTaskLogListResponse() {}

  explicit DescribeTaskLogListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTaskLogListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTaskLogListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTaskLogListResponse() = default;
};
class DescribeTemplateBaseInfoByTemplateIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<long> templateId{};

  DescribeTemplateBaseInfoByTemplateIdRequest() {}

  explicit DescribeTemplateBaseInfoByTemplateIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["templateId"]));
    }
  }


  virtual ~DescribeTemplateBaseInfoByTemplateIdRequest() = default;
};
class DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectInputFields : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> fieldCode{};
  shared_ptr<string> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<string> title{};

  DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectInputFields() {}

  explicit DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectInputFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (fieldCode) {
      res["fieldCode"] = boost::any(*fieldCode);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("fieldCode") != m.end() && !m["fieldCode"].empty()) {
      fieldCode = make_shared<string>(boost::any_cast<string>(m["fieldCode"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<string>(boost::any_cast<string>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectInputFields() = default;
};
class DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectRuleDetails : public Darabonba::Model {
public:
  shared_ptr<string> logicExpression{};
  shared_ptr<string> memo{};
  shared_ptr<string> ruleActions{};
  shared_ptr<string> ruleExpressions{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};

  DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectRuleDetails() {}

  explicit DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectRuleDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicExpression) {
      res["logicExpression"] = boost::any(*logicExpression);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (ruleActions) {
      res["ruleActions"] = boost::any(*ruleActions);
    }
    if (ruleExpressions) {
      res["ruleExpressions"] = boost::any(*ruleExpressions);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logicExpression") != m.end() && !m["logicExpression"].empty()) {
      logicExpression = make_shared<string>(boost::any_cast<string>(m["logicExpression"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("ruleActions") != m.end() && !m["ruleActions"].empty()) {
      ruleActions = make_shared<string>(boost::any_cast<string>(m["ruleActions"]));
    }
    if (m.find("ruleExpressions") != m.end() && !m["ruleExpressions"].empty()) {
      ruleExpressions = make_shared<string>(boost::any_cast<string>(m["ruleExpressions"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
  }


  virtual ~DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectRuleDetails() = default;
};
class DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventStauts{};
  shared_ptr<vector<DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectInputFields>> inputFields{};
  shared_ptr<vector<DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectRuleDetails>> ruleDetails{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};
  shared_ptr<long> version{};

  DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObject() {}

  explicit DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (eventStauts) {
      res["eventStauts"] = boost::any(*eventStauts);
    }
    if (inputFields) {
      vector<boost::any> temp1;
      for(auto item1:*inputFields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["inputFields"] = boost::any(temp1);
    }
    if (ruleDetails) {
      vector<boost::any> temp1;
      for(auto item1:*ruleDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ruleDetails"] = boost::any(temp1);
    }
    if (templateCode) {
      res["templateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["templateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["templateType"] = boost::any(*templateType);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("eventStauts") != m.end() && !m["eventStauts"].empty()) {
      eventStauts = make_shared<string>(boost::any_cast<string>(m["eventStauts"]));
    }
    if (m.find("inputFields") != m.end() && !m["inputFields"].empty()) {
      if (typeid(vector<boost::any>) == m["inputFields"].type()) {
        vector<DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectInputFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["inputFields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectInputFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputFields = make_shared<vector<DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectInputFields>>(expect1);
      }
    }
    if (m.find("ruleDetails") != m.end() && !m["ruleDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ruleDetails"].type()) {
        vector<DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectRuleDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ruleDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectRuleDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleDetails = make_shared<vector<DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObjectRuleDetails>>(expect1);
      }
    }
    if (m.find("templateCode") != m.end() && !m["templateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["templateCode"]));
    }
    if (m.find("templateName") != m.end() && !m["templateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["templateName"]));
    }
    if (m.find("templateType") != m.end() && !m["templateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["templateType"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObject() = default;
};
class DescribeTemplateBaseInfoByTemplateIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObject> resultObject{};

  DescribeTemplateBaseInfoByTemplateIdResponseBody() {}

  explicit DescribeTemplateBaseInfoByTemplateIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeTemplateBaseInfoByTemplateIdResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeTemplateBaseInfoByTemplateIdResponseBody() = default;
};
class DescribeTemplateBaseInfoByTemplateIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTemplateBaseInfoByTemplateIdResponseBody> body{};

  DescribeTemplateBaseInfoByTemplateIdResponse() {}

  explicit DescribeTemplateBaseInfoByTemplateIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTemplateBaseInfoByTemplateIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTemplateBaseInfoByTemplateIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTemplateBaseInfoByTemplateIdResponse() = default;
};
class DescribeTemplateCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeTemplateCountRequest() {}

  explicit DescribeTemplateCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeTemplateCountRequest() = default;
};
class DescribeTemplateCountResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<bool> limit{};
  shared_ptr<long> maxTotalItem{};
  shared_ptr<long> totalItem{};

  DescribeTemplateCountResponseBodyResultObject() {}

  explicit DescribeTemplateCountResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (limit) {
      res["limit"] = boost::any(*limit);
    }
    if (maxTotalItem) {
      res["maxTotalItem"] = boost::any(*maxTotalItem);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("limit") != m.end() && !m["limit"].empty()) {
      limit = make_shared<bool>(boost::any_cast<bool>(m["limit"]));
    }
    if (m.find("maxTotalItem") != m.end() && !m["maxTotalItem"].empty()) {
      maxTotalItem = make_shared<long>(boost::any_cast<long>(m["maxTotalItem"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
  }


  virtual ~DescribeTemplateCountResponseBodyResultObject() = default;
};
class DescribeTemplateCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTemplateCountResponseBodyResultObject> resultObject{};

  DescribeTemplateCountResponseBody() {}

  explicit DescribeTemplateCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeTemplateCountResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeTemplateCountResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeTemplateCountResponseBody() = default;
};
class DescribeTemplateCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTemplateCountResponseBody> body{};

  DescribeTemplateCountResponse() {}

  explicit DescribeTemplateCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTemplateCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTemplateCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTemplateCountResponse() = default;
};
class DescribeTemplateDownloadRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeTemplateDownloadRequest() {}

  explicit DescribeTemplateDownloadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeTemplateDownloadRequest() = default;
};
class DescribeTemplateDownloadResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  DescribeTemplateDownloadResponseBody() {}

  explicit DescribeTemplateDownloadResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~DescribeTemplateDownloadResponseBody() = default;
};
class DescribeTemplateDownloadResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTemplateDownloadResponseBody> body{};

  DescribeTemplateDownloadResponse() {}

  explicit DescribeTemplateDownloadResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTemplateDownloadResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTemplateDownloadResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTemplateDownloadResponse() = default;
};
class DescribeTemplatePageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> eventCodes{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateSearchItem{};
  shared_ptr<string> templateStatus{};
  shared_ptr<string> templateType{};

  DescribeTemplatePageListRequest() {}

  explicit DescribeTemplatePageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (templateName) {
      res["templateName"] = boost::any(*templateName);
    }
    if (templateSearchItem) {
      res["templateSearchItem"] = boost::any(*templateSearchItem);
    }
    if (templateStatus) {
      res["templateStatus"] = boost::any(*templateStatus);
    }
    if (templateType) {
      res["templateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("templateName") != m.end() && !m["templateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["templateName"]));
    }
    if (m.find("templateSearchItem") != m.end() && !m["templateSearchItem"].empty()) {
      templateSearchItem = make_shared<string>(boost::any_cast<string>(m["templateSearchItem"]));
    }
    if (m.find("templateStatus") != m.end() && !m["templateStatus"].empty()) {
      templateStatus = make_shared<string>(boost::any_cast<string>(m["templateStatus"]));
    }
    if (m.find("templateType") != m.end() && !m["templateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["templateType"]));
    }
  }


  virtual ~DescribeTemplatePageListRequest() = default;
};
class DescribeTemplatePageListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> ruleCount{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateStatus{};
  shared_ptr<string> templateType{};
  shared_ptr<long> userCount{};
  shared_ptr<long> version{};

  DescribeTemplatePageListResponseBodyResultObject() {}

  explicit DescribeTemplatePageListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (ruleCount) {
      res["ruleCount"] = boost::any(*ruleCount);
    }
    if (templateCode) {
      res["templateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["templateName"] = boost::any(*templateName);
    }
    if (templateStatus) {
      res["templateStatus"] = boost::any(*templateStatus);
    }
    if (templateType) {
      res["templateType"] = boost::any(*templateType);
    }
    if (userCount) {
      res["userCount"] = boost::any(*userCount);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("ruleCount") != m.end() && !m["ruleCount"].empty()) {
      ruleCount = make_shared<long>(boost::any_cast<long>(m["ruleCount"]));
    }
    if (m.find("templateCode") != m.end() && !m["templateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["templateCode"]));
    }
    if (m.find("templateName") != m.end() && !m["templateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["templateName"]));
    }
    if (m.find("templateStatus") != m.end() && !m["templateStatus"].empty()) {
      templateStatus = make_shared<string>(boost::any_cast<string>(m["templateStatus"]));
    }
    if (m.find("templateType") != m.end() && !m["templateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["templateType"]));
    }
    if (m.find("userCount") != m.end() && !m["userCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["userCount"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~DescribeTemplatePageListResponseBodyResultObject() = default;
};
class DescribeTemplatePageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTemplatePageListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeTemplatePageListResponseBody() {}

  explicit DescribeTemplatePageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeTemplatePageListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTemplatePageListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeTemplatePageListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeTemplatePageListResponseBody() = default;
};
class DescribeTemplatePageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTemplatePageListResponseBody> body{};

  DescribeTemplatePageListResponse() {}

  explicit DescribeTemplatePageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTemplatePageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTemplatePageListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTemplatePageListResponse() = default;
};
class DescribeUsedServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeUsedServiceRequest() {}

  explicit DescribeUsedServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeUsedServiceRequest() = default;
};
class DescribeUsedServiceResponseBodyRecords : public Darabonba::Model {
public:
  shared_ptr<string> enName{};
  shared_ptr<string> name{};
  shared_ptr<string> serviceCode{};

  DescribeUsedServiceResponseBodyRecords() {}

  explicit DescribeUsedServiceResponseBodyRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enName) {
      res["enName"] = boost::any(*enName);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (serviceCode) {
      res["serviceCode"] = boost::any(*serviceCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enName") != m.end() && !m["enName"].empty()) {
      enName = make_shared<string>(boost::any_cast<string>(m["enName"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("serviceCode") != m.end() && !m["serviceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["serviceCode"]));
    }
  }


  virtual ~DescribeUsedServiceResponseBodyRecords() = default;
};
class DescribeUsedServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeUsedServiceResponseBodyRecords>> records{};

  DescribeUsedServiceResponseBody() {}

  explicit DescribeUsedServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["records"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("records") != m.end() && !m["records"].empty()) {
      if (typeid(vector<boost::any>) == m["records"].type()) {
        vector<DescribeUsedServiceResponseBodyRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUsedServiceResponseBodyRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<DescribeUsedServiceResponseBodyRecords>>(expect1);
      }
    }
  }


  virtual ~DescribeUsedServiceResponseBody() = default;
};
class DescribeUsedServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUsedServiceResponseBody> body{};

  DescribeUsedServiceResponse() {}

  explicit DescribeUsedServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUsedServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUsedServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUsedServiceResponse() = default;
};
class DescribeUserInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  DescribeUserInfoRequest() {}

  explicit DescribeUserInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeUserInfoRequest() = default;
};
class DescribeUserInfoResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> clientIp{};
  shared_ptr<string> subId{};
  shared_ptr<long> userId{};
  shared_ptr<string> userName{};

  DescribeUserInfoResponseBodyResultObject() {}

  explicit DescribeUserInfoResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIp) {
      res["clientIp"] = boost::any(*clientIp);
    }
    if (subId) {
      res["subId"] = boost::any(*subId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientIp") != m.end() && !m["clientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["clientIp"]));
    }
    if (m.find("subId") != m.end() && !m["subId"].empty()) {
      subId = make_shared<string>(boost::any_cast<string>(m["subId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~DescribeUserInfoResponseBodyResultObject() = default;
};
class DescribeUserInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<DescribeUserInfoResponseBodyResultObject> resultObject{};
  shared_ptr<bool> success{};

  DescribeUserInfoResponseBody() {}

  explicit DescribeUserInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeUserInfoResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeUserInfoResponseBodyResultObject>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DescribeUserInfoResponseBody() = default;
};
class DescribeUserInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserInfoResponseBody> body{};

  DescribeUserInfoResponse() {}

  explicit DescribeUserInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserInfoResponse() = default;
};
class DescribeVariableBindDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> defineId{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  DescribeVariableBindDetailRequest() {}

  explicit DescribeVariableBindDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<long>(boost::any_cast<long>(m["defineId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeVariableBindDetailRequest() = default;
};
class DescribeVariableBindDetailResponseBodyResultObjectParams : public Darabonba::Model {
public:
  shared_ptr<string> eventFieldName{};
  shared_ptr<bool> required{};
  shared_ptr<string> variableName{};

  DescribeVariableBindDetailResponseBodyResultObjectParams() {}

  explicit DescribeVariableBindDetailResponseBodyResultObjectParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventFieldName) {
      res["eventFieldName"] = boost::any(*eventFieldName);
    }
    if (required) {
      res["required"] = boost::any(*required);
    }
    if (variableName) {
      res["variableName"] = boost::any(*variableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventFieldName") != m.end() && !m["eventFieldName"].empty()) {
      eventFieldName = make_shared<string>(boost::any_cast<string>(m["eventFieldName"]));
    }
    if (m.find("required") != m.end() && !m["required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["required"]));
    }
    if (m.find("variableName") != m.end() && !m["variableName"].empty()) {
      variableName = make_shared<string>(boost::any_cast<string>(m["variableName"]));
    }
  }


  virtual ~DescribeVariableBindDetailResponseBodyResultObjectParams() = default;
};
class DescribeVariableBindDetailResponseBodyResultObjectRelationRules : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVariableBindDetailResponseBodyResultObjectRelationRules() {}

  explicit DescribeVariableBindDetailResponseBodyResultObjectRelationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeVariableBindDetailResponseBodyResultObjectRelationRules() = default;
};
class DescribeVariableBindDetailResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<bool> allowModify{};
  shared_ptr<long> defineId{};
  shared_ptr<string> defineTitle{};
  shared_ptr<string> description{};
  shared_ptr<string> eventCode{};
  shared_ptr<long> id{};
  shared_ptr<vector<DescribeVariableBindDetailResponseBodyResultObjectParams>> params{};
  shared_ptr<vector<DescribeVariableBindDetailResponseBodyResultObjectRelationRules>> relationRules{};
  shared_ptr<string> title{};

  DescribeVariableBindDetailResponseBodyResultObject() {}

  explicit DescribeVariableBindDetailResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowModify) {
      res["allowModify"] = boost::any(*allowModify);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (defineTitle) {
      res["defineTitle"] = boost::any(*defineTitle);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (params) {
      vector<boost::any> temp1;
      for(auto item1:*params){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["params"] = boost::any(temp1);
    }
    if (relationRules) {
      vector<boost::any> temp1;
      for(auto item1:*relationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["relationRules"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allowModify") != m.end() && !m["allowModify"].empty()) {
      allowModify = make_shared<bool>(boost::any_cast<bool>(m["allowModify"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<long>(boost::any_cast<long>(m["defineId"]));
    }
    if (m.find("defineTitle") != m.end() && !m["defineTitle"].empty()) {
      defineTitle = make_shared<string>(boost::any_cast<string>(m["defineTitle"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("params") != m.end() && !m["params"].empty()) {
      if (typeid(vector<boost::any>) == m["params"].type()) {
        vector<DescribeVariableBindDetailResponseBodyResultObjectParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["params"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVariableBindDetailResponseBodyResultObjectParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        params = make_shared<vector<DescribeVariableBindDetailResponseBodyResultObjectParams>>(expect1);
      }
    }
    if (m.find("relationRules") != m.end() && !m["relationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["relationRules"].type()) {
        vector<DescribeVariableBindDetailResponseBodyResultObjectRelationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["relationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVariableBindDetailResponseBodyResultObjectRelationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relationRules = make_shared<vector<DescribeVariableBindDetailResponseBodyResultObjectRelationRules>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~DescribeVariableBindDetailResponseBodyResultObject() = default;
};
class DescribeVariableBindDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeVariableBindDetailResponseBodyResultObject> resultObject{};

  DescribeVariableBindDetailResponseBody() {}

  explicit DescribeVariableBindDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeVariableBindDetailResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeVariableBindDetailResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeVariableBindDetailResponseBody() = default;
};
class DescribeVariableBindDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVariableBindDetailResponseBody> body{};

  DescribeVariableBindDetailResponse() {}

  explicit DescribeVariableBindDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVariableBindDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVariableBindDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVariableBindDetailResponse() = default;
};
class DescribeVariableDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  DescribeVariableDetailRequest() {}

  explicit DescribeVariableDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeVariableDetailRequest() = default;
};
class DescribeVariableDetailResponseBodyResultObjectBaseInfo : public Darabonba::Model {
public:
  shared_ptr<string> allowBind{};
  shared_ptr<string> chargingMode{};
  shared_ptr<string> chargingModeDesc{};
  shared_ptr<string> creator{};
  shared_ptr<string> dataDisplay{};
  shared_ptr<string> dataThreshold{};
  shared_ptr<long> deductionFactor{};
  shared_ptr<string> description{};
  shared_ptr<string> frontAllowBind{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> inputRequired{};
  shared_ptr<string> inputs{};
  shared_ptr<string> inputsDesc{};
  shared_ptr<string> invokeKey{};
  shared_ptr<long> invokeRt{};
  shared_ptr<string> invokeSuccessRate{};
  shared_ptr<long> invokeTimes{};
  shared_ptr<string> lastModifiedOperator{};
  shared_ptr<string> name{};
  shared_ptr<string> outputs{};
  shared_ptr<string> outputsDesc{};
  shared_ptr<vector<string>> scene{};
  shared_ptr<vector<string>> sceneDesc{};
  shared_ptr<string> showOrder{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceDesc{};
  shared_ptr<string> status{};
  shared_ptr<vector<string>> supportRegions{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<string> typeDesc{};
  shared_ptr<string> xLabel{};
  shared_ptr<string> yLabel{};

  DescribeVariableDetailResponseBodyResultObjectBaseInfo() {}

  explicit DescribeVariableDetailResponseBodyResultObjectBaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowBind) {
      res["allowBind"] = boost::any(*allowBind);
    }
    if (chargingMode) {
      res["chargingMode"] = boost::any(*chargingMode);
    }
    if (chargingModeDesc) {
      res["chargingModeDesc"] = boost::any(*chargingModeDesc);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (dataDisplay) {
      res["dataDisplay"] = boost::any(*dataDisplay);
    }
    if (dataThreshold) {
      res["dataThreshold"] = boost::any(*dataThreshold);
    }
    if (deductionFactor) {
      res["deductionFactor"] = boost::any(*deductionFactor);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (frontAllowBind) {
      res["frontAllowBind"] = boost::any(*frontAllowBind);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inputRequired) {
      res["inputRequired"] = boost::any(*inputRequired);
    }
    if (inputs) {
      res["inputs"] = boost::any(*inputs);
    }
    if (inputsDesc) {
      res["inputsDesc"] = boost::any(*inputsDesc);
    }
    if (invokeKey) {
      res["invokeKey"] = boost::any(*invokeKey);
    }
    if (invokeRt) {
      res["invokeRt"] = boost::any(*invokeRt);
    }
    if (invokeSuccessRate) {
      res["invokeSuccessRate"] = boost::any(*invokeSuccessRate);
    }
    if (invokeTimes) {
      res["invokeTimes"] = boost::any(*invokeTimes);
    }
    if (lastModifiedOperator) {
      res["lastModifiedOperator"] = boost::any(*lastModifiedOperator);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outputs) {
      res["outputs"] = boost::any(*outputs);
    }
    if (outputsDesc) {
      res["outputsDesc"] = boost::any(*outputsDesc);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    if (sceneDesc) {
      res["sceneDesc"] = boost::any(*sceneDesc);
    }
    if (showOrder) {
      res["showOrder"] = boost::any(*showOrder);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (sourceDesc) {
      res["sourceDesc"] = boost::any(*sourceDesc);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (supportRegions) {
      res["supportRegions"] = boost::any(*supportRegions);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (typeDesc) {
      res["typeDesc"] = boost::any(*typeDesc);
    }
    if (xLabel) {
      res["xLabel"] = boost::any(*xLabel);
    }
    if (yLabel) {
      res["yLabel"] = boost::any(*yLabel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allowBind") != m.end() && !m["allowBind"].empty()) {
      allowBind = make_shared<string>(boost::any_cast<string>(m["allowBind"]));
    }
    if (m.find("chargingMode") != m.end() && !m["chargingMode"].empty()) {
      chargingMode = make_shared<string>(boost::any_cast<string>(m["chargingMode"]));
    }
    if (m.find("chargingModeDesc") != m.end() && !m["chargingModeDesc"].empty()) {
      chargingModeDesc = make_shared<string>(boost::any_cast<string>(m["chargingModeDesc"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("dataDisplay") != m.end() && !m["dataDisplay"].empty()) {
      dataDisplay = make_shared<string>(boost::any_cast<string>(m["dataDisplay"]));
    }
    if (m.find("dataThreshold") != m.end() && !m["dataThreshold"].empty()) {
      dataThreshold = make_shared<string>(boost::any_cast<string>(m["dataThreshold"]));
    }
    if (m.find("deductionFactor") != m.end() && !m["deductionFactor"].empty()) {
      deductionFactor = make_shared<long>(boost::any_cast<long>(m["deductionFactor"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("frontAllowBind") != m.end() && !m["frontAllowBind"].empty()) {
      frontAllowBind = make_shared<string>(boost::any_cast<string>(m["frontAllowBind"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inputRequired") != m.end() && !m["inputRequired"].empty()) {
      inputRequired = make_shared<string>(boost::any_cast<string>(m["inputRequired"]));
    }
    if (m.find("inputs") != m.end() && !m["inputs"].empty()) {
      inputs = make_shared<string>(boost::any_cast<string>(m["inputs"]));
    }
    if (m.find("inputsDesc") != m.end() && !m["inputsDesc"].empty()) {
      inputsDesc = make_shared<string>(boost::any_cast<string>(m["inputsDesc"]));
    }
    if (m.find("invokeKey") != m.end() && !m["invokeKey"].empty()) {
      invokeKey = make_shared<string>(boost::any_cast<string>(m["invokeKey"]));
    }
    if (m.find("invokeRt") != m.end() && !m["invokeRt"].empty()) {
      invokeRt = make_shared<long>(boost::any_cast<long>(m["invokeRt"]));
    }
    if (m.find("invokeSuccessRate") != m.end() && !m["invokeSuccessRate"].empty()) {
      invokeSuccessRate = make_shared<string>(boost::any_cast<string>(m["invokeSuccessRate"]));
    }
    if (m.find("invokeTimes") != m.end() && !m["invokeTimes"].empty()) {
      invokeTimes = make_shared<long>(boost::any_cast<long>(m["invokeTimes"]));
    }
    if (m.find("lastModifiedOperator") != m.end() && !m["lastModifiedOperator"].empty()) {
      lastModifiedOperator = make_shared<string>(boost::any_cast<string>(m["lastModifiedOperator"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outputs") != m.end() && !m["outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["outputs"]));
    }
    if (m.find("outputsDesc") != m.end() && !m["outputsDesc"].empty()) {
      outputsDesc = make_shared<string>(boost::any_cast<string>(m["outputsDesc"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["scene"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["scene"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scene = make_shared<vector<string>>(toVec1);
    }
    if (m.find("sceneDesc") != m.end() && !m["sceneDesc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sceneDesc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sceneDesc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sceneDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("showOrder") != m.end() && !m["showOrder"].empty()) {
      showOrder = make_shared<string>(boost::any_cast<string>(m["showOrder"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("sourceDesc") != m.end() && !m["sourceDesc"].empty()) {
      sourceDesc = make_shared<string>(boost::any_cast<string>(m["sourceDesc"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("supportRegions") != m.end() && !m["supportRegions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["supportRegions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["supportRegions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportRegions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("typeDesc") != m.end() && !m["typeDesc"].empty()) {
      typeDesc = make_shared<string>(boost::any_cast<string>(m["typeDesc"]));
    }
    if (m.find("xLabel") != m.end() && !m["xLabel"].empty()) {
      xLabel = make_shared<string>(boost::any_cast<string>(m["xLabel"]));
    }
    if (m.find("yLabel") != m.end() && !m["yLabel"].empty()) {
      yLabel = make_shared<string>(boost::any_cast<string>(m["yLabel"]));
    }
  }


  virtual ~DescribeVariableDetailResponseBodyResultObjectBaseInfo() = default;
};
class DescribeVariableDetailResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<DescribeVariableDetailResponseBodyResultObjectBaseInfo> baseInfo{};

  DescribeVariableDetailResponseBodyResultObject() {}

  explicit DescribeVariableDetailResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseInfo) {
      res["baseInfo"] = baseInfo ? boost::any(baseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baseInfo") != m.end() && !m["baseInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["baseInfo"].type()) {
        DescribeVariableDetailResponseBodyResultObjectBaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["baseInfo"]));
        baseInfo = make_shared<DescribeVariableDetailResponseBodyResultObjectBaseInfo>(model1);
      }
    }
  }


  virtual ~DescribeVariableDetailResponseBodyResultObject() = default;
};
class DescribeVariableDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeVariableDetailResponseBodyResultObject> resultObject{};

  DescribeVariableDetailResponseBody() {}

  explicit DescribeVariableDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        DescribeVariableDetailResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<DescribeVariableDetailResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~DescribeVariableDetailResponseBody() = default;
};
class DescribeVariableDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVariableDetailResponseBody> body{};

  DescribeVariableDetailResponse() {}

  explicit DescribeVariableDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVariableDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVariableDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVariableDetailResponse() = default;
};
class DescribeVariableFeeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> regId{};

  DescribeVariableFeeRequest() {}

  explicit DescribeVariableFeeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (ids) {
      res["ids"] = boost::any(*ids);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ids") != m.end() && !m["ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeVariableFeeRequest() = default;
};
class DescribeVariableFeeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  DescribeVariableFeeResponseBody() {}

  explicit DescribeVariableFeeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~DescribeVariableFeeResponseBody() = default;
};
class DescribeVariableFeeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVariableFeeResponseBody> body{};

  DescribeVariableFeeResponse() {}

  explicit DescribeVariableFeeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVariableFeeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVariableFeeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVariableFeeResponse() = default;
};
class DescribeVariableListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> refObjId{};
  shared_ptr<string> regId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};
  shared_ptr<string> typesStr{};
  shared_ptr<string> value{};

  DescribeVariableListRequest() {}

  explicit DescribeVariableListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (refObjId) {
      res["refObjId"] = boost::any(*refObjId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (typesStr) {
      res["typesStr"] = boost::any(*typesStr);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("refObjId") != m.end() && !m["refObjId"].empty()) {
      refObjId = make_shared<string>(boost::any_cast<string>(m["refObjId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("typesStr") != m.end() && !m["typesStr"].empty()) {
      typesStr = make_shared<string>(boost::any_cast<string>(m["typesStr"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeVariableListRequest() = default;
};
class DescribeVariableListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> capacity{};
  shared_ptr<string> defineId{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> extendInfo{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> leftCapacity{};
  shared_ptr<string> name{};
  shared_ptr<string> outputsType{};
  shared_ptr<string> refObjId{};
  shared_ptr<string> refObjName{};
  shared_ptr<string> refObjType{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<long> userId{};

  DescribeVariableListResponseBodyResultObject() {}

  explicit DescribeVariableListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacity) {
      res["capacity"] = boost::any(*capacity);
    }
    if (defineId) {
      res["defineId"] = boost::any(*defineId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (extendInfo) {
      res["extendInfo"] = boost::any(*extendInfo);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (leftCapacity) {
      res["leftCapacity"] = boost::any(*leftCapacity);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outputsType) {
      res["outputsType"] = boost::any(*outputsType);
    }
    if (refObjId) {
      res["refObjId"] = boost::any(*refObjId);
    }
    if (refObjName) {
      res["refObjName"] = boost::any(*refObjName);
    }
    if (refObjType) {
      res["refObjType"] = boost::any(*refObjType);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("capacity") != m.end() && !m["capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["capacity"]));
    }
    if (m.find("defineId") != m.end() && !m["defineId"].empty()) {
      defineId = make_shared<string>(boost::any_cast<string>(m["defineId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("extendInfo") != m.end() && !m["extendInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["extendInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extendInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("leftCapacity") != m.end() && !m["leftCapacity"].empty()) {
      leftCapacity = make_shared<long>(boost::any_cast<long>(m["leftCapacity"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outputsType") != m.end() && !m["outputsType"].empty()) {
      outputsType = make_shared<string>(boost::any_cast<string>(m["outputsType"]));
    }
    if (m.find("refObjId") != m.end() && !m["refObjId"].empty()) {
      refObjId = make_shared<string>(boost::any_cast<string>(m["refObjId"]));
    }
    if (m.find("refObjName") != m.end() && !m["refObjName"].empty()) {
      refObjName = make_shared<string>(boost::any_cast<string>(m["refObjName"]));
    }
    if (m.find("refObjType") != m.end() && !m["refObjType"].empty()) {
      refObjType = make_shared<string>(boost::any_cast<string>(m["refObjType"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~DescribeVariableListResponseBodyResultObject() = default;
};
class DescribeVariableListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeVariableListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeVariableListResponseBody() {}

  explicit DescribeVariableListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeVariableListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVariableListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeVariableListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeVariableListResponseBody() = default;
};
class DescribeVariableListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVariableListResponseBody> body{};

  DescribeVariableListResponse() {}

  explicit DescribeVariableListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVariableListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVariableListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVariableListResponse() = default;
};
class DescribeVariableMarketListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> chargingMode{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> paging{};
  shared_ptr<string> queryContent{};
  shared_ptr<string> regId{};
  shared_ptr<string> scenesStr{};
  shared_ptr<string> source{};
  shared_ptr<string> title{};

  DescribeVariableMarketListRequest() {}

  explicit DescribeVariableMarketListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (chargingMode) {
      res["chargingMode"] = boost::any(*chargingMode);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (paging) {
      res["paging"] = boost::any(*paging);
    }
    if (queryContent) {
      res["queryContent"] = boost::any(*queryContent);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (scenesStr) {
      res["scenesStr"] = boost::any(*scenesStr);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("chargingMode") != m.end() && !m["chargingMode"].empty()) {
      chargingMode = make_shared<string>(boost::any_cast<string>(m["chargingMode"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("paging") != m.end() && !m["paging"].empty()) {
      paging = make_shared<string>(boost::any_cast<string>(m["paging"]));
    }
    if (m.find("queryContent") != m.end() && !m["queryContent"].empty()) {
      queryContent = make_shared<string>(boost::any_cast<string>(m["queryContent"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("scenesStr") != m.end() && !m["scenesStr"].empty()) {
      scenesStr = make_shared<string>(boost::any_cast<string>(m["scenesStr"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~DescribeVariableMarketListRequest() = default;
};
class DescribeVariableMarketListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeVariableMarketListResponseBody() {}

  explicit DescribeVariableMarketListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeVariableMarketListResponseBody() = default;
};
class DescribeVariableMarketListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVariableMarketListResponseBody> body{};

  DescribeVariableMarketListResponse() {}

  explicit DescribeVariableMarketListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVariableMarketListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVariableMarketListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVariableMarketListResponse() = default;
};
class DescribeVariableSceneListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> bizType{};
  shared_ptr<string> configKey{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> pageSize{};
  shared_ptr<bool> paging{};
  shared_ptr<string> regId{};

  DescribeVariableSceneListRequest() {}

  explicit DescribeVariableSceneListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (bizType) {
      res["bizType"] = boost::any(*bizType);
    }
    if (configKey) {
      res["configKey"] = boost::any(*configKey);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (paging) {
      res["paging"] = boost::any(*paging);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("bizType") != m.end() && !m["bizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["bizType"]));
    }
    if (m.find("configKey") != m.end() && !m["configKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["configKey"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("paging") != m.end() && !m["paging"].empty()) {
      paging = make_shared<bool>(boost::any_cast<bool>(m["paging"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~DescribeVariableSceneListRequest() = default;
};
class DescribeVariableSceneListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifiedOperator{};
  shared_ptr<string> status{};

  DescribeVariableSceneListResponseBodyResultObject() {}

  explicit DescribeVariableSceneListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["bizType"] = boost::any(*bizType);
    }
    if (configKey) {
      res["configKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["configValue"] = boost::any(*configValue);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastModifiedOperator) {
      res["lastModifiedOperator"] = boost::any(*lastModifiedOperator);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizType") != m.end() && !m["bizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["bizType"]));
    }
    if (m.find("configKey") != m.end() && !m["configKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["configKey"]));
    }
    if (m.find("configValue") != m.end() && !m["configValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["configValue"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("lastModifiedOperator") != m.end() && !m["lastModifiedOperator"].empty()) {
      lastModifiedOperator = make_shared<string>(boost::any_cast<string>(m["lastModifiedOperator"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~DescribeVariableSceneListResponseBodyResultObject() = default;
};
class DescribeVariableSceneListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeVariableSceneListResponseBodyResultObject>> resultObject{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalPage{};

  DescribeVariableSceneListResponseBody() {}

  explicit DescribeVariableSceneListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    if (totalItem) {
      res["totalItem"] = boost::any(*totalItem);
    }
    if (totalPage) {
      res["totalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<DescribeVariableSceneListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVariableSceneListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<DescribeVariableSceneListResponseBodyResultObject>>(expect1);
      }
    }
    if (m.find("totalItem") != m.end() && !m["totalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["totalItem"]));
    }
    if (m.find("totalPage") != m.end() && !m["totalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["totalPage"]));
    }
  }


  virtual ~DescribeVariableSceneListResponseBody() = default;
};
class DescribeVariableSceneListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVariableSceneListResponseBody> body{};

  DescribeVariableSceneListResponse() {}

  explicit DescribeVariableSceneListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVariableSceneListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVariableSceneListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVariableSceneListResponse() = default;
};
class ExpressionTestRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> expression{};
  shared_ptr<string> expressionVariable{};
  shared_ptr<string> expressionVariableIds{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};
  shared_ptr<string> scene{};

  ExpressionTestRequest() {}

  explicit ExpressionTestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (expression) {
      res["expression"] = boost::any(*expression);
    }
    if (expressionVariable) {
      res["expressionVariable"] = boost::any(*expressionVariable);
    }
    if (expressionVariableIds) {
      res["expressionVariableIds"] = boost::any(*expressionVariableIds);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("expression") != m.end() && !m["expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["expression"]));
    }
    if (m.find("expressionVariable") != m.end() && !m["expressionVariable"].empty()) {
      expressionVariable = make_shared<string>(boost::any_cast<string>(m["expressionVariable"]));
    }
    if (m.find("expressionVariableIds") != m.end() && !m["expressionVariableIds"].empty()) {
      expressionVariableIds = make_shared<string>(boost::any_cast<string>(m["expressionVariableIds"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["scene"]));
    }
  }


  virtual ~ExpressionTestRequest() = default;
};
class ExpressionTestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  ExpressionTestResponseBody() {}

  explicit ExpressionTestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~ExpressionTestResponseBody() = default;
};
class ExpressionTestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExpressionTestResponseBody> body{};

  ExpressionTestResponse() {}

  explicit ExpressionTestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExpressionTestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExpressionTestResponseBody>(model1);
      }
    }
  }


  virtual ~ExpressionTestResponse() = default;
};
class FileUploadRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> lang{};
  shared_ptr<string> tab{};

  FileUploadRequest() {}

  explicit FileUploadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (tab) {
      res["Tab"] = boost::any(*tab);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Tab") != m.end() && !m["Tab"].empty()) {
      tab = make_shared<string>(boost::any_cast<string>(m["Tab"]));
    }
  }


  virtual ~FileUploadRequest() = default;
};
class FileUploadResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultObject{};

  FileUploadResponseBody() {}

  explicit FileUploadResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["ResultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultObject") != m.end() && !m["ResultObject"].empty()) {
      resultObject = make_shared<string>(boost::any_cast<string>(m["ResultObject"]));
    }
  }


  virtual ~FileUploadResponseBody() = default;
};
class FileUploadResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FileUploadResponseBody> body{};

  FileUploadResponse() {}

  explicit FileUploadResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FileUploadResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FileUploadResponseBody>(model1);
      }
    }
  }


  virtual ~FileUploadResponse() = default;
};
class ImportNameListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> data{};
  shared_ptr<string> description{};
  shared_ptr<string> importType{};
  shared_ptr<string> nameListType{};
  shared_ptr<string> regId{};
  shared_ptr<string> title{};
  shared_ptr<long> variableId{};

  ImportNameListRequest() {}

  explicit ImportNameListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (importType) {
      res["importType"] = boost::any(*importType);
    }
    if (nameListType) {
      res["nameListType"] = boost::any(*nameListType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (variableId) {
      res["variableId"] = boost::any(*variableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("importType") != m.end() && !m["importType"].empty()) {
      importType = make_shared<string>(boost::any_cast<string>(m["importType"]));
    }
    if (m.find("nameListType") != m.end() && !m["nameListType"].empty()) {
      nameListType = make_shared<string>(boost::any_cast<string>(m["nameListType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("variableId") != m.end() && !m["variableId"].empty()) {
      variableId = make_shared<long>(boost::any_cast<long>(m["variableId"]));
    }
  }


  virtual ~ImportNameListRequest() = default;
};
class ImportNameListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  ImportNameListResponseBody() {}

  explicit ImportNameListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~ImportNameListResponseBody() = default;
};
class ImportNameListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportNameListResponseBody> body{};

  ImportNameListResponse() {}

  explicit ImportNameListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportNameListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportNameListResponseBody>(model1);
      }
    }
  }


  virtual ~ImportNameListResponse() = default;
};
class ImportTemplateEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventTemplateIds{};
  shared_ptr<string> regId{};

  ImportTemplateEventRequest() {}

  explicit ImportTemplateEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventTemplateIds) {
      res["eventTemplateIds"] = boost::any(*eventTemplateIds);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventTemplateIds") != m.end() && !m["eventTemplateIds"].empty()) {
      eventTemplateIds = make_shared<string>(boost::any_cast<string>(m["eventTemplateIds"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~ImportTemplateEventRequest() = default;
};
class ImportTemplateEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  ImportTemplateEventResponseBody() {}

  explicit ImportTemplateEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~ImportTemplateEventResponseBody() = default;
};
class ImportTemplateEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportTemplateEventResponseBody> body{};

  ImportTemplateEventResponse() {}

  explicit ImportTemplateEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportTemplateEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportTemplateEventResponseBody>(model1);
      }
    }
  }


  virtual ~ImportTemplateEventResponse() = default;
};
class ModifyAppKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> appKey{};
  shared_ptr<string> memo{};
  shared_ptr<string> regId{};

  ModifyAppKeyRequest() {}

  explicit ModifyAppKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (appKey) {
      res["appKey"] = boost::any(*appKey);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("appKey") != m.end() && !m["appKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["appKey"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~ModifyAppKeyRequest() = default;
};
class ModifyAppKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  ModifyAppKeyResponseBody() {}

  explicit ModifyAppKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~ModifyAppKeyResponseBody() = default;
};
class ModifyAppKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAppKeyResponseBody> body{};

  ModifyAppKeyResponse() {}

  explicit ModifyAppKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAppKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAppKeyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAppKeyResponse() = default;
};
class ModifyCustVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> condition{};
  shared_ptr<long> dataVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> eventCodes{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> outputs{};
  shared_ptr<string> regId{};

  ModifyCustVariableRequest() {}

  explicit ModifyCustVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (dataVersion) {
      res["dataVersion"] = boost::any(*dataVersion);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCodes) {
      res["eventCodes"] = boost::any(*eventCodes);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (outputs) {
      res["outputs"] = boost::any(*outputs);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("dataVersion") != m.end() && !m["dataVersion"].empty()) {
      dataVersion = make_shared<long>(boost::any_cast<long>(m["dataVersion"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCodes") != m.end() && !m["eventCodes"].empty()) {
      eventCodes = make_shared<string>(boost::any_cast<string>(m["eventCodes"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("outputs") != m.end() && !m["outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["outputs"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~ModifyCustVariableRequest() = default;
};
class ModifyCustVariableResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> failType{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  ModifyCustVariableResponseBodyResultObject() {}

  explicit ModifyCustVariableResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failType) {
      res["failType"] = boost::any(*failType);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("failType") != m.end() && !m["failType"].empty()) {
      failType = make_shared<string>(boost::any_cast<string>(m["failType"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ModifyCustVariableResponseBodyResultObject() = default;
};
class ModifyCustVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ModifyCustVariableResponseBodyResultObject>> resultObject{};

  ModifyCustVariableResponseBody() {}

  explicit ModifyCustVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<ModifyCustVariableResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCustVariableResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<ModifyCustVariableResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~ModifyCustVariableResponseBody() = default;
};
class ModifyCustVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCustVariableResponseBody> body{};

  ModifyCustVariableResponse() {}

  explicit ModifyCustVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCustVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCustVariableResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCustVariableResponse() = default;
};
class ModifyEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> bizVersion{};
  shared_ptr<string> createType{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> inputFieldsStr{};
  shared_ptr<string> memo{};
  shared_ptr<string> regId{};
  shared_ptr<string> templateType{};

  ModifyEventRequest() {}

  explicit ModifyEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (bizVersion) {
      res["bizVersion"] = boost::any(*bizVersion);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (inputFieldsStr) {
      res["inputFieldsStr"] = boost::any(*inputFieldsStr);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (templateType) {
      res["templateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("bizVersion") != m.end() && !m["bizVersion"].empty()) {
      bizVersion = make_shared<long>(boost::any_cast<long>(m["bizVersion"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("inputFieldsStr") != m.end() && !m["inputFieldsStr"].empty()) {
      inputFieldsStr = make_shared<string>(boost::any_cast<string>(m["inputFieldsStr"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("templateType") != m.end() && !m["templateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["templateType"]));
    }
  }


  virtual ~ModifyEventRequest() = default;
};
class ModifyEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  ModifyEventResponseBody() {}

  explicit ModifyEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~ModifyEventResponseBody() = default;
};
class ModifyEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyEventResponseBody> body{};

  ModifyEventResponse() {}

  explicit ModifyEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEventResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEventResponse() = default;
};
class ModifyEventStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> fromEventSatus{};
  shared_ptr<string> regId{};
  shared_ptr<string> toEventSatus{};

  ModifyEventStatusRequest() {}

  explicit ModifyEventStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (fromEventSatus) {
      res["fromEventSatus"] = boost::any(*fromEventSatus);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (toEventSatus) {
      res["toEventSatus"] = boost::any(*toEventSatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("fromEventSatus") != m.end() && !m["fromEventSatus"].empty()) {
      fromEventSatus = make_shared<string>(boost::any_cast<string>(m["fromEventSatus"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("toEventSatus") != m.end() && !m["toEventSatus"].empty()) {
      toEventSatus = make_shared<string>(boost::any_cast<string>(m["toEventSatus"]));
    }
  }


  virtual ~ModifyEventStatusRequest() = default;
};
class ModifyEventStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  ModifyEventStatusResponseBody() {}

  explicit ModifyEventStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~ModifyEventStatusResponseBody() = default;
};
class ModifyEventStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyEventStatusResponseBody> body{};

  ModifyEventStatusResponse() {}

  explicit ModifyEventStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEventStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEventStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEventStatusResponse() = default;
};
class ModifyExpressionVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> dataVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> expression{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<string> expressionVariable{};
  shared_ptr<long> id{};
  shared_ptr<string> outlier{};
  shared_ptr<string> outputs{};
  shared_ptr<string> regId{};
  shared_ptr<string> title{};

  ModifyExpressionVariableRequest() {}

  explicit ModifyExpressionVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (dataVersion) {
      res["dataVersion"] = boost::any(*dataVersion);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (expression) {
      res["expression"] = boost::any(*expression);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (expressionVariable) {
      res["expressionVariable"] = boost::any(*expressionVariable);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputs) {
      res["outputs"] = boost::any(*outputs);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("dataVersion") != m.end() && !m["dataVersion"].empty()) {
      dataVersion = make_shared<long>(boost::any_cast<long>(m["dataVersion"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("expression") != m.end() && !m["expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["expression"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("expressionVariable") != m.end() && !m["expressionVariable"].empty()) {
      expressionVariable = make_shared<string>(boost::any_cast<string>(m["expressionVariable"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputs") != m.end() && !m["outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["outputs"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ModifyExpressionVariableRequest() = default;
};
class ModifyExpressionVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  ModifyExpressionVariableResponseBody() {}

  explicit ModifyExpressionVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~ModifyExpressionVariableResponseBody() = default;
};
class ModifyExpressionVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyExpressionVariableResponseBody> body{};

  ModifyExpressionVariableResponse() {}

  explicit ModifyExpressionVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyExpressionVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyExpressionVariableResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyExpressionVariableResponse() = default;
};
class ModifyFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> classify{};
  shared_ptr<string> description{};
  shared_ptr<string> enumData{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> regId{};
  shared_ptr<string> title{};

  ModifyFieldRequest() {}

  explicit ModifyFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (classify) {
      res["classify"] = boost::any(*classify);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (enumData) {
      res["enumData"] = boost::any(*enumData);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("classify") != m.end() && !m["classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["classify"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("enumData") != m.end() && !m["enumData"].empty()) {
      enumData = make_shared<string>(boost::any_cast<string>(m["enumData"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ModifyFieldRequest() = default;
};
class ModifyFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  ModifyFieldResponseBody() {}

  explicit ModifyFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~ModifyFieldResponseBody() = default;
};
class ModifyFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyFieldResponseBody> body{};

  ModifyFieldResponse() {}

  explicit ModifyFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFieldResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFieldResponse() = default;
};
class ModifyPocTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> accessType{};
  shared_ptr<string> config{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> reason{};
  shared_ptr<string> regId{};
  shared_ptr<string> serviceCode{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> type{};

  ModifyPocTaskRequest() {}

  explicit ModifyPocTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (accessType) {
      res["accessType"] = boost::any(*accessType);
    }
    if (config) {
      res["config"] = boost::any(*config);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["fileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["fileUrl"] = boost::any(*fileUrl);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (serviceCode) {
      res["serviceCode"] = boost::any(*serviceCode);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["taskName"] = boost::any(*taskName);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("accessType") != m.end() && !m["accessType"].empty()) {
      accessType = make_shared<string>(boost::any_cast<string>(m["accessType"]));
    }
    if (m.find("config") != m.end() && !m["config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["config"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
    if (m.find("fileType") != m.end() && !m["fileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["fileType"]));
    }
    if (m.find("fileUrl") != m.end() && !m["fileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["fileUrl"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("serviceCode") != m.end() && !m["serviceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["serviceCode"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
    if (m.find("taskName") != m.end() && !m["taskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["taskName"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ModifyPocTaskRequest() = default;
};
class ModifyPocTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  ModifyPocTaskResponseBody() {}

  explicit ModifyPocTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~ModifyPocTaskResponseBody() = default;
};
class ModifyPocTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPocTaskResponseBody> body{};

  ModifyPocTaskResponse() {}

  explicit ModifyPocTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPocTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPocTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPocTaskResponse() = default;
};
class ModifyRulePriorityRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> consoleRuleId{};
  shared_ptr<long> priority{};
  shared_ptr<string> regId{};
  shared_ptr<long> ruleId{};

  ModifyRulePriorityRequest() {}

  explicit ModifyRulePriorityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["ruleId"]));
    }
  }


  virtual ~ModifyRulePriorityRequest() = default;
};
class ModifyRulePriorityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  ModifyRulePriorityResponseBody() {}

  explicit ModifyRulePriorityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~ModifyRulePriorityResponseBody() = default;
};
class ModifyRulePriorityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRulePriorityResponseBody> body{};

  ModifyRulePriorityResponse() {}

  explicit ModifyRulePriorityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRulePriorityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRulePriorityResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRulePriorityResponse() = default;
};
class ModifyRuleStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> applyUserId{};
  shared_ptr<string> applyUserName{};
  shared_ptr<string> auditRemark{};
  shared_ptr<string> auditUserId{};
  shared_ptr<string> auditUserName{};
  shared_ptr<long> consoleRuleId{};
  shared_ptr<string> eventType{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleAuditType{};
  shared_ptr<string> ruleId{};
  shared_ptr<long> ruleVersionId{};

  ModifyRuleStatusRequest() {}

  explicit ModifyRuleStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (applyUserId) {
      res["applyUserId"] = boost::any(*applyUserId);
    }
    if (applyUserName) {
      res["applyUserName"] = boost::any(*applyUserName);
    }
    if (auditRemark) {
      res["auditRemark"] = boost::any(*auditRemark);
    }
    if (auditUserId) {
      res["auditUserId"] = boost::any(*auditUserId);
    }
    if (auditUserName) {
      res["auditUserName"] = boost::any(*auditUserName);
    }
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleAuditType) {
      res["ruleAuditType"] = boost::any(*ruleAuditType);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleVersionId) {
      res["ruleVersionId"] = boost::any(*ruleVersionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("applyUserId") != m.end() && !m["applyUserId"].empty()) {
      applyUserId = make_shared<string>(boost::any_cast<string>(m["applyUserId"]));
    }
    if (m.find("applyUserName") != m.end() && !m["applyUserName"].empty()) {
      applyUserName = make_shared<string>(boost::any_cast<string>(m["applyUserName"]));
    }
    if (m.find("auditRemark") != m.end() && !m["auditRemark"].empty()) {
      auditRemark = make_shared<string>(boost::any_cast<string>(m["auditRemark"]));
    }
    if (m.find("auditUserId") != m.end() && !m["auditUserId"].empty()) {
      auditUserId = make_shared<string>(boost::any_cast<string>(m["auditUserId"]));
    }
    if (m.find("auditUserName") != m.end() && !m["auditUserName"].empty()) {
      auditUserName = make_shared<string>(boost::any_cast<string>(m["auditUserName"]));
    }
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleAuditType") != m.end() && !m["ruleAuditType"].empty()) {
      ruleAuditType = make_shared<string>(boost::any_cast<string>(m["ruleAuditType"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleVersionId") != m.end() && !m["ruleVersionId"].empty()) {
      ruleVersionId = make_shared<long>(boost::any_cast<long>(m["ruleVersionId"]));
    }
  }


  virtual ~ModifyRuleStatusRequest() = default;
};
class ModifyRuleStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  ModifyRuleStatusResponseBody() {}

  explicit ModifyRuleStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~ModifyRuleStatusResponseBody() = default;
};
class ModifyRuleStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRuleStatusResponseBody> body{};

  ModifyRuleStatusResponse() {}

  explicit ModifyRuleStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRuleStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRuleStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRuleStatusResponse() = default;
};
class ModifyTemplateRequestInputFields : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> fieldCode{};
  shared_ptr<long> fieldRank{};
  shared_ptr<string> fieldSource{};
  shared_ptr<string> fieldType{};
  shared_ptr<string> title{};

  ModifyTemplateRequestInputFields() {}

  explicit ModifyTemplateRequestInputFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (fieldCode) {
      res["fieldCode"] = boost::any(*fieldCode);
    }
    if (fieldRank) {
      res["fieldRank"] = boost::any(*fieldRank);
    }
    if (fieldSource) {
      res["fieldSource"] = boost::any(*fieldSource);
    }
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("fieldCode") != m.end() && !m["fieldCode"].empty()) {
      fieldCode = make_shared<string>(boost::any_cast<string>(m["fieldCode"]));
    }
    if (m.find("fieldRank") != m.end() && !m["fieldRank"].empty()) {
      fieldRank = make_shared<long>(boost::any_cast<long>(m["fieldRank"]));
    }
    if (m.find("fieldSource") != m.end() && !m["fieldSource"].empty()) {
      fieldSource = make_shared<string>(boost::any_cast<string>(m["fieldSource"]));
    }
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ModifyTemplateRequestInputFields() = default;
};
class ModifyTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> description{};
  shared_ptr<string> eventCode{};
  shared_ptr<ModifyTemplateRequestInputFields> inputFields{};
  shared_ptr<string> regId{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<long> version{};

  ModifyTemplateRequest() {}

  explicit ModifyTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (inputFields) {
      res["inputFields"] = inputFields ? boost::any(inputFields->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["templateType"] = boost::any(*templateType);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("inputFields") != m.end() && !m["inputFields"].empty()) {
      if (typeid(map<string, boost::any>) == m["inputFields"].type()) {
        ModifyTemplateRequestInputFields model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["inputFields"]));
        inputFields = make_shared<ModifyTemplateRequestInputFields>(model1);
      }
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["templateId"]));
    }
    if (m.find("templateType") != m.end() && !m["templateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["templateType"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~ModifyTemplateRequest() = default;
};
class ModifyTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  ModifyTemplateResponseBody() {}

  explicit ModifyTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~ModifyTemplateResponseBody() = default;
};
class ModifyTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTemplateResponseBody> body{};

  ModifyTemplateResponse() {}

  explicit ModifyTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTemplateResponse() = default;
};
class ModifyTemplateStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> fromTemplateSatus{};
  shared_ptr<string> regId{};
  shared_ptr<long> templateId{};
  shared_ptr<string> toTemplateSatus{};

  ModifyTemplateStatusRequest() {}

  explicit ModifyTemplateStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (fromTemplateSatus) {
      res["fromTemplateSatus"] = boost::any(*fromTemplateSatus);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    if (toTemplateSatus) {
      res["toTemplateSatus"] = boost::any(*toTemplateSatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("fromTemplateSatus") != m.end() && !m["fromTemplateSatus"].empty()) {
      fromTemplateSatus = make_shared<string>(boost::any_cast<string>(m["fromTemplateSatus"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["templateId"]));
    }
    if (m.find("toTemplateSatus") != m.end() && !m["toTemplateSatus"].empty()) {
      toTemplateSatus = make_shared<string>(boost::any_cast<string>(m["toTemplateSatus"]));
    }
  }


  virtual ~ModifyTemplateStatusRequest() = default;
};
class ModifyTemplateStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  ModifyTemplateStatusResponseBody() {}

  explicit ModifyTemplateStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~ModifyTemplateStatusResponseBody() = default;
};
class ModifyTemplateStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTemplateStatusResponseBody> body{};

  ModifyTemplateStatusResponse() {}

  explicit ModifyTemplateStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTemplateStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTemplateStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTemplateStatusResponse() = default;
};
class ModifyVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};
  shared_ptr<string> title{};

  ModifyVariableRequest() {}

  explicit ModifyVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ModifyVariableRequest() = default;
};
class ModifyVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  ModifyVariableResponseBody() {}

  explicit ModifyVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~ModifyVariableResponseBody() = default;
};
class ModifyVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVariableResponseBody> body{};

  ModifyVariableResponse() {}

  explicit ModifyVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVariableResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVariableResponse() = default;
};
class OpenConsoleSlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> scene{};

  OpenConsoleSlsRequest() {}

  explicit OpenConsoleSlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["scene"]));
    }
  }


  virtual ~OpenConsoleSlsRequest() = default;
};
class OpenConsoleSlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resultObject{};

  OpenConsoleSlsResponseBody() {}

  explicit OpenConsoleSlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<string>(boost::any_cast<string>(m["resultObject"]));
    }
  }


  virtual ~OpenConsoleSlsResponseBody() = default;
};
class OpenConsoleSlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenConsoleSlsResponseBody> body{};

  OpenConsoleSlsResponse() {}

  explicit OpenConsoleSlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenConsoleSlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenConsoleSlsResponseBody>(model1);
      }
    }
  }


  virtual ~OpenConsoleSlsResponse() = default;
};
class OperateFavoriteVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> operate{};
  shared_ptr<string> regId{};

  OperateFavoriteVariableRequest() {}

  explicit OperateFavoriteVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (operate) {
      res["operate"] = boost::any(*operate);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("operate") != m.end() && !m["operate"].empty()) {
      operate = make_shared<string>(boost::any_cast<string>(m["operate"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~OperateFavoriteVariableRequest() = default;
};
class OperateFavoriteVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  OperateFavoriteVariableResponseBody() {}

  explicit OperateFavoriteVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~OperateFavoriteVariableResponseBody() = default;
};
class OperateFavoriteVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateFavoriteVariableResponseBody> body{};

  OperateFavoriteVariableResponse() {}

  explicit OperateFavoriteVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateFavoriteVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateFavoriteVariableResponseBody>(model1);
      }
    }
  }


  virtual ~OperateFavoriteVariableResponse() = default;
};
class PermissionCheckRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};

  PermissionCheckRequest() {}

  explicit PermissionCheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["RegId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RegId") != m.end() && !m["RegId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["RegId"]));
    }
  }


  virtual ~PermissionCheckRequest() = default;
};
class PermissionCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultObject{};

  PermissionCheckResponseBody() {}

  explicit PermissionCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["ResultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultObject") != m.end() && !m["ResultObject"].empty()) {
      resultObject = make_shared<string>(boost::any_cast<string>(m["ResultObject"]));
    }
  }


  virtual ~PermissionCheckResponseBody() = default;
};
class PermissionCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PermissionCheckResponseBody> body{};

  PermissionCheckResponse() {}

  explicit PermissionCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PermissionCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PermissionCheckResponseBody>(model1);
      }
    }
  }


  virtual ~PermissionCheckResponse() = default;
};
class QueryAuthRuleDetailByRuleIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> consoleRuleId{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleId{};
  shared_ptr<long> ruleVersionId{};

  QueryAuthRuleDetailByRuleIdRequest() {}

  explicit QueryAuthRuleDetailByRuleIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleVersionId) {
      res["ruleVersionId"] = boost::any(*ruleVersionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleVersionId") != m.end() && !m["ruleVersionId"].empty()) {
      ruleVersionId = make_shared<long>(boost::any_cast<long>(m["ruleVersionId"]));
    }
  }


  virtual ~QueryAuthRuleDetailByRuleIdRequest() = default;
};
class QueryAuthRuleDetailByRuleIdResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<long> auditId{};
  shared_ptr<string> authType{};
  shared_ptr<string> authUsers{};
  shared_ptr<long> consoleRuleId{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> eventName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> logicExpression{};
  shared_ptr<string> memo{};
  shared_ptr<long> priority{};
  shared_ptr<map<string, string>> ruleActionMap{};
  shared_ptr<string> ruleActions{};
  shared_ptr<string> ruleAuthType{};
  shared_ptr<string> ruleExpressions{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};
  shared_ptr<long> ruleVersionId{};
  shared_ptr<string> templateType{};
  shared_ptr<long> version{};

  QueryAuthRuleDetailByRuleIdResponseBodyResultObject() {}

  explicit QueryAuthRuleDetailByRuleIdResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditId) {
      res["auditId"] = boost::any(*auditId);
    }
    if (authType) {
      res["authType"] = boost::any(*authType);
    }
    if (authUsers) {
      res["authUsers"] = boost::any(*authUsers);
    }
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (logicExpression) {
      res["logicExpression"] = boost::any(*logicExpression);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (ruleActionMap) {
      res["ruleActionMap"] = boost::any(*ruleActionMap);
    }
    if (ruleActions) {
      res["ruleActions"] = boost::any(*ruleActions);
    }
    if (ruleAuthType) {
      res["ruleAuthType"] = boost::any(*ruleAuthType);
    }
    if (ruleExpressions) {
      res["ruleExpressions"] = boost::any(*ruleExpressions);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    if (ruleVersionId) {
      res["ruleVersionId"] = boost::any(*ruleVersionId);
    }
    if (templateType) {
      res["templateType"] = boost::any(*templateType);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auditId") != m.end() && !m["auditId"].empty()) {
      auditId = make_shared<long>(boost::any_cast<long>(m["auditId"]));
    }
    if (m.find("authType") != m.end() && !m["authType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["authType"]));
    }
    if (m.find("authUsers") != m.end() && !m["authUsers"].empty()) {
      authUsers = make_shared<string>(boost::any_cast<string>(m["authUsers"]));
    }
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("logicExpression") != m.end() && !m["logicExpression"].empty()) {
      logicExpression = make_shared<string>(boost::any_cast<string>(m["logicExpression"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("ruleActionMap") != m.end() && !m["ruleActionMap"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ruleActionMap"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      ruleActionMap = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ruleActions") != m.end() && !m["ruleActions"].empty()) {
      ruleActions = make_shared<string>(boost::any_cast<string>(m["ruleActions"]));
    }
    if (m.find("ruleAuthType") != m.end() && !m["ruleAuthType"].empty()) {
      ruleAuthType = make_shared<string>(boost::any_cast<string>(m["ruleAuthType"]));
    }
    if (m.find("ruleExpressions") != m.end() && !m["ruleExpressions"].empty()) {
      ruleExpressions = make_shared<string>(boost::any_cast<string>(m["ruleExpressions"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
    if (m.find("ruleVersionId") != m.end() && !m["ruleVersionId"].empty()) {
      ruleVersionId = make_shared<long>(boost::any_cast<long>(m["ruleVersionId"]));
    }
    if (m.find("templateType") != m.end() && !m["templateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["templateType"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~QueryAuthRuleDetailByRuleIdResponseBodyResultObject() = default;
};
class QueryAuthRuleDetailByRuleIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryAuthRuleDetailByRuleIdResponseBodyResultObject> resultObject{};

  QueryAuthRuleDetailByRuleIdResponseBody() {}

  explicit QueryAuthRuleDetailByRuleIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        QueryAuthRuleDetailByRuleIdResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<QueryAuthRuleDetailByRuleIdResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~QueryAuthRuleDetailByRuleIdResponseBody() = default;
};
class QueryAuthRuleDetailByRuleIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAuthRuleDetailByRuleIdResponseBody> body{};

  QueryAuthRuleDetailByRuleIdResponse() {}

  explicit QueryAuthRuleDetailByRuleIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAuthRuleDetailByRuleIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAuthRuleDetailByRuleIdResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAuthRuleDetailByRuleIdResponse() = default;
};
class QueryAuthUserNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> bindId{};
  shared_ptr<string> regId{};

  QueryAuthUserNameRequest() {}

  explicit QueryAuthUserNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (bindId) {
      res["bindId"] = boost::any(*bindId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("bindId") != m.end() && !m["bindId"].empty()) {
      bindId = make_shared<long>(boost::any_cast<long>(m["bindId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~QueryAuthUserNameRequest() = default;
};
class QueryAuthUserNameResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> company{};
  shared_ptr<long> userId{};

  QueryAuthUserNameResponseBodyResultObject() {}

  explicit QueryAuthUserNameResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (company) {
      res["company"] = boost::any(*company);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("company") != m.end() && !m["company"].empty()) {
      company = make_shared<string>(boost::any_cast<string>(m["company"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~QueryAuthUserNameResponseBodyResultObject() = default;
};
class QueryAuthUserNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryAuthUserNameResponseBodyResultObject> resultObject{};

  QueryAuthUserNameResponseBody() {}

  explicit QueryAuthUserNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = resultObject ? boost::any(resultObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["resultObject"].type()) {
        QueryAuthUserNameResponseBodyResultObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["resultObject"]));
        resultObject = make_shared<QueryAuthUserNameResponseBodyResultObject>(model1);
      }
    }
  }


  virtual ~QueryAuthUserNameResponseBody() = default;
};
class QueryAuthUserNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAuthUserNameResponseBody> body{};

  QueryAuthUserNameResponse() {}

  explicit QueryAuthUserNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAuthUserNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAuthUserNameResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAuthUserNameResponse() = default;
};
class QueryAuthorizationUserListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> eventCode{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  QueryAuthorizationUserListRequest() {}

  explicit QueryAuthorizationUserListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~QueryAuthorizationUserListRequest() = default;
};
class QueryAuthorizationUserListResponseBodyResultObject : public Darabonba::Model {
public:
  shared_ptr<string> company{};
  shared_ptr<long> id{};
  shared_ptr<string> uid{};
  shared_ptr<long> userId{};

  QueryAuthorizationUserListResponseBodyResultObject() {}

  explicit QueryAuthorizationUserListResponseBodyResultObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (company) {
      res["company"] = boost::any(*company);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (uid) {
      res["uid"] = boost::any(*uid);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("company") != m.end() && !m["company"].empty()) {
      company = make_shared<string>(boost::any_cast<string>(m["company"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("uid") != m.end() && !m["uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["uid"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~QueryAuthorizationUserListResponseBodyResultObject() = default;
};
class QueryAuthorizationUserListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryAuthorizationUserListResponseBodyResultObject>> resultObject{};

  QueryAuthorizationUserListResponseBody() {}

  explicit QueryAuthorizationUserListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      vector<boost::any> temp1;
      for(auto item1:*resultObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resultObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      if (typeid(vector<boost::any>) == m["resultObject"].type()) {
        vector<QueryAuthorizationUserListResponseBodyResultObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resultObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAuthorizationUserListResponseBodyResultObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultObject = make_shared<vector<QueryAuthorizationUserListResponseBodyResultObject>>(expect1);
      }
    }
  }


  virtual ~QueryAuthorizationUserListResponseBody() = default;
};
class QueryAuthorizationUserListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAuthorizationUserListResponseBody> body{};

  QueryAuthorizationUserListResponse() {}

  explicit QueryAuthorizationUserListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAuthorizationUserListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAuthorizationUserListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAuthorizationUserListResponse() = default;
};
class RecallRuleAuditRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  RecallRuleAuditRequest() {}

  explicit RecallRuleAuditRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~RecallRuleAuditRequest() = default;
};
class RecallRuleAuditResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  RecallRuleAuditResponseBody() {}

  explicit RecallRuleAuditResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~RecallRuleAuditResponseBody() = default;
};
class RecallRuleAuditResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecallRuleAuditResponseBody> body{};

  RecallRuleAuditResponse() {}

  explicit RecallRuleAuditResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecallRuleAuditResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecallRuleAuditResponseBody>(model1);
      }
    }
  }


  virtual ~RecallRuleAuditResponse() = default;
};
class RemoveEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> createType{};
  shared_ptr<string> eventCode{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};
  shared_ptr<string> templateCode{};

  RemoveEventRequest() {}

  explicit RemoveEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (createType) {
      res["createType"] = boost::any(*createType);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (templateCode) {
      res["templateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("createType") != m.end() && !m["createType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["createType"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("templateCode") != m.end() && !m["templateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["templateCode"]));
    }
  }


  virtual ~RemoveEventRequest() = default;
};
class RemoveEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  RemoveEventResponseBody() {}

  explicit RemoveEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~RemoveEventResponseBody() = default;
};
class RemoveEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveEventResponseBody> body{};

  RemoveEventResponse() {}

  explicit RemoveEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveEventResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveEventResponse() = default;
};
class RemoveTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> regId{};
  shared_ptr<long> templateId{};
  shared_ptr<long> version{};

  RemoveTemplateRequest() {}

  explicit RemoveTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["templateId"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~RemoveTemplateRequest() = default;
};
class RemoveTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  RemoveTemplateResponseBody() {}

  explicit RemoveTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~RemoveTemplateResponseBody() = default;
};
class RemoveTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveTemplateResponseBody> body{};

  RemoveTemplateResponse() {}

  explicit RemoveTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveTemplateResponse() = default;
};
class SampleFileDownloadRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> tab{};

  SampleFileDownloadRequest() {}

  explicit SampleFileDownloadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["RegId"] = boost::any(*regId);
    }
    if (tab) {
      res["Tab"] = boost::any(*tab);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RegId") != m.end() && !m["RegId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["RegId"]));
    }
    if (m.find("Tab") != m.end() && !m["Tab"].empty()) {
      tab = make_shared<string>(boost::any_cast<string>(m["Tab"]));
    }
  }


  virtual ~SampleFileDownloadRequest() = default;
};
class SampleFileDownloadResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultObject{};

  SampleFileDownloadResponseBody() {}

  explicit SampleFileDownloadResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["ResultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultObject") != m.end() && !m["ResultObject"].empty()) {
      resultObject = make_shared<string>(boost::any_cast<string>(m["ResultObject"]));
    }
  }


  virtual ~SampleFileDownloadResponseBody() = default;
};
class SampleFileDownloadResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SampleFileDownloadResponseBody> body{};

  SampleFileDownloadResponse() {}

  explicit SampleFileDownloadResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SampleFileDownloadResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SampleFileDownloadResponseBody>(model1);
      }
    }
  }


  virtual ~SampleFileDownloadResponse() = default;
};
class SaveAnalysisColumnRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> columns{};
  shared_ptr<string> regId{};

  SaveAnalysisColumnRequest() {}

  explicit SaveAnalysisColumnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (columns) {
      res["columns"] = boost::any(*columns);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("columns") != m.end() && !m["columns"].empty()) {
      columns = make_shared<string>(boost::any_cast<string>(m["columns"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~SaveAnalysisColumnRequest() = default;
};
class SaveAnalysisColumnResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  SaveAnalysisColumnResponseBody() {}

  explicit SaveAnalysisColumnResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~SaveAnalysisColumnResponseBody() = default;
};
class SaveAnalysisColumnResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveAnalysisColumnResponseBody> body{};

  SaveAnalysisColumnResponse() {}

  explicit SaveAnalysisColumnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveAnalysisColumnResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveAnalysisColumnResponseBody>(model1);
      }
    }
  }


  virtual ~SaveAnalysisColumnResponse() = default;
};
class SaveByPassOrShuntEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> eventId{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};
  shared_ptr<string> regId{};

  SaveByPassOrShuntEventRequest() {}

  explicit SaveByPassOrShuntEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventId) {
      res["eventId"] = boost::any(*eventId);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventId") != m.end() && !m["eventId"].empty()) {
      eventId = make_shared<long>(boost::any_cast<long>(m["eventId"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~SaveByPassOrShuntEventRequest() = default;
};
class SaveByPassOrShuntEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};
  shared_ptr<bool> success{};

  SaveByPassOrShuntEventResponseBody() {}

  explicit SaveByPassOrShuntEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~SaveByPassOrShuntEventResponseBody() = default;
};
class SaveByPassOrShuntEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveByPassOrShuntEventResponseBody> body{};

  SaveByPassOrShuntEventResponse() {}

  explicit SaveByPassOrShuntEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveByPassOrShuntEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveByPassOrShuntEventResponseBody>(model1);
      }
    }
  }


  virtual ~SaveByPassOrShuntEventResponse() = default;
};
class StartOrStopByPassShuntEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> eventId{};
  shared_ptr<string> regId{};
  shared_ptr<string> status{};

  StartOrStopByPassShuntEventRequest() {}

  explicit StartOrStopByPassShuntEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventId) {
      res["eventId"] = boost::any(*eventId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventId") != m.end() && !m["eventId"].empty()) {
      eventId = make_shared<long>(boost::any_cast<long>(m["eventId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~StartOrStopByPassShuntEventRequest() = default;
};
class StartOrStopByPassShuntEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};
  shared_ptr<bool> success{};

  StartOrStopByPassShuntEventResponseBody() {}

  explicit StartOrStopByPassShuntEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~StartOrStopByPassShuntEventResponseBody() = default;
};
class StartOrStopByPassShuntEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartOrStopByPassShuntEventResponseBody> body{};

  StartOrStopByPassShuntEventResponse() {}

  explicit StartOrStopByPassShuntEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartOrStopByPassShuntEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartOrStopByPassShuntEventResponseBody>(model1);
      }
    }
  }


  virtual ~StartOrStopByPassShuntEventResponse() = default;
};
class StartSimulationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> id{};
  shared_ptr<string> regId{};

  StartSimulationTaskRequest() {}

  explicit StartSimulationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~StartSimulationTaskRequest() = default;
};
class StartSimulationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  StartSimulationTaskResponseBody() {}

  explicit StartSimulationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~StartSimulationTaskResponseBody() = default;
};
class StartSimulationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartSimulationTaskResponseBody> body{};

  StartSimulationTaskResponse() {}

  explicit StartSimulationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartSimulationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartSimulationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~StartSimulationTaskResponse() = default;
};
class StopSimulationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> id{};
  shared_ptr<string> regId{};

  StopSimulationTaskRequest() {}

  explicit StopSimulationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~StopSimulationTaskRequest() = default;
};
class StopSimulationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  StopSimulationTaskResponseBody() {}

  explicit StopSimulationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~StopSimulationTaskResponseBody() = default;
};
class StopSimulationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopSimulationTaskResponseBody> body{};

  StopSimulationTaskResponse() {}

  explicit StopSimulationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopSimulationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopSimulationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~StopSimulationTaskResponse() = default;
};
class SubmitImportTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> fileName{};
  shared_ptr<string> regId{};
  shared_ptr<string> url{};

  SubmitImportTaskRequest() {}

  explicit SubmitImportTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~SubmitImportTaskRequest() = default;
};
class SubmitImportTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  SubmitImportTaskResponseBody() {}

  explicit SubmitImportTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~SubmitImportTaskResponseBody() = default;
};
class SubmitImportTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitImportTaskResponseBody> body{};

  SubmitImportTaskResponse() {}

  explicit SubmitImportTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitImportTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitImportTaskResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitImportTaskResponse() = default;
};
class SwitchExpressionVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> dataVersion{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};
  shared_ptr<string> status{};

  SwitchExpressionVariableRequest() {}

  explicit SwitchExpressionVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (dataVersion) {
      res["dataVersion"] = boost::any(*dataVersion);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("dataVersion") != m.end() && !m["dataVersion"].empty()) {
      dataVersion = make_shared<long>(boost::any_cast<long>(m["dataVersion"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~SwitchExpressionVariableRequest() = default;
};
class SwitchExpressionVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  SwitchExpressionVariableResponseBody() {}

  explicit SwitchExpressionVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~SwitchExpressionVariableResponseBody() = default;
};
class SwitchExpressionVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchExpressionVariableResponseBody> body{};

  SwitchExpressionVariableResponse() {}

  explicit SwitchExpressionVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchExpressionVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchExpressionVariableResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchExpressionVariableResponse() = default;
};
class SwitchFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> regId{};
  shared_ptr<string> source{};
  shared_ptr<string> status{};

  SwitchFieldRequest() {}

  explicit SwitchFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~SwitchFieldRequest() = default;
};
class SwitchFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  SwitchFieldResponseBody() {}

  explicit SwitchFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~SwitchFieldResponseBody() = default;
};
class SwitchFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchFieldResponseBody> body{};

  SwitchFieldResponse() {}

  explicit SwitchFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchFieldResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchFieldResponse() = default;
};
class SwitchQueryVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};
  shared_ptr<string> status{};

  SwitchQueryVariableRequest() {}

  explicit SwitchQueryVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~SwitchQueryVariableRequest() = default;
};
class SwitchQueryVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  SwitchQueryVariableResponseBody() {}

  explicit SwitchQueryVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~SwitchQueryVariableResponseBody() = default;
};
class SwitchQueryVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchQueryVariableResponseBody> body{};

  SwitchQueryVariableResponse() {}

  explicit SwitchQueryVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchQueryVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchQueryVariableResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchQueryVariableResponse() = default;
};
class SwitchToOnlineRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> eventId{};
  shared_ptr<string> regId{};

  SwitchToOnlineRequest() {}

  explicit SwitchToOnlineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventId) {
      res["eventId"] = boost::any(*eventId);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventId") != m.end() && !m["eventId"].empty()) {
      eventId = make_shared<long>(boost::any_cast<long>(m["eventId"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~SwitchToOnlineRequest() = default;
};
class SwitchToOnlineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};
  shared_ptr<bool> success{};

  SwitchToOnlineResponseBody() {}

  explicit SwitchToOnlineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~SwitchToOnlineResponseBody() = default;
};
class SwitchToOnlineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchToOnlineResponseBody> body{};

  SwitchToOnlineResponse() {}

  explicit SwitchToOnlineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchToOnlineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchToOnlineResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchToOnlineResponse() = default;
};
class SwitchVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> dataVersion{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> regId{};
  shared_ptr<string> status{};

  SwitchVariableRequest() {}

  explicit SwitchVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (dataVersion) {
      res["dataVersion"] = boost::any(*dataVersion);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("dataVersion") != m.end() && !m["dataVersion"].empty()) {
      dataVersion = make_shared<long>(boost::any_cast<long>(m["dataVersion"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~SwitchVariableRequest() = default;
};
class SwitchVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  SwitchVariableResponseBody() {}

  explicit SwitchVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~SwitchVariableResponseBody() = default;
};
class SwitchVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchVariableResponseBody> body{};

  SwitchVariableResponse() {}

  explicit SwitchVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchVariableResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchVariableResponse() = default;
};
class TaskNameByUserIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regId{};
  shared_ptr<string> taskName{};

  TaskNameByUserIdRequest() {}

  explicit TaskNameByUserIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regId) {
      res["RegId"] = boost::any(*regId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RegId") != m.end() && !m["RegId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["RegId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~TaskNameByUserIdRequest() = default;
};
class TaskNameByUserIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  TaskNameByUserIdResponseBody() {}

  explicit TaskNameByUserIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["ResultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultObject") != m.end() && !m["ResultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["ResultObject"]));
    }
  }


  virtual ~TaskNameByUserIdResponseBody() = default;
};
class TaskNameByUserIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TaskNameByUserIdResponseBody> body{};

  TaskNameByUserIdResponse() {}

  explicit TaskNameByUserIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TaskNameByUserIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TaskNameByUserIdResponseBody>(model1);
      }
    }
  }


  virtual ~TaskNameByUserIdResponse() = default;
};
class UpdateAnalysisConditionFavoriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> condition{};
  shared_ptr<long> eventBeginTime{};
  shared_ptr<string> eventCode{};
  shared_ptr<long> eventEndTime{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> regId{};
  shared_ptr<string> type{};

  UpdateAnalysisConditionFavoriteRequest() {}

  explicit UpdateAnalysisConditionFavoriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (eventBeginTime) {
      res["eventBeginTime"] = boost::any(*eventBeginTime);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (eventEndTime) {
      res["eventEndTime"] = boost::any(*eventEndTime);
    }
    if (fieldName) {
      res["fieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("eventBeginTime") != m.end() && !m["eventBeginTime"].empty()) {
      eventBeginTime = make_shared<long>(boost::any_cast<long>(m["eventBeginTime"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("eventEndTime") != m.end() && !m["eventEndTime"].empty()) {
      eventEndTime = make_shared<long>(boost::any_cast<long>(m["eventEndTime"]));
    }
    if (m.find("fieldName") != m.end() && !m["fieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["fieldName"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~UpdateAnalysisConditionFavoriteRequest() = default;
};
class UpdateAnalysisConditionFavoriteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  UpdateAnalysisConditionFavoriteResponseBody() {}

  explicit UpdateAnalysisConditionFavoriteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~UpdateAnalysisConditionFavoriteResponseBody() = default;
};
class UpdateAnalysisConditionFavoriteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAnalysisConditionFavoriteResponseBody> body{};

  UpdateAnalysisConditionFavoriteResponse() {}

  explicit UpdateAnalysisConditionFavoriteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAnalysisConditionFavoriteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAnalysisConditionFavoriteResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAnalysisConditionFavoriteResponse() = default;
};
class UpdateAuditRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> auditMsg{};
  shared_ptr<string> auditRelationType{};
  shared_ptr<string> auditStatus{};
  shared_ptr<long> id{};
  shared_ptr<string> regId{};

  UpdateAuditRequest() {}

  explicit UpdateAuditRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (auditMsg) {
      res["auditMsg"] = boost::any(*auditMsg);
    }
    if (auditRelationType) {
      res["auditRelationType"] = boost::any(*auditRelationType);
    }
    if (auditStatus) {
      res["auditStatus"] = boost::any(*auditStatus);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("auditMsg") != m.end() && !m["auditMsg"].empty()) {
      auditMsg = make_shared<string>(boost::any_cast<string>(m["auditMsg"]));
    }
    if (m.find("auditRelationType") != m.end() && !m["auditRelationType"].empty()) {
      auditRelationType = make_shared<string>(boost::any_cast<string>(m["auditRelationType"]));
    }
    if (m.find("auditStatus") != m.end() && !m["auditStatus"].empty()) {
      auditStatus = make_shared<string>(boost::any_cast<string>(m["auditStatus"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~UpdateAuditRequest() = default;
};
class UpdateAuditResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<bool> resultObject{};
  shared_ptr<bool> success{};

  UpdateAuditResponseBody() {}

  explicit UpdateAuditResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateAuditResponseBody() = default;
};
class UpdateAuditResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAuditResponseBody> body{};

  UpdateAuditResponse() {}

  explicit UpdateAuditResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAuditResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAuditResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAuditResponse() = default;
};
class UpdateAuthRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> consoleRuleId{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleActions{};
  shared_ptr<string> ruleExpressions{};
  shared_ptr<string> ruleId{};
  shared_ptr<long> ruleVersionId{};

  UpdateAuthRuleRequest() {}

  explicit UpdateAuthRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleActions) {
      res["ruleActions"] = boost::any(*ruleActions);
    }
    if (ruleExpressions) {
      res["ruleExpressions"] = boost::any(*ruleExpressions);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleVersionId) {
      res["ruleVersionId"] = boost::any(*ruleVersionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleActions") != m.end() && !m["ruleActions"].empty()) {
      ruleActions = make_shared<string>(boost::any_cast<string>(m["ruleActions"]));
    }
    if (m.find("ruleExpressions") != m.end() && !m["ruleExpressions"].empty()) {
      ruleExpressions = make_shared<string>(boost::any_cast<string>(m["ruleExpressions"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleVersionId") != m.end() && !m["ruleVersionId"].empty()) {
      ruleVersionId = make_shared<long>(boost::any_cast<long>(m["ruleVersionId"]));
    }
  }


  virtual ~UpdateAuthRuleRequest() = default;
};
class UpdateAuthRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  UpdateAuthRuleResponseBody() {}

  explicit UpdateAuthRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~UpdateAuthRuleResponseBody() = default;
};
class UpdateAuthRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAuthRuleResponseBody> body{};

  UpdateAuthRuleResponse() {}

  explicit UpdateAuthRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAuthRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAuthRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAuthRuleResponse() = default;
};
class UpdateByPassShuntEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> eventId{};
  shared_ptr<string> eventName{};
  shared_ptr<string> regId{};

  UpdateByPassShuntEventRequest() {}

  explicit UpdateByPassShuntEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (eventId) {
      res["eventId"] = boost::any(*eventId);
    }
    if (eventName) {
      res["eventName"] = boost::any(*eventName);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("eventId") != m.end() && !m["eventId"].empty()) {
      eventId = make_shared<long>(boost::any_cast<long>(m["eventId"]));
    }
    if (m.find("eventName") != m.end() && !m["eventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["eventName"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
  }


  virtual ~UpdateByPassShuntEventRequest() = default;
};
class UpdateByPassShuntEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};
  shared_ptr<bool> success{};

  UpdateByPassShuntEventResponseBody() {}

  explicit UpdateByPassShuntEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["httpStatusCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateByPassShuntEventResponseBody() = default;
};
class UpdateByPassShuntEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateByPassShuntEventResponseBody> body{};

  UpdateByPassShuntEventResponse() {}

  explicit UpdateByPassShuntEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateByPassShuntEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateByPassShuntEventResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateByPassShuntEventResponse() = default;
};
class UpdateDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> ossKey{};
  shared_ptr<string> regId{};
  shared_ptr<string> type{};

  UpdateDataSourceRequest() {}

  explicit UpdateDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (ossKey) {
      res["ossKey"] = boost::any(*ossKey);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("ossKey") != m.end() && !m["ossKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["ossKey"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~UpdateDataSourceRequest() = default;
};
class UpdateDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  UpdateDataSourceResponseBody() {}

  explicit UpdateDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~UpdateDataSourceResponseBody() = default;
};
class UpdateDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataSourceResponseBody> body{};

  UpdateDataSourceResponse() {}

  explicit UpdateDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataSourceResponse() = default;
};
class UpdateQueryVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> dataSourceCode{};
  shared_ptr<string> description{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> expression{};
  shared_ptr<string> expressionTitle{};
  shared_ptr<string> expressionVariable{};
  shared_ptr<long> id{};
  shared_ptr<string> outlier{};
  shared_ptr<string> outputs{};
  shared_ptr<string> regId{};
  shared_ptr<string> title{};

  UpdateQueryVariableRequest() {}

  explicit UpdateQueryVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (dataSourceCode) {
      res["dataSourceCode"] = boost::any(*dataSourceCode);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (expression) {
      res["expression"] = boost::any(*expression);
    }
    if (expressionTitle) {
      res["expressionTitle"] = boost::any(*expressionTitle);
    }
    if (expressionVariable) {
      res["expressionVariable"] = boost::any(*expressionVariable);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (outlier) {
      res["outlier"] = boost::any(*outlier);
    }
    if (outputs) {
      res["outputs"] = boost::any(*outputs);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("dataSourceCode") != m.end() && !m["dataSourceCode"].empty()) {
      dataSourceCode = make_shared<string>(boost::any_cast<string>(m["dataSourceCode"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("expression") != m.end() && !m["expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["expression"]));
    }
    if (m.find("expressionTitle") != m.end() && !m["expressionTitle"].empty()) {
      expressionTitle = make_shared<string>(boost::any_cast<string>(m["expressionTitle"]));
    }
    if (m.find("expressionVariable") != m.end() && !m["expressionVariable"].empty()) {
      expressionVariable = make_shared<string>(boost::any_cast<string>(m["expressionVariable"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("outlier") != m.end() && !m["outlier"].empty()) {
      outlier = make_shared<string>(boost::any_cast<string>(m["outlier"]));
    }
    if (m.find("outputs") != m.end() && !m["outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["outputs"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~UpdateQueryVariableRequest() = default;
};
class UpdateQueryVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  UpdateQueryVariableResponseBody() {}

  explicit UpdateQueryVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~UpdateQueryVariableResponseBody() = default;
};
class UpdateQueryVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateQueryVariableResponseBody> body{};

  UpdateQueryVariableResponse() {}

  explicit UpdateQueryVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateQueryVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateQueryVariableResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateQueryVariableResponse() = default;
};
class UpdateRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> consoleRuleId{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> logicExpression{};
  shared_ptr<string> memo{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleActions{};
  shared_ptr<string> ruleExpressions{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};
  shared_ptr<long> ruleVersionId{};

  UpdateRuleRequest() {}

  explicit UpdateRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (logicExpression) {
      res["logicExpression"] = boost::any(*logicExpression);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleActions) {
      res["ruleActions"] = boost::any(*ruleActions);
    }
    if (ruleExpressions) {
      res["ruleExpressions"] = boost::any(*ruleExpressions);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["ruleStatus"] = boost::any(*ruleStatus);
    }
    if (ruleVersionId) {
      res["ruleVersionId"] = boost::any(*ruleVersionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("logicExpression") != m.end() && !m["logicExpression"].empty()) {
      logicExpression = make_shared<string>(boost::any_cast<string>(m["logicExpression"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleActions") != m.end() && !m["ruleActions"].empty()) {
      ruleActions = make_shared<string>(boost::any_cast<string>(m["ruleActions"]));
    }
    if (m.find("ruleExpressions") != m.end() && !m["ruleExpressions"].empty()) {
      ruleExpressions = make_shared<string>(boost::any_cast<string>(m["ruleExpressions"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("ruleStatus") != m.end() && !m["ruleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["ruleStatus"]));
    }
    if (m.find("ruleVersionId") != m.end() && !m["ruleVersionId"].empty()) {
      ruleVersionId = make_shared<long>(boost::any_cast<long>(m["ruleVersionId"]));
    }
  }


  virtual ~UpdateRuleRequest() = default;
};
class UpdateRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  UpdateRuleResponseBody() {}

  explicit UpdateRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~UpdateRuleResponseBody() = default;
};
class UpdateRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRuleResponseBody> body{};

  UpdateRuleResponse() {}

  explicit UpdateRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRuleResponse() = default;
};
class UpdateRuleBaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> consoleRuleId{};
  shared_ptr<string> eventCode{};
  shared_ptr<string> memo{};
  shared_ptr<string> regId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};

  UpdateRuleBaseRequest() {}

  explicit UpdateRuleBaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (consoleRuleId) {
      res["consoleRuleId"] = boost::any(*consoleRuleId);
    }
    if (eventCode) {
      res["eventCode"] = boost::any(*eventCode);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("consoleRuleId") != m.end() && !m["consoleRuleId"].empty()) {
      consoleRuleId = make_shared<long>(boost::any_cast<long>(m["consoleRuleId"]));
    }
    if (m.find("eventCode") != m.end() && !m["eventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["eventCode"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["ruleId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
  }


  virtual ~UpdateRuleBaseRequest() = default;
};
class UpdateRuleBaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> resultObject{};

  UpdateRuleBaseResponseBody() {}

  explicit UpdateRuleBaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resultObject) {
      res["resultObject"] = boost::any(*resultObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resultObject") != m.end() && !m["resultObject"].empty()) {
      resultObject = make_shared<bool>(boost::any_cast<bool>(m["resultObject"]));
    }
  }


  virtual ~UpdateRuleBaseResponseBody() = default;
};
class UpdateRuleBaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRuleBaseResponseBody> body{};

  UpdateRuleBaseResponse() {}

  explicit UpdateRuleBaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRuleBaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRuleBaseResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRuleBaseResponse() = default;
};
class UpdateSampleBatchRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> ids{};
  shared_ptr<string> regId{};
  shared_ptr<string> tags{};
  shared_ptr<string> versions{};

  UpdateSampleBatchRequest() {}

  explicit UpdateSampleBatchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (ids) {
      res["ids"] = boost::any(*ids);
    }
    if (regId) {
      res["regId"] = boost::any(*regId);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (versions) {
      res["versions"] = boost::any(*versions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ids") != m.end() && !m["ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["ids"]));
    }
    if (m.find("regId") != m.end() && !m["regId"].empty()) {
      regId = make_shared<string>(boost::any_cast<string>(m["regId"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["tags"]));
    }
    if (m.find("versions") != m.end() && !m["versions"].empty()) {
      versions = make_shared<string>(boost::any_cast<string>(m["versions"]));
    }
  }


  virtual ~UpdateSampleBatchRequest() = default;
};
class UpdateSampleBatchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  UpdateSampleBatchResponseBody() {}

  explicit UpdateSampleBatchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~UpdateSampleBatchResponseBody() = default;
};
class UpdateSampleBatchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSampleBatchResponseBody> body{};

  UpdateSampleBatchResponse() {}

  explicit UpdateSampleBatchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSampleBatchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSampleBatchResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSampleBatchResponse() = default;
};
class UploadSampleApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataType{};
  shared_ptr<string> dataValue{};
  shared_ptr<string> sampleType{};
  shared_ptr<string> service{};

  UploadSampleApiRequest() {}

  explicit UploadSampleApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (dataValue) {
      res["DataValue"] = boost::any(*dataValue);
    }
    if (sampleType) {
      res["SampleType"] = boost::any(*sampleType);
    }
    if (service) {
      res["Service"] = boost::any(*service);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("DataValue") != m.end() && !m["DataValue"].empty()) {
      dataValue = make_shared<string>(boost::any_cast<string>(m["DataValue"]));
    }
    if (m.find("SampleType") != m.end() && !m["SampleType"].empty()) {
      sampleType = make_shared<string>(boost::any_cast<string>(m["SampleType"]));
    }
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["Service"]));
    }
  }


  virtual ~UploadSampleApiRequest() = default;
};
class UploadSampleApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UploadSampleApiResponseBody() {}

  explicit UploadSampleApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UploadSampleApiResponseBody() = default;
};
class UploadSampleApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadSampleApiResponseBody> body{};

  UploadSampleApiResponse() {}

  explicit UploadSampleApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadSampleApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadSampleApiResponseBody>(model1);
      }
    }
  }


  virtual ~UploadSampleApiResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  BindVariableResponse bindVariableWithOptions(shared_ptr<BindVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindVariableResponse bindVariable(shared_ptr<BindVariableRequest> request);
  CheckCustVariableLimitResponse checkCustVariableLimitWithOptions(shared_ptr<CheckCustVariableLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckCustVariableLimitResponse checkCustVariableLimit(shared_ptr<CheckCustVariableLimitRequest> request);
  CheckExpressionVariableLimitResponse checkExpressionVariableLimitWithOptions(shared_ptr<CheckExpressionVariableLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckExpressionVariableLimitResponse checkExpressionVariableLimit(shared_ptr<CheckExpressionVariableLimitRequest> request);
  CheckFieldLimitResponse checkFieldLimitWithOptions(shared_ptr<CheckFieldLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckFieldLimitResponse checkFieldLimit(shared_ptr<CheckFieldLimitRequest> request);
  CheckPermissionResponse checkPermissionWithOptions(shared_ptr<CheckPermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckPermissionResponse checkPermission(shared_ptr<CheckPermissionRequest> request);
  CheckUsageVariableResponse checkUsageVariableWithOptions(shared_ptr<CheckUsageVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckUsageVariableResponse checkUsageVariable(shared_ptr<CheckUsageVariableRequest> request);
  ClearNameListResponse clearNameListWithOptions(shared_ptr<ClearNameListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearNameListResponse clearNameList(shared_ptr<ClearNameListRequest> request);
  CreateAnalysisConditionFavoriteResponse createAnalysisConditionFavoriteWithOptions(shared_ptr<CreateAnalysisConditionFavoriteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAnalysisConditionFavoriteResponse createAnalysisConditionFavorite(shared_ptr<CreateAnalysisConditionFavoriteRequest> request);
  CreateAnalysisExportTaskResponse createAnalysisExportTaskWithOptions(shared_ptr<CreateAnalysisExportTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAnalysisExportTaskResponse createAnalysisExportTask(shared_ptr<CreateAnalysisExportTaskRequest> request);
  CreateAppKeyResponse createAppKeyWithOptions(shared_ptr<CreateAppKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAppKeyResponse createAppKey(shared_ptr<CreateAppKeyRequest> request);
  CreateAuthorizationUserResponse createAuthorizationUserWithOptions(shared_ptr<CreateAuthorizationUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAuthorizationUserResponse createAuthorizationUser(shared_ptr<CreateAuthorizationUserRequest> request);
  CreateCustVariableResponse createCustVariableWithOptions(shared_ptr<CreateCustVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustVariableResponse createCustVariable(shared_ptr<CreateCustVariableRequest> request);
  CreateDataSourceResponse createDataSourceWithOptions(shared_ptr<CreateDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataSourceResponse createDataSource(shared_ptr<CreateDataSourceRequest> request);
  CreateEventResponse createEventWithOptions(shared_ptr<CreateEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEventResponse createEvent(shared_ptr<CreateEventRequest> request);
  CreateExpressionVariableResponse createExpressionVariableWithOptions(shared_ptr<CreateExpressionVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateExpressionVariableResponse createExpressionVariable(shared_ptr<CreateExpressionVariableRequest> request);
  CreateFieldResponse createFieldWithOptions(shared_ptr<CreateFieldRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFieldResponse createField(shared_ptr<CreateFieldRequest> request);
  CreateGroupSignResponse createGroupSignWithOptions(shared_ptr<CreateGroupSignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateGroupSignResponse createGroupSign(shared_ptr<CreateGroupSignRequest> request);
  CreateMonitorTaskResponse createMonitorTaskWithOptions(shared_ptr<CreateMonitorTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMonitorTaskResponse createMonitorTask(shared_ptr<CreateMonitorTaskRequest> request);
  CreatePocResponse createPocWithOptions(shared_ptr<CreatePocRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePocResponse createPoc(shared_ptr<CreatePocRequest> request);
  CreatePocEvResponse createPocEvWithOptions(shared_ptr<CreatePocEvRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePocEvResponse createPocEv(shared_ptr<CreatePocEvRequest> request);
  CreateQueryVariableResponse createQueryVariableWithOptions(shared_ptr<CreateQueryVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateQueryVariableResponse createQueryVariable(shared_ptr<CreateQueryVariableRequest> request);
  CreateRecommendEventRuleResponse createRecommendEventRuleWithOptions(shared_ptr<CreateRecommendEventRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRecommendEventRuleResponse createRecommendEventRule(shared_ptr<CreateRecommendEventRuleRequest> request);
  CreateRecommendTaskResponse createRecommendTaskWithOptions(shared_ptr<CreateRecommendTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRecommendTaskResponse createRecommendTask(shared_ptr<CreateRecommendTaskRequest> request);
  CreateReplenishTaskResponse createReplenishTaskWithOptions(shared_ptr<CreateReplenishTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateReplenishTaskResponse createReplenishTask(shared_ptr<CreateReplenishTaskRequest> request);
  CreateRuleResponse createRuleWithOptions(shared_ptr<CreateRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRuleResponse createRule(shared_ptr<CreateRuleRequest> request);
  CreateSampleResponse createSampleWithOptions(shared_ptr<CreateSampleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSampleResponse createSample(shared_ptr<CreateSampleRequest> request);
  CreateSampleApiResponse createSampleApiWithOptions(shared_ptr<CreateSampleApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSampleApiResponse createSampleApi(shared_ptr<CreateSampleApiRequest> request);
  CreateSampleDataResponse createSampleDataWithOptions(shared_ptr<CreateSampleDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSampleDataResponse createSampleData(shared_ptr<CreateSampleDataRequest> request);
  CreateSimulationTaskResponse createSimulationTaskWithOptions(shared_ptr<CreateSimulationTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSimulationTaskResponse createSimulationTask(shared_ptr<CreateSimulationTaskRequest> request);
  CreateTaskResponse createTaskWithOptions(shared_ptr<CreateTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTaskResponse createTask(shared_ptr<CreateTaskRequest> request);
  CreateTemplateResponse createTemplateWithOptions(shared_ptr<CreateTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTemplateResponse createTemplate(shared_ptr<CreateTemplateRequest> request);
  DeleteAnalysisConditionFavoriteResponse deleteAnalysisConditionFavoriteWithOptions(shared_ptr<DeleteAnalysisConditionFavoriteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAnalysisConditionFavoriteResponse deleteAnalysisConditionFavorite(shared_ptr<DeleteAnalysisConditionFavoriteRequest> request);
  DeleteAuthUserResponse deleteAuthUserWithOptions(shared_ptr<DeleteAuthUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAuthUserResponse deleteAuthUser(shared_ptr<DeleteAuthUserRequest> request);
  DeleteByPassShuntEventResponse deleteByPassShuntEventWithOptions(shared_ptr<DeleteByPassShuntEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteByPassShuntEventResponse deleteByPassShuntEvent(shared_ptr<DeleteByPassShuntEventRequest> request);
  DeleteCustVariableResponse deleteCustVariableWithOptions(shared_ptr<DeleteCustVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustVariableResponse deleteCustVariable(shared_ptr<DeleteCustVariableRequest> request);
  DeleteDataSourceResponse deleteDataSourceWithOptions(shared_ptr<DeleteDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataSourceResponse deleteDataSource(shared_ptr<DeleteDataSourceRequest> request);
  DeleteExpressionVariableResponse deleteExpressionVariableWithOptions(shared_ptr<DeleteExpressionVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteExpressionVariableResponse deleteExpressionVariable(shared_ptr<DeleteExpressionVariableRequest> request);
  DeleteFieldResponse deleteFieldWithOptions(shared_ptr<DeleteFieldRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFieldResponse deleteField(shared_ptr<DeleteFieldRequest> request);
  DeleteNameListResponse deleteNameListWithOptions(shared_ptr<DeleteNameListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNameListResponse deleteNameList(shared_ptr<DeleteNameListRequest> request);
  DeleteNameListDataResponse deleteNameListDataWithOptions(shared_ptr<DeleteNameListDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNameListDataResponse deleteNameListData(shared_ptr<DeleteNameListDataRequest> request);
  DeleteQueryVariableResponse deleteQueryVariableWithOptions(shared_ptr<DeleteQueryVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteQueryVariableResponse deleteQueryVariable(shared_ptr<DeleteQueryVariableRequest> request);
  DeleteRuleResponse deleteRuleWithOptions(shared_ptr<DeleteRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRuleResponse deleteRule(shared_ptr<DeleteRuleRequest> request);
  DeleteSampleBatchResponse deleteSampleBatchWithOptions(shared_ptr<DeleteSampleBatchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSampleBatchResponse deleteSampleBatch(shared_ptr<DeleteSampleBatchRequest> request);
  DeleteSampleDataResponse deleteSampleDataWithOptions(shared_ptr<DeleteSampleDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSampleDataResponse deleteSampleData(shared_ptr<DeleteSampleDataRequest> request);
  DeleteTaskResponse deleteTaskWithOptions(shared_ptr<DeleteTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTaskResponse deleteTask(shared_ptr<DeleteTaskRequest> request);
  DescribeAdvanceSearchLeftVariableListResponse describeAdvanceSearchLeftVariableListWithOptions(shared_ptr<DescribeAdvanceSearchLeftVariableListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAdvanceSearchLeftVariableListResponse describeAdvanceSearchLeftVariableList(shared_ptr<DescribeAdvanceSearchLeftVariableListRequest> request);
  DescribeAdvanceSearchPageListResponse describeAdvanceSearchPageListWithOptions(shared_ptr<DescribeAdvanceSearchPageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAdvanceSearchPageListResponse describeAdvanceSearchPageList(shared_ptr<DescribeAdvanceSearchPageListRequest> request);
  DescribeAllDataSourceResponse describeAllDataSourceWithOptions(shared_ptr<DescribeAllDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAllDataSourceResponse describeAllDataSource(shared_ptr<DescribeAllDataSourceRequest> request);
  DescribeAllEventNameAndCodeResponse describeAllEventNameAndCodeWithOptions(shared_ptr<DescribeAllEventNameAndCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAllEventNameAndCodeResponse describeAllEventNameAndCode(shared_ptr<DescribeAllEventNameAndCodeRequest> request);
  DescribeAllRootVariableResponse describeAllRootVariableWithOptions(shared_ptr<DescribeAllRootVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAllRootVariableResponse describeAllRootVariable(shared_ptr<DescribeAllRootVariableRequest> request);
  DescribeAnalysisColumnFieldListResponse describeAnalysisColumnFieldListWithOptions(shared_ptr<DescribeAnalysisColumnFieldListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAnalysisColumnFieldListResponse describeAnalysisColumnFieldList(shared_ptr<DescribeAnalysisColumnFieldListRequest> request);
  DescribeAnalysisColumnListResponse describeAnalysisColumnListWithOptions(shared_ptr<DescribeAnalysisColumnListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAnalysisColumnListResponse describeAnalysisColumnList(shared_ptr<DescribeAnalysisColumnListRequest> request);
  DescribeAnalysisConditionFavoriteListResponse describeAnalysisConditionFavoriteListWithOptions(shared_ptr<DescribeAnalysisConditionFavoriteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAnalysisConditionFavoriteListResponse describeAnalysisConditionFavoriteList(shared_ptr<DescribeAnalysisConditionFavoriteListRequest> request);
  DescribeAnalysisExportTaskDownloadUrlResponse describeAnalysisExportTaskDownloadUrlWithOptions(shared_ptr<DescribeAnalysisExportTaskDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAnalysisExportTaskDownloadUrlResponse describeAnalysisExportTaskDownloadUrl(shared_ptr<DescribeAnalysisExportTaskDownloadUrlRequest> request);
  DescribeApiResponse describeApiWithOptions(shared_ptr<DescribeApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiResponse describeApi(shared_ptr<DescribeApiRequest> request);
  DescribeApiGroupsResponse describeApiGroupsWithOptions(shared_ptr<DescribeApiGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiGroupsResponse describeApiGroups(shared_ptr<DescribeApiGroupsRequest> request);
  DescribeApiLimitResponse describeApiLimitWithOptions(shared_ptr<DescribeApiLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiLimitResponse describeApiLimit(shared_ptr<DescribeApiLimitRequest> request);
  DescribeApiNameListResponse describeApiNameListWithOptions(shared_ptr<DescribeApiNameListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiNameListResponse describeApiNameList(shared_ptr<DescribeApiNameListRequest> request);
  DescribeApiVariableResponse describeApiVariableWithOptions(shared_ptr<DescribeApiVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiVariableResponse describeApiVariable(shared_ptr<DescribeApiVariableRequest> request);
  DescribeApisResponse describeApisWithOptions(shared_ptr<DescribeApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisResponse describeApis(shared_ptr<DescribeApisRequest> request);
  DescribeAppKeyPageResponse describeAppKeyPageWithOptions(shared_ptr<DescribeAppKeyPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppKeyPageResponse describeAppKeyPage(shared_ptr<DescribeAppKeyPageRequest> request);
  DescribeAuditConfigResponse describeAuditConfigWithOptions(shared_ptr<DescribeAuditConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAuditConfigResponse describeAuditConfig(shared_ptr<DescribeAuditConfigRequest> request);
  DescribeAuditDetailsResponse describeAuditDetailsWithOptions(shared_ptr<DescribeAuditDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAuditDetailsResponse describeAuditDetails(shared_ptr<DescribeAuditDetailsRequest> request);
  DescribeAuditPageListResponse describeAuditPageListWithOptions(shared_ptr<DescribeAuditPageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAuditPageListResponse describeAuditPageList(shared_ptr<DescribeAuditPageListRequest> request);
  DescribeAuthEventNameListResponse describeAuthEventNameListWithOptions(shared_ptr<DescribeAuthEventNameListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAuthEventNameListResponse describeAuthEventNameList(shared_ptr<DescribeAuthEventNameListRequest> request);
  DescribeAuthRulePageListResponse describeAuthRulePageListWithOptions(shared_ptr<DescribeAuthRulePageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAuthRulePageListResponse describeAuthRulePageList(shared_ptr<DescribeAuthRulePageListRequest> request);
  DescribeAuthSceneListResponse describeAuthSceneListWithOptions(shared_ptr<DescribeAuthSceneListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAuthSceneListResponse describeAuthSceneList(shared_ptr<DescribeAuthSceneListRequest> request);
  DescribeAuthScenePageListResponse describeAuthScenePageListWithOptions(shared_ptr<DescribeAuthScenePageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAuthScenePageListResponse describeAuthScenePageList(shared_ptr<DescribeAuthScenePageListRequest> request);
  DescribeAuthStatusResponse describeAuthStatusWithOptions(shared_ptr<DescribeAuthStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAuthStatusResponse describeAuthStatus(shared_ptr<DescribeAuthStatusRequest> request);
  DescribeAvgExecuteCostReportResponse describeAvgExecuteCostReportWithOptions(shared_ptr<DescribeAvgExecuteCostReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvgExecuteCostReportResponse describeAvgExecuteCostReport(shared_ptr<DescribeAvgExecuteCostReportRequest> request);
  DescribeBasicSearchPageListResponse describeBasicSearchPageListWithOptions(shared_ptr<DescribeBasicSearchPageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBasicSearchPageListResponse describeBasicSearchPageList(shared_ptr<DescribeBasicSearchPageListRequest> request);
  DescribeBasicStartResponse describeBasicStartWithOptions(shared_ptr<DescribeBasicStartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBasicStartResponse describeBasicStart(shared_ptr<DescribeBasicStartRequest> request);
  DescribeByPassShuntEventResponse describeByPassShuntEventWithOptions(shared_ptr<DescribeByPassShuntEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeByPassShuntEventResponse describeByPassShuntEvent(shared_ptr<DescribeByPassShuntEventRequest> request);
  DescribeCustVariableConfigListResponse describeCustVariableConfigListWithOptions(shared_ptr<DescribeCustVariableConfigListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustVariableConfigListResponse describeCustVariableConfigList(shared_ptr<DescribeCustVariableConfigListRequest> request);
  DescribeCustVariableDetailResponse describeCustVariableDetailWithOptions(shared_ptr<DescribeCustVariableDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustVariableDetailResponse describeCustVariableDetail(shared_ptr<DescribeCustVariableDetailRequest> request);
  DescribeCustVariablePageResponse describeCustVariablePageWithOptions(shared_ptr<DescribeCustVariablePageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustVariablePageResponse describeCustVariablePage(shared_ptr<DescribeCustVariablePageRequest> request);
  DescribeDataSourceDataDownloadUrlResponse describeDataSourceDataDownloadUrlWithOptions(shared_ptr<DescribeDataSourceDataDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDataSourceDataDownloadUrlResponse describeDataSourceDataDownloadUrl(shared_ptr<DescribeDataSourceDataDownloadUrlRequest> request);
  DescribeDataSourceFieldsResponse describeDataSourceFieldsWithOptions(shared_ptr<DescribeDataSourceFieldsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDataSourceFieldsResponse describeDataSourceFields(shared_ptr<DescribeDataSourceFieldsRequest> request);
  DescribeDataSourcePageListResponse describeDataSourcePageListWithOptions(shared_ptr<DescribeDataSourcePageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDataSourcePageListResponse describeDataSourcePageList(shared_ptr<DescribeDataSourcePageListRequest> request);
  DescribeDecisionResultFluctuationResponse describeDecisionResultFluctuationWithOptions(shared_ptr<DescribeDecisionResultFluctuationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDecisionResultFluctuationResponse describeDecisionResultFluctuation(shared_ptr<DescribeDecisionResultFluctuationRequest> request);
  DescribeDecisionResultTrendResponse describeDecisionResultTrendWithOptions(shared_ptr<DescribeDecisionResultTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDecisionResultTrendResponse describeDecisionResultTrend(shared_ptr<DescribeDecisionResultTrendRequest> request);
  DescribeDetailStartResponse describeDetailStartWithOptions(shared_ptr<DescribeDetailStartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDetailStartResponse describeDetailStart(shared_ptr<DescribeDetailStartRequest> request);
  DescribeDownloadUrlResponse describeDownloadUrlWithOptions(shared_ptr<DescribeDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDownloadUrlResponse describeDownloadUrl(shared_ptr<DescribeDownloadUrlRequest> request);
  DescribeEventBaseInfoByEventCodeResponse describeEventBaseInfoByEventCodeWithOptions(shared_ptr<DescribeEventBaseInfoByEventCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventBaseInfoByEventCodeResponse describeEventBaseInfoByEventCode(shared_ptr<DescribeEventBaseInfoByEventCodeRequest> request);
  DescribeEventCountResponse describeEventCountWithOptions(shared_ptr<DescribeEventCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventCountResponse describeEventCount(shared_ptr<DescribeEventCountRequest> request);
  DescribeEventDetailByRequestIdResponse describeEventDetailByRequestIdWithOptions(shared_ptr<DescribeEventDetailByRequestIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventDetailByRequestIdResponse describeEventDetailByRequestId(shared_ptr<DescribeEventDetailByRequestIdRequest> request);
  DescribeEventLogDetailResponse describeEventLogDetailWithOptions(shared_ptr<DescribeEventLogDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventLogDetailResponse describeEventLogDetail(shared_ptr<DescribeEventLogDetailRequest> request);
  DescribeEventLogPageResponse describeEventLogPageWithOptions(shared_ptr<DescribeEventLogPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventLogPageResponse describeEventLogPage(shared_ptr<DescribeEventLogPageRequest> request);
  DescribeEventPageListResponse describeEventPageListWithOptions(shared_ptr<DescribeEventPageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventPageListResponse describeEventPageList(shared_ptr<DescribeEventPageListRequest> request);
  DescribeEventResultBarChartResponse describeEventResultBarChartWithOptions(shared_ptr<DescribeEventResultBarChartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventResultBarChartResponse describeEventResultBarChart(shared_ptr<DescribeEventResultBarChartRequest> request);
  DescribeEventResultListResponse describeEventResultListWithOptions(shared_ptr<DescribeEventResultListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventResultListResponse describeEventResultList(shared_ptr<DescribeEventResultListRequest> request);
  DescribeEventTaskHistoryResponse describeEventTaskHistoryWithOptions(shared_ptr<DescribeEventTaskHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventTaskHistoryResponse describeEventTaskHistory(shared_ptr<DescribeEventTaskHistoryRequest> request);
  DescribeEventTotalCountReportResponse describeEventTotalCountReportWithOptions(shared_ptr<DescribeEventTotalCountReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventTotalCountReportResponse describeEventTotalCountReport(shared_ptr<DescribeEventTotalCountReportRequest> request);
  DescribeEventUploadPolicyResponse describeEventUploadPolicyWithOptions(shared_ptr<DescribeEventUploadPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventUploadPolicyResponse describeEventUploadPolicy(shared_ptr<DescribeEventUploadPolicyRequest> request);
  DescribeEventVariableListResponse describeEventVariableListWithOptions(shared_ptr<DescribeEventVariableListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventVariableListResponse describeEventVariableList(shared_ptr<DescribeEventVariableListRequest> request);
  DescribeEventVariableTemplateBindResponse describeEventVariableTemplateBindWithOptions(shared_ptr<DescribeEventVariableTemplateBindRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventVariableTemplateBindResponse describeEventVariableTemplateBind(shared_ptr<DescribeEventVariableTemplateBindRequest> request);
  DescribeEventVariableTemplateListResponse describeEventVariableTemplateListWithOptions(shared_ptr<DescribeEventVariableTemplateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventVariableTemplateListResponse describeEventVariableTemplateList(shared_ptr<DescribeEventVariableTemplateListRequest> request);
  DescribeEventsVariableListResponse describeEventsVariableListWithOptions(shared_ptr<DescribeEventsVariableListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventsVariableListResponse describeEventsVariableList(shared_ptr<DescribeEventsVariableListRequest> request);
  DescribeExcuteNumResponse describeExcuteNumWithOptions(shared_ptr<DescribeExcuteNumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExcuteNumResponse describeExcuteNum(shared_ptr<DescribeExcuteNumRequest> request);
  DescribeExistNameResponse describeExistNameWithOptions(shared_ptr<DescribeExistNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExistNameResponse describeExistName(shared_ptr<DescribeExistNameRequest> request);
  DescribeExistSceneResponse describeExistSceneWithOptions(shared_ptr<DescribeExistSceneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExistSceneResponse describeExistScene(shared_ptr<DescribeExistSceneRequest> request);
  DescribeExpressionVariableDetailResponse describeExpressionVariableDetailWithOptions(shared_ptr<DescribeExpressionVariableDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExpressionVariableDetailResponse describeExpressionVariableDetail(shared_ptr<DescribeExpressionVariableDetailRequest> request);
  DescribeExpressionVariableFunctionListResponse describeExpressionVariableFunctionListWithOptions(shared_ptr<DescribeExpressionVariableFunctionListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExpressionVariableFunctionListResponse describeExpressionVariableFunctionList(shared_ptr<DescribeExpressionVariableFunctionListRequest> request);
  DescribeExpressionVariablePageResponse describeExpressionVariablePageWithOptions(shared_ptr<DescribeExpressionVariablePageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExpressionVariablePageResponse describeExpressionVariablePage(shared_ptr<DescribeExpressionVariablePageRequest> request);
  DescribeFieldByIdResponse describeFieldByIdWithOptions(shared_ptr<DescribeFieldByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFieldByIdResponse describeFieldById(shared_ptr<DescribeFieldByIdRequest> request);
  DescribeFieldListResponse describeFieldListWithOptions(shared_ptr<DescribeFieldListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFieldListResponse describeFieldList(shared_ptr<DescribeFieldListRequest> request);
  DescribeFieldPageResponse describeFieldPageWithOptions(shared_ptr<DescribeFieldPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFieldPageResponse describeFieldPage(shared_ptr<DescribeFieldPageRequest> request);
  DescribeGroupAccountPageResponse describeGroupAccountPageWithOptions(shared_ptr<DescribeGroupAccountPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupAccountPageResponse describeGroupAccountPage(shared_ptr<DescribeGroupAccountPageRequest> request);
  DescribeGroupConditionListResponse describeGroupConditionListWithOptions(shared_ptr<DescribeGroupConditionListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupConditionListResponse describeGroupConditionList(shared_ptr<DescribeGroupConditionListRequest> request);
  DescribeGroupPageResponse describeGroupPageWithOptions(shared_ptr<DescribeGroupPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupPageResponse describeGroupPage(shared_ptr<DescribeGroupPageRequest> request);
  DescribeGroupStatisticsByTodayResponse describeGroupStatisticsByTodayWithOptions(shared_ptr<DescribeGroupStatisticsByTodayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupStatisticsByTodayResponse describeGroupStatisticsByToday(shared_ptr<DescribeGroupStatisticsByTodayRequest> request);
  DescribeGroupTrendResponse describeGroupTrendWithOptions(shared_ptr<DescribeGroupTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupTrendResponse describeGroupTrend(shared_ptr<DescribeGroupTrendRequest> request);
  DescribeHasRuleNameByEventCodeResponse describeHasRuleNameByEventCodeWithOptions(shared_ptr<DescribeHasRuleNameByEventCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHasRuleNameByEventCodeResponse describeHasRuleNameByEventCode(shared_ptr<DescribeHasRuleNameByEventCodeRequest> request);
  DescribeHighRiskPieChartResponse describeHighRiskPieChartWithOptions(shared_ptr<DescribeHighRiskPieChartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHighRiskPieChartResponse describeHighRiskPieChart(shared_ptr<DescribeHighRiskPieChartRequest> request);
  DescribeHitRuleFluctuationResponse describeHitRuleFluctuationWithOptions(shared_ptr<DescribeHitRuleFluctuationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHitRuleFluctuationResponse describeHitRuleFluctuation(shared_ptr<DescribeHitRuleFluctuationRequest> request);
  DescribeHitRuleListResponse describeHitRuleListWithOptions(shared_ptr<DescribeHitRuleListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHitRuleListResponse describeHitRuleList(shared_ptr<DescribeHitRuleListRequest> request);
  DescribeHitRuleTrendResponse describeHitRuleTrendWithOptions(shared_ptr<DescribeHitRuleTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHitRuleTrendResponse describeHitRuleTrend(shared_ptr<DescribeHitRuleTrendRequest> request);
  DescribeInputFeildCountByEventCodeResponse describeInputFeildCountByEventCodeWithOptions(shared_ptr<DescribeInputFeildCountByEventCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInputFeildCountByEventCodeResponse describeInputFeildCountByEventCode(shared_ptr<DescribeInputFeildCountByEventCodeRequest> request);
  DescribeListPocResponse describeListPocWithOptions(shared_ptr<DescribeListPocRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeListPocResponse describeListPoc(shared_ptr<DescribeListPocRequest> request);
  DescribeLoanExecListResponse describeLoanExecListWithOptions(shared_ptr<DescribeLoanExecListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoanExecListResponse describeLoanExecList(shared_ptr<DescribeLoanExecListRequest> request);
  DescribeLoanTaskListResponse describeLoanTaskListWithOptions(shared_ptr<DescribeLoanTaskListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoanTaskListResponse describeLoanTaskList(shared_ptr<DescribeLoanTaskListRequest> request);
  DescribeMarkPageResponse describeMarkPageWithOptions(shared_ptr<DescribeMarkPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMarkPageResponse describeMarkPage(shared_ptr<DescribeMarkPageRequest> request);
  DescribeMenuPermissionResponse describeMenuPermissionWithOptions(shared_ptr<DescribeMenuPermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMenuPermissionResponse describeMenuPermission(shared_ptr<DescribeMenuPermissionRequest> request);
  DescribeMonitorTaskLimitResponse describeMonitorTaskLimitWithOptions(shared_ptr<DescribeMonitorTaskLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitorTaskLimitResponse describeMonitorTaskLimit(shared_ptr<DescribeMonitorTaskLimitRequest> request);
  DescribeNameListResponse describeNameListWithOptions(shared_ptr<DescribeNameListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNameListResponse describeNameList(shared_ptr<DescribeNameListRequest> request);
  DescribeNameListDownloadUrlResponse describeNameListDownloadUrlWithOptions(shared_ptr<DescribeNameListDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNameListDownloadUrlResponse describeNameListDownloadUrl(shared_ptr<DescribeNameListDownloadUrlRequest> request);
  DescribeNameListLimitResponse describeNameListLimitWithOptions(shared_ptr<DescribeNameListLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNameListLimitResponse describeNameListLimit(shared_ptr<DescribeNameListLimitRequest> request);
  DescribeNameListPageListResponse describeNameListPageListWithOptions(shared_ptr<DescribeNameListPageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNameListPageListResponse describeNameListPageList(shared_ptr<DescribeNameListPageListRequest> request);
  DescribeNameListTypeListResponse describeNameListTypeListWithOptions(shared_ptr<DescribeNameListTypeListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNameListTypeListResponse describeNameListTypeList(shared_ptr<DescribeNameListTypeListRequest> request);
  DescribeNameListVariablePageListResponse describeNameListVariablePageListWithOptions(shared_ptr<DescribeNameListVariablePageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNameListVariablePageListResponse describeNameListVariablePageList(shared_ptr<DescribeNameListVariablePageListRequest> request);
  DescribeOperationLogPageListResponse describeOperationLogPageListWithOptions(shared_ptr<DescribeOperationLogPageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOperationLogPageListResponse describeOperationLogPageList(shared_ptr<DescribeOperationLogPageListRequest> request);
  DescribeOperatorListResponse describeOperatorListWithOptions(shared_ptr<DescribeOperatorListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOperatorListResponse describeOperatorList(shared_ptr<DescribeOperatorListRequest> request);
  DescribeOperatorListBySceneResponse describeOperatorListBySceneWithOptions(shared_ptr<DescribeOperatorListBySceneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOperatorListBySceneResponse describeOperatorListByScene(shared_ptr<DescribeOperatorListBySceneRequest> request);
  DescribeOperatorListByTypeResponse describeOperatorListByTypeWithOptions(shared_ptr<DescribeOperatorListByTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOperatorListByTypeResponse describeOperatorListByType(shared_ptr<DescribeOperatorListByTypeRequest> request);
  DescribeOssAuthStatusResponse describeOssAuthStatusWithOptions(shared_ptr<DescribeOssAuthStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOssAuthStatusResponse describeOssAuthStatus(shared_ptr<DescribeOssAuthStatusRequest> request);
  DescribeOssPolicyResponse describeOssPolicyWithOptions(shared_ptr<DescribeOssPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOssPolicyResponse describeOssPolicy(shared_ptr<DescribeOssPolicyRequest> request);
  DescribeOssTokenResponse describeOssTokenWithOptions(shared_ptr<DescribeOssTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOssTokenResponse describeOssToken(shared_ptr<DescribeOssTokenRequest> request);
  DescribeParamByEventCodesResponse describeParamByEventCodesWithOptions(shared_ptr<DescribeParamByEventCodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeParamByEventCodesResponse describeParamByEventCodes(shared_ptr<DescribeParamByEventCodesRequest> request);
  DescribeParamListResponse describeParamListWithOptions(shared_ptr<DescribeParamListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeParamListResponse describeParamList(shared_ptr<DescribeParamListRequest> request);
  DescribePocDetailResponse describePocDetailWithOptions(shared_ptr<DescribePocDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePocDetailResponse describePocDetail(shared_ptr<DescribePocDetailRequest> request);
  DescribePocOssTokenResponse describePocOssTokenWithOptions(shared_ptr<DescribePocOssTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePocOssTokenResponse describePocOssToken(shared_ptr<DescribePocOssTokenRequest> request);
  DescribePocTaskListResponse describePocTaskListWithOptions(shared_ptr<DescribePocTaskListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePocTaskListResponse describePocTaskList(shared_ptr<DescribePocTaskListRequest> request);
  DescribePrivateStackResponse describePrivateStackWithOptions(shared_ptr<DescribePrivateStackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePrivateStackResponse describePrivateStack(shared_ptr<DescribePrivateStackRequest> request);
  DescribeQueryVariableDetailResponse describeQueryVariableDetailWithOptions(shared_ptr<DescribeQueryVariableDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeQueryVariableDetailResponse describeQueryVariableDetail(shared_ptr<DescribeQueryVariableDetailRequest> request);
  DescribeQueryVariablePageListResponse describeQueryVariablePageListWithOptions(shared_ptr<DescribeQueryVariablePageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeQueryVariablePageListResponse describeQueryVariablePageList(shared_ptr<DescribeQueryVariablePageListRequest> request);
  DescribeRecommendSceneVariablesResponse describeRecommendSceneVariablesWithOptions(shared_ptr<DescribeRecommendSceneVariablesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecommendSceneVariablesResponse describeRecommendSceneVariables(shared_ptr<DescribeRecommendSceneVariablesRequest> request);
  DescribeRecommendTaskDetailResponse describeRecommendTaskDetailWithOptions(shared_ptr<DescribeRecommendTaskDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecommendTaskDetailResponse describeRecommendTaskDetail(shared_ptr<DescribeRecommendTaskDetailRequest> request);
  DescribeRecommendTaskPageListResponse describeRecommendTaskPageListWithOptions(shared_ptr<DescribeRecommendTaskPageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecommendTaskPageListResponse describeRecommendTaskPageList(shared_ptr<DescribeRecommendTaskPageListRequest> request);
  DescribeRecommendVariablesVelocityResponse describeRecommendVariablesVelocityWithOptions(shared_ptr<DescribeRecommendVariablesVelocityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecommendVariablesVelocityResponse describeRecommendVariablesVelocity(shared_ptr<DescribeRecommendVariablesVelocityRequest> request);
  DescribeRecommendVelocitiesResponse describeRecommendVelocitiesWithOptions(shared_ptr<DescribeRecommendVelocitiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecommendVelocitiesResponse describeRecommendVelocities(shared_ptr<DescribeRecommendVelocitiesRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  DescribeRequestHitResponse describeRequestHitWithOptions(shared_ptr<DescribeRequestHitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRequestHitResponse describeRequestHit(shared_ptr<DescribeRequestHitRequest> request);
  DescribeRequestPeakReportResponse describeRequestPeakReportWithOptions(shared_ptr<DescribeRequestPeakReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRequestPeakReportResponse describeRequestPeakReport(shared_ptr<DescribeRequestPeakReportRequest> request);
  DescribeResultCountResponse describeResultCountWithOptions(shared_ptr<DescribeResultCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResultCountResponse describeResultCount(shared_ptr<DescribeResultCountRequest> request);
  DescribeRiskLineChartResponse describeRiskLineChartWithOptions(shared_ptr<DescribeRiskLineChartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRiskLineChartResponse describeRiskLineChart(shared_ptr<DescribeRiskLineChartRequest> request);
  DescribeRuleBarChartResponse describeRuleBarChartWithOptions(shared_ptr<DescribeRuleBarChartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleBarChartResponse describeRuleBarChart(shared_ptr<DescribeRuleBarChartRequest> request);
  DescribeRuleCountByUserIdResponse describeRuleCountByUserIdWithOptions(shared_ptr<DescribeRuleCountByUserIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleCountByUserIdResponse describeRuleCountByUserId(shared_ptr<DescribeRuleCountByUserIdRequest> request);
  DescribeRuleDetailByRuleIdResponse describeRuleDetailByRuleIdWithOptions(shared_ptr<DescribeRuleDetailByRuleIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleDetailByRuleIdResponse describeRuleDetailByRuleId(shared_ptr<DescribeRuleDetailByRuleIdRequest> request);
  DescribeRuleHitResponse describeRuleHitWithOptions(shared_ptr<DescribeRuleHitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleHitResponse describeRuleHit(shared_ptr<DescribeRuleHitRequest> request);
  DescribeRuleListByEventCodesListResponse describeRuleListByEventCodesListWithOptions(shared_ptr<DescribeRuleListByEventCodesListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleListByEventCodesListResponse describeRuleListByEventCodesList(shared_ptr<DescribeRuleListByEventCodesListRequest> request);
  DescribeRulePageListResponse describeRulePageListWithOptions(shared_ptr<DescribeRulePageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRulePageListResponse describeRulePageList(shared_ptr<DescribeRulePageListRequest> request);
  DescribeRuleSnapshotResponse describeRuleSnapshotWithOptions(shared_ptr<DescribeRuleSnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleSnapshotResponse describeRuleSnapshot(shared_ptr<DescribeRuleSnapshotRequest> request);
  DescribeRuleVersionListResponse describeRuleVersionListWithOptions(shared_ptr<DescribeRuleVersionListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleVersionListResponse describeRuleVersionList(shared_ptr<DescribeRuleVersionListRequest> request);
  DescribeSDKDownloadListResponse describeSDKDownloadListWithOptions(shared_ptr<DescribeSDKDownloadListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSDKDownloadListResponse describeSDKDownloadList(shared_ptr<DescribeSDKDownloadListRequest> request);
  DescribeSafConsoleResponse describeSafConsoleWithOptions(shared_ptr<DescribeSafConsoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSafConsoleResponse describeSafConsole(shared_ptr<DescribeSafConsoleRequest> request);
  DescribeSafDeOrderResponse describeSafDeOrderWithOptions(shared_ptr<DescribeSafDeOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSafDeOrderResponse describeSafDeOrder(shared_ptr<DescribeSafDeOrderRequest> request);
  DescribeSafOrderResponse describeSafOrderWithOptions(shared_ptr<DescribeSafOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSafOrderResponse describeSafOrder(shared_ptr<DescribeSafOrderRequest> request);
  DescribeSafStartConfigResponse describeSafStartConfigWithOptions(shared_ptr<DescribeSafStartConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSafStartConfigResponse describeSafStartConfig(shared_ptr<DescribeSafStartConfigRequest> request);
  DescribeSafStartStepsResponse describeSafStartStepsWithOptions(shared_ptr<DescribeSafStartStepsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSafStartStepsResponse describeSafStartSteps(shared_ptr<DescribeSafStartStepsRequest> request);
  DescribeSafTagListResponse describeSafTagListWithOptions(shared_ptr<DescribeSafTagListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSafTagListResponse describeSafTagList(shared_ptr<DescribeSafTagListRequest> request);
  DescribeSampleDataListResponse describeSampleDataListWithOptions(shared_ptr<DescribeSampleDataListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSampleDataListResponse describeSampleDataList(shared_ptr<DescribeSampleDataListRequest> request);
  DescribeSampleDemoDownloadUrlResponse describeSampleDemoDownloadUrlWithOptions(shared_ptr<DescribeSampleDemoDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSampleDemoDownloadUrlResponse describeSampleDemoDownloadUrl(shared_ptr<DescribeSampleDemoDownloadUrlRequest> request);
  DescribeSampleDownloadUrlResponse describeSampleDownloadUrlWithOptions(shared_ptr<DescribeSampleDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSampleDownloadUrlResponse describeSampleDownloadUrl(shared_ptr<DescribeSampleDownloadUrlRequest> request);
  DescribeSampleInfoResponse describeSampleInfoWithOptions(shared_ptr<DescribeSampleInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSampleInfoResponse describeSampleInfo(shared_ptr<DescribeSampleInfoRequest> request);
  DescribeSampleListResponse describeSampleListWithOptions(shared_ptr<DescribeSampleListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSampleListResponse describeSampleList(shared_ptr<DescribeSampleListRequest> request);
  DescribeSampleSceneListResponse describeSampleSceneListWithOptions(shared_ptr<DescribeSampleSceneListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSampleSceneListResponse describeSampleSceneList(shared_ptr<DescribeSampleSceneListRequest> request);
  DescribeSampleTagListResponse describeSampleTagListWithOptions(shared_ptr<DescribeSampleTagListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSampleTagListResponse describeSampleTagList(shared_ptr<DescribeSampleTagListRequest> request);
  DescribeSampleUploadPolicyResponse describeSampleUploadPolicyWithOptions(shared_ptr<DescribeSampleUploadPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSampleUploadPolicyResponse describeSampleUploadPolicy(shared_ptr<DescribeSampleUploadPolicyRequest> request);
  DescribeSceneAllEventNameCodeListResponse describeSceneAllEventNameCodeListWithOptions(shared_ptr<DescribeSceneAllEventNameCodeListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSceneAllEventNameCodeListResponse describeSceneAllEventNameCodeList(shared_ptr<DescribeSceneAllEventNameCodeListRequest> request);
  DescribeSceneEventPageListResponse describeSceneEventPageListWithOptions(shared_ptr<DescribeSceneEventPageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSceneEventPageListResponse describeSceneEventPageList(shared_ptr<DescribeSceneEventPageListRequest> request);
  DescribeSceneRulePageListResponse describeSceneRulePageListWithOptions(shared_ptr<DescribeSceneRulePageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSceneRulePageListResponse describeSceneRulePageList(shared_ptr<DescribeSceneRulePageListRequest> request);
  DescribeScoreSectionNumLineChartResponse describeScoreSectionNumLineChartWithOptions(shared_ptr<DescribeScoreSectionNumLineChartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScoreSectionNumLineChartResponse describeScoreSectionNumLineChart(shared_ptr<DescribeScoreSectionNumLineChartRequest> request);
  DescribeScoreSectionPieChartResponse describeScoreSectionPieChartWithOptions(shared_ptr<DescribeScoreSectionPieChartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScoreSectionPieChartResponse describeScoreSectionPieChart(shared_ptr<DescribeScoreSectionPieChartRequest> request);
  DescribeScoreSectionRatioLineChartResponse describeScoreSectionRatioLineChartWithOptions(shared_ptr<DescribeScoreSectionRatioLineChartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScoreSectionRatioLineChartResponse describeScoreSectionRatioLineChart(shared_ptr<DescribeScoreSectionRatioLineChartRequest> request);
  DescribeSelectItemResponse describeSelectItemWithOptions(shared_ptr<DescribeSelectItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSelectItemResponse describeSelectItem(shared_ptr<DescribeSelectItemRequest> request);
  DescribeServiceAppKeyResponse describeServiceAppKeyWithOptions(shared_ptr<DescribeServiceAppKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeServiceAppKeyResponse describeServiceAppKey(shared_ptr<DescribeServiceAppKeyRequest> request);
  DescribeServiceConsumeResponse describeServiceConsumeWithOptions(shared_ptr<DescribeServiceConsumeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeServiceConsumeResponse describeServiceConsume(shared_ptr<DescribeServiceConsumeRequest> request);
  DescribeServiceConsumeDownloadUrlResponse describeServiceConsumeDownloadUrlWithOptions(shared_ptr<DescribeServiceConsumeDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeServiceConsumeDownloadUrlResponse describeServiceConsumeDownloadUrl(shared_ptr<DescribeServiceConsumeDownloadUrlRequest> request);
  DescribeServiceListResponse describeServiceListWithOptions(shared_ptr<DescribeServiceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeServiceListResponse describeServiceList(shared_ptr<DescribeServiceListRequest> request);
  DescribeSimulationPreditInfoResponse describeSimulationPreditInfoWithOptions(shared_ptr<DescribeSimulationPreditInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSimulationPreditInfoResponse describeSimulationPreditInfo(shared_ptr<DescribeSimulationPreditInfoRequest> request);
  DescribeSimulationTaskCountResponse describeSimulationTaskCountWithOptions(shared_ptr<DescribeSimulationTaskCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSimulationTaskCountResponse describeSimulationTaskCount(shared_ptr<DescribeSimulationTaskCountRequest> request);
  DescribeSimulationTaskListResponse describeSimulationTaskListWithOptions(shared_ptr<DescribeSimulationTaskListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSimulationTaskListResponse describeSimulationTaskList(shared_ptr<DescribeSimulationTaskListRequest> request);
  DescribeSlsUrlConfigResponse describeSlsUrlConfigWithOptions(shared_ptr<DescribeSlsUrlConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSlsUrlConfigResponse describeSlsUrlConfig(shared_ptr<DescribeSlsUrlConfigRequest> request);
  DescribeSupportRuleListResponse describeSupportRuleListWithOptions(shared_ptr<DescribeSupportRuleListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSupportRuleListResponse describeSupportRuleList(shared_ptr<DescribeSupportRuleListRequest> request);
  DescribeTagListResponse describeTagListWithOptions(shared_ptr<DescribeTagListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagListResponse describeTagList(shared_ptr<DescribeTagListRequest> request);
  DescribeTagsBarChartResponse describeTagsBarChartWithOptions(shared_ptr<DescribeTagsBarChartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagsBarChartResponse describeTagsBarChart(shared_ptr<DescribeTagsBarChartRequest> request);
  DescribeTagsFluctuationResponse describeTagsFluctuationWithOptions(shared_ptr<DescribeTagsFluctuationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagsFluctuationResponse describeTagsFluctuation(shared_ptr<DescribeTagsFluctuationRequest> request);
  DescribeTagsListResponse describeTagsListWithOptions(shared_ptr<DescribeTagsListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagsListResponse describeTagsList(shared_ptr<DescribeTagsListRequest> request);
  DescribeTagsNumLineChartResponse describeTagsNumLineChartWithOptions(shared_ptr<DescribeTagsNumLineChartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagsNumLineChartResponse describeTagsNumLineChart(shared_ptr<DescribeTagsNumLineChartRequest> request);
  DescribeTagsRatioLineChartResponse describeTagsRatioLineChartWithOptions(shared_ptr<DescribeTagsRatioLineChartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagsRatioLineChartResponse describeTagsRatioLineChart(shared_ptr<DescribeTagsRatioLineChartRequest> request);
  DescribeTagsTrendResponse describeTagsTrendWithOptions(shared_ptr<DescribeTagsTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagsTrendResponse describeTagsTrend(shared_ptr<DescribeTagsTrendRequest> request);
  DescribeTaskListResponse describeTaskListWithOptions(shared_ptr<DescribeTaskListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTaskListResponse describeTaskList(shared_ptr<DescribeTaskListRequest> request);
  DescribeTaskLogListResponse describeTaskLogListWithOptions(shared_ptr<DescribeTaskLogListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTaskLogListResponse describeTaskLogList(shared_ptr<DescribeTaskLogListRequest> request);
  DescribeTemplateBaseInfoByTemplateIdResponse describeTemplateBaseInfoByTemplateIdWithOptions(shared_ptr<DescribeTemplateBaseInfoByTemplateIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTemplateBaseInfoByTemplateIdResponse describeTemplateBaseInfoByTemplateId(shared_ptr<DescribeTemplateBaseInfoByTemplateIdRequest> request);
  DescribeTemplateCountResponse describeTemplateCountWithOptions(shared_ptr<DescribeTemplateCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTemplateCountResponse describeTemplateCount(shared_ptr<DescribeTemplateCountRequest> request);
  DescribeTemplateDownloadResponse describeTemplateDownloadWithOptions(shared_ptr<DescribeTemplateDownloadRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTemplateDownloadResponse describeTemplateDownload(shared_ptr<DescribeTemplateDownloadRequest> request);
  DescribeTemplatePageListResponse describeTemplatePageListWithOptions(shared_ptr<DescribeTemplatePageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTemplatePageListResponse describeTemplatePageList(shared_ptr<DescribeTemplatePageListRequest> request);
  DescribeUsedServiceResponse describeUsedServiceWithOptions(shared_ptr<DescribeUsedServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUsedServiceResponse describeUsedService(shared_ptr<DescribeUsedServiceRequest> request);
  DescribeUserInfoResponse describeUserInfoWithOptions(shared_ptr<DescribeUserInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserInfoResponse describeUserInfo(shared_ptr<DescribeUserInfoRequest> request);
  DescribeVariableBindDetailResponse describeVariableBindDetailWithOptions(shared_ptr<DescribeVariableBindDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVariableBindDetailResponse describeVariableBindDetail(shared_ptr<DescribeVariableBindDetailRequest> request);
  DescribeVariableDetailResponse describeVariableDetailWithOptions(shared_ptr<DescribeVariableDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVariableDetailResponse describeVariableDetail(shared_ptr<DescribeVariableDetailRequest> request);
  DescribeVariableFeeResponse describeVariableFeeWithOptions(shared_ptr<DescribeVariableFeeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVariableFeeResponse describeVariableFee(shared_ptr<DescribeVariableFeeRequest> request);
  DescribeVariableListResponse describeVariableListWithOptions(shared_ptr<DescribeVariableListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVariableListResponse describeVariableList(shared_ptr<DescribeVariableListRequest> request);
  DescribeVariableMarketListResponse describeVariableMarketListWithOptions(shared_ptr<DescribeVariableMarketListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVariableMarketListResponse describeVariableMarketList(shared_ptr<DescribeVariableMarketListRequest> request);
  DescribeVariableSceneListResponse describeVariableSceneListWithOptions(shared_ptr<DescribeVariableSceneListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVariableSceneListResponse describeVariableSceneList(shared_ptr<DescribeVariableSceneListRequest> request);
  ExpressionTestResponse expressionTestWithOptions(shared_ptr<ExpressionTestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExpressionTestResponse expressionTest(shared_ptr<ExpressionTestRequest> request);
  FileUploadResponse fileUploadWithOptions(shared_ptr<FileUploadRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FileUploadResponse fileUpload(shared_ptr<FileUploadRequest> request);
  ImportNameListResponse importNameListWithOptions(shared_ptr<ImportNameListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportNameListResponse importNameList(shared_ptr<ImportNameListRequest> request);
  ImportTemplateEventResponse importTemplateEventWithOptions(shared_ptr<ImportTemplateEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportTemplateEventResponse importTemplateEvent(shared_ptr<ImportTemplateEventRequest> request);
  ModifyAppKeyResponse modifyAppKeyWithOptions(shared_ptr<ModifyAppKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAppKeyResponse modifyAppKey(shared_ptr<ModifyAppKeyRequest> request);
  ModifyCustVariableResponse modifyCustVariableWithOptions(shared_ptr<ModifyCustVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCustVariableResponse modifyCustVariable(shared_ptr<ModifyCustVariableRequest> request);
  ModifyEventResponse modifyEventWithOptions(shared_ptr<ModifyEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEventResponse modifyEvent(shared_ptr<ModifyEventRequest> request);
  ModifyEventStatusResponse modifyEventStatusWithOptions(shared_ptr<ModifyEventStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEventStatusResponse modifyEventStatus(shared_ptr<ModifyEventStatusRequest> request);
  ModifyExpressionVariableResponse modifyExpressionVariableWithOptions(shared_ptr<ModifyExpressionVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyExpressionVariableResponse modifyExpressionVariable(shared_ptr<ModifyExpressionVariableRequest> request);
  ModifyFieldResponse modifyFieldWithOptions(shared_ptr<ModifyFieldRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFieldResponse modifyField(shared_ptr<ModifyFieldRequest> request);
  ModifyPocTaskResponse modifyPocTaskWithOptions(shared_ptr<ModifyPocTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPocTaskResponse modifyPocTask(shared_ptr<ModifyPocTaskRequest> request);
  ModifyRulePriorityResponse modifyRulePriorityWithOptions(shared_ptr<ModifyRulePriorityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRulePriorityResponse modifyRulePriority(shared_ptr<ModifyRulePriorityRequest> request);
  ModifyRuleStatusResponse modifyRuleStatusWithOptions(shared_ptr<ModifyRuleStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRuleStatusResponse modifyRuleStatus(shared_ptr<ModifyRuleStatusRequest> request);
  ModifyTemplateResponse modifyTemplateWithOptions(shared_ptr<ModifyTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTemplateResponse modifyTemplate(shared_ptr<ModifyTemplateRequest> request);
  ModifyTemplateStatusResponse modifyTemplateStatusWithOptions(shared_ptr<ModifyTemplateStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTemplateStatusResponse modifyTemplateStatus(shared_ptr<ModifyTemplateStatusRequest> request);
  ModifyVariableResponse modifyVariableWithOptions(shared_ptr<ModifyVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVariableResponse modifyVariable(shared_ptr<ModifyVariableRequest> request);
  OpenConsoleSlsResponse openConsoleSlsWithOptions(shared_ptr<OpenConsoleSlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenConsoleSlsResponse openConsoleSls(shared_ptr<OpenConsoleSlsRequest> request);
  OperateFavoriteVariableResponse operateFavoriteVariableWithOptions(shared_ptr<OperateFavoriteVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateFavoriteVariableResponse operateFavoriteVariable(shared_ptr<OperateFavoriteVariableRequest> request);
  PermissionCheckResponse permissionCheckWithOptions(shared_ptr<PermissionCheckRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PermissionCheckResponse permissionCheck(shared_ptr<PermissionCheckRequest> request);
  QueryAuthRuleDetailByRuleIdResponse queryAuthRuleDetailByRuleIdWithOptions(shared_ptr<QueryAuthRuleDetailByRuleIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAuthRuleDetailByRuleIdResponse queryAuthRuleDetailByRuleId(shared_ptr<QueryAuthRuleDetailByRuleIdRequest> request);
  QueryAuthUserNameResponse queryAuthUserNameWithOptions(shared_ptr<QueryAuthUserNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAuthUserNameResponse queryAuthUserName(shared_ptr<QueryAuthUserNameRequest> request);
  QueryAuthorizationUserListResponse queryAuthorizationUserListWithOptions(shared_ptr<QueryAuthorizationUserListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAuthorizationUserListResponse queryAuthorizationUserList(shared_ptr<QueryAuthorizationUserListRequest> request);
  RecallRuleAuditResponse recallRuleAuditWithOptions(shared_ptr<RecallRuleAuditRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecallRuleAuditResponse recallRuleAudit(shared_ptr<RecallRuleAuditRequest> request);
  RemoveEventResponse removeEventWithOptions(shared_ptr<RemoveEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveEventResponse removeEvent(shared_ptr<RemoveEventRequest> request);
  RemoveTemplateResponse removeTemplateWithOptions(shared_ptr<RemoveTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveTemplateResponse removeTemplate(shared_ptr<RemoveTemplateRequest> request);
  SampleFileDownloadResponse sampleFileDownloadWithOptions(shared_ptr<SampleFileDownloadRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SampleFileDownloadResponse sampleFileDownload(shared_ptr<SampleFileDownloadRequest> request);
  SaveAnalysisColumnResponse saveAnalysisColumnWithOptions(shared_ptr<SaveAnalysisColumnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveAnalysisColumnResponse saveAnalysisColumn(shared_ptr<SaveAnalysisColumnRequest> request);
  SaveByPassOrShuntEventResponse saveByPassOrShuntEventWithOptions(shared_ptr<SaveByPassOrShuntEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveByPassOrShuntEventResponse saveByPassOrShuntEvent(shared_ptr<SaveByPassOrShuntEventRequest> request);
  StartOrStopByPassShuntEventResponse startOrStopByPassShuntEventWithOptions(shared_ptr<StartOrStopByPassShuntEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartOrStopByPassShuntEventResponse startOrStopByPassShuntEvent(shared_ptr<StartOrStopByPassShuntEventRequest> request);
  StartSimulationTaskResponse startSimulationTaskWithOptions(shared_ptr<StartSimulationTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartSimulationTaskResponse startSimulationTask(shared_ptr<StartSimulationTaskRequest> request);
  StopSimulationTaskResponse stopSimulationTaskWithOptions(shared_ptr<StopSimulationTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopSimulationTaskResponse stopSimulationTask(shared_ptr<StopSimulationTaskRequest> request);
  SubmitImportTaskResponse submitImportTaskWithOptions(shared_ptr<SubmitImportTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitImportTaskResponse submitImportTask(shared_ptr<SubmitImportTaskRequest> request);
  SwitchExpressionVariableResponse switchExpressionVariableWithOptions(shared_ptr<SwitchExpressionVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchExpressionVariableResponse switchExpressionVariable(shared_ptr<SwitchExpressionVariableRequest> request);
  SwitchFieldResponse switchFieldWithOptions(shared_ptr<SwitchFieldRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchFieldResponse switchField(shared_ptr<SwitchFieldRequest> request);
  SwitchQueryVariableResponse switchQueryVariableWithOptions(shared_ptr<SwitchQueryVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchQueryVariableResponse switchQueryVariable(shared_ptr<SwitchQueryVariableRequest> request);
  SwitchToOnlineResponse switchToOnlineWithOptions(shared_ptr<SwitchToOnlineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchToOnlineResponse switchToOnline(shared_ptr<SwitchToOnlineRequest> request);
  SwitchVariableResponse switchVariableWithOptions(shared_ptr<SwitchVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchVariableResponse switchVariable(shared_ptr<SwitchVariableRequest> request);
  TaskNameByUserIdResponse taskNameByUserIdWithOptions(shared_ptr<TaskNameByUserIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TaskNameByUserIdResponse taskNameByUserId(shared_ptr<TaskNameByUserIdRequest> request);
  UpdateAnalysisConditionFavoriteResponse updateAnalysisConditionFavoriteWithOptions(shared_ptr<UpdateAnalysisConditionFavoriteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAnalysisConditionFavoriteResponse updateAnalysisConditionFavorite(shared_ptr<UpdateAnalysisConditionFavoriteRequest> request);
  UpdateAuditResponse updateAuditWithOptions(shared_ptr<UpdateAuditRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAuditResponse updateAudit(shared_ptr<UpdateAuditRequest> request);
  UpdateAuthRuleResponse updateAuthRuleWithOptions(shared_ptr<UpdateAuthRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAuthRuleResponse updateAuthRule(shared_ptr<UpdateAuthRuleRequest> request);
  UpdateByPassShuntEventResponse updateByPassShuntEventWithOptions(shared_ptr<UpdateByPassShuntEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateByPassShuntEventResponse updateByPassShuntEvent(shared_ptr<UpdateByPassShuntEventRequest> request);
  UpdateDataSourceResponse updateDataSourceWithOptions(shared_ptr<UpdateDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataSourceResponse updateDataSource(shared_ptr<UpdateDataSourceRequest> request);
  UpdateQueryVariableResponse updateQueryVariableWithOptions(shared_ptr<UpdateQueryVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateQueryVariableResponse updateQueryVariable(shared_ptr<UpdateQueryVariableRequest> request);
  UpdateRuleResponse updateRuleWithOptions(shared_ptr<UpdateRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRuleResponse updateRule(shared_ptr<UpdateRuleRequest> request);
  UpdateRuleBaseResponse updateRuleBaseWithOptions(shared_ptr<UpdateRuleBaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRuleBaseResponse updateRuleBase(shared_ptr<UpdateRuleBaseRequest> request);
  UpdateSampleBatchResponse updateSampleBatchWithOptions(shared_ptr<UpdateSampleBatchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSampleBatchResponse updateSampleBatch(shared_ptr<UpdateSampleBatchRequest> request);
  UploadSampleApiResponse uploadSampleApiWithOptions(shared_ptr<UploadSampleApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadSampleApiResponse uploadSampleApi(shared_ptr<UploadSampleApiRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Xtee20210910

#endif
