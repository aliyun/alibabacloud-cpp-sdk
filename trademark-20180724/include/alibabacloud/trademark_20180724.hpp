// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_TRADEMARK20180724_H_
#define ALIBABACLOUD_TRADEMARK20180724_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Trademark20180724 {
class AcceptPartnerNotificationRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> material{};
  shared_ptr<string> operation{};
  shared_ptr<string> remark{};

  AcceptPartnerNotificationRequest() {}

  explicit AcceptPartnerNotificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (material) {
      res["Material"] = boost::any(*material);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Material") != m.end() && !m["Material"].empty()) {
      material = make_shared<string>(boost::any_cast<string>(m["Material"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~AcceptPartnerNotificationRequest() = default;
};
class AcceptPartnerNotificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AcceptPartnerNotificationResponseBody() {}

  explicit AcceptPartnerNotificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AcceptPartnerNotificationResponseBody() = default;
};
class AcceptPartnerNotificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AcceptPartnerNotificationResponseBody> body{};

  AcceptPartnerNotificationResponse() {}

  explicit AcceptPartnerNotificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AcceptPartnerNotificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AcceptPartnerNotificationResponseBody>(model1);
      }
    }
  }


  virtual ~AcceptPartnerNotificationResponse() = default;
};
class ApplyNotaryPostRequest : public Darabonba::Model {
public:
  shared_ptr<long> notaryOrderId{};
  shared_ptr<string> receiverAddress{};
  shared_ptr<string> receiverName{};
  shared_ptr<string> receiverPhone{};

  ApplyNotaryPostRequest() {}

  explicit ApplyNotaryPostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notaryOrderId) {
      res["NotaryOrderId"] = boost::any(*notaryOrderId);
    }
    if (receiverAddress) {
      res["ReceiverAddress"] = boost::any(*receiverAddress);
    }
    if (receiverName) {
      res["ReceiverName"] = boost::any(*receiverName);
    }
    if (receiverPhone) {
      res["ReceiverPhone"] = boost::any(*receiverPhone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotaryOrderId") != m.end() && !m["NotaryOrderId"].empty()) {
      notaryOrderId = make_shared<long>(boost::any_cast<long>(m["NotaryOrderId"]));
    }
    if (m.find("ReceiverAddress") != m.end() && !m["ReceiverAddress"].empty()) {
      receiverAddress = make_shared<string>(boost::any_cast<string>(m["ReceiverAddress"]));
    }
    if (m.find("ReceiverName") != m.end() && !m["ReceiverName"].empty()) {
      receiverName = make_shared<string>(boost::any_cast<string>(m["ReceiverName"]));
    }
    if (m.find("ReceiverPhone") != m.end() && !m["ReceiverPhone"].empty()) {
      receiverPhone = make_shared<string>(boost::any_cast<string>(m["ReceiverPhone"]));
    }
  }


  virtual ~ApplyNotaryPostRequest() = default;
};
class ApplyNotaryPostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ApplyNotaryPostResponseBody() {}

  explicit ApplyNotaryPostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ApplyNotaryPostResponseBody() = default;
};
class ApplyNotaryPostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyNotaryPostResponseBody> body{};

  ApplyNotaryPostResponse() {}

  explicit ApplyNotaryPostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyNotaryPostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyNotaryPostResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyNotaryPostResponse() = default;
};
class AskAdjudicationFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactCity{};
  shared_ptr<string> contactCounty{};
  shared_ptr<string> contactDistrict{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactNumber{};
  shared_ptr<string> contactProvince{};

  AskAdjudicationFileRequest() {}

  explicit AskAdjudicationFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactCity) {
      res["ContactCity"] = boost::any(*contactCity);
    }
    if (contactCounty) {
      res["ContactCounty"] = boost::any(*contactCounty);
    }
    if (contactDistrict) {
      res["ContactDistrict"] = boost::any(*contactDistrict);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactNumber) {
      res["ContactNumber"] = boost::any(*contactNumber);
    }
    if (contactProvince) {
      res["ContactProvince"] = boost::any(*contactProvince);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactCity") != m.end() && !m["ContactCity"].empty()) {
      contactCity = make_shared<string>(boost::any_cast<string>(m["ContactCity"]));
    }
    if (m.find("ContactCounty") != m.end() && !m["ContactCounty"].empty()) {
      contactCounty = make_shared<string>(boost::any_cast<string>(m["ContactCounty"]));
    }
    if (m.find("ContactDistrict") != m.end() && !m["ContactDistrict"].empty()) {
      contactDistrict = make_shared<string>(boost::any_cast<string>(m["ContactDistrict"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactNumber") != m.end() && !m["ContactNumber"].empty()) {
      contactNumber = make_shared<string>(boost::any_cast<string>(m["ContactNumber"]));
    }
    if (m.find("ContactProvince") != m.end() && !m["ContactProvince"].empty()) {
      contactProvince = make_shared<string>(boost::any_cast<string>(m["ContactProvince"]));
    }
  }


  virtual ~AskAdjudicationFileRequest() = default;
};
class AskAdjudicationFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AskAdjudicationFileResponseBody() {}

  explicit AskAdjudicationFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AskAdjudicationFileResponseBody() = default;
};
class AskAdjudicationFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AskAdjudicationFileResponseBody> body{};

  AskAdjudicationFileResponse() {}

  explicit AskAdjudicationFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AskAdjudicationFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AskAdjudicationFileResponseBody>(model1);
      }
    }
  }


  virtual ~AskAdjudicationFileResponse() = default;
};
class BindMaterialRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> legalNoticeKey{};
  shared_ptr<string> loaOssKey{};
  shared_ptr<string> materialId{};

  BindMaterialRequest() {}

  explicit BindMaterialRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (legalNoticeKey) {
      res["LegalNoticeKey"] = boost::any(*legalNoticeKey);
    }
    if (loaOssKey) {
      res["LoaOssKey"] = boost::any(*loaOssKey);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("LegalNoticeKey") != m.end() && !m["LegalNoticeKey"].empty()) {
      legalNoticeKey = make_shared<string>(boost::any_cast<string>(m["LegalNoticeKey"]));
    }
    if (m.find("LoaOssKey") != m.end() && !m["LoaOssKey"].empty()) {
      loaOssKey = make_shared<string>(boost::any_cast<string>(m["LoaOssKey"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
  }


  virtual ~BindMaterialRequest() = default;
};
class BindMaterialResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BindMaterialResponseBody() {}

  explicit BindMaterialResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindMaterialResponseBody() = default;
};
class BindMaterialResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindMaterialResponseBody> body{};

  BindMaterialResponse() {}

  explicit BindMaterialResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindMaterialResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindMaterialResponseBody>(model1);
      }
    }
  }


  virtual ~BindMaterialResponse() = default;
};
class CancelTradeOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};

  CancelTradeOrderRequest() {}

  explicit CancelTradeOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~CancelTradeOrderRequest() = default;
};
class CancelTradeOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CancelTradeOrderResponseBody() {}

  explicit CancelTradeOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelTradeOrderResponseBody() = default;
};
class CancelTradeOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelTradeOrderResponseBody> body{};

  CancelTradeOrderResponse() {}

  explicit CancelTradeOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelTradeOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelTradeOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CancelTradeOrderResponse() = default;
};
class CheckFlsmFillRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicantType{};
  shared_ptr<string> ossKey{};
  shared_ptr<string> personalType{};
  shared_ptr<string> wtrName{};

  CheckFlsmFillRequest() {}

  explicit CheckFlsmFillRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicantType) {
      res["ApplicantType"] = boost::any(*applicantType);
    }
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (wtrName) {
      res["WtrName"] = boost::any(*wtrName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicantType") != m.end() && !m["ApplicantType"].empty()) {
      applicantType = make_shared<string>(boost::any_cast<string>(m["ApplicantType"]));
    }
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["OssKey"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<string>(boost::any_cast<string>(m["PersonalType"]));
    }
    if (m.find("WtrName") != m.end() && !m["WtrName"].empty()) {
      wtrName = make_shared<string>(boost::any_cast<string>(m["WtrName"]));
    }
  }


  virtual ~CheckFlsmFillRequest() = default;
};
class CheckFlsmFillResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> tips{};

  CheckFlsmFillResponseBody() {}

  explicit CheckFlsmFillResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tips) {
      res["Tips"] = boost::any(*tips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tips") != m.end() && !m["Tips"].empty()) {
      tips = make_shared<string>(boost::any_cast<string>(m["Tips"]));
    }
  }


  virtual ~CheckFlsmFillResponseBody() = default;
};
class CheckFlsmFillResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckFlsmFillResponseBody> body{};

  CheckFlsmFillResponse() {}

  explicit CheckFlsmFillResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckFlsmFillResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckFlsmFillResponseBody>(model1);
      }
    }
  }


  virtual ~CheckFlsmFillResponse() = default;
};
class CheckIfCollectedRequest : public Darabonba::Model {
public:
  shared_ptr<string> itemIdList{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> type{};

  CheckIfCollectedRequest() {}

  explicit CheckIfCollectedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemIdList) {
      res["ItemIdList"] = boost::any(*itemIdList);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemIdList") != m.end() && !m["ItemIdList"].empty()) {
      itemIdList = make_shared<string>(boost::any_cast<string>(m["ItemIdList"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~CheckIfCollectedRequest() = default;
};
class CheckIfCollectedResponseBodyDataTrademark : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> itemIdList{};
  shared_ptr<string> name{};
  shared_ptr<long> type{};

  CheckIfCollectedResponseBodyDataTrademark() {}

  explicit CheckIfCollectedResponseBodyDataTrademark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (itemIdList) {
      res["ItemIdList"] = boost::any(*itemIdList);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ItemIdList") != m.end() && !m["ItemIdList"].empty()) {
      itemIdList = make_shared<string>(boost::any_cast<string>(m["ItemIdList"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~CheckIfCollectedResponseBodyDataTrademark() = default;
};
class CheckIfCollectedResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<CheckIfCollectedResponseBodyDataTrademark>> trademark{};

  CheckIfCollectedResponseBodyData() {}

  explicit CheckIfCollectedResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trademark) {
      vector<boost::any> temp1;
      for(auto item1:*trademark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Trademark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Trademark") != m.end() && !m["Trademark"].empty()) {
      if (typeid(vector<boost::any>) == m["Trademark"].type()) {
        vector<CheckIfCollectedResponseBodyDataTrademark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Trademark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CheckIfCollectedResponseBodyDataTrademark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trademark = make_shared<vector<CheckIfCollectedResponseBodyDataTrademark>>(expect1);
      }
    }
  }


  virtual ~CheckIfCollectedResponseBodyData() = default;
};
class CheckIfCollectedResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<CheckIfCollectedResponseBodyData> data{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  CheckIfCollectedResponseBody() {}

  explicit CheckIfCollectedResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CheckIfCollectedResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CheckIfCollectedResponseBodyData>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~CheckIfCollectedResponseBody() = default;
};
class CheckIfCollectedResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckIfCollectedResponseBody> body{};

  CheckIfCollectedResponse() {}

  explicit CheckIfCollectedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckIfCollectedResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckIfCollectedResponseBody>(model1);
      }
    }
  }


  virtual ~CheckIfCollectedResponse() = default;
};
class CheckLoaFillRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicantType{};
  shared_ptr<string> bizType{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactNumber{};
  shared_ptr<string> contactZipcode{};
  shared_ptr<string> ossKey{};
  shared_ptr<string> personalType{};
  shared_ptr<string> principalName{};
  shared_ptr<string> type{};
  shared_ptr<string> wtrName{};

  CheckLoaFillRequest() {}

  explicit CheckLoaFillRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicantType) {
      res["ApplicantType"] = boost::any(*applicantType);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactNumber) {
      res["ContactNumber"] = boost::any(*contactNumber);
    }
    if (contactZipcode) {
      res["ContactZipcode"] = boost::any(*contactZipcode);
    }
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (wtrName) {
      res["WtrName"] = boost::any(*wtrName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicantType") != m.end() && !m["ApplicantType"].empty()) {
      applicantType = make_shared<string>(boost::any_cast<string>(m["ApplicantType"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactNumber") != m.end() && !m["ContactNumber"].empty()) {
      contactNumber = make_shared<string>(boost::any_cast<string>(m["ContactNumber"]));
    }
    if (m.find("ContactZipcode") != m.end() && !m["ContactZipcode"].empty()) {
      contactZipcode = make_shared<string>(boost::any_cast<string>(m["ContactZipcode"]));
    }
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["OssKey"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<string>(boost::any_cast<string>(m["PersonalType"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WtrName") != m.end() && !m["WtrName"].empty()) {
      wtrName = make_shared<string>(boost::any_cast<string>(m["WtrName"]));
    }
  }


  virtual ~CheckLoaFillRequest() = default;
};
class CheckLoaFillResponseBodyDataErrorMsgs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> errorMsg{};

  CheckLoaFillResponseBodyDataErrorMsgs() {}

  explicit CheckLoaFillResponseBodyDataErrorMsgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ErrorMsg"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ErrorMsg"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      errorMsg = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CheckLoaFillResponseBodyDataErrorMsgs() = default;
};
class CheckLoaFillResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> addressFill{};
  shared_ptr<bool> countryFill{};
  shared_ptr<CheckLoaFillResponseBodyDataErrorMsgs> errorMsgs{};
  shared_ptr<bool> materialNameFill{};
  shared_ptr<bool> nationalityFill{};
  shared_ptr<bool> stampFill{};
  shared_ptr<string> templateUrl{};
  shared_ptr<string> tips{};
  shared_ptr<bool> tradeMarkNameFill{};

  CheckLoaFillResponseBodyData() {}

  explicit CheckLoaFillResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressFill) {
      res["AddressFill"] = boost::any(*addressFill);
    }
    if (countryFill) {
      res["CountryFill"] = boost::any(*countryFill);
    }
    if (errorMsgs) {
      res["ErrorMsgs"] = errorMsgs ? boost::any(errorMsgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (materialNameFill) {
      res["MaterialNameFill"] = boost::any(*materialNameFill);
    }
    if (nationalityFill) {
      res["NationalityFill"] = boost::any(*nationalityFill);
    }
    if (stampFill) {
      res["StampFill"] = boost::any(*stampFill);
    }
    if (templateUrl) {
      res["TemplateUrl"] = boost::any(*templateUrl);
    }
    if (tips) {
      res["Tips"] = boost::any(*tips);
    }
    if (tradeMarkNameFill) {
      res["TradeMarkNameFill"] = boost::any(*tradeMarkNameFill);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressFill") != m.end() && !m["AddressFill"].empty()) {
      addressFill = make_shared<bool>(boost::any_cast<bool>(m["AddressFill"]));
    }
    if (m.find("CountryFill") != m.end() && !m["CountryFill"].empty()) {
      countryFill = make_shared<bool>(boost::any_cast<bool>(m["CountryFill"]));
    }
    if (m.find("ErrorMsgs") != m.end() && !m["ErrorMsgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorMsgs"].type()) {
        CheckLoaFillResponseBodyDataErrorMsgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorMsgs"]));
        errorMsgs = make_shared<CheckLoaFillResponseBodyDataErrorMsgs>(model1);
      }
    }
    if (m.find("MaterialNameFill") != m.end() && !m["MaterialNameFill"].empty()) {
      materialNameFill = make_shared<bool>(boost::any_cast<bool>(m["MaterialNameFill"]));
    }
    if (m.find("NationalityFill") != m.end() && !m["NationalityFill"].empty()) {
      nationalityFill = make_shared<bool>(boost::any_cast<bool>(m["NationalityFill"]));
    }
    if (m.find("StampFill") != m.end() && !m["StampFill"].empty()) {
      stampFill = make_shared<bool>(boost::any_cast<bool>(m["StampFill"]));
    }
    if (m.find("TemplateUrl") != m.end() && !m["TemplateUrl"].empty()) {
      templateUrl = make_shared<string>(boost::any_cast<string>(m["TemplateUrl"]));
    }
    if (m.find("Tips") != m.end() && !m["Tips"].empty()) {
      tips = make_shared<string>(boost::any_cast<string>(m["Tips"]));
    }
    if (m.find("TradeMarkNameFill") != m.end() && !m["TradeMarkNameFill"].empty()) {
      tradeMarkNameFill = make_shared<bool>(boost::any_cast<bool>(m["TradeMarkNameFill"]));
    }
  }


  virtual ~CheckLoaFillResponseBodyData() = default;
};
class CheckLoaFillResponseBody : public Darabonba::Model {
public:
  shared_ptr<CheckLoaFillResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CheckLoaFillResponseBody() {}

  explicit CheckLoaFillResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CheckLoaFillResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CheckLoaFillResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckLoaFillResponseBody() = default;
};
class CheckLoaFillResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckLoaFillResponseBody> body{};

  CheckLoaFillResponse() {}

  explicit CheckLoaFillResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckLoaFillResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckLoaFillResponseBody>(model1);
      }
    }
  }


  virtual ~CheckLoaFillResponse() = default;
};
class CheckTrademarkIconRequest : public Darabonba::Model {
public:
  shared_ptr<long> eventSceneType{};
  shared_ptr<string> trademarkIconOssKey{};

  CheckTrademarkIconRequest() {}

  explicit CheckTrademarkIconRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventSceneType) {
      res["EventSceneType"] = boost::any(*eventSceneType);
    }
    if (trademarkIconOssKey) {
      res["TrademarkIconOssKey"] = boost::any(*trademarkIconOssKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventSceneType") != m.end() && !m["EventSceneType"].empty()) {
      eventSceneType = make_shared<long>(boost::any_cast<long>(m["EventSceneType"]));
    }
    if (m.find("TrademarkIconOssKey") != m.end() && !m["TrademarkIconOssKey"].empty()) {
      trademarkIconOssKey = make_shared<string>(boost::any_cast<string>(m["TrademarkIconOssKey"]));
    }
  }


  virtual ~CheckTrademarkIconRequest() = default;
};
class CheckTrademarkIconResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CheckTrademarkIconResponseBody() {}

  explicit CheckTrademarkIconResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CheckTrademarkIconResponseBody() = default;
};
class CheckTrademarkIconResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckTrademarkIconResponseBody> body{};

  CheckTrademarkIconResponse() {}

  explicit CheckTrademarkIconResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckTrademarkIconResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckTrademarkIconResponseBody>(model1);
      }
    }
  }


  virtual ~CheckTrademarkIconResponse() = default;
};
class CheckTrademarkOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> agreementId{};
  shared_ptr<string> bizId{};
  shared_ptr<string> channel{};
  shared_ptr<bool> isBlackIcon{};
  shared_ptr<string> loaOssKey{};
  shared_ptr<string> logoGoodsId{};
  shared_ptr<string> materialId{};
  shared_ptr<string> orderData{};
  shared_ptr<string> partnerCode{};
  shared_ptr<string> phoneNum{};
  shared_ptr<string> realUserName{};
  shared_ptr<string> registerName{};
  shared_ptr<string> registerNumber{};
  shared_ptr<string> renewInfoId{};
  shared_ptr<string> rootCode{};
  shared_ptr<string> tmComment{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNameType{};
  shared_ptr<long> type{};
  shared_ptr<string> uid{};
  shared_ptr<long> userId{};

  CheckTrademarkOrderRequest() {}

  explicit CheckTrademarkOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementId) {
      res["AgreementId"] = boost::any(*agreementId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (isBlackIcon) {
      res["IsBlackIcon"] = boost::any(*isBlackIcon);
    }
    if (loaOssKey) {
      res["LoaOssKey"] = boost::any(*loaOssKey);
    }
    if (logoGoodsId) {
      res["LogoGoodsId"] = boost::any(*logoGoodsId);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (orderData) {
      res["OrderData"] = boost::any(*orderData);
    }
    if (partnerCode) {
      res["PartnerCode"] = boost::any(*partnerCode);
    }
    if (phoneNum) {
      res["PhoneNum"] = boost::any(*phoneNum);
    }
    if (realUserName) {
      res["RealUserName"] = boost::any(*realUserName);
    }
    if (registerName) {
      res["RegisterName"] = boost::any(*registerName);
    }
    if (registerNumber) {
      res["RegisterNumber"] = boost::any(*registerNumber);
    }
    if (renewInfoId) {
      res["RenewInfoId"] = boost::any(*renewInfoId);
    }
    if (rootCode) {
      res["RootCode"] = boost::any(*rootCode);
    }
    if (tmComment) {
      res["TmComment"] = boost::any(*tmComment);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNameType) {
      res["TmNameType"] = boost::any(*tmNameType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementId") != m.end() && !m["AgreementId"].empty()) {
      agreementId = make_shared<string>(boost::any_cast<string>(m["AgreementId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("IsBlackIcon") != m.end() && !m["IsBlackIcon"].empty()) {
      isBlackIcon = make_shared<bool>(boost::any_cast<bool>(m["IsBlackIcon"]));
    }
    if (m.find("LoaOssKey") != m.end() && !m["LoaOssKey"].empty()) {
      loaOssKey = make_shared<string>(boost::any_cast<string>(m["LoaOssKey"]));
    }
    if (m.find("LogoGoodsId") != m.end() && !m["LogoGoodsId"].empty()) {
      logoGoodsId = make_shared<string>(boost::any_cast<string>(m["LogoGoodsId"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("OrderData") != m.end() && !m["OrderData"].empty()) {
      orderData = make_shared<string>(boost::any_cast<string>(m["OrderData"]));
    }
    if (m.find("PartnerCode") != m.end() && !m["PartnerCode"].empty()) {
      partnerCode = make_shared<string>(boost::any_cast<string>(m["PartnerCode"]));
    }
    if (m.find("PhoneNum") != m.end() && !m["PhoneNum"].empty()) {
      phoneNum = make_shared<string>(boost::any_cast<string>(m["PhoneNum"]));
    }
    if (m.find("RealUserName") != m.end() && !m["RealUserName"].empty()) {
      realUserName = make_shared<string>(boost::any_cast<string>(m["RealUserName"]));
    }
    if (m.find("RegisterName") != m.end() && !m["RegisterName"].empty()) {
      registerName = make_shared<string>(boost::any_cast<string>(m["RegisterName"]));
    }
    if (m.find("RegisterNumber") != m.end() && !m["RegisterNumber"].empty()) {
      registerNumber = make_shared<string>(boost::any_cast<string>(m["RegisterNumber"]));
    }
    if (m.find("RenewInfoId") != m.end() && !m["RenewInfoId"].empty()) {
      renewInfoId = make_shared<string>(boost::any_cast<string>(m["RenewInfoId"]));
    }
    if (m.find("RootCode") != m.end() && !m["RootCode"].empty()) {
      rootCode = make_shared<string>(boost::any_cast<string>(m["RootCode"]));
    }
    if (m.find("TmComment") != m.end() && !m["TmComment"].empty()) {
      tmComment = make_shared<string>(boost::any_cast<string>(m["TmComment"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNameType") != m.end() && !m["TmNameType"].empty()) {
      tmNameType = make_shared<string>(boost::any_cast<string>(m["TmNameType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~CheckTrademarkOrderRequest() = default;
};
class CheckTrademarkOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CheckTrademarkOrderResponseBody() {}

  explicit CheckTrademarkOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CheckTrademarkOrderResponseBody() = default;
};
class CheckTrademarkOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckTrademarkOrderResponseBody> body{};

  CheckTrademarkOrderResponse() {}

  explicit CheckTrademarkOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckTrademarkOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckTrademarkOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CheckTrademarkOrderResponse() = default;
};
class CombineLoaRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> applicantType{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhone{};
  shared_ptr<string> contactPostcode{};
  shared_ptr<string> materialId{};
  shared_ptr<string> materialName{};
  shared_ptr<string> nationality{};
  shared_ptr<string> personalType{};
  shared_ptr<long> principalName{};
  shared_ptr<string> tmNumber{};
  shared_ptr<string> tmProduceType{};
  shared_ptr<string> trademarkName{};

  CombineLoaRequest() {}

  explicit CombineLoaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (applicantType) {
      res["ApplicantType"] = boost::any(*applicantType);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactPhone) {
      res["ContactPhone"] = boost::any(*contactPhone);
    }
    if (contactPostcode) {
      res["ContactPostcode"] = boost::any(*contactPostcode);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (materialName) {
      res["MaterialName"] = boost::any(*materialName);
    }
    if (nationality) {
      res["Nationality"] = boost::any(*nationality);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (tmProduceType) {
      res["TmProduceType"] = boost::any(*tmProduceType);
    }
    if (trademarkName) {
      res["TrademarkName"] = boost::any(*trademarkName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("ApplicantType") != m.end() && !m["ApplicantType"].empty()) {
      applicantType = make_shared<string>(boost::any_cast<string>(m["ApplicantType"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactPhone") != m.end() && !m["ContactPhone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["ContactPhone"]));
    }
    if (m.find("ContactPostcode") != m.end() && !m["ContactPostcode"].empty()) {
      contactPostcode = make_shared<string>(boost::any_cast<string>(m["ContactPostcode"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("MaterialName") != m.end() && !m["MaterialName"].empty()) {
      materialName = make_shared<string>(boost::any_cast<string>(m["MaterialName"]));
    }
    if (m.find("Nationality") != m.end() && !m["Nationality"].empty()) {
      nationality = make_shared<string>(boost::any_cast<string>(m["Nationality"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<string>(boost::any_cast<string>(m["PersonalType"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("TmProduceType") != m.end() && !m["TmProduceType"].empty()) {
      tmProduceType = make_shared<string>(boost::any_cast<string>(m["TmProduceType"]));
    }
    if (m.find("TrademarkName") != m.end() && !m["TrademarkName"].empty()) {
      trademarkName = make_shared<string>(boost::any_cast<string>(m["TrademarkName"]));
    }
  }


  virtual ~CombineLoaRequest() = default;
};
class CombineLoaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateCombineUrl{};

  CombineLoaResponseBody() {}

  explicit CombineLoaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateCombineUrl) {
      res["TemplateCombineUrl"] = boost::any(*templateCombineUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateCombineUrl") != m.end() && !m["TemplateCombineUrl"].empty()) {
      templateCombineUrl = make_shared<string>(boost::any_cast<string>(m["TemplateCombineUrl"]));
    }
  }


  virtual ~CombineLoaResponseBody() = default;
};
class CombineLoaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CombineLoaResponseBody> body{};

  CombineLoaResponse() {}

  explicit CombineLoaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CombineLoaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CombineLoaResponseBody>(model1);
      }
    }
  }


  virtual ~CombineLoaResponse() = default;
};
class CombineWTSRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> contact{};
  shared_ptr<string> contactAddressPost{};
  shared_ptr<string> contactMobile{};
  shared_ptr<string> materialId{};
  shared_ptr<string> materialName{};
  shared_ptr<string> nationality{};
  shared_ptr<string> principalName{};
  shared_ptr<string> tmNum{};
  shared_ptr<string> tmProduceType{};
  shared_ptr<string> trademarkName{};
  shared_ptr<string> wtsType{};

  CombineWTSRequest() {}

  explicit CombineWTSRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (contact) {
      res["Contact"] = boost::any(*contact);
    }
    if (contactAddressPost) {
      res["ContactAddressPost"] = boost::any(*contactAddressPost);
    }
    if (contactMobile) {
      res["ContactMobile"] = boost::any(*contactMobile);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (materialName) {
      res["MaterialName"] = boost::any(*materialName);
    }
    if (nationality) {
      res["Nationality"] = boost::any(*nationality);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (tmNum) {
      res["TmNum"] = boost::any(*tmNum);
    }
    if (tmProduceType) {
      res["TmProduceType"] = boost::any(*tmProduceType);
    }
    if (trademarkName) {
      res["TrademarkName"] = boost::any(*trademarkName);
    }
    if (wtsType) {
      res["WtsType"] = boost::any(*wtsType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      contact = make_shared<string>(boost::any_cast<string>(m["Contact"]));
    }
    if (m.find("ContactAddressPost") != m.end() && !m["ContactAddressPost"].empty()) {
      contactAddressPost = make_shared<string>(boost::any_cast<string>(m["ContactAddressPost"]));
    }
    if (m.find("ContactMobile") != m.end() && !m["ContactMobile"].empty()) {
      contactMobile = make_shared<string>(boost::any_cast<string>(m["ContactMobile"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("MaterialName") != m.end() && !m["MaterialName"].empty()) {
      materialName = make_shared<string>(boost::any_cast<string>(m["MaterialName"]));
    }
    if (m.find("Nationality") != m.end() && !m["Nationality"].empty()) {
      nationality = make_shared<string>(boost::any_cast<string>(m["Nationality"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("TmNum") != m.end() && !m["TmNum"].empty()) {
      tmNum = make_shared<string>(boost::any_cast<string>(m["TmNum"]));
    }
    if (m.find("TmProduceType") != m.end() && !m["TmProduceType"].empty()) {
      tmProduceType = make_shared<string>(boost::any_cast<string>(m["TmProduceType"]));
    }
    if (m.find("TrademarkName") != m.end() && !m["TrademarkName"].empty()) {
      trademarkName = make_shared<string>(boost::any_cast<string>(m["TrademarkName"]));
    }
    if (m.find("WtsType") != m.end() && !m["WtsType"].empty()) {
      wtsType = make_shared<string>(boost::any_cast<string>(m["WtsType"]));
    }
  }


  virtual ~CombineWTSRequest() = default;
};
class CombineWTSResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateCombineUrl{};

  CombineWTSResponseBody() {}

  explicit CombineWTSResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateCombineUrl) {
      res["TemplateCombineUrl"] = boost::any(*templateCombineUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateCombineUrl") != m.end() && !m["TemplateCombineUrl"].empty()) {
      templateCombineUrl = make_shared<string>(boost::any_cast<string>(m["TemplateCombineUrl"]));
    }
  }


  virtual ~CombineWTSResponseBody() = default;
};
class CombineWTSResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CombineWTSResponseBody> body{};

  CombineWTSResponse() {}

  explicit CombineWTSResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CombineWTSResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CombineWTSResponseBody>(model1);
      }
    }
  }


  virtual ~CombineWTSResponse() = default;
};
class ComplementIntentionUserIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunKp{};
  shared_ptr<string> bid{};
  shared_ptr<string> bizId{};
  shared_ptr<long> callerParentId{};
  shared_ptr<string> callerType{};
  shared_ptr<string> complementUserId{};
  shared_ptr<long> type{};

  ComplementIntentionUserIdRequest() {}

  explicit ComplementIntentionUserIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunKp) {
      res["AliyunKp"] = boost::any(*aliyunKp);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (callerParentId) {
      res["CallerParentId"] = boost::any(*callerParentId);
    }
    if (callerType) {
      res["CallerType"] = boost::any(*callerType);
    }
    if (complementUserId) {
      res["ComplementUserId"] = boost::any(*complementUserId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunKp") != m.end() && !m["AliyunKp"].empty()) {
      aliyunKp = make_shared<string>(boost::any_cast<string>(m["AliyunKp"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CallerParentId") != m.end() && !m["CallerParentId"].empty()) {
      callerParentId = make_shared<long>(boost::any_cast<long>(m["CallerParentId"]));
    }
    if (m.find("CallerType") != m.end() && !m["CallerType"].empty()) {
      callerType = make_shared<string>(boost::any_cast<string>(m["CallerType"]));
    }
    if (m.find("ComplementUserId") != m.end() && !m["ComplementUserId"].empty()) {
      complementUserId = make_shared<string>(boost::any_cast<string>(m["ComplementUserId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~ComplementIntentionUserIdRequest() = default;
};
class ComplementIntentionUserIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ComplementIntentionUserIdResponseBody() {}

  explicit ComplementIntentionUserIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ComplementIntentionUserIdResponseBody() = default;
};
class ComplementIntentionUserIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ComplementIntentionUserIdResponseBody> body{};

  ComplementIntentionUserIdResponse() {}

  explicit ComplementIntentionUserIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ComplementIntentionUserIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ComplementIntentionUserIdResponseBody>(model1);
      }
    }
  }


  virtual ~ComplementIntentionUserIdResponse() = default;
};
class ConfirmAdditionalMaterialRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> note{};

  ConfirmAdditionalMaterialRequest() {}

  explicit ConfirmAdditionalMaterialRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
  }


  virtual ~ConfirmAdditionalMaterialRequest() = default;
};
class ConfirmAdditionalMaterialResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ConfirmAdditionalMaterialResponseBody() {}

  explicit ConfirmAdditionalMaterialResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ConfirmAdditionalMaterialResponseBody() = default;
};
class ConfirmAdditionalMaterialResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfirmAdditionalMaterialResponseBody> body{};

  ConfirmAdditionalMaterialResponse() {}

  explicit ConfirmAdditionalMaterialResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfirmAdditionalMaterialResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfirmAdditionalMaterialResponseBody>(model1);
      }
    }
  }


  virtual ~ConfirmAdditionalMaterialResponse() = default;
};
class ConfirmApplicantRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> note{};

  ConfirmApplicantRequest() {}

  explicit ConfirmApplicantRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
  }


  virtual ~ConfirmApplicantRequest() = default;
};
class ConfirmApplicantResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ConfirmApplicantResponseBody() {}

  explicit ConfirmApplicantResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ConfirmApplicantResponseBody() = default;
};
class ConfirmApplicantResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfirmApplicantResponseBody> body{};

  ConfirmApplicantResponse() {}

  explicit ConfirmApplicantResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfirmApplicantResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfirmApplicantResponseBody>(model1);
      }
    }
  }


  virtual ~ConfirmApplicantResponse() = default;
};
class ConfirmDissentOriginalRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactCity{};
  shared_ptr<string> contactCounty{};
  shared_ptr<string> contactDistrict{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactNumber{};
  shared_ptr<string> contactProvince{};
  shared_ptr<string> operateType{};

  ConfirmDissentOriginalRequest() {}

  explicit ConfirmDissentOriginalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactCity) {
      res["ContactCity"] = boost::any(*contactCity);
    }
    if (contactCounty) {
      res["ContactCounty"] = boost::any(*contactCounty);
    }
    if (contactDistrict) {
      res["ContactDistrict"] = boost::any(*contactDistrict);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactNumber) {
      res["ContactNumber"] = boost::any(*contactNumber);
    }
    if (contactProvince) {
      res["ContactProvince"] = boost::any(*contactProvince);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactCity") != m.end() && !m["ContactCity"].empty()) {
      contactCity = make_shared<string>(boost::any_cast<string>(m["ContactCity"]));
    }
    if (m.find("ContactCounty") != m.end() && !m["ContactCounty"].empty()) {
      contactCounty = make_shared<string>(boost::any_cast<string>(m["ContactCounty"]));
    }
    if (m.find("ContactDistrict") != m.end() && !m["ContactDistrict"].empty()) {
      contactDistrict = make_shared<string>(boost::any_cast<string>(m["ContactDistrict"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactNumber") != m.end() && !m["ContactNumber"].empty()) {
      contactNumber = make_shared<string>(boost::any_cast<string>(m["ContactNumber"]));
    }
    if (m.find("ContactProvince") != m.end() && !m["ContactProvince"].empty()) {
      contactProvince = make_shared<string>(boost::any_cast<string>(m["ContactProvince"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
  }


  virtual ~ConfirmDissentOriginalRequest() = default;
};
class ConfirmDissentOriginalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfirmDissentOriginalResponseBody() {}

  explicit ConfirmDissentOriginalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfirmDissentOriginalResponseBody() = default;
};
class ConfirmDissentOriginalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfirmDissentOriginalResponseBody> body{};

  ConfirmDissentOriginalResponse() {}

  explicit ConfirmDissentOriginalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfirmDissentOriginalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfirmDissentOriginalResponseBody>(model1);
      }
    }
  }


  virtual ~ConfirmDissentOriginalResponse() = default;
};
class ConvertImageToGrayRequest : public Darabonba::Model {
public:
  shared_ptr<string> ossKey{};

  ConvertImageToGrayRequest() {}

  explicit ConvertImageToGrayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["OssKey"]));
    }
  }


  virtual ~ConvertImageToGrayRequest() = default;
};
class ConvertImageToGrayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> signatureUrl{};

  ConvertImageToGrayResponseBody() {}

  explicit ConvertImageToGrayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signatureUrl) {
      res["SignatureUrl"] = boost::any(*signatureUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SignatureUrl") != m.end() && !m["SignatureUrl"].empty()) {
      signatureUrl = make_shared<string>(boost::any_cast<string>(m["SignatureUrl"]));
    }
  }


  virtual ~ConvertImageToGrayResponseBody() = default;
};
class ConvertImageToGrayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConvertImageToGrayResponseBody> body{};

  ConvertImageToGrayResponse() {}

  explicit ConvertImageToGrayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConvertImageToGrayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConvertImageToGrayResponseBody>(model1);
      }
    }
  }


  virtual ~ConvertImageToGrayResponse() = default;
};
class CopyApplicantRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  CopyApplicantRequest() {}

  explicit CopyApplicantRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~CopyApplicantRequest() = default;
};
class CopyApplicantResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CopyApplicantResponseBody() {}

  explicit CopyApplicantResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopyApplicantResponseBody() = default;
};
class CopyApplicantResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyApplicantResponseBody> body{};

  CopyApplicantResponse() {}

  explicit CopyApplicantResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyApplicantResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyApplicantResponseBody>(model1);
      }
    }
  }


  virtual ~CopyApplicantResponse() = default;
};
class CreateIntentionOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<string> intentionBizId{};

  CreateIntentionOrderRequest() {}

  explicit CreateIntentionOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (intentionBizId) {
      res["IntentionBizId"] = boost::any(*intentionBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("IntentionBizId") != m.end() && !m["IntentionBizId"].empty()) {
      intentionBizId = make_shared<string>(boost::any_cast<string>(m["IntentionBizId"]));
    }
  }


  virtual ~CreateIntentionOrderRequest() = default;
};
class CreateIntentionOrderResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> orderIds{};

  CreateIntentionOrderResponseBodyData() {}

  explicit CreateIntentionOrderResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateIntentionOrderResponseBodyData() = default;
};
class CreateIntentionOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateIntentionOrderResponseBodyData> data{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateIntentionOrderResponseBody() {}

  explicit CreateIntentionOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateIntentionOrderResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateIntentionOrderResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateIntentionOrderResponseBody() = default;
};
class CreateIntentionOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIntentionOrderResponseBody> body{};

  CreateIntentionOrderResponse() {}

  explicit CreateIntentionOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIntentionOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIntentionOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIntentionOrderResponse() = default;
};
class CreateIntentionOrderGeneratingPayRequest : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<string> intentionBizId{};
  shared_ptr<string> paymentCallback{};

  CreateIntentionOrderGeneratingPayRequest() {}

  explicit CreateIntentionOrderGeneratingPayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (intentionBizId) {
      res["IntentionBizId"] = boost::any(*intentionBizId);
    }
    if (paymentCallback) {
      res["PaymentCallback"] = boost::any(*paymentCallback);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("IntentionBizId") != m.end() && !m["IntentionBizId"].empty()) {
      intentionBizId = make_shared<string>(boost::any_cast<string>(m["IntentionBizId"]));
    }
    if (m.find("PaymentCallback") != m.end() && !m["PaymentCallback"].empty()) {
      paymentCallback = make_shared<string>(boost::any_cast<string>(m["PaymentCallback"]));
    }
  }


  virtual ~CreateIntentionOrderGeneratingPayRequest() = default;
};
class CreateIntentionOrderGeneratingPayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<vector<long>> orderIds{};
  shared_ptr<string> payUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateIntentionOrderGeneratingPayResponseBody() {}

  explicit CreateIntentionOrderGeneratingPayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    if (payUrl) {
      res["PayUrl"] = boost::any(*payUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      orderIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("PayUrl") != m.end() && !m["PayUrl"].empty()) {
      payUrl = make_shared<string>(boost::any_cast<string>(m["PayUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateIntentionOrderGeneratingPayResponseBody() = default;
};
class CreateIntentionOrderGeneratingPayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIntentionOrderGeneratingPayResponseBody> body{};

  CreateIntentionOrderGeneratingPayResponse() {}

  explicit CreateIntentionOrderGeneratingPayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIntentionOrderGeneratingPayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIntentionOrderGeneratingPayResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIntentionOrderGeneratingPayResponse() = default;
};
class CreateTrademarkOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> agreementId{};
  shared_ptr<string> bigDipperSource{};
  shared_ptr<string> bizId{};
  shared_ptr<string> channel{};
  shared_ptr<bool> isBlackIcon{};
  shared_ptr<string> legalNoticeKey{};
  shared_ptr<string> loaOssKey{};
  shared_ptr<string> materialId{};
  shared_ptr<string> orderData{};
  shared_ptr<string> partnerCode{};
  shared_ptr<string> phoneNum{};
  shared_ptr<long> principalName{};
  shared_ptr<string> realUserName{};
  shared_ptr<string> registerName{};
  shared_ptr<string> registerNumber{};
  shared_ptr<string> renewInfoId{};
  shared_ptr<string> rootCode{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> tmComment{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNameType{};
  shared_ptr<long> type{};
  shared_ptr<string> ua{};
  shared_ptr<string> uid{};
  shared_ptr<long> userId{};

  CreateTrademarkOrderRequest() {}

  explicit CreateTrademarkOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementId) {
      res["AgreementId"] = boost::any(*agreementId);
    }
    if (bigDipperSource) {
      res["BigDipperSource"] = boost::any(*bigDipperSource);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (isBlackIcon) {
      res["IsBlackIcon"] = boost::any(*isBlackIcon);
    }
    if (legalNoticeKey) {
      res["LegalNoticeKey"] = boost::any(*legalNoticeKey);
    }
    if (loaOssKey) {
      res["LoaOssKey"] = boost::any(*loaOssKey);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (orderData) {
      res["OrderData"] = boost::any(*orderData);
    }
    if (partnerCode) {
      res["PartnerCode"] = boost::any(*partnerCode);
    }
    if (phoneNum) {
      res["PhoneNum"] = boost::any(*phoneNum);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (realUserName) {
      res["RealUserName"] = boost::any(*realUserName);
    }
    if (registerName) {
      res["RegisterName"] = boost::any(*registerName);
    }
    if (registerNumber) {
      res["RegisterNumber"] = boost::any(*registerNumber);
    }
    if (renewInfoId) {
      res["RenewInfoId"] = boost::any(*renewInfoId);
    }
    if (rootCode) {
      res["RootCode"] = boost::any(*rootCode);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (tmComment) {
      res["TmComment"] = boost::any(*tmComment);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNameType) {
      res["TmNameType"] = boost::any(*tmNameType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (ua) {
      res["Ua"] = boost::any(*ua);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementId") != m.end() && !m["AgreementId"].empty()) {
      agreementId = make_shared<string>(boost::any_cast<string>(m["AgreementId"]));
    }
    if (m.find("BigDipperSource") != m.end() && !m["BigDipperSource"].empty()) {
      bigDipperSource = make_shared<string>(boost::any_cast<string>(m["BigDipperSource"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("IsBlackIcon") != m.end() && !m["IsBlackIcon"].empty()) {
      isBlackIcon = make_shared<bool>(boost::any_cast<bool>(m["IsBlackIcon"]));
    }
    if (m.find("LegalNoticeKey") != m.end() && !m["LegalNoticeKey"].empty()) {
      legalNoticeKey = make_shared<string>(boost::any_cast<string>(m["LegalNoticeKey"]));
    }
    if (m.find("LoaOssKey") != m.end() && !m["LoaOssKey"].empty()) {
      loaOssKey = make_shared<string>(boost::any_cast<string>(m["LoaOssKey"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("OrderData") != m.end() && !m["OrderData"].empty()) {
      orderData = make_shared<string>(boost::any_cast<string>(m["OrderData"]));
    }
    if (m.find("PartnerCode") != m.end() && !m["PartnerCode"].empty()) {
      partnerCode = make_shared<string>(boost::any_cast<string>(m["PartnerCode"]));
    }
    if (m.find("PhoneNum") != m.end() && !m["PhoneNum"].empty()) {
      phoneNum = make_shared<string>(boost::any_cast<string>(m["PhoneNum"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("RealUserName") != m.end() && !m["RealUserName"].empty()) {
      realUserName = make_shared<string>(boost::any_cast<string>(m["RealUserName"]));
    }
    if (m.find("RegisterName") != m.end() && !m["RegisterName"].empty()) {
      registerName = make_shared<string>(boost::any_cast<string>(m["RegisterName"]));
    }
    if (m.find("RegisterNumber") != m.end() && !m["RegisterNumber"].empty()) {
      registerNumber = make_shared<string>(boost::any_cast<string>(m["RegisterNumber"]));
    }
    if (m.find("RenewInfoId") != m.end() && !m["RenewInfoId"].empty()) {
      renewInfoId = make_shared<string>(boost::any_cast<string>(m["RenewInfoId"]));
    }
    if (m.find("RootCode") != m.end() && !m["RootCode"].empty()) {
      rootCode = make_shared<string>(boost::any_cast<string>(m["RootCode"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TmComment") != m.end() && !m["TmComment"].empty()) {
      tmComment = make_shared<string>(boost::any_cast<string>(m["TmComment"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNameType") != m.end() && !m["TmNameType"].empty()) {
      tmNameType = make_shared<string>(boost::any_cast<string>(m["TmNameType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Ua") != m.end() && !m["Ua"].empty()) {
      ua = make_shared<string>(boost::any_cast<string>(m["Ua"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~CreateTrademarkOrderRequest() = default;
};
class CreateTrademarkOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<long> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateTrademarkOrderResponseBody() {}

  explicit CreateTrademarkOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateTrademarkOrderResponseBody() = default;
};
class CreateTrademarkOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTrademarkOrderResponseBody> body{};

  CreateTrademarkOrderResponse() {}

  explicit CreateTrademarkOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTrademarkOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTrademarkOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTrademarkOrderResponse() = default;
};
class DeleteMaterialRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteMaterialRequest() {}

  explicit DeleteMaterialRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteMaterialRequest() = default;
};
class DeleteMaterialResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteMaterialResponseBody() {}

  explicit DeleteMaterialResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMaterialResponseBody() = default;
};
class DeleteMaterialResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMaterialResponseBody> body{};

  DeleteMaterialResponse() {}

  explicit DeleteMaterialResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMaterialResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMaterialResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMaterialResponse() = default;
};
class DeleteTmMonitorRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteTmMonitorRuleRequest() {}

  explicit DeleteTmMonitorRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteTmMonitorRuleRequest() = default;
};
class DeleteTmMonitorRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteTmMonitorRuleResponseBody() {}

  explicit DeleteTmMonitorRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteTmMonitorRuleResponseBody() = default;
};
class DeleteTmMonitorRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTmMonitorRuleResponseBody> body{};

  DeleteTmMonitorRuleResponse() {}

  explicit DeleteTmMonitorRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTmMonitorRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTmMonitorRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTmMonitorRuleResponse() = default;
};
class DeleteTrademarkApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};

  DeleteTrademarkApplicationRequest() {}

  explicit DeleteTrademarkApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~DeleteTrademarkApplicationRequest() = default;
};
class DeleteTrademarkApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteTrademarkApplicationResponseBody() {}

  explicit DeleteTrademarkApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteTrademarkApplicationResponseBody() = default;
};
class DeleteTrademarkApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTrademarkApplicationResponseBody> body{};

  DeleteTrademarkApplicationResponse() {}

  explicit DeleteTrademarkApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTrademarkApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTrademarkApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTrademarkApplicationResponse() = default;
};
class DenySupplementRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DenySupplementRequest() {}

  explicit DenySupplementRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DenySupplementRequest() = default;
};
class DenySupplementResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DenySupplementResponseBody() {}

  explicit DenySupplementResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DenySupplementResponseBody() = default;
};
class DenySupplementResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DenySupplementResponseBody> body{};

  DenySupplementResponse() {}

  explicit DenySupplementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DenySupplementResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DenySupplementResponseBody>(model1);
      }
    }
  }


  virtual ~DenySupplementResponse() = default;
};
class DescirbeCombineTrademarkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> accurateMatch{};
  shared_ptr<string> classification{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> products{};
  shared_ptr<string> registrationNumber{};
  shared_ptr<string> similarGroups{};

  DescirbeCombineTrademarkRequest() {}

  explicit DescirbeCombineTrademarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accurateMatch) {
      res["AccurateMatch"] = boost::any(*accurateMatch);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (products) {
      res["Products"] = boost::any(*products);
    }
    if (registrationNumber) {
      res["RegistrationNumber"] = boost::any(*registrationNumber);
    }
    if (similarGroups) {
      res["SimilarGroups"] = boost::any(*similarGroups);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccurateMatch") != m.end() && !m["AccurateMatch"].empty()) {
      accurateMatch = make_shared<bool>(boost::any_cast<bool>(m["AccurateMatch"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Products") != m.end() && !m["Products"].empty()) {
      products = make_shared<string>(boost::any_cast<string>(m["Products"]));
    }
    if (m.find("RegistrationNumber") != m.end() && !m["RegistrationNumber"].empty()) {
      registrationNumber = make_shared<string>(boost::any_cast<string>(m["RegistrationNumber"]));
    }
    if (m.find("SimilarGroups") != m.end() && !m["SimilarGroups"].empty()) {
      similarGroups = make_shared<string>(boost::any_cast<string>(m["SimilarGroups"]));
    }
  }


  virtual ~DescirbeCombineTrademarkRequest() = default;
};
class DescirbeCombineTrademarkResponseBodyDataAnnouncementList : public Darabonba::Model {
public:
  shared_ptr<string> annDate{};
  shared_ptr<string> annNumber{};
  shared_ptr<string> annTypeCode{};
  shared_ptr<string> annTypeName{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> originalImageUrl{};

  DescirbeCombineTrademarkResponseBodyDataAnnouncementList() {}

  explicit DescirbeCombineTrademarkResponseBodyDataAnnouncementList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annDate) {
      res["AnnDate"] = boost::any(*annDate);
    }
    if (annNumber) {
      res["AnnNumber"] = boost::any(*annNumber);
    }
    if (annTypeCode) {
      res["AnnTypeCode"] = boost::any(*annTypeCode);
    }
    if (annTypeName) {
      res["AnnTypeName"] = boost::any(*annTypeName);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (originalImageUrl) {
      res["OriginalImageUrl"] = boost::any(*originalImageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnDate") != m.end() && !m["AnnDate"].empty()) {
      annDate = make_shared<string>(boost::any_cast<string>(m["AnnDate"]));
    }
    if (m.find("AnnNumber") != m.end() && !m["AnnNumber"].empty()) {
      annNumber = make_shared<string>(boost::any_cast<string>(m["AnnNumber"]));
    }
    if (m.find("AnnTypeCode") != m.end() && !m["AnnTypeCode"].empty()) {
      annTypeCode = make_shared<string>(boost::any_cast<string>(m["AnnTypeCode"]));
    }
    if (m.find("AnnTypeName") != m.end() && !m["AnnTypeName"].empty()) {
      annTypeName = make_shared<string>(boost::any_cast<string>(m["AnnTypeName"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("OriginalImageUrl") != m.end() && !m["OriginalImageUrl"].empty()) {
      originalImageUrl = make_shared<string>(boost::any_cast<string>(m["OriginalImageUrl"]));
    }
  }


  virtual ~DescirbeCombineTrademarkResponseBodyDataAnnouncementList() = default;
};
class DescirbeCombineTrademarkResponseBodyDataProcedures : public Darabonba::Model {
public:
  shared_ptr<string> procedureCode{};
  shared_ptr<string> procedureDate{};
  shared_ptr<string> procedureName{};
  shared_ptr<string> procedureResult{};
  shared_ptr<string> procedureStep{};

  DescirbeCombineTrademarkResponseBodyDataProcedures() {}

  explicit DescirbeCombineTrademarkResponseBodyDataProcedures(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (procedureCode) {
      res["ProcedureCode"] = boost::any(*procedureCode);
    }
    if (procedureDate) {
      res["ProcedureDate"] = boost::any(*procedureDate);
    }
    if (procedureName) {
      res["ProcedureName"] = boost::any(*procedureName);
    }
    if (procedureResult) {
      res["ProcedureResult"] = boost::any(*procedureResult);
    }
    if (procedureStep) {
      res["ProcedureStep"] = boost::any(*procedureStep);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProcedureCode") != m.end() && !m["ProcedureCode"].empty()) {
      procedureCode = make_shared<string>(boost::any_cast<string>(m["ProcedureCode"]));
    }
    if (m.find("ProcedureDate") != m.end() && !m["ProcedureDate"].empty()) {
      procedureDate = make_shared<string>(boost::any_cast<string>(m["ProcedureDate"]));
    }
    if (m.find("ProcedureName") != m.end() && !m["ProcedureName"].empty()) {
      procedureName = make_shared<string>(boost::any_cast<string>(m["ProcedureName"]));
    }
    if (m.find("ProcedureResult") != m.end() && !m["ProcedureResult"].empty()) {
      procedureResult = make_shared<string>(boost::any_cast<string>(m["ProcedureResult"]));
    }
    if (m.find("ProcedureStep") != m.end() && !m["ProcedureStep"].empty()) {
      procedureStep = make_shared<string>(boost::any_cast<string>(m["ProcedureStep"]));
    }
  }


  virtual ~DescirbeCombineTrademarkResponseBodyDataProcedures() = default;
};
class DescirbeCombineTrademarkResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> agency{};
  shared_ptr<vector<DescirbeCombineTrademarkResponseBodyDataAnnouncementList>> announcementList{};
  shared_ptr<string> applyDate{};
  shared_ptr<string> classification{};
  shared_ptr<string> exclusiveDateLimit{};
  shared_ptr<string> firstAnnoNumber{};
  shared_ptr<string> firstAnnoType{};
  shared_ptr<string> image{};
  shared_ptr<string> indexId{};
  shared_ptr<string> intlRegDate{};
  shared_ptr<string> lastProcedureStatus{};
  shared_ptr<string> lawFinalStatus{};
  shared_ptr<string> name{};
  shared_ptr<long> onSale{};
  shared_ptr<string> ownerAddress{};
  shared_ptr<string> ownerEnAddress{};
  shared_ptr<string> ownerEnName{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> preAnnDate{};
  shared_ptr<string> preAnnNumber{};
  shared_ptr<string> priorityDate{};
  shared_ptr<vector<DescirbeCombineTrademarkResponseBodyDataProcedures>> procedures{};
  shared_ptr<string> productDescription{};
  shared_ptr<string> regAnnDate{};
  shared_ptr<string> regAnnNumber{};
  shared_ptr<string> registrationNumber{};
  shared_ptr<string> registrationType{};
  shared_ptr<string> secondAnnoNumber{};
  shared_ptr<string> secondAnnoType{};
  shared_ptr<string> share{};
  shared_ptr<string> similarGroup{};
  shared_ptr<string> status{};
  shared_ptr<string> subsequentDesignationDate{};

  DescirbeCombineTrademarkResponseBodyData() {}

  explicit DescirbeCombineTrademarkResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agency) {
      res["Agency"] = boost::any(*agency);
    }
    if (announcementList) {
      vector<boost::any> temp1;
      for(auto item1:*announcementList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnouncementList"] = boost::any(temp1);
    }
    if (applyDate) {
      res["ApplyDate"] = boost::any(*applyDate);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (exclusiveDateLimit) {
      res["ExclusiveDateLimit"] = boost::any(*exclusiveDateLimit);
    }
    if (firstAnnoNumber) {
      res["FirstAnnoNumber"] = boost::any(*firstAnnoNumber);
    }
    if (firstAnnoType) {
      res["FirstAnnoType"] = boost::any(*firstAnnoType);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (indexId) {
      res["IndexId"] = boost::any(*indexId);
    }
    if (intlRegDate) {
      res["IntlRegDate"] = boost::any(*intlRegDate);
    }
    if (lastProcedureStatus) {
      res["LastProcedureStatus"] = boost::any(*lastProcedureStatus);
    }
    if (lawFinalStatus) {
      res["LawFinalStatus"] = boost::any(*lawFinalStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (onSale) {
      res["OnSale"] = boost::any(*onSale);
    }
    if (ownerAddress) {
      res["OwnerAddress"] = boost::any(*ownerAddress);
    }
    if (ownerEnAddress) {
      res["OwnerEnAddress"] = boost::any(*ownerEnAddress);
    }
    if (ownerEnName) {
      res["OwnerEnName"] = boost::any(*ownerEnName);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (preAnnDate) {
      res["PreAnnDate"] = boost::any(*preAnnDate);
    }
    if (preAnnNumber) {
      res["PreAnnNumber"] = boost::any(*preAnnNumber);
    }
    if (priorityDate) {
      res["PriorityDate"] = boost::any(*priorityDate);
    }
    if (procedures) {
      vector<boost::any> temp1;
      for(auto item1:*procedures){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Procedures"] = boost::any(temp1);
    }
    if (productDescription) {
      res["ProductDescription"] = boost::any(*productDescription);
    }
    if (regAnnDate) {
      res["RegAnnDate"] = boost::any(*regAnnDate);
    }
    if (regAnnNumber) {
      res["RegAnnNumber"] = boost::any(*regAnnNumber);
    }
    if (registrationNumber) {
      res["RegistrationNumber"] = boost::any(*registrationNumber);
    }
    if (registrationType) {
      res["RegistrationType"] = boost::any(*registrationType);
    }
    if (secondAnnoNumber) {
      res["SecondAnnoNumber"] = boost::any(*secondAnnoNumber);
    }
    if (secondAnnoType) {
      res["SecondAnnoType"] = boost::any(*secondAnnoType);
    }
    if (share) {
      res["Share"] = boost::any(*share);
    }
    if (similarGroup) {
      res["SimilarGroup"] = boost::any(*similarGroup);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subsequentDesignationDate) {
      res["SubsequentDesignationDate"] = boost::any(*subsequentDesignationDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Agency") != m.end() && !m["Agency"].empty()) {
      agency = make_shared<string>(boost::any_cast<string>(m["Agency"]));
    }
    if (m.find("AnnouncementList") != m.end() && !m["AnnouncementList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnouncementList"].type()) {
        vector<DescirbeCombineTrademarkResponseBodyDataAnnouncementList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnouncementList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescirbeCombineTrademarkResponseBodyDataAnnouncementList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        announcementList = make_shared<vector<DescirbeCombineTrademarkResponseBodyDataAnnouncementList>>(expect1);
      }
    }
    if (m.find("ApplyDate") != m.end() && !m["ApplyDate"].empty()) {
      applyDate = make_shared<string>(boost::any_cast<string>(m["ApplyDate"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("ExclusiveDateLimit") != m.end() && !m["ExclusiveDateLimit"].empty()) {
      exclusiveDateLimit = make_shared<string>(boost::any_cast<string>(m["ExclusiveDateLimit"]));
    }
    if (m.find("FirstAnnoNumber") != m.end() && !m["FirstAnnoNumber"].empty()) {
      firstAnnoNumber = make_shared<string>(boost::any_cast<string>(m["FirstAnnoNumber"]));
    }
    if (m.find("FirstAnnoType") != m.end() && !m["FirstAnnoType"].empty()) {
      firstAnnoType = make_shared<string>(boost::any_cast<string>(m["FirstAnnoType"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("IndexId") != m.end() && !m["IndexId"].empty()) {
      indexId = make_shared<string>(boost::any_cast<string>(m["IndexId"]));
    }
    if (m.find("IntlRegDate") != m.end() && !m["IntlRegDate"].empty()) {
      intlRegDate = make_shared<string>(boost::any_cast<string>(m["IntlRegDate"]));
    }
    if (m.find("LastProcedureStatus") != m.end() && !m["LastProcedureStatus"].empty()) {
      lastProcedureStatus = make_shared<string>(boost::any_cast<string>(m["LastProcedureStatus"]));
    }
    if (m.find("LawFinalStatus") != m.end() && !m["LawFinalStatus"].empty()) {
      lawFinalStatus = make_shared<string>(boost::any_cast<string>(m["LawFinalStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OnSale") != m.end() && !m["OnSale"].empty()) {
      onSale = make_shared<long>(boost::any_cast<long>(m["OnSale"]));
    }
    if (m.find("OwnerAddress") != m.end() && !m["OwnerAddress"].empty()) {
      ownerAddress = make_shared<string>(boost::any_cast<string>(m["OwnerAddress"]));
    }
    if (m.find("OwnerEnAddress") != m.end() && !m["OwnerEnAddress"].empty()) {
      ownerEnAddress = make_shared<string>(boost::any_cast<string>(m["OwnerEnAddress"]));
    }
    if (m.find("OwnerEnName") != m.end() && !m["OwnerEnName"].empty()) {
      ownerEnName = make_shared<string>(boost::any_cast<string>(m["OwnerEnName"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("PreAnnDate") != m.end() && !m["PreAnnDate"].empty()) {
      preAnnDate = make_shared<string>(boost::any_cast<string>(m["PreAnnDate"]));
    }
    if (m.find("PreAnnNumber") != m.end() && !m["PreAnnNumber"].empty()) {
      preAnnNumber = make_shared<string>(boost::any_cast<string>(m["PreAnnNumber"]));
    }
    if (m.find("PriorityDate") != m.end() && !m["PriorityDate"].empty()) {
      priorityDate = make_shared<string>(boost::any_cast<string>(m["PriorityDate"]));
    }
    if (m.find("Procedures") != m.end() && !m["Procedures"].empty()) {
      if (typeid(vector<boost::any>) == m["Procedures"].type()) {
        vector<DescirbeCombineTrademarkResponseBodyDataProcedures> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Procedures"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescirbeCombineTrademarkResponseBodyDataProcedures model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        procedures = make_shared<vector<DescirbeCombineTrademarkResponseBodyDataProcedures>>(expect1);
      }
    }
    if (m.find("ProductDescription") != m.end() && !m["ProductDescription"].empty()) {
      productDescription = make_shared<string>(boost::any_cast<string>(m["ProductDescription"]));
    }
    if (m.find("RegAnnDate") != m.end() && !m["RegAnnDate"].empty()) {
      regAnnDate = make_shared<string>(boost::any_cast<string>(m["RegAnnDate"]));
    }
    if (m.find("RegAnnNumber") != m.end() && !m["RegAnnNumber"].empty()) {
      regAnnNumber = make_shared<string>(boost::any_cast<string>(m["RegAnnNumber"]));
    }
    if (m.find("RegistrationNumber") != m.end() && !m["RegistrationNumber"].empty()) {
      registrationNumber = make_shared<string>(boost::any_cast<string>(m["RegistrationNumber"]));
    }
    if (m.find("RegistrationType") != m.end() && !m["RegistrationType"].empty()) {
      registrationType = make_shared<string>(boost::any_cast<string>(m["RegistrationType"]));
    }
    if (m.find("SecondAnnoNumber") != m.end() && !m["SecondAnnoNumber"].empty()) {
      secondAnnoNumber = make_shared<string>(boost::any_cast<string>(m["SecondAnnoNumber"]));
    }
    if (m.find("SecondAnnoType") != m.end() && !m["SecondAnnoType"].empty()) {
      secondAnnoType = make_shared<string>(boost::any_cast<string>(m["SecondAnnoType"]));
    }
    if (m.find("Share") != m.end() && !m["Share"].empty()) {
      share = make_shared<string>(boost::any_cast<string>(m["Share"]));
    }
    if (m.find("SimilarGroup") != m.end() && !m["SimilarGroup"].empty()) {
      similarGroup = make_shared<string>(boost::any_cast<string>(m["SimilarGroup"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubsequentDesignationDate") != m.end() && !m["SubsequentDesignationDate"].empty()) {
      subsequentDesignationDate = make_shared<string>(boost::any_cast<string>(m["SubsequentDesignationDate"]));
    }
  }


  virtual ~DescirbeCombineTrademarkResponseBodyData() = default;
};
class DescirbeCombineTrademarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNumber{};
  shared_ptr<vector<DescirbeCombineTrademarkResponseBodyData>> data{};
  shared_ptr<bool> nextPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> prePage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNumber{};
  shared_ptr<long> totalPageNumber{};

  DescirbeCombineTrademarkResponseBody() {}

  explicit DescirbeCombineTrademarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNumber) {
      res["CurrentPageNumber"] = boost::any(*currentPageNumber);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (nextPage) {
      res["NextPage"] = boost::any(*nextPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prePage) {
      res["PrePage"] = boost::any(*prePage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNumber) {
      res["TotalItemNumber"] = boost::any(*totalItemNumber);
    }
    if (totalPageNumber) {
      res["TotalPageNumber"] = boost::any(*totalPageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNumber") != m.end() && !m["CurrentPageNumber"].empty()) {
      currentPageNumber = make_shared<long>(boost::any_cast<long>(m["CurrentPageNumber"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescirbeCombineTrademarkResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescirbeCombineTrademarkResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescirbeCombineTrademarkResponseBodyData>>(expect1);
      }
    }
    if (m.find("NextPage") != m.end() && !m["NextPage"].empty()) {
      nextPage = make_shared<bool>(boost::any_cast<bool>(m["NextPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PrePage") != m.end() && !m["PrePage"].empty()) {
      prePage = make_shared<bool>(boost::any_cast<bool>(m["PrePage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNumber") != m.end() && !m["TotalItemNumber"].empty()) {
      totalItemNumber = make_shared<long>(boost::any_cast<long>(m["TotalItemNumber"]));
    }
    if (m.find("TotalPageNumber") != m.end() && !m["TotalPageNumber"].empty()) {
      totalPageNumber = make_shared<long>(boost::any_cast<long>(m["TotalPageNumber"]));
    }
  }


  virtual ~DescirbeCombineTrademarkResponseBody() = default;
};
class DescirbeCombineTrademarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescirbeCombineTrademarkResponseBody> body{};

  DescirbeCombineTrademarkResponse() {}

  explicit DescirbeCombineTrademarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescirbeCombineTrademarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescirbeCombineTrademarkResponseBody>(model1);
      }
    }
  }


  virtual ~DescirbeCombineTrademarkResponse() = default;
};
class FillLogisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> logistics{};

  FillLogisticsRequest() {}

  explicit FillLogisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (logistics) {
      res["Logistics"] = boost::any(*logistics);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Logistics") != m.end() && !m["Logistics"].empty()) {
      logistics = make_shared<string>(boost::any_cast<string>(m["Logistics"]));
    }
  }


  virtual ~FillLogisticsRequest() = default;
};
class FillLogisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  FillLogisticsResponseBody() {}

  explicit FillLogisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~FillLogisticsResponseBody() = default;
};
class FillLogisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FillLogisticsResponseBody> body{};

  FillLogisticsResponse() {}

  explicit FillLogisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FillLogisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FillLogisticsResponseBody>(model1);
      }
    }
  }


  virtual ~FillLogisticsResponse() = default;
};
class FilterUnavailableCodesRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> codes{};

  FilterUnavailableCodesRequest() {}

  explicit FilterUnavailableCodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codes) {
      res["Codes"] = boost::any(*codes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codes") != m.end() && !m["Codes"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Codes"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      codes = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~FilterUnavailableCodesRequest() = default;
};
class FilterUnavailableCodesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> codesShrink{};

  FilterUnavailableCodesShrinkRequest() {}

  explicit FilterUnavailableCodesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codesShrink) {
      res["Codes"] = boost::any(*codesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codes") != m.end() && !m["Codes"].empty()) {
      codesShrink = make_shared<string>(boost::any_cast<string>(m["Codes"]));
    }
  }


  virtual ~FilterUnavailableCodesShrinkRequest() = default;
};
class FilterUnavailableCodesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> codes{};

  FilterUnavailableCodesResponseBodyData() {}

  explicit FilterUnavailableCodesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codes) {
      res["Codes"] = boost::any(*codes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codes") != m.end() && !m["Codes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Codes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Codes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      codes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~FilterUnavailableCodesResponseBodyData() = default;
};
class FilterUnavailableCodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<FilterUnavailableCodesResponseBodyData> data{};
  shared_ptr<string> requestId{};

  FilterUnavailableCodesResponseBody() {}

  explicit FilterUnavailableCodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        FilterUnavailableCodesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<FilterUnavailableCodesResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~FilterUnavailableCodesResponseBody() = default;
};
class FilterUnavailableCodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FilterUnavailableCodesResponseBody> body{};

  FilterUnavailableCodesResponse() {}

  explicit FilterUnavailableCodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FilterUnavailableCodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FilterUnavailableCodesResponseBody>(model1);
      }
    }
  }


  virtual ~FilterUnavailableCodesResponse() = default;
};
class ForceUploadTrademarkOnsaleRequest : public Darabonba::Model {
public:
  shared_ptr<long> beginTime{};
  shared_ptr<string> classificationCode{};
  shared_ptr<string> description{};
  shared_ptr<long> endTime{};
  shared_ptr<string> label{};
  shared_ptr<double> originalPrice{};
  shared_ptr<string> ownerEnName{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> reason{};
  shared_ptr<long> regAnnDate{};
  shared_ptr<string> secondaryClassification{};
  shared_ptr<string> thirdClassification{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNumber{};
  shared_ptr<string> type{};

  ForceUploadTrademarkOnsaleRequest() {}

  explicit ForceUploadTrademarkOnsaleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (ownerEnName) {
      res["OwnerEnName"] = boost::any(*ownerEnName);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (regAnnDate) {
      res["RegAnnDate"] = boost::any(*regAnnDate);
    }
    if (secondaryClassification) {
      res["SecondaryClassification"] = boost::any(*secondaryClassification);
    }
    if (thirdClassification) {
      res["ThirdClassification"] = boost::any(*thirdClassification);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("OwnerEnName") != m.end() && !m["OwnerEnName"].empty()) {
      ownerEnName = make_shared<string>(boost::any_cast<string>(m["OwnerEnName"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("RegAnnDate") != m.end() && !m["RegAnnDate"].empty()) {
      regAnnDate = make_shared<long>(boost::any_cast<long>(m["RegAnnDate"]));
    }
    if (m.find("SecondaryClassification") != m.end() && !m["SecondaryClassification"].empty()) {
      secondaryClassification = make_shared<string>(boost::any_cast<string>(m["SecondaryClassification"]));
    }
    if (m.find("ThirdClassification") != m.end() && !m["ThirdClassification"].empty()) {
      thirdClassification = make_shared<string>(boost::any_cast<string>(m["ThirdClassification"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ForceUploadTrademarkOnsaleRequest() = default;
};
class ForceUploadTrademarkOnsaleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ForceUploadTrademarkOnsaleResponseBody() {}

  explicit ForceUploadTrademarkOnsaleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ForceUploadTrademarkOnsaleResponseBody() = default;
};
class ForceUploadTrademarkOnsaleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ForceUploadTrademarkOnsaleResponseBody> body{};

  ForceUploadTrademarkOnsaleResponse() {}

  explicit ForceUploadTrademarkOnsaleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ForceUploadTrademarkOnsaleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ForceUploadTrademarkOnsaleResponseBody>(model1);
      }
    }
  }


  virtual ~ForceUploadTrademarkOnsaleResponse() = default;
};
class GenerateQrCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> fieldKey{};
  shared_ptr<string> ossKey{};
  shared_ptr<string> uuid{};

  GenerateQrCodeRequest() {}

  explicit GenerateQrCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldKey) {
      res["FieldKey"] = boost::any(*fieldKey);
    }
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldKey") != m.end() && !m["FieldKey"].empty()) {
      fieldKey = make_shared<string>(boost::any_cast<string>(m["FieldKey"]));
    }
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["OssKey"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~GenerateQrCodeRequest() = default;
};
class GenerateQrCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> expireTime{};
  shared_ptr<string> fieldKey{};
  shared_ptr<string> qrcodeUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> uuid{};

  GenerateQrCodeResponseBody() {}

  explicit GenerateQrCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (fieldKey) {
      res["FieldKey"] = boost::any(*fieldKey);
    }
    if (qrcodeUrl) {
      res["QrcodeUrl"] = boost::any(*qrcodeUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("FieldKey") != m.end() && !m["FieldKey"].empty()) {
      fieldKey = make_shared<string>(boost::any_cast<string>(m["FieldKey"]));
    }
    if (m.find("QrcodeUrl") != m.end() && !m["QrcodeUrl"].empty()) {
      qrcodeUrl = make_shared<string>(boost::any_cast<string>(m["QrcodeUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~GenerateQrCodeResponseBody() = default;
};
class GenerateQrCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateQrCodeResponseBody> body{};

  GenerateQrCodeResponse() {}

  explicit GenerateQrCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateQrCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateQrCodeResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateQrCodeResponse() = default;
};
class GenerateUploadFilePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> fileType{};

  GenerateUploadFilePolicyRequest() {}

  explicit GenerateUploadFilePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
  }


  virtual ~GenerateUploadFilePolicyRequest() = default;
};
class GenerateUploadFilePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<string> encodedPolicy{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> fileDir{};
  shared_ptr<string> host{};
  shared_ptr<string> requestId{};
  shared_ptr<string> signature{};

  GenerateUploadFilePolicyResponseBody() {}

  explicit GenerateUploadFilePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (encodedPolicy) {
      res["EncodedPolicy"] = boost::any(*encodedPolicy);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (fileDir) {
      res["FileDir"] = boost::any(*fileDir);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("EncodedPolicy") != m.end() && !m["EncodedPolicy"].empty()) {
      encodedPolicy = make_shared<string>(boost::any_cast<string>(m["EncodedPolicy"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("FileDir") != m.end() && !m["FileDir"].empty()) {
      fileDir = make_shared<string>(boost::any_cast<string>(m["FileDir"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~GenerateUploadFilePolicyResponseBody() = default;
};
class GenerateUploadFilePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateUploadFilePolicyResponseBody> body{};

  GenerateUploadFilePolicyResponse() {}

  explicit GenerateUploadFilePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateUploadFilePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateUploadFilePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateUploadFilePolicyResponse() = default;
};
class GetAuthorizationLetterVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> ossKey{};

  GetAuthorizationLetterVersionRequest() {}

  explicit GetAuthorizationLetterVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["OssKey"]));
    }
  }


  virtual ~GetAuthorizationLetterVersionRequest() = default;
};
class GetAuthorizationLetterVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> version{};

  GetAuthorizationLetterVersionResponseBody() {}

  explicit GetAuthorizationLetterVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetAuthorizationLetterVersionResponseBody() = default;
};
class GetAuthorizationLetterVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAuthorizationLetterVersionResponseBody> body{};

  GetAuthorizationLetterVersionResponse() {}

  explicit GetAuthorizationLetterVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAuthorizationLetterVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAuthorizationLetterVersionResponseBody>(model1);
      }
    }
  }


  virtual ~GetAuthorizationLetterVersionResponse() = default;
};
class GetDefaultPrincipalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> principalDescription{};
  shared_ptr<string> principalName{};
  shared_ptr<long> principalValue{};
  shared_ptr<string> requestId{};

  GetDefaultPrincipalResponseBody() {}

  explicit GetDefaultPrincipalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (principalDescription) {
      res["PrincipalDescription"] = boost::any(*principalDescription);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (principalValue) {
      res["PrincipalValue"] = boost::any(*principalValue);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrincipalDescription") != m.end() && !m["PrincipalDescription"].empty()) {
      principalDescription = make_shared<string>(boost::any_cast<string>(m["PrincipalDescription"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("PrincipalValue") != m.end() && !m["PrincipalValue"].empty()) {
      principalValue = make_shared<long>(boost::any_cast<long>(m["PrincipalValue"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDefaultPrincipalResponseBody() = default;
};
class GetDefaultPrincipalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDefaultPrincipalResponseBody> body{};

  GetDefaultPrincipalResponse() {}

  explicit GetDefaultPrincipalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDefaultPrincipalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDefaultPrincipalResponseBody>(model1);
      }
    }
  }


  virtual ~GetDefaultPrincipalResponse() = default;
};
class GetDefaultPrincipalNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};

  GetDefaultPrincipalNameRequest() {}

  explicit GetDefaultPrincipalNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
  }


  virtual ~GetDefaultPrincipalNameRequest() = default;
};
class GetDefaultPrincipalNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> principalName{};
  shared_ptr<string> requestId{};

  GetDefaultPrincipalNameResponseBody() {}

  explicit GetDefaultPrincipalNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDefaultPrincipalNameResponseBody() = default;
};
class GetDefaultPrincipalNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDefaultPrincipalNameResponseBody> body{};

  GetDefaultPrincipalNameResponse() {}

  explicit GetDefaultPrincipalNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDefaultPrincipalNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDefaultPrincipalNameResponseBody>(model1);
      }
    }
  }


  virtual ~GetDefaultPrincipalNameResponse() = default;
};
class GetNotaryOrderRequest : public Darabonba::Model {
public:
  shared_ptr<long> notaryOrderId{};

  GetNotaryOrderRequest() {}

  explicit GetNotaryOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notaryOrderId) {
      res["NotaryOrderId"] = boost::any(*notaryOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotaryOrderId") != m.end() && !m["NotaryOrderId"].empty()) {
      notaryOrderId = make_shared<long>(boost::any_cast<long>(m["NotaryOrderId"]));
    }
  }


  virtual ~GetNotaryOrderRequest() = default;
};
class GetNotaryOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aliyunOrderId{};
  shared_ptr<long> applyPostStatus{};
  shared_ptr<string> bizId{};
  shared_ptr<string> businessLicense{};
  shared_ptr<string> businessLicenseId{};
  shared_ptr<string> companyContactName{};
  shared_ptr<string> companyContactPhone{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> legalPersonIdCard{};
  shared_ptr<string> legalPersonName{};
  shared_ptr<string> legalPersonPhone{};
  shared_ptr<string> name{};
  shared_ptr<long> notaryAcceptDate{};
  shared_ptr<string> notaryCertificate{};
  shared_ptr<long> notaryFailedDate{};
  shared_ptr<string> notaryFailedReason{};
  shared_ptr<long> notaryOrderId{};
  shared_ptr<string> notaryPlatformName{};
  shared_ptr<string> notaryPostReceipt{};
  shared_ptr<long> notaryStatus{};
  shared_ptr<long> notarySucceedDate{};
  shared_ptr<long> notaryType{};
  shared_ptr<long> orderDate{};
  shared_ptr<double> orderPrice{};
  shared_ptr<string> phone{};
  shared_ptr<string> receiverAddress{};
  shared_ptr<string> receiverName{};
  shared_ptr<string> receiverPhone{};
  shared_ptr<string> receiverPostalCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sellerBackOfIdCard{};
  shared_ptr<string> sellerCompanyName{};
  shared_ptr<string> sellerFrontOfIdCard{};
  shared_ptr<bool> success{};
  shared_ptr<string> tmAcceptCertificate{};
  shared_ptr<string> tmClassification{};
  shared_ptr<string> tmImage{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmRegisterCertificate{};
  shared_ptr<string> tmRegisterChangeCertificate{};
  shared_ptr<string> tmRegisterNo{};
  shared_ptr<string> type{};

  GetNotaryOrderResponseBody() {}

  explicit GetNotaryOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunOrderId) {
      res["AliyunOrderId"] = boost::any(*aliyunOrderId);
    }
    if (applyPostStatus) {
      res["ApplyPostStatus"] = boost::any(*applyPostStatus);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (businessLicense) {
      res["BusinessLicense"] = boost::any(*businessLicense);
    }
    if (businessLicenseId) {
      res["BusinessLicenseId"] = boost::any(*businessLicenseId);
    }
    if (companyContactName) {
      res["CompanyContactName"] = boost::any(*companyContactName);
    }
    if (companyContactPhone) {
      res["CompanyContactPhone"] = boost::any(*companyContactPhone);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (legalPersonIdCard) {
      res["LegalPersonIdCard"] = boost::any(*legalPersonIdCard);
    }
    if (legalPersonName) {
      res["LegalPersonName"] = boost::any(*legalPersonName);
    }
    if (legalPersonPhone) {
      res["LegalPersonPhone"] = boost::any(*legalPersonPhone);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notaryAcceptDate) {
      res["NotaryAcceptDate"] = boost::any(*notaryAcceptDate);
    }
    if (notaryCertificate) {
      res["NotaryCertificate"] = boost::any(*notaryCertificate);
    }
    if (notaryFailedDate) {
      res["NotaryFailedDate"] = boost::any(*notaryFailedDate);
    }
    if (notaryFailedReason) {
      res["NotaryFailedReason"] = boost::any(*notaryFailedReason);
    }
    if (notaryOrderId) {
      res["NotaryOrderId"] = boost::any(*notaryOrderId);
    }
    if (notaryPlatformName) {
      res["NotaryPlatformName"] = boost::any(*notaryPlatformName);
    }
    if (notaryPostReceipt) {
      res["NotaryPostReceipt"] = boost::any(*notaryPostReceipt);
    }
    if (notaryStatus) {
      res["NotaryStatus"] = boost::any(*notaryStatus);
    }
    if (notarySucceedDate) {
      res["NotarySucceedDate"] = boost::any(*notarySucceedDate);
    }
    if (notaryType) {
      res["NotaryType"] = boost::any(*notaryType);
    }
    if (orderDate) {
      res["OrderDate"] = boost::any(*orderDate);
    }
    if (orderPrice) {
      res["OrderPrice"] = boost::any(*orderPrice);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (receiverAddress) {
      res["ReceiverAddress"] = boost::any(*receiverAddress);
    }
    if (receiverName) {
      res["ReceiverName"] = boost::any(*receiverName);
    }
    if (receiverPhone) {
      res["ReceiverPhone"] = boost::any(*receiverPhone);
    }
    if (receiverPostalCode) {
      res["ReceiverPostalCode"] = boost::any(*receiverPostalCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sellerBackOfIdCard) {
      res["SellerBackOfIdCard"] = boost::any(*sellerBackOfIdCard);
    }
    if (sellerCompanyName) {
      res["SellerCompanyName"] = boost::any(*sellerCompanyName);
    }
    if (sellerFrontOfIdCard) {
      res["SellerFrontOfIdCard"] = boost::any(*sellerFrontOfIdCard);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tmAcceptCertificate) {
      res["TmAcceptCertificate"] = boost::any(*tmAcceptCertificate);
    }
    if (tmClassification) {
      res["TmClassification"] = boost::any(*tmClassification);
    }
    if (tmImage) {
      res["TmImage"] = boost::any(*tmImage);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmRegisterCertificate) {
      res["TmRegisterCertificate"] = boost::any(*tmRegisterCertificate);
    }
    if (tmRegisterChangeCertificate) {
      res["TmRegisterChangeCertificate"] = boost::any(*tmRegisterChangeCertificate);
    }
    if (tmRegisterNo) {
      res["TmRegisterNo"] = boost::any(*tmRegisterNo);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunOrderId") != m.end() && !m["AliyunOrderId"].empty()) {
      aliyunOrderId = make_shared<string>(boost::any_cast<string>(m["AliyunOrderId"]));
    }
    if (m.find("ApplyPostStatus") != m.end() && !m["ApplyPostStatus"].empty()) {
      applyPostStatus = make_shared<long>(boost::any_cast<long>(m["ApplyPostStatus"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BusinessLicense") != m.end() && !m["BusinessLicense"].empty()) {
      businessLicense = make_shared<string>(boost::any_cast<string>(m["BusinessLicense"]));
    }
    if (m.find("BusinessLicenseId") != m.end() && !m["BusinessLicenseId"].empty()) {
      businessLicenseId = make_shared<string>(boost::any_cast<string>(m["BusinessLicenseId"]));
    }
    if (m.find("CompanyContactName") != m.end() && !m["CompanyContactName"].empty()) {
      companyContactName = make_shared<string>(boost::any_cast<string>(m["CompanyContactName"]));
    }
    if (m.find("CompanyContactPhone") != m.end() && !m["CompanyContactPhone"].empty()) {
      companyContactPhone = make_shared<string>(boost::any_cast<string>(m["CompanyContactPhone"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("LegalPersonIdCard") != m.end() && !m["LegalPersonIdCard"].empty()) {
      legalPersonIdCard = make_shared<string>(boost::any_cast<string>(m["LegalPersonIdCard"]));
    }
    if (m.find("LegalPersonName") != m.end() && !m["LegalPersonName"].empty()) {
      legalPersonName = make_shared<string>(boost::any_cast<string>(m["LegalPersonName"]));
    }
    if (m.find("LegalPersonPhone") != m.end() && !m["LegalPersonPhone"].empty()) {
      legalPersonPhone = make_shared<string>(boost::any_cast<string>(m["LegalPersonPhone"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotaryAcceptDate") != m.end() && !m["NotaryAcceptDate"].empty()) {
      notaryAcceptDate = make_shared<long>(boost::any_cast<long>(m["NotaryAcceptDate"]));
    }
    if (m.find("NotaryCertificate") != m.end() && !m["NotaryCertificate"].empty()) {
      notaryCertificate = make_shared<string>(boost::any_cast<string>(m["NotaryCertificate"]));
    }
    if (m.find("NotaryFailedDate") != m.end() && !m["NotaryFailedDate"].empty()) {
      notaryFailedDate = make_shared<long>(boost::any_cast<long>(m["NotaryFailedDate"]));
    }
    if (m.find("NotaryFailedReason") != m.end() && !m["NotaryFailedReason"].empty()) {
      notaryFailedReason = make_shared<string>(boost::any_cast<string>(m["NotaryFailedReason"]));
    }
    if (m.find("NotaryOrderId") != m.end() && !m["NotaryOrderId"].empty()) {
      notaryOrderId = make_shared<long>(boost::any_cast<long>(m["NotaryOrderId"]));
    }
    if (m.find("NotaryPlatformName") != m.end() && !m["NotaryPlatformName"].empty()) {
      notaryPlatformName = make_shared<string>(boost::any_cast<string>(m["NotaryPlatformName"]));
    }
    if (m.find("NotaryPostReceipt") != m.end() && !m["NotaryPostReceipt"].empty()) {
      notaryPostReceipt = make_shared<string>(boost::any_cast<string>(m["NotaryPostReceipt"]));
    }
    if (m.find("NotaryStatus") != m.end() && !m["NotaryStatus"].empty()) {
      notaryStatus = make_shared<long>(boost::any_cast<long>(m["NotaryStatus"]));
    }
    if (m.find("NotarySucceedDate") != m.end() && !m["NotarySucceedDate"].empty()) {
      notarySucceedDate = make_shared<long>(boost::any_cast<long>(m["NotarySucceedDate"]));
    }
    if (m.find("NotaryType") != m.end() && !m["NotaryType"].empty()) {
      notaryType = make_shared<long>(boost::any_cast<long>(m["NotaryType"]));
    }
    if (m.find("OrderDate") != m.end() && !m["OrderDate"].empty()) {
      orderDate = make_shared<long>(boost::any_cast<long>(m["OrderDate"]));
    }
    if (m.find("OrderPrice") != m.end() && !m["OrderPrice"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["OrderPrice"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("ReceiverAddress") != m.end() && !m["ReceiverAddress"].empty()) {
      receiverAddress = make_shared<string>(boost::any_cast<string>(m["ReceiverAddress"]));
    }
    if (m.find("ReceiverName") != m.end() && !m["ReceiverName"].empty()) {
      receiverName = make_shared<string>(boost::any_cast<string>(m["ReceiverName"]));
    }
    if (m.find("ReceiverPhone") != m.end() && !m["ReceiverPhone"].empty()) {
      receiverPhone = make_shared<string>(boost::any_cast<string>(m["ReceiverPhone"]));
    }
    if (m.find("ReceiverPostalCode") != m.end() && !m["ReceiverPostalCode"].empty()) {
      receiverPostalCode = make_shared<string>(boost::any_cast<string>(m["ReceiverPostalCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SellerBackOfIdCard") != m.end() && !m["SellerBackOfIdCard"].empty()) {
      sellerBackOfIdCard = make_shared<string>(boost::any_cast<string>(m["SellerBackOfIdCard"]));
    }
    if (m.find("SellerCompanyName") != m.end() && !m["SellerCompanyName"].empty()) {
      sellerCompanyName = make_shared<string>(boost::any_cast<string>(m["SellerCompanyName"]));
    }
    if (m.find("SellerFrontOfIdCard") != m.end() && !m["SellerFrontOfIdCard"].empty()) {
      sellerFrontOfIdCard = make_shared<string>(boost::any_cast<string>(m["SellerFrontOfIdCard"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TmAcceptCertificate") != m.end() && !m["TmAcceptCertificate"].empty()) {
      tmAcceptCertificate = make_shared<string>(boost::any_cast<string>(m["TmAcceptCertificate"]));
    }
    if (m.find("TmClassification") != m.end() && !m["TmClassification"].empty()) {
      tmClassification = make_shared<string>(boost::any_cast<string>(m["TmClassification"]));
    }
    if (m.find("TmImage") != m.end() && !m["TmImage"].empty()) {
      tmImage = make_shared<string>(boost::any_cast<string>(m["TmImage"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmRegisterCertificate") != m.end() && !m["TmRegisterCertificate"].empty()) {
      tmRegisterCertificate = make_shared<string>(boost::any_cast<string>(m["TmRegisterCertificate"]));
    }
    if (m.find("TmRegisterChangeCertificate") != m.end() && !m["TmRegisterChangeCertificate"].empty()) {
      tmRegisterChangeCertificate = make_shared<string>(boost::any_cast<string>(m["TmRegisterChangeCertificate"]));
    }
    if (m.find("TmRegisterNo") != m.end() && !m["TmRegisterNo"].empty()) {
      tmRegisterNo = make_shared<string>(boost::any_cast<string>(m["TmRegisterNo"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetNotaryOrderResponseBody() = default;
};
class GetNotaryOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNotaryOrderResponseBody> body{};

  GetNotaryOrderResponse() {}

  explicit GetNotaryOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNotaryOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNotaryOrderResponseBody>(model1);
      }
    }
  }


  virtual ~GetNotaryOrderResponse() = default;
};
class GetSupportPrincipalNameResponseBodyPrincipals : public Darabonba::Model {
public:
  shared_ptr<bool> defaultPrincipal{};
  shared_ptr<string> principalDescription{};
  shared_ptr<long> principalValue{};

  GetSupportPrincipalNameResponseBodyPrincipals() {}

  explicit GetSupportPrincipalNameResponseBodyPrincipals(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultPrincipal) {
      res["DefaultPrincipal"] = boost::any(*defaultPrincipal);
    }
    if (principalDescription) {
      res["PrincipalDescription"] = boost::any(*principalDescription);
    }
    if (principalValue) {
      res["PrincipalValue"] = boost::any(*principalValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultPrincipal") != m.end() && !m["DefaultPrincipal"].empty()) {
      defaultPrincipal = make_shared<bool>(boost::any_cast<bool>(m["DefaultPrincipal"]));
    }
    if (m.find("PrincipalDescription") != m.end() && !m["PrincipalDescription"].empty()) {
      principalDescription = make_shared<string>(boost::any_cast<string>(m["PrincipalDescription"]));
    }
    if (m.find("PrincipalValue") != m.end() && !m["PrincipalValue"].empty()) {
      principalValue = make_shared<long>(boost::any_cast<long>(m["PrincipalValue"]));
    }
  }


  virtual ~GetSupportPrincipalNameResponseBodyPrincipals() = default;
};
class GetSupportPrincipalNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetSupportPrincipalNameResponseBodyPrincipals>> principals{};
  shared_ptr<string> requestId{};

  GetSupportPrincipalNameResponseBody() {}

  explicit GetSupportPrincipalNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (principals) {
      vector<boost::any> temp1;
      for(auto item1:*principals){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Principals"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Principals") != m.end() && !m["Principals"].empty()) {
      if (typeid(vector<boost::any>) == m["Principals"].type()) {
        vector<GetSupportPrincipalNameResponseBodyPrincipals> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Principals"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSupportPrincipalNameResponseBodyPrincipals model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        principals = make_shared<vector<GetSupportPrincipalNameResponseBodyPrincipals>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetSupportPrincipalNameResponseBody() = default;
};
class GetSupportPrincipalNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSupportPrincipalNameResponseBody> body{};

  GetSupportPrincipalNameResponse() {}

  explicit GetSupportPrincipalNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSupportPrincipalNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSupportPrincipalNameResponseBody>(model1);
      }
    }
  }


  virtual ~GetSupportPrincipalNameResponse() = default;
};
class InsertMaterialRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> businessLicenceOssKey{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> city{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactCity{};
  shared_ptr<string> contactCounty{};
  shared_ptr<string> contactDistrict{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactNumber{};
  shared_ptr<string> contactProvince{};
  shared_ptr<string> contactZipcode{};
  shared_ptr<string> country{};
  shared_ptr<string> EAddress{};
  shared_ptr<string> EName{};
  shared_ptr<string> idCardName{};
  shared_ptr<string> idCardNumber{};
  shared_ptr<string> idCardOssKey{};
  shared_ptr<string> legalNoticeOssKey{};
  shared_ptr<string> loaOssKey{};
  shared_ptr<string> name{};
  shared_ptr<string> passportOssKey{};
  shared_ptr<long> personalType{};
  shared_ptr<long> principalName{};
  shared_ptr<string> province{};
  shared_ptr<long> region{};
  shared_ptr<string> town{};
  shared_ptr<long> type{};

  InsertMaterialRequest() {}

  explicit InsertMaterialRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (businessLicenceOssKey) {
      res["BusinessLicenceOssKey"] = boost::any(*businessLicenceOssKey);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactCity) {
      res["ContactCity"] = boost::any(*contactCity);
    }
    if (contactCounty) {
      res["ContactCounty"] = boost::any(*contactCounty);
    }
    if (contactDistrict) {
      res["ContactDistrict"] = boost::any(*contactDistrict);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactNumber) {
      res["ContactNumber"] = boost::any(*contactNumber);
    }
    if (contactProvince) {
      res["ContactProvince"] = boost::any(*contactProvince);
    }
    if (contactZipcode) {
      res["ContactZipcode"] = boost::any(*contactZipcode);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (EAddress) {
      res["EAddress"] = boost::any(*EAddress);
    }
    if (EName) {
      res["EName"] = boost::any(*EName);
    }
    if (idCardName) {
      res["IdCardName"] = boost::any(*idCardName);
    }
    if (idCardNumber) {
      res["IdCardNumber"] = boost::any(*idCardNumber);
    }
    if (idCardOssKey) {
      res["IdCardOssKey"] = boost::any(*idCardOssKey);
    }
    if (legalNoticeOssKey) {
      res["LegalNoticeOssKey"] = boost::any(*legalNoticeOssKey);
    }
    if (loaOssKey) {
      res["LoaOssKey"] = boost::any(*loaOssKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportOssKey) {
      res["PassportOssKey"] = boost::any(*passportOssKey);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (town) {
      res["Town"] = boost::any(*town);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BusinessLicenceOssKey") != m.end() && !m["BusinessLicenceOssKey"].empty()) {
      businessLicenceOssKey = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceOssKey"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactCity") != m.end() && !m["ContactCity"].empty()) {
      contactCity = make_shared<string>(boost::any_cast<string>(m["ContactCity"]));
    }
    if (m.find("ContactCounty") != m.end() && !m["ContactCounty"].empty()) {
      contactCounty = make_shared<string>(boost::any_cast<string>(m["ContactCounty"]));
    }
    if (m.find("ContactDistrict") != m.end() && !m["ContactDistrict"].empty()) {
      contactDistrict = make_shared<string>(boost::any_cast<string>(m["ContactDistrict"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactNumber") != m.end() && !m["ContactNumber"].empty()) {
      contactNumber = make_shared<string>(boost::any_cast<string>(m["ContactNumber"]));
    }
    if (m.find("ContactProvince") != m.end() && !m["ContactProvince"].empty()) {
      contactProvince = make_shared<string>(boost::any_cast<string>(m["ContactProvince"]));
    }
    if (m.find("ContactZipcode") != m.end() && !m["ContactZipcode"].empty()) {
      contactZipcode = make_shared<string>(boost::any_cast<string>(m["ContactZipcode"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("EAddress") != m.end() && !m["EAddress"].empty()) {
      EAddress = make_shared<string>(boost::any_cast<string>(m["EAddress"]));
    }
    if (m.find("EName") != m.end() && !m["EName"].empty()) {
      EName = make_shared<string>(boost::any_cast<string>(m["EName"]));
    }
    if (m.find("IdCardName") != m.end() && !m["IdCardName"].empty()) {
      idCardName = make_shared<string>(boost::any_cast<string>(m["IdCardName"]));
    }
    if (m.find("IdCardNumber") != m.end() && !m["IdCardNumber"].empty()) {
      idCardNumber = make_shared<string>(boost::any_cast<string>(m["IdCardNumber"]));
    }
    if (m.find("IdCardOssKey") != m.end() && !m["IdCardOssKey"].empty()) {
      idCardOssKey = make_shared<string>(boost::any_cast<string>(m["IdCardOssKey"]));
    }
    if (m.find("LegalNoticeOssKey") != m.end() && !m["LegalNoticeOssKey"].empty()) {
      legalNoticeOssKey = make_shared<string>(boost::any_cast<string>(m["LegalNoticeOssKey"]));
    }
    if (m.find("LoaOssKey") != m.end() && !m["LoaOssKey"].empty()) {
      loaOssKey = make_shared<string>(boost::any_cast<string>(m["LoaOssKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportOssKey") != m.end() && !m["PassportOssKey"].empty()) {
      passportOssKey = make_shared<string>(boost::any_cast<string>(m["PassportOssKey"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<long>(boost::any_cast<long>(m["PersonalType"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("Town") != m.end() && !m["Town"].empty()) {
      town = make_shared<string>(boost::any_cast<string>(m["Town"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~InsertMaterialRequest() = default;
};
class InsertMaterialResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InsertMaterialResponseBody() {}

  explicit InsertMaterialResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InsertMaterialResponseBody() = default;
};
class InsertMaterialResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertMaterialResponseBody> body{};

  InsertMaterialResponse() {}

  explicit InsertMaterialResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertMaterialResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertMaterialResponseBody>(model1);
      }
    }
  }


  virtual ~InsertMaterialResponse() = default;
};
class InsertRenewInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> engAddress{};
  shared_ptr<string> engName{};
  shared_ptr<string> name{};
  shared_ptr<long> registerTime{};

  InsertRenewInfoRequest() {}

  explicit InsertRenewInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (engAddress) {
      res["EngAddress"] = boost::any(*engAddress);
    }
    if (engName) {
      res["EngName"] = boost::any(*engName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (registerTime) {
      res["RegisterTime"] = boost::any(*registerTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("EngAddress") != m.end() && !m["EngAddress"].empty()) {
      engAddress = make_shared<string>(boost::any_cast<string>(m["EngAddress"]));
    }
    if (m.find("EngName") != m.end() && !m["EngName"].empty()) {
      engName = make_shared<string>(boost::any_cast<string>(m["EngName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegisterTime") != m.end() && !m["RegisterTime"].empty()) {
      registerTime = make_shared<long>(boost::any_cast<long>(m["RegisterTime"]));
    }
  }


  virtual ~InsertRenewInfoRequest() = default;
};
class InsertRenewInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InsertRenewInfoResponseBody() {}

  explicit InsertRenewInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InsertRenewInfoResponseBody() = default;
};
class InsertRenewInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertRenewInfoResponseBody> body{};

  InsertRenewInfoResponse() {}

  explicit InsertRenewInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertRenewInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertRenewInfoResponseBody>(model1);
      }
    }
  }


  virtual ~InsertRenewInfoResponse() = default;
};
class InsertTmMonitorRuleRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> classification{};
  shared_ptr<string> endApplyDate{};
  shared_ptr<map<string, boost::any>> notifyStatus{};
  shared_ptr<string> ruleKeyword{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleSource{};
  shared_ptr<long> ruleType{};
  shared_ptr<string> startApplyDate{};

  InsertTmMonitorRuleRequest() {}

  explicit InsertTmMonitorRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (endApplyDate) {
      res["EndApplyDate"] = boost::any(*endApplyDate);
    }
    if (notifyStatus) {
      res["NotifyStatus"] = boost::any(*notifyStatus);
    }
    if (ruleKeyword) {
      res["RuleKeyword"] = boost::any(*ruleKeyword);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleSource) {
      res["RuleSource"] = boost::any(*ruleSource);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (startApplyDate) {
      res["StartApplyDate"] = boost::any(*startApplyDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Classification"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      classification = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("EndApplyDate") != m.end() && !m["EndApplyDate"].empty()) {
      endApplyDate = make_shared<string>(boost::any_cast<string>(m["EndApplyDate"]));
    }
    if (m.find("NotifyStatus") != m.end() && !m["NotifyStatus"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["NotifyStatus"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      notifyStatus = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RuleKeyword") != m.end() && !m["RuleKeyword"].empty()) {
      ruleKeyword = make_shared<string>(boost::any_cast<string>(m["RuleKeyword"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleSource") != m.end() && !m["RuleSource"].empty()) {
      ruleSource = make_shared<string>(boost::any_cast<string>(m["RuleSource"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("StartApplyDate") != m.end() && !m["StartApplyDate"].empty()) {
      startApplyDate = make_shared<string>(boost::any_cast<string>(m["StartApplyDate"]));
    }
  }


  virtual ~InsertTmMonitorRuleRequest() = default;
};
class InsertTmMonitorRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> classificationShrink{};
  shared_ptr<string> endApplyDate{};
  shared_ptr<string> notifyStatusShrink{};
  shared_ptr<string> ruleKeyword{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleSource{};
  shared_ptr<long> ruleType{};
  shared_ptr<string> startApplyDate{};

  InsertTmMonitorRuleShrinkRequest() {}

  explicit InsertTmMonitorRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationShrink) {
      res["Classification"] = boost::any(*classificationShrink);
    }
    if (endApplyDate) {
      res["EndApplyDate"] = boost::any(*endApplyDate);
    }
    if (notifyStatusShrink) {
      res["NotifyStatus"] = boost::any(*notifyStatusShrink);
    }
    if (ruleKeyword) {
      res["RuleKeyword"] = boost::any(*ruleKeyword);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleSource) {
      res["RuleSource"] = boost::any(*ruleSource);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (startApplyDate) {
      res["StartApplyDate"] = boost::any(*startApplyDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classificationShrink = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("EndApplyDate") != m.end() && !m["EndApplyDate"].empty()) {
      endApplyDate = make_shared<string>(boost::any_cast<string>(m["EndApplyDate"]));
    }
    if (m.find("NotifyStatus") != m.end() && !m["NotifyStatus"].empty()) {
      notifyStatusShrink = make_shared<string>(boost::any_cast<string>(m["NotifyStatus"]));
    }
    if (m.find("RuleKeyword") != m.end() && !m["RuleKeyword"].empty()) {
      ruleKeyword = make_shared<string>(boost::any_cast<string>(m["RuleKeyword"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleSource") != m.end() && !m["RuleSource"].empty()) {
      ruleSource = make_shared<string>(boost::any_cast<string>(m["RuleSource"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("StartApplyDate") != m.end() && !m["StartApplyDate"].empty()) {
      startApplyDate = make_shared<string>(boost::any_cast<string>(m["StartApplyDate"]));
    }
  }


  virtual ~InsertTmMonitorRuleShrinkRequest() = default;
};
class InsertTmMonitorRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InsertTmMonitorRuleResponseBody() {}

  explicit InsertTmMonitorRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InsertTmMonitorRuleResponseBody() = default;
};
class InsertTmMonitorRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertTmMonitorRuleResponseBody> body{};

  InsertTmMonitorRuleResponse() {}

  explicit InsertTmMonitorRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertTmMonitorRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertTmMonitorRuleResponseBody>(model1);
      }
    }
  }


  virtual ~InsertTmMonitorRuleResponse() = default;
};
class ListNotaryInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizOrderNo{};
  shared_ptr<long> notaryType{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> token{};

  ListNotaryInfosRequest() {}

  explicit ListNotaryInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizOrderNo) {
      res["BizOrderNo"] = boost::any(*bizOrderNo);
    }
    if (notaryType) {
      res["NotaryType"] = boost::any(*notaryType);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizOrderNo") != m.end() && !m["BizOrderNo"].empty()) {
      bizOrderNo = make_shared<string>(boost::any_cast<string>(m["BizOrderNo"]));
    }
    if (m.find("NotaryType") != m.end() && !m["NotaryType"].empty()) {
      notaryType = make_shared<long>(boost::any_cast<long>(m["NotaryType"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~ListNotaryInfosRequest() = default;
};
class ListNotaryInfosResponseBodyDataNotaryInfo : public Darabonba::Model {
public:
  shared_ptr<string> bizOrderNo{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> notaryFailedReason{};
  shared_ptr<long> notaryStatus{};
  shared_ptr<string> tmClassification{};
  shared_ptr<string> tmRegisterNo{};
  shared_ptr<string> token{};

  ListNotaryInfosResponseBodyDataNotaryInfo() {}

  explicit ListNotaryInfosResponseBodyDataNotaryInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizOrderNo) {
      res["BizOrderNo"] = boost::any(*bizOrderNo);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (notaryFailedReason) {
      res["NotaryFailedReason"] = boost::any(*notaryFailedReason);
    }
    if (notaryStatus) {
      res["NotaryStatus"] = boost::any(*notaryStatus);
    }
    if (tmClassification) {
      res["TmClassification"] = boost::any(*tmClassification);
    }
    if (tmRegisterNo) {
      res["TmRegisterNo"] = boost::any(*tmRegisterNo);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizOrderNo") != m.end() && !m["BizOrderNo"].empty()) {
      bizOrderNo = make_shared<string>(boost::any_cast<string>(m["BizOrderNo"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("NotaryFailedReason") != m.end() && !m["NotaryFailedReason"].empty()) {
      notaryFailedReason = make_shared<string>(boost::any_cast<string>(m["NotaryFailedReason"]));
    }
    if (m.find("NotaryStatus") != m.end() && !m["NotaryStatus"].empty()) {
      notaryStatus = make_shared<long>(boost::any_cast<long>(m["NotaryStatus"]));
    }
    if (m.find("TmClassification") != m.end() && !m["TmClassification"].empty()) {
      tmClassification = make_shared<string>(boost::any_cast<string>(m["TmClassification"]));
    }
    if (m.find("TmRegisterNo") != m.end() && !m["TmRegisterNo"].empty()) {
      tmRegisterNo = make_shared<string>(boost::any_cast<string>(m["TmRegisterNo"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~ListNotaryInfosResponseBodyDataNotaryInfo() = default;
};
class ListNotaryInfosResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListNotaryInfosResponseBodyDataNotaryInfo>> notaryInfo{};

  ListNotaryInfosResponseBodyData() {}

  explicit ListNotaryInfosResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notaryInfo) {
      vector<boost::any> temp1;
      for(auto item1:*notaryInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotaryInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotaryInfo") != m.end() && !m["NotaryInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["NotaryInfo"].type()) {
        vector<ListNotaryInfosResponseBodyDataNotaryInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotaryInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNotaryInfosResponseBodyDataNotaryInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notaryInfo = make_shared<vector<ListNotaryInfosResponseBodyDataNotaryInfo>>(expect1);
      }
    }
  }


  virtual ~ListNotaryInfosResponseBodyData() = default;
};
class ListNotaryInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<ListNotaryInfosResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<bool> nextPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> prePage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  ListNotaryInfosResponseBody() {}

  explicit ListNotaryInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (nextPage) {
      res["NextPage"] = boost::any(*nextPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prePage) {
      res["PrePage"] = boost::any(*prePage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListNotaryInfosResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListNotaryInfosResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("NextPage") != m.end() && !m["NextPage"].empty()) {
      nextPage = make_shared<bool>(boost::any_cast<bool>(m["NextPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PrePage") != m.end() && !m["PrePage"].empty()) {
      prePage = make_shared<bool>(boost::any_cast<bool>(m["PrePage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~ListNotaryInfosResponseBody() = default;
};
class ListNotaryInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNotaryInfosResponseBody> body{};

  ListNotaryInfosResponse() {}

  explicit ListNotaryInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNotaryInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNotaryInfosResponseBody>(model1);
      }
    }
  }


  virtual ~ListNotaryInfosResponse() = default;
};
class ListNotaryOrdersRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunOrderId{};
  shared_ptr<string> bizId{};
  shared_ptr<long> endOrderDate{};
  shared_ptr<long> notaryStatus{};
  shared_ptr<long> notaryType{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortByType{};
  shared_ptr<long> sortKeyType{};
  shared_ptr<long> startOrderDate{};

  ListNotaryOrdersRequest() {}

  explicit ListNotaryOrdersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunOrderId) {
      res["AliyunOrderId"] = boost::any(*aliyunOrderId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (endOrderDate) {
      res["EndOrderDate"] = boost::any(*endOrderDate);
    }
    if (notaryStatus) {
      res["NotaryStatus"] = boost::any(*notaryStatus);
    }
    if (notaryType) {
      res["NotaryType"] = boost::any(*notaryType);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortByType) {
      res["SortByType"] = boost::any(*sortByType);
    }
    if (sortKeyType) {
      res["SortKeyType"] = boost::any(*sortKeyType);
    }
    if (startOrderDate) {
      res["StartOrderDate"] = boost::any(*startOrderDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunOrderId") != m.end() && !m["AliyunOrderId"].empty()) {
      aliyunOrderId = make_shared<string>(boost::any_cast<string>(m["AliyunOrderId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("EndOrderDate") != m.end() && !m["EndOrderDate"].empty()) {
      endOrderDate = make_shared<long>(boost::any_cast<long>(m["EndOrderDate"]));
    }
    if (m.find("NotaryStatus") != m.end() && !m["NotaryStatus"].empty()) {
      notaryStatus = make_shared<long>(boost::any_cast<long>(m["NotaryStatus"]));
    }
    if (m.find("NotaryType") != m.end() && !m["NotaryType"].empty()) {
      notaryType = make_shared<long>(boost::any_cast<long>(m["NotaryType"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortByType") != m.end() && !m["SortByType"].empty()) {
      sortByType = make_shared<string>(boost::any_cast<string>(m["SortByType"]));
    }
    if (m.find("SortKeyType") != m.end() && !m["SortKeyType"].empty()) {
      sortKeyType = make_shared<long>(boost::any_cast<long>(m["SortKeyType"]));
    }
    if (m.find("StartOrderDate") != m.end() && !m["StartOrderDate"].empty()) {
      startOrderDate = make_shared<long>(boost::any_cast<long>(m["StartOrderDate"]));
    }
  }


  virtual ~ListNotaryOrdersRequest() = default;
};
class ListNotaryOrdersResponseBodyDataNotaryOrder : public Darabonba::Model {
public:
  shared_ptr<string> aliyunOrderId{};
  shared_ptr<string> applyPostStatus{};
  shared_ptr<string> bizId{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> notaryCertificate{};
  shared_ptr<long> notaryOrderId{};
  shared_ptr<string> notaryPlatformName{};
  shared_ptr<long> notaryStatus{};
  shared_ptr<long> notaryType{};
  shared_ptr<long> orderDate{};
  shared_ptr<double> orderPrice{};
  shared_ptr<string> tmClassification{};
  shared_ptr<string> tmImage{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmRegisterNo{};

  ListNotaryOrdersResponseBodyDataNotaryOrder() {}

  explicit ListNotaryOrdersResponseBodyDataNotaryOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunOrderId) {
      res["AliyunOrderId"] = boost::any(*aliyunOrderId);
    }
    if (applyPostStatus) {
      res["ApplyPostStatus"] = boost::any(*applyPostStatus);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (notaryCertificate) {
      res["NotaryCertificate"] = boost::any(*notaryCertificate);
    }
    if (notaryOrderId) {
      res["NotaryOrderId"] = boost::any(*notaryOrderId);
    }
    if (notaryPlatformName) {
      res["NotaryPlatformName"] = boost::any(*notaryPlatformName);
    }
    if (notaryStatus) {
      res["NotaryStatus"] = boost::any(*notaryStatus);
    }
    if (notaryType) {
      res["NotaryType"] = boost::any(*notaryType);
    }
    if (orderDate) {
      res["OrderDate"] = boost::any(*orderDate);
    }
    if (orderPrice) {
      res["OrderPrice"] = boost::any(*orderPrice);
    }
    if (tmClassification) {
      res["TmClassification"] = boost::any(*tmClassification);
    }
    if (tmImage) {
      res["TmImage"] = boost::any(*tmImage);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmRegisterNo) {
      res["TmRegisterNo"] = boost::any(*tmRegisterNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunOrderId") != m.end() && !m["AliyunOrderId"].empty()) {
      aliyunOrderId = make_shared<string>(boost::any_cast<string>(m["AliyunOrderId"]));
    }
    if (m.find("ApplyPostStatus") != m.end() && !m["ApplyPostStatus"].empty()) {
      applyPostStatus = make_shared<string>(boost::any_cast<string>(m["ApplyPostStatus"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("NotaryCertificate") != m.end() && !m["NotaryCertificate"].empty()) {
      notaryCertificate = make_shared<string>(boost::any_cast<string>(m["NotaryCertificate"]));
    }
    if (m.find("NotaryOrderId") != m.end() && !m["NotaryOrderId"].empty()) {
      notaryOrderId = make_shared<long>(boost::any_cast<long>(m["NotaryOrderId"]));
    }
    if (m.find("NotaryPlatformName") != m.end() && !m["NotaryPlatformName"].empty()) {
      notaryPlatformName = make_shared<string>(boost::any_cast<string>(m["NotaryPlatformName"]));
    }
    if (m.find("NotaryStatus") != m.end() && !m["NotaryStatus"].empty()) {
      notaryStatus = make_shared<long>(boost::any_cast<long>(m["NotaryStatus"]));
    }
    if (m.find("NotaryType") != m.end() && !m["NotaryType"].empty()) {
      notaryType = make_shared<long>(boost::any_cast<long>(m["NotaryType"]));
    }
    if (m.find("OrderDate") != m.end() && !m["OrderDate"].empty()) {
      orderDate = make_shared<long>(boost::any_cast<long>(m["OrderDate"]));
    }
    if (m.find("OrderPrice") != m.end() && !m["OrderPrice"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["OrderPrice"]));
    }
    if (m.find("TmClassification") != m.end() && !m["TmClassification"].empty()) {
      tmClassification = make_shared<string>(boost::any_cast<string>(m["TmClassification"]));
    }
    if (m.find("TmImage") != m.end() && !m["TmImage"].empty()) {
      tmImage = make_shared<string>(boost::any_cast<string>(m["TmImage"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmRegisterNo") != m.end() && !m["TmRegisterNo"].empty()) {
      tmRegisterNo = make_shared<string>(boost::any_cast<string>(m["TmRegisterNo"]));
    }
  }


  virtual ~ListNotaryOrdersResponseBodyDataNotaryOrder() = default;
};
class ListNotaryOrdersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListNotaryOrdersResponseBodyDataNotaryOrder>> notaryOrder{};

  ListNotaryOrdersResponseBodyData() {}

  explicit ListNotaryOrdersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notaryOrder) {
      vector<boost::any> temp1;
      for(auto item1:*notaryOrder){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotaryOrder"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotaryOrder") != m.end() && !m["NotaryOrder"].empty()) {
      if (typeid(vector<boost::any>) == m["NotaryOrder"].type()) {
        vector<ListNotaryOrdersResponseBodyDataNotaryOrder> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotaryOrder"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNotaryOrdersResponseBodyDataNotaryOrder model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notaryOrder = make_shared<vector<ListNotaryOrdersResponseBodyDataNotaryOrder>>(expect1);
      }
    }
  }


  virtual ~ListNotaryOrdersResponseBodyData() = default;
};
class ListNotaryOrdersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<ListNotaryOrdersResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<bool> nextPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> prePage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  ListNotaryOrdersResponseBody() {}

  explicit ListNotaryOrdersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (nextPage) {
      res["NextPage"] = boost::any(*nextPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prePage) {
      res["PrePage"] = boost::any(*prePage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListNotaryOrdersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListNotaryOrdersResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("NextPage") != m.end() && !m["NextPage"].empty()) {
      nextPage = make_shared<bool>(boost::any_cast<bool>(m["NextPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PrePage") != m.end() && !m["PrePage"].empty()) {
      prePage = make_shared<bool>(boost::any_cast<bool>(m["PrePage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~ListNotaryOrdersResponseBody() = default;
};
class ListNotaryOrdersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNotaryOrdersResponseBody> body{};

  ListNotaryOrdersResponse() {}

  explicit ListNotaryOrdersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNotaryOrdersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNotaryOrdersResponseBody>(model1);
      }
    }
  }


  virtual ~ListNotaryOrdersResponse() = default;
};
class ListTrademarkSbjKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> principalKey{};
  shared_ptr<string> principalName{};

  ListTrademarkSbjKeyRequest() {}

  explicit ListTrademarkSbjKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (principalKey) {
      res["PrincipalKey"] = boost::any(*principalKey);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrincipalKey") != m.end() && !m["PrincipalKey"].empty()) {
      principalKey = make_shared<string>(boost::any_cast<string>(m["PrincipalKey"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
  }


  virtual ~ListTrademarkSbjKeyRequest() = default;
};
class ListTrademarkSbjKeyResponseBodyTmSbjKeyInfo : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agreeProt{};
  shared_ptr<string> certInfo{};
  shared_ptr<string> clearData{};
  shared_ptr<string> hashData{};
  shared_ptr<long> keyType{};
  shared_ptr<string> name{};
  shared_ptr<string> pin{};
  shared_ptr<string> principalKey{};
  shared_ptr<string> principalName{};
  shared_ptr<string> signCert{};
  shared_ptr<string> signData{};
  shared_ptr<string> startValidDate{};
  shared_ptr<string> submitSignData{};
  shared_ptr<string> typeCert{};
  shared_ptr<string> username{};
  shared_ptr<string> validDate{};
  shared_ptr<string> tmurl{};

  ListTrademarkSbjKeyResponseBodyTmSbjKeyInfo() {}

  explicit ListTrademarkSbjKeyResponseBodyTmSbjKeyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agreeProt) {
      res["AgreeProt"] = boost::any(*agreeProt);
    }
    if (certInfo) {
      res["CertInfo"] = boost::any(*certInfo);
    }
    if (clearData) {
      res["ClearData"] = boost::any(*clearData);
    }
    if (hashData) {
      res["HashData"] = boost::any(*hashData);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pin) {
      res["Pin"] = boost::any(*pin);
    }
    if (principalKey) {
      res["PrincipalKey"] = boost::any(*principalKey);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (signCert) {
      res["SignCert"] = boost::any(*signCert);
    }
    if (signData) {
      res["SignData"] = boost::any(*signData);
    }
    if (startValidDate) {
      res["StartValidDate"] = boost::any(*startValidDate);
    }
    if (submitSignData) {
      res["SubmitSignData"] = boost::any(*submitSignData);
    }
    if (typeCert) {
      res["TypeCert"] = boost::any(*typeCert);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (validDate) {
      res["ValidDate"] = boost::any(*validDate);
    }
    if (tmurl) {
      res["tmurl"] = boost::any(*tmurl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgreeProt") != m.end() && !m["AgreeProt"].empty()) {
      agreeProt = make_shared<string>(boost::any_cast<string>(m["AgreeProt"]));
    }
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      certInfo = make_shared<string>(boost::any_cast<string>(m["CertInfo"]));
    }
    if (m.find("ClearData") != m.end() && !m["ClearData"].empty()) {
      clearData = make_shared<string>(boost::any_cast<string>(m["ClearData"]));
    }
    if (m.find("HashData") != m.end() && !m["HashData"].empty()) {
      hashData = make_shared<string>(boost::any_cast<string>(m["HashData"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<long>(boost::any_cast<long>(m["KeyType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pin") != m.end() && !m["Pin"].empty()) {
      pin = make_shared<string>(boost::any_cast<string>(m["Pin"]));
    }
    if (m.find("PrincipalKey") != m.end() && !m["PrincipalKey"].empty()) {
      principalKey = make_shared<string>(boost::any_cast<string>(m["PrincipalKey"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("SignCert") != m.end() && !m["SignCert"].empty()) {
      signCert = make_shared<string>(boost::any_cast<string>(m["SignCert"]));
    }
    if (m.find("SignData") != m.end() && !m["SignData"].empty()) {
      signData = make_shared<string>(boost::any_cast<string>(m["SignData"]));
    }
    if (m.find("StartValidDate") != m.end() && !m["StartValidDate"].empty()) {
      startValidDate = make_shared<string>(boost::any_cast<string>(m["StartValidDate"]));
    }
    if (m.find("SubmitSignData") != m.end() && !m["SubmitSignData"].empty()) {
      submitSignData = make_shared<string>(boost::any_cast<string>(m["SubmitSignData"]));
    }
    if (m.find("TypeCert") != m.end() && !m["TypeCert"].empty()) {
      typeCert = make_shared<string>(boost::any_cast<string>(m["TypeCert"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("ValidDate") != m.end() && !m["ValidDate"].empty()) {
      validDate = make_shared<string>(boost::any_cast<string>(m["ValidDate"]));
    }
    if (m.find("tmurl") != m.end() && !m["tmurl"].empty()) {
      tmurl = make_shared<string>(boost::any_cast<string>(m["tmurl"]));
    }
  }


  virtual ~ListTrademarkSbjKeyResponseBodyTmSbjKeyInfo() = default;
};
class ListTrademarkSbjKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTrademarkSbjKeyResponseBodyTmSbjKeyInfo>> tmSbjKeyInfo{};

  ListTrademarkSbjKeyResponseBody() {}

  explicit ListTrademarkSbjKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tmSbjKeyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*tmSbjKeyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TmSbjKeyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TmSbjKeyInfo") != m.end() && !m["TmSbjKeyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TmSbjKeyInfo"].type()) {
        vector<ListTrademarkSbjKeyResponseBodyTmSbjKeyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TmSbjKeyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTrademarkSbjKeyResponseBodyTmSbjKeyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tmSbjKeyInfo = make_shared<vector<ListTrademarkSbjKeyResponseBodyTmSbjKeyInfo>>(expect1);
      }
    }
  }


  virtual ~ListTrademarkSbjKeyResponseBody() = default;
};
class ListTrademarkSbjKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTrademarkSbjKeyResponseBody> body{};

  ListTrademarkSbjKeyResponse() {}

  explicit ListTrademarkSbjKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTrademarkSbjKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTrademarkSbjKeyResponseBody>(model1);
      }
    }
  }


  virtual ~ListTrademarkSbjKeyResponse() = default;
};
class ModifySubmitTransferMaterailRequest : public Darabonba::Model {
public:
  shared_ptr<string> addr{};
  shared_ptr<string> assigneeProxy{};
  shared_ptr<string> bizId{};
  shared_ptr<string> buyerBusinessLicense{};
  shared_ptr<string> buyerBusinessLicenseTranslation{};
  shared_ptr<string> buyerIdCard{};
  shared_ptr<string> cardNo{};
  shared_ptr<string> cardType{};
  shared_ptr<bool> complete{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactMobile{};
  shared_ptr<string> contactName{};
  shared_ptr<string> name{};
  shared_ptr<string> notarization{};
  shared_ptr<string> note{};
  shared_ptr<map<string, boost::any>> other{};
  shared_ptr<string> registrationCert{};
  shared_ptr<string> sellerApply{};
  shared_ptr<string> sellerBusinessLicense{};
  shared_ptr<string> sellerBusinessLicenseTranslation{};
  shared_ptr<string> sellerIdCard{};
  shared_ptr<string> sellerProxy{};
  shared_ptr<bool> tradeMaterialFullUpdate{};

  ModifySubmitTransferMaterailRequest() {}

  explicit ModifySubmitTransferMaterailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      res["Addr"] = boost::any(*addr);
    }
    if (assigneeProxy) {
      res["AssigneeProxy"] = boost::any(*assigneeProxy);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (buyerBusinessLicense) {
      res["BuyerBusinessLicense"] = boost::any(*buyerBusinessLicense);
    }
    if (buyerBusinessLicenseTranslation) {
      res["BuyerBusinessLicenseTranslation"] = boost::any(*buyerBusinessLicenseTranslation);
    }
    if (buyerIdCard) {
      res["BuyerIdCard"] = boost::any(*buyerIdCard);
    }
    if (cardNo) {
      res["CardNo"] = boost::any(*cardNo);
    }
    if (cardType) {
      res["CardType"] = boost::any(*cardType);
    }
    if (complete) {
      res["Complete"] = boost::any(*complete);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactMobile) {
      res["ContactMobile"] = boost::any(*contactMobile);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notarization) {
      res["Notarization"] = boost::any(*notarization);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (other) {
      res["Other"] = boost::any(*other);
    }
    if (registrationCert) {
      res["RegistrationCert"] = boost::any(*registrationCert);
    }
    if (sellerApply) {
      res["SellerApply"] = boost::any(*sellerApply);
    }
    if (sellerBusinessLicense) {
      res["SellerBusinessLicense"] = boost::any(*sellerBusinessLicense);
    }
    if (sellerBusinessLicenseTranslation) {
      res["SellerBusinessLicenseTranslation"] = boost::any(*sellerBusinessLicenseTranslation);
    }
    if (sellerIdCard) {
      res["SellerIdCard"] = boost::any(*sellerIdCard);
    }
    if (sellerProxy) {
      res["SellerProxy"] = boost::any(*sellerProxy);
    }
    if (tradeMaterialFullUpdate) {
      res["TradeMaterialFullUpdate"] = boost::any(*tradeMaterialFullUpdate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      addr = make_shared<string>(boost::any_cast<string>(m["Addr"]));
    }
    if (m.find("AssigneeProxy") != m.end() && !m["AssigneeProxy"].empty()) {
      assigneeProxy = make_shared<string>(boost::any_cast<string>(m["AssigneeProxy"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BuyerBusinessLicense") != m.end() && !m["BuyerBusinessLicense"].empty()) {
      buyerBusinessLicense = make_shared<string>(boost::any_cast<string>(m["BuyerBusinessLicense"]));
    }
    if (m.find("BuyerBusinessLicenseTranslation") != m.end() && !m["BuyerBusinessLicenseTranslation"].empty()) {
      buyerBusinessLicenseTranslation = make_shared<string>(boost::any_cast<string>(m["BuyerBusinessLicenseTranslation"]));
    }
    if (m.find("BuyerIdCard") != m.end() && !m["BuyerIdCard"].empty()) {
      buyerIdCard = make_shared<string>(boost::any_cast<string>(m["BuyerIdCard"]));
    }
    if (m.find("CardNo") != m.end() && !m["CardNo"].empty()) {
      cardNo = make_shared<string>(boost::any_cast<string>(m["CardNo"]));
    }
    if (m.find("CardType") != m.end() && !m["CardType"].empty()) {
      cardType = make_shared<string>(boost::any_cast<string>(m["CardType"]));
    }
    if (m.find("Complete") != m.end() && !m["Complete"].empty()) {
      complete = make_shared<bool>(boost::any_cast<bool>(m["Complete"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactMobile") != m.end() && !m["ContactMobile"].empty()) {
      contactMobile = make_shared<string>(boost::any_cast<string>(m["ContactMobile"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notarization") != m.end() && !m["Notarization"].empty()) {
      notarization = make_shared<string>(boost::any_cast<string>(m["Notarization"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("Other") != m.end() && !m["Other"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Other"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      other = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RegistrationCert") != m.end() && !m["RegistrationCert"].empty()) {
      registrationCert = make_shared<string>(boost::any_cast<string>(m["RegistrationCert"]));
    }
    if (m.find("SellerApply") != m.end() && !m["SellerApply"].empty()) {
      sellerApply = make_shared<string>(boost::any_cast<string>(m["SellerApply"]));
    }
    if (m.find("SellerBusinessLicense") != m.end() && !m["SellerBusinessLicense"].empty()) {
      sellerBusinessLicense = make_shared<string>(boost::any_cast<string>(m["SellerBusinessLicense"]));
    }
    if (m.find("SellerBusinessLicenseTranslation") != m.end() && !m["SellerBusinessLicenseTranslation"].empty()) {
      sellerBusinessLicenseTranslation = make_shared<string>(boost::any_cast<string>(m["SellerBusinessLicenseTranslation"]));
    }
    if (m.find("SellerIdCard") != m.end() && !m["SellerIdCard"].empty()) {
      sellerIdCard = make_shared<string>(boost::any_cast<string>(m["SellerIdCard"]));
    }
    if (m.find("SellerProxy") != m.end() && !m["SellerProxy"].empty()) {
      sellerProxy = make_shared<string>(boost::any_cast<string>(m["SellerProxy"]));
    }
    if (m.find("TradeMaterialFullUpdate") != m.end() && !m["TradeMaterialFullUpdate"].empty()) {
      tradeMaterialFullUpdate = make_shared<bool>(boost::any_cast<bool>(m["TradeMaterialFullUpdate"]));
    }
  }


  virtual ~ModifySubmitTransferMaterailRequest() = default;
};
class ModifySubmitTransferMaterailShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> addr{};
  shared_ptr<string> assigneeProxy{};
  shared_ptr<string> bizId{};
  shared_ptr<string> buyerBusinessLicense{};
  shared_ptr<string> buyerBusinessLicenseTranslation{};
  shared_ptr<string> buyerIdCard{};
  shared_ptr<string> cardNo{};
  shared_ptr<string> cardType{};
  shared_ptr<bool> complete{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactMobile{};
  shared_ptr<string> contactName{};
  shared_ptr<string> name{};
  shared_ptr<string> notarization{};
  shared_ptr<string> note{};
  shared_ptr<string> otherShrink{};
  shared_ptr<string> registrationCert{};
  shared_ptr<string> sellerApply{};
  shared_ptr<string> sellerBusinessLicense{};
  shared_ptr<string> sellerBusinessLicenseTranslation{};
  shared_ptr<string> sellerIdCard{};
  shared_ptr<string> sellerProxy{};
  shared_ptr<bool> tradeMaterialFullUpdate{};

  ModifySubmitTransferMaterailShrinkRequest() {}

  explicit ModifySubmitTransferMaterailShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      res["Addr"] = boost::any(*addr);
    }
    if (assigneeProxy) {
      res["AssigneeProxy"] = boost::any(*assigneeProxy);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (buyerBusinessLicense) {
      res["BuyerBusinessLicense"] = boost::any(*buyerBusinessLicense);
    }
    if (buyerBusinessLicenseTranslation) {
      res["BuyerBusinessLicenseTranslation"] = boost::any(*buyerBusinessLicenseTranslation);
    }
    if (buyerIdCard) {
      res["BuyerIdCard"] = boost::any(*buyerIdCard);
    }
    if (cardNo) {
      res["CardNo"] = boost::any(*cardNo);
    }
    if (cardType) {
      res["CardType"] = boost::any(*cardType);
    }
    if (complete) {
      res["Complete"] = boost::any(*complete);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactMobile) {
      res["ContactMobile"] = boost::any(*contactMobile);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notarization) {
      res["Notarization"] = boost::any(*notarization);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (otherShrink) {
      res["Other"] = boost::any(*otherShrink);
    }
    if (registrationCert) {
      res["RegistrationCert"] = boost::any(*registrationCert);
    }
    if (sellerApply) {
      res["SellerApply"] = boost::any(*sellerApply);
    }
    if (sellerBusinessLicense) {
      res["SellerBusinessLicense"] = boost::any(*sellerBusinessLicense);
    }
    if (sellerBusinessLicenseTranslation) {
      res["SellerBusinessLicenseTranslation"] = boost::any(*sellerBusinessLicenseTranslation);
    }
    if (sellerIdCard) {
      res["SellerIdCard"] = boost::any(*sellerIdCard);
    }
    if (sellerProxy) {
      res["SellerProxy"] = boost::any(*sellerProxy);
    }
    if (tradeMaterialFullUpdate) {
      res["TradeMaterialFullUpdate"] = boost::any(*tradeMaterialFullUpdate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      addr = make_shared<string>(boost::any_cast<string>(m["Addr"]));
    }
    if (m.find("AssigneeProxy") != m.end() && !m["AssigneeProxy"].empty()) {
      assigneeProxy = make_shared<string>(boost::any_cast<string>(m["AssigneeProxy"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BuyerBusinessLicense") != m.end() && !m["BuyerBusinessLicense"].empty()) {
      buyerBusinessLicense = make_shared<string>(boost::any_cast<string>(m["BuyerBusinessLicense"]));
    }
    if (m.find("BuyerBusinessLicenseTranslation") != m.end() && !m["BuyerBusinessLicenseTranslation"].empty()) {
      buyerBusinessLicenseTranslation = make_shared<string>(boost::any_cast<string>(m["BuyerBusinessLicenseTranslation"]));
    }
    if (m.find("BuyerIdCard") != m.end() && !m["BuyerIdCard"].empty()) {
      buyerIdCard = make_shared<string>(boost::any_cast<string>(m["BuyerIdCard"]));
    }
    if (m.find("CardNo") != m.end() && !m["CardNo"].empty()) {
      cardNo = make_shared<string>(boost::any_cast<string>(m["CardNo"]));
    }
    if (m.find("CardType") != m.end() && !m["CardType"].empty()) {
      cardType = make_shared<string>(boost::any_cast<string>(m["CardType"]));
    }
    if (m.find("Complete") != m.end() && !m["Complete"].empty()) {
      complete = make_shared<bool>(boost::any_cast<bool>(m["Complete"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactMobile") != m.end() && !m["ContactMobile"].empty()) {
      contactMobile = make_shared<string>(boost::any_cast<string>(m["ContactMobile"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Notarization") != m.end() && !m["Notarization"].empty()) {
      notarization = make_shared<string>(boost::any_cast<string>(m["Notarization"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("Other") != m.end() && !m["Other"].empty()) {
      otherShrink = make_shared<string>(boost::any_cast<string>(m["Other"]));
    }
    if (m.find("RegistrationCert") != m.end() && !m["RegistrationCert"].empty()) {
      registrationCert = make_shared<string>(boost::any_cast<string>(m["RegistrationCert"]));
    }
    if (m.find("SellerApply") != m.end() && !m["SellerApply"].empty()) {
      sellerApply = make_shared<string>(boost::any_cast<string>(m["SellerApply"]));
    }
    if (m.find("SellerBusinessLicense") != m.end() && !m["SellerBusinessLicense"].empty()) {
      sellerBusinessLicense = make_shared<string>(boost::any_cast<string>(m["SellerBusinessLicense"]));
    }
    if (m.find("SellerBusinessLicenseTranslation") != m.end() && !m["SellerBusinessLicenseTranslation"].empty()) {
      sellerBusinessLicenseTranslation = make_shared<string>(boost::any_cast<string>(m["SellerBusinessLicenseTranslation"]));
    }
    if (m.find("SellerIdCard") != m.end() && !m["SellerIdCard"].empty()) {
      sellerIdCard = make_shared<string>(boost::any_cast<string>(m["SellerIdCard"]));
    }
    if (m.find("SellerProxy") != m.end() && !m["SellerProxy"].empty()) {
      sellerProxy = make_shared<string>(boost::any_cast<string>(m["SellerProxy"]));
    }
    if (m.find("TradeMaterialFullUpdate") != m.end() && !m["TradeMaterialFullUpdate"].empty()) {
      tradeMaterialFullUpdate = make_shared<bool>(boost::any_cast<bool>(m["TradeMaterialFullUpdate"]));
    }
  }


  virtual ~ModifySubmitTransferMaterailShrinkRequest() = default;
};
class ModifySubmitTransferMaterailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifySubmitTransferMaterailResponseBody() {}

  explicit ModifySubmitTransferMaterailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifySubmitTransferMaterailResponseBody() = default;
};
class ModifySubmitTransferMaterailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySubmitTransferMaterailResponseBody> body{};

  ModifySubmitTransferMaterailResponse() {}

  explicit ModifySubmitTransferMaterailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySubmitTransferMaterailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySubmitTransferMaterailResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySubmitTransferMaterailResponse() = default;
};
class OperateProduceRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};
  shared_ptr<string> extMap{};
  shared_ptr<string> operateType{};

  OperateProduceRequest() {}

  explicit OperateProduceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (extMap) {
      res["ExtMap"] = boost::any(*extMap);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExtMap") != m.end() && !m["ExtMap"].empty()) {
      extMap = make_shared<string>(boost::any_cast<string>(m["ExtMap"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
  }


  virtual ~OperateProduceRequest() = default;
};
class OperateProduceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OperateProduceResponseBody() {}

  explicit OperateProduceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~OperateProduceResponseBody() = default;
};
class OperateProduceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateProduceResponseBody> body{};

  OperateProduceResponse() {}

  explicit OperateProduceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateProduceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateProduceResponseBody>(model1);
      }
    }
  }


  virtual ~OperateProduceResponse() = default;
};
class PartnerUpdateTrademarkNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunKp{};
  shared_ptr<string> bid{};
  shared_ptr<string> bizId{};
  shared_ptr<long> callerParentId{};
  shared_ptr<string> callerType{};
  shared_ptr<long> eventSceneType{};
  shared_ptr<string> intentionBizId{};
  shared_ptr<string> tmComment{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<long> type{};

  PartnerUpdateTrademarkNameRequest() {}

  explicit PartnerUpdateTrademarkNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunKp) {
      res["AliyunKp"] = boost::any(*aliyunKp);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (callerParentId) {
      res["CallerParentId"] = boost::any(*callerParentId);
    }
    if (callerType) {
      res["CallerType"] = boost::any(*callerType);
    }
    if (eventSceneType) {
      res["EventSceneType"] = boost::any(*eventSceneType);
    }
    if (intentionBizId) {
      res["IntentionBizId"] = boost::any(*intentionBizId);
    }
    if (tmComment) {
      res["TmComment"] = boost::any(*tmComment);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunKp") != m.end() && !m["AliyunKp"].empty()) {
      aliyunKp = make_shared<string>(boost::any_cast<string>(m["AliyunKp"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CallerParentId") != m.end() && !m["CallerParentId"].empty()) {
      callerParentId = make_shared<long>(boost::any_cast<long>(m["CallerParentId"]));
    }
    if (m.find("CallerType") != m.end() && !m["CallerType"].empty()) {
      callerType = make_shared<string>(boost::any_cast<string>(m["CallerType"]));
    }
    if (m.find("EventSceneType") != m.end() && !m["EventSceneType"].empty()) {
      eventSceneType = make_shared<long>(boost::any_cast<long>(m["EventSceneType"]));
    }
    if (m.find("IntentionBizId") != m.end() && !m["IntentionBizId"].empty()) {
      intentionBizId = make_shared<string>(boost::any_cast<string>(m["IntentionBizId"]));
    }
    if (m.find("TmComment") != m.end() && !m["TmComment"].empty()) {
      tmComment = make_shared<string>(boost::any_cast<string>(m["TmComment"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~PartnerUpdateTrademarkNameRequest() = default;
};
class PartnerUpdateTrademarkNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> allowRetry{};
  shared_ptr<string> appName{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PartnerUpdateTrademarkNameResponseBody() {}

  explicit PartnerUpdateTrademarkNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowRetry) {
      res["AllowRetry"] = boost::any(*allowRetry);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowRetry") != m.end() && !m["AllowRetry"].empty()) {
      allowRetry = make_shared<bool>(boost::any_cast<bool>(m["AllowRetry"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PartnerUpdateTrademarkNameResponseBody() = default;
};
class PartnerUpdateTrademarkNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PartnerUpdateTrademarkNameResponseBody> body{};

  PartnerUpdateTrademarkNameResponse() {}

  explicit PartnerUpdateTrademarkNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PartnerUpdateTrademarkNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PartnerUpdateTrademarkNameResponseBody>(model1);
      }
    }
  }


  virtual ~PartnerUpdateTrademarkNameResponse() = default;
};
class QueryCommunicationLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> type{};

  QueryCommunicationLogsRequest() {}

  explicit QueryCommunicationLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryCommunicationLogsRequest() = default;
};
class QueryCommunicationLogsResponseBodyDataTaskList : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> note{};
  shared_ptr<string> partnerCode{};
  shared_ptr<long> updateTime{};

  QueryCommunicationLogsResponseBodyDataTaskList() {}

  explicit QueryCommunicationLogsResponseBodyDataTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (partnerCode) {
      res["PartnerCode"] = boost::any(*partnerCode);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("PartnerCode") != m.end() && !m["PartnerCode"].empty()) {
      partnerCode = make_shared<string>(boost::any_cast<string>(m["PartnerCode"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~QueryCommunicationLogsResponseBodyDataTaskList() = default;
};
class QueryCommunicationLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCommunicationLogsResponseBodyDataTaskList>> taskList{};

  QueryCommunicationLogsResponseBodyData() {}

  explicit QueryCommunicationLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskList) {
      vector<boost::any> temp1;
      for(auto item1:*taskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskList"].type()) {
        vector<QueryCommunicationLogsResponseBodyDataTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCommunicationLogsResponseBodyDataTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskList = make_shared<vector<QueryCommunicationLogsResponseBodyDataTaskList>>(expect1);
      }
    }
  }


  virtual ~QueryCommunicationLogsResponseBodyData() = default;
};
class QueryCommunicationLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryCommunicationLogsResponseBodyData> data{};
  shared_ptr<string> requestId{};

  QueryCommunicationLogsResponseBody() {}

  explicit QueryCommunicationLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryCommunicationLogsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryCommunicationLogsResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryCommunicationLogsResponseBody() = default;
};
class QueryCommunicationLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCommunicationLogsResponseBody> body{};

  QueryCommunicationLogsResponse() {}

  explicit QueryCommunicationLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCommunicationLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCommunicationLogsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCommunicationLogsResponse() = default;
};
class QueryCredentialsInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> companyName{};
  shared_ptr<string> materialType{};
  shared_ptr<string> ossKey{};

  QueryCredentialsInfoRequest() {}

  explicit QueryCredentialsInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (companyName) {
      res["CompanyName"] = boost::any(*companyName);
    }
    if (materialType) {
      res["MaterialType"] = boost::any(*materialType);
    }
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompanyName") != m.end() && !m["CompanyName"].empty()) {
      companyName = make_shared<string>(boost::any_cast<string>(m["CompanyName"]));
    }
    if (m.find("MaterialType") != m.end() && !m["MaterialType"].empty()) {
      materialType = make_shared<string>(boost::any_cast<string>(m["MaterialType"]));
    }
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["OssKey"]));
    }
  }


  virtual ~QueryCredentialsInfoRequest() = default;
};
class QueryCredentialsInfoResponseBodyCredentialsInfo : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> companyName{};
  shared_ptr<string> personName{};
  shared_ptr<string> province{};

  QueryCredentialsInfoResponseBodyCredentialsInfo() {}

  explicit QueryCredentialsInfoResponseBodyCredentialsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (companyName) {
      res["CompanyName"] = boost::any(*companyName);
    }
    if (personName) {
      res["PersonName"] = boost::any(*personName);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("CompanyName") != m.end() && !m["CompanyName"].empty()) {
      companyName = make_shared<string>(boost::any_cast<string>(m["CompanyName"]));
    }
    if (m.find("PersonName") != m.end() && !m["PersonName"].empty()) {
      personName = make_shared<string>(boost::any_cast<string>(m["PersonName"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~QueryCredentialsInfoResponseBodyCredentialsInfo() = default;
};
class QueryCredentialsInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryCredentialsInfoResponseBodyCredentialsInfo> credentialsInfo{};
  shared_ptr<string> requestId{};

  QueryCredentialsInfoResponseBody() {}

  explicit QueryCredentialsInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialsInfo) {
      res["CredentialsInfo"] = credentialsInfo ? boost::any(credentialsInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialsInfo") != m.end() && !m["CredentialsInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialsInfo"].type()) {
        QueryCredentialsInfoResponseBodyCredentialsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialsInfo"]));
        credentialsInfo = make_shared<QueryCredentialsInfoResponseBodyCredentialsInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryCredentialsInfoResponseBody() = default;
};
class QueryCredentialsInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCredentialsInfoResponseBody> body{};

  QueryCredentialsInfoResponse() {}

  explicit QueryCredentialsInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCredentialsInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCredentialsInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCredentialsInfoResponse() = default;
};
class QueryExtensionAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> attributeKey{};
  shared_ptr<string> bizId{};

  QueryExtensionAttributeRequest() {}

  explicit QueryExtensionAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeKey) {
      res["AttributeKey"] = boost::any(*attributeKey);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeKey") != m.end() && !m["AttributeKey"].empty()) {
      attributeKey = make_shared<string>(boost::any_cast<string>(m["AttributeKey"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~QueryExtensionAttributeRequest() = default;
};
class QueryExtensionAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> attributeValue{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryExtensionAttributeResponseBody() {}

  explicit QueryExtensionAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeValue) {
      res["AttributeValue"] = boost::any(*attributeValue);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeValue") != m.end() && !m["AttributeValue"].empty()) {
      attributeValue = make_shared<string>(boost::any_cast<string>(m["AttributeValue"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryExtensionAttributeResponseBody() = default;
};
class QueryExtensionAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryExtensionAttributeResponseBody> body{};

  QueryExtensionAttributeResponse() {}

  explicit QueryExtensionAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryExtensionAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryExtensionAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~QueryExtensionAttributeResponse() = default;
};
class QueryIntentionDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};

  QueryIntentionDetailRequest() {}

  explicit QueryIntentionDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~QueryIntentionDetailRequest() = default;
};
class QueryIntentionDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> classification{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> mobile{};
  shared_ptr<string> partnerMobile{};
  shared_ptr<string> registerNumber{};
  shared_ptr<string> relationBizId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> status{};
  shared_ptr<long> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  QueryIntentionDetailResponseBody() {}

  explicit QueryIntentionDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (partnerMobile) {
      res["PartnerMobile"] = boost::any(*partnerMobile);
    }
    if (registerNumber) {
      res["RegisterNumber"] = boost::any(*registerNumber);
    }
    if (relationBizId) {
      res["RelationBizId"] = boost::any(*relationBizId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("PartnerMobile") != m.end() && !m["PartnerMobile"].empty()) {
      partnerMobile = make_shared<string>(boost::any_cast<string>(m["PartnerMobile"]));
    }
    if (m.find("RegisterNumber") != m.end() && !m["RegisterNumber"].empty()) {
      registerNumber = make_shared<string>(boost::any_cast<string>(m["RegisterNumber"]));
    }
    if (m.find("RelationBizId") != m.end() && !m["RelationBizId"].empty()) {
      relationBizId = make_shared<string>(boost::any_cast<string>(m["RelationBizId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~QueryIntentionDetailResponseBody() = default;
};
class QueryIntentionDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryIntentionDetailResponseBody> body{};

  QueryIntentionDetailResponse() {}

  explicit QueryIntentionDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryIntentionDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryIntentionDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryIntentionDetailResponse() = default;
};
class QueryIntentionListRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortFiled{};
  shared_ptr<string> sortOrder{};
  shared_ptr<long> status{};
  shared_ptr<long> type{};

  QueryIntentionListRequest() {}

  explicit QueryIntentionListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortFiled) {
      res["SortFiled"] = boost::any(*sortFiled);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortFiled") != m.end() && !m["SortFiled"].empty()) {
      sortFiled = make_shared<string>(boost::any_cast<string>(m["SortFiled"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryIntentionListRequest() = default;
};
class QueryIntentionListResponseBodyDataIntention : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> classification{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> registerNumber{};
  shared_ptr<long> status{};
  shared_ptr<long> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  QueryIntentionListResponseBodyDataIntention() {}

  explicit QueryIntentionListResponseBodyDataIntention(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (registerNumber) {
      res["RegisterNumber"] = boost::any(*registerNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegisterNumber") != m.end() && !m["RegisterNumber"].empty()) {
      registerNumber = make_shared<string>(boost::any_cast<string>(m["RegisterNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryIntentionListResponseBodyDataIntention() = default;
};
class QueryIntentionListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryIntentionListResponseBodyDataIntention>> intention{};

  QueryIntentionListResponseBodyData() {}

  explicit QueryIntentionListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (intention) {
      vector<boost::any> temp1;
      for(auto item1:*intention){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Intention"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Intention") != m.end() && !m["Intention"].empty()) {
      if (typeid(vector<boost::any>) == m["Intention"].type()) {
        vector<QueryIntentionListResponseBodyDataIntention> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Intention"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryIntentionListResponseBodyDataIntention model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        intention = make_shared<vector<QueryIntentionListResponseBodyDataIntention>>(expect1);
      }
    }
  }


  virtual ~QueryIntentionListResponseBodyData() = default;
};
class QueryIntentionListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<QueryIntentionListResponseBodyData> data{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryIntentionListResponseBody() {}

  explicit QueryIntentionListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryIntentionListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryIntentionListResponseBodyData>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryIntentionListResponseBody() = default;
};
class QueryIntentionListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryIntentionListResponseBody> body{};

  QueryIntentionListResponse() {}

  explicit QueryIntentionListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryIntentionListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryIntentionListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryIntentionListResponse() = default;
};
class QueryIntentionOwnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};

  QueryIntentionOwnerRequest() {}

  explicit QueryIntentionOwnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~QueryIntentionOwnerRequest() = default;
};
class QueryIntentionOwnerResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<double> ownerId{};
  shared_ptr<string> ownerName{};

  QueryIntentionOwnerResponseBodyModule() {}

  explicit QueryIntentionOwnerResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<double>(boost::any_cast<double>(m["OwnerId"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
  }


  virtual ~QueryIntentionOwnerResponseBodyModule() = default;
};
class QueryIntentionOwnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<QueryIntentionOwnerResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryIntentionOwnerResponseBody() {}

  explicit QueryIntentionOwnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (module) {
      res["Module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("Module") != m.end() && !m["Module"].empty()) {
      if (typeid(map<string, boost::any>) == m["Module"].type()) {
        QueryIntentionOwnerResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Module"]));
        module = make_shared<QueryIntentionOwnerResponseBodyModule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryIntentionOwnerResponseBody() = default;
};
class QueryIntentionOwnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryIntentionOwnerResponseBody> body{};

  QueryIntentionOwnerResponse() {}

  explicit QueryIntentionOwnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryIntentionOwnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryIntentionOwnerResponseBody>(model1);
      }
    }
  }


  virtual ~QueryIntentionOwnerResponse() = default;
};
class QueryIntentionPriceRequest : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<string> intentionBizId{};

  QueryIntentionPriceRequest() {}

  explicit QueryIntentionPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (intentionBizId) {
      res["IntentionBizId"] = boost::any(*intentionBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("IntentionBizId") != m.end() && !m["IntentionBizId"].empty()) {
      intentionBizId = make_shared<string>(boost::any_cast<string>(m["IntentionBizId"]));
    }
  }


  virtual ~QueryIntentionPriceRequest() = default;
};
class QueryIntentionPriceResponseBodyDataTmProducesFirstClassification : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryIntentionPriceResponseBodyDataTmProducesFirstClassification() {}

  explicit QueryIntentionPriceResponseBodyDataTmProducesFirstClassification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryIntentionPriceResponseBodyDataTmProducesFirstClassification() = default;
};
class QueryIntentionPriceResponseBodyDataTmProducesThirdClassificationThirdClassifications : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryIntentionPriceResponseBodyDataTmProducesThirdClassificationThirdClassifications() {}

  explicit QueryIntentionPriceResponseBodyDataTmProducesThirdClassificationThirdClassifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryIntentionPriceResponseBodyDataTmProducesThirdClassificationThirdClassifications() = default;
};
class QueryIntentionPriceResponseBodyDataTmProducesThirdClassification : public Darabonba::Model {
public:
  shared_ptr<vector<QueryIntentionPriceResponseBodyDataTmProducesThirdClassificationThirdClassifications>> thirdClassifications{};

  QueryIntentionPriceResponseBodyDataTmProducesThirdClassification() {}

  explicit QueryIntentionPriceResponseBodyDataTmProducesThirdClassification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thirdClassifications) {
      vector<boost::any> temp1;
      for(auto item1:*thirdClassifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ThirdClassifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThirdClassifications") != m.end() && !m["ThirdClassifications"].empty()) {
      if (typeid(vector<boost::any>) == m["ThirdClassifications"].type()) {
        vector<QueryIntentionPriceResponseBodyDataTmProducesThirdClassificationThirdClassifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ThirdClassifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryIntentionPriceResponseBodyDataTmProducesThirdClassificationThirdClassifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        thirdClassifications = make_shared<vector<QueryIntentionPriceResponseBodyDataTmProducesThirdClassificationThirdClassifications>>(expect1);
      }
    }
  }


  virtual ~QueryIntentionPriceResponseBodyDataTmProducesThirdClassification() = default;
};
class QueryIntentionPriceResponseBodyDataTmProduces : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> createTime{};
  shared_ptr<QueryIntentionPriceResponseBodyDataTmProducesFirstClassification> firstClassification{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> materialId{};
  shared_ptr<string> materialName{};
  shared_ptr<string> note{};
  shared_ptr<double> orderPrice{};
  shared_ptr<double> servicePrice{};
  shared_ptr<long> status{};
  shared_ptr<long> supplementId{};
  shared_ptr<long> supplementStatus{};
  shared_ptr<QueryIntentionPriceResponseBodyDataTmProducesThirdClassification> thirdClassification{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNumber{};
  shared_ptr<double> totalPrice{};
  shared_ptr<long> type{};
  shared_ptr<long> updateTime{};

  QueryIntentionPriceResponseBodyDataTmProduces() {}

  explicit QueryIntentionPriceResponseBodyDataTmProduces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (firstClassification) {
      res["FirstClassification"] = firstClassification ? boost::any(firstClassification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (materialName) {
      res["MaterialName"] = boost::any(*materialName);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (orderPrice) {
      res["OrderPrice"] = boost::any(*orderPrice);
    }
    if (servicePrice) {
      res["ServicePrice"] = boost::any(*servicePrice);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (supplementId) {
      res["SupplementId"] = boost::any(*supplementId);
    }
    if (supplementStatus) {
      res["SupplementStatus"] = boost::any(*supplementStatus);
    }
    if (thirdClassification) {
      res["ThirdClassification"] = thirdClassification ? boost::any(thirdClassification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (totalPrice) {
      res["TotalPrice"] = boost::any(*totalPrice);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FirstClassification") != m.end() && !m["FirstClassification"].empty()) {
      if (typeid(map<string, boost::any>) == m["FirstClassification"].type()) {
        QueryIntentionPriceResponseBodyDataTmProducesFirstClassification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FirstClassification"]));
        firstClassification = make_shared<QueryIntentionPriceResponseBodyDataTmProducesFirstClassification>(model1);
      }
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("MaterialName") != m.end() && !m["MaterialName"].empty()) {
      materialName = make_shared<string>(boost::any_cast<string>(m["MaterialName"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("OrderPrice") != m.end() && !m["OrderPrice"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["OrderPrice"]));
    }
    if (m.find("ServicePrice") != m.end() && !m["ServicePrice"].empty()) {
      servicePrice = make_shared<double>(boost::any_cast<double>(m["ServicePrice"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SupplementId") != m.end() && !m["SupplementId"].empty()) {
      supplementId = make_shared<long>(boost::any_cast<long>(m["SupplementId"]));
    }
    if (m.find("SupplementStatus") != m.end() && !m["SupplementStatus"].empty()) {
      supplementStatus = make_shared<long>(boost::any_cast<long>(m["SupplementStatus"]));
    }
    if (m.find("ThirdClassification") != m.end() && !m["ThirdClassification"].empty()) {
      if (typeid(map<string, boost::any>) == m["ThirdClassification"].type()) {
        QueryIntentionPriceResponseBodyDataTmProducesThirdClassification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ThirdClassification"]));
        thirdClassification = make_shared<QueryIntentionPriceResponseBodyDataTmProducesThirdClassification>(model1);
      }
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("TotalPrice") != m.end() && !m["TotalPrice"].empty()) {
      totalPrice = make_shared<double>(boost::any_cast<double>(m["TotalPrice"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~QueryIntentionPriceResponseBodyDataTmProduces() = default;
};
class QueryIntentionPriceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryIntentionPriceResponseBodyDataTmProduces>> tmProduces{};

  QueryIntentionPriceResponseBodyData() {}

  explicit QueryIntentionPriceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tmProduces) {
      vector<boost::any> temp1;
      for(auto item1:*tmProduces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TmProduces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TmProduces") != m.end() && !m["TmProduces"].empty()) {
      if (typeid(vector<boost::any>) == m["TmProduces"].type()) {
        vector<QueryIntentionPriceResponseBodyDataTmProduces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TmProduces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryIntentionPriceResponseBodyDataTmProduces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tmProduces = make_shared<vector<QueryIntentionPriceResponseBodyDataTmProduces>>(expect1);
      }
    }
  }


  virtual ~QueryIntentionPriceResponseBodyData() = default;
};
class QueryIntentionPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<QueryIntentionPriceResponseBodyData> data{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryIntentionPriceResponseBody() {}

  explicit QueryIntentionPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryIntentionPriceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryIntentionPriceResponseBodyData>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryIntentionPriceResponseBody() = default;
};
class QueryIntentionPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryIntentionPriceResponseBody> body{};

  QueryIntentionPriceResponse() {}

  explicit QueryIntentionPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryIntentionPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryIntentionPriceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryIntentionPriceResponse() = default;
};
class QueryMaterialRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<bool> queryUnconfirmedInfo{};

  QueryMaterialRequest() {}

  explicit QueryMaterialRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (queryUnconfirmedInfo) {
      res["QueryUnconfirmedInfo"] = boost::any(*queryUnconfirmedInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("QueryUnconfirmedInfo") != m.end() && !m["QueryUnconfirmedInfo"].empty()) {
      queryUnconfirmedInfo = make_shared<bool>(boost::any_cast<bool>(m["QueryUnconfirmedInfo"]));
    }
  }


  virtual ~QueryMaterialRequest() = default;
};
class QueryMaterialResponseBodyReviewAdditionalFiles : public Darabonba::Model {
public:
  shared_ptr<vector<string>> reviewAdditionalFile{};

  QueryMaterialResponseBodyReviewAdditionalFiles() {}

  explicit QueryMaterialResponseBodyReviewAdditionalFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reviewAdditionalFile) {
      res["ReviewAdditionalFile"] = boost::any(*reviewAdditionalFile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReviewAdditionalFile") != m.end() && !m["ReviewAdditionalFile"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReviewAdditionalFile"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReviewAdditionalFile"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reviewAdditionalFile = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMaterialResponseBodyReviewAdditionalFiles() = default;
};
class QueryMaterialResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> businessLicenceUrl{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> city{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactCity{};
  shared_ptr<string> contactCounty{};
  shared_ptr<string> contactDistrict{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactNumber{};
  shared_ptr<string> contactProvince{};
  shared_ptr<string> contactZipcode{};
  shared_ptr<string> country{};
  shared_ptr<string> EAddress{};
  shared_ptr<string> EName{};
  shared_ptr<string> evidenceCatalogPath{};
  shared_ptr<string> evidenceOfservicePath{};
  shared_ptr<string> evidencePath{};
  shared_ptr<long> expirationDate{};
  shared_ptr<string> factandreasonPdfPath{};
  shared_ptr<string> fgsqPath{};
  shared_ptr<string> fileBgPath{};
  shared_ptr<string> fileFsSqPath{};
  shared_ptr<string> fileGtPath{};
  shared_ptr<string> fileYgPath{};
  shared_ptr<long> id{};
  shared_ptr<string> idCardName{};
  shared_ptr<string> idCardNumber{};
  shared_ptr<string> idCardUrl{};
  shared_ptr<string> legalNoticeKey{};
  shared_ptr<string> legalNoticeUrl{};
  shared_ptr<long> loaStatus{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> materialVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> note{};
  shared_ptr<string> passportUrl{};
  shared_ptr<long> personalType{};
  shared_ptr<string> principalDescription{};
  shared_ptr<long> principalName{};
  shared_ptr<string> province{};
  shared_ptr<string> reason{};
  shared_ptr<long> region{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryMaterialResponseBodyReviewAdditionalFiles> reviewAdditionalFiles{};
  shared_ptr<string> reviewApplicationFile{};
  shared_ptr<long> status{};
  shared_ptr<string> supplementEvidenceCatalogFile{};
  shared_ptr<string> supplementEvidenceMaterialFile{};
  shared_ptr<string> supplementReasonFile{};
  shared_ptr<string> systemVersion{};
  shared_ptr<string> town{};
  shared_ptr<long> type{};
  shared_ptr<long> validDate{};

  QueryMaterialResponseBody() {}

  explicit QueryMaterialResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (businessLicenceUrl) {
      res["BusinessLicenceUrl"] = boost::any(*businessLicenceUrl);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactCity) {
      res["ContactCity"] = boost::any(*contactCity);
    }
    if (contactCounty) {
      res["ContactCounty"] = boost::any(*contactCounty);
    }
    if (contactDistrict) {
      res["ContactDistrict"] = boost::any(*contactDistrict);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactNumber) {
      res["ContactNumber"] = boost::any(*contactNumber);
    }
    if (contactProvince) {
      res["ContactProvince"] = boost::any(*contactProvince);
    }
    if (contactZipcode) {
      res["ContactZipcode"] = boost::any(*contactZipcode);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (EAddress) {
      res["EAddress"] = boost::any(*EAddress);
    }
    if (EName) {
      res["EName"] = boost::any(*EName);
    }
    if (evidenceCatalogPath) {
      res["EvidenceCatalogPath"] = boost::any(*evidenceCatalogPath);
    }
    if (evidenceOfservicePath) {
      res["EvidenceOfservicePath"] = boost::any(*evidenceOfservicePath);
    }
    if (evidencePath) {
      res["EvidencePath"] = boost::any(*evidencePath);
    }
    if (expirationDate) {
      res["ExpirationDate"] = boost::any(*expirationDate);
    }
    if (factandreasonPdfPath) {
      res["FactandreasonPdfPath"] = boost::any(*factandreasonPdfPath);
    }
    if (fgsqPath) {
      res["FgsqPath"] = boost::any(*fgsqPath);
    }
    if (fileBgPath) {
      res["FileBgPath"] = boost::any(*fileBgPath);
    }
    if (fileFsSqPath) {
      res["FileFsSqPath"] = boost::any(*fileFsSqPath);
    }
    if (fileGtPath) {
      res["FileGtPath"] = boost::any(*fileGtPath);
    }
    if (fileYgPath) {
      res["FileYgPath"] = boost::any(*fileYgPath);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (idCardName) {
      res["IdCardName"] = boost::any(*idCardName);
    }
    if (idCardNumber) {
      res["IdCardNumber"] = boost::any(*idCardNumber);
    }
    if (idCardUrl) {
      res["IdCardUrl"] = boost::any(*idCardUrl);
    }
    if (legalNoticeKey) {
      res["LegalNoticeKey"] = boost::any(*legalNoticeKey);
    }
    if (legalNoticeUrl) {
      res["LegalNoticeUrl"] = boost::any(*legalNoticeUrl);
    }
    if (loaStatus) {
      res["LoaStatus"] = boost::any(*loaStatus);
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (materialVersion) {
      res["MaterialVersion"] = boost::any(*materialVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (passportUrl) {
      res["PassportUrl"] = boost::any(*passportUrl);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (principalDescription) {
      res["PrincipalDescription"] = boost::any(*principalDescription);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reviewAdditionalFiles) {
      res["ReviewAdditionalFiles"] = reviewAdditionalFiles ? boost::any(reviewAdditionalFiles->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reviewApplicationFile) {
      res["ReviewApplicationFile"] = boost::any(*reviewApplicationFile);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (supplementEvidenceCatalogFile) {
      res["SupplementEvidenceCatalogFile"] = boost::any(*supplementEvidenceCatalogFile);
    }
    if (supplementEvidenceMaterialFile) {
      res["SupplementEvidenceMaterialFile"] = boost::any(*supplementEvidenceMaterialFile);
    }
    if (supplementReasonFile) {
      res["SupplementReasonFile"] = boost::any(*supplementReasonFile);
    }
    if (systemVersion) {
      res["SystemVersion"] = boost::any(*systemVersion);
    }
    if (town) {
      res["Town"] = boost::any(*town);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (validDate) {
      res["ValidDate"] = boost::any(*validDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BusinessLicenceUrl") != m.end() && !m["BusinessLicenceUrl"].empty()) {
      businessLicenceUrl = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceUrl"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactCity") != m.end() && !m["ContactCity"].empty()) {
      contactCity = make_shared<string>(boost::any_cast<string>(m["ContactCity"]));
    }
    if (m.find("ContactCounty") != m.end() && !m["ContactCounty"].empty()) {
      contactCounty = make_shared<string>(boost::any_cast<string>(m["ContactCounty"]));
    }
    if (m.find("ContactDistrict") != m.end() && !m["ContactDistrict"].empty()) {
      contactDistrict = make_shared<string>(boost::any_cast<string>(m["ContactDistrict"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactNumber") != m.end() && !m["ContactNumber"].empty()) {
      contactNumber = make_shared<string>(boost::any_cast<string>(m["ContactNumber"]));
    }
    if (m.find("ContactProvince") != m.end() && !m["ContactProvince"].empty()) {
      contactProvince = make_shared<string>(boost::any_cast<string>(m["ContactProvince"]));
    }
    if (m.find("ContactZipcode") != m.end() && !m["ContactZipcode"].empty()) {
      contactZipcode = make_shared<string>(boost::any_cast<string>(m["ContactZipcode"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("EAddress") != m.end() && !m["EAddress"].empty()) {
      EAddress = make_shared<string>(boost::any_cast<string>(m["EAddress"]));
    }
    if (m.find("EName") != m.end() && !m["EName"].empty()) {
      EName = make_shared<string>(boost::any_cast<string>(m["EName"]));
    }
    if (m.find("EvidenceCatalogPath") != m.end() && !m["EvidenceCatalogPath"].empty()) {
      evidenceCatalogPath = make_shared<string>(boost::any_cast<string>(m["EvidenceCatalogPath"]));
    }
    if (m.find("EvidenceOfservicePath") != m.end() && !m["EvidenceOfservicePath"].empty()) {
      evidenceOfservicePath = make_shared<string>(boost::any_cast<string>(m["EvidenceOfservicePath"]));
    }
    if (m.find("EvidencePath") != m.end() && !m["EvidencePath"].empty()) {
      evidencePath = make_shared<string>(boost::any_cast<string>(m["EvidencePath"]));
    }
    if (m.find("ExpirationDate") != m.end() && !m["ExpirationDate"].empty()) {
      expirationDate = make_shared<long>(boost::any_cast<long>(m["ExpirationDate"]));
    }
    if (m.find("FactandreasonPdfPath") != m.end() && !m["FactandreasonPdfPath"].empty()) {
      factandreasonPdfPath = make_shared<string>(boost::any_cast<string>(m["FactandreasonPdfPath"]));
    }
    if (m.find("FgsqPath") != m.end() && !m["FgsqPath"].empty()) {
      fgsqPath = make_shared<string>(boost::any_cast<string>(m["FgsqPath"]));
    }
    if (m.find("FileBgPath") != m.end() && !m["FileBgPath"].empty()) {
      fileBgPath = make_shared<string>(boost::any_cast<string>(m["FileBgPath"]));
    }
    if (m.find("FileFsSqPath") != m.end() && !m["FileFsSqPath"].empty()) {
      fileFsSqPath = make_shared<string>(boost::any_cast<string>(m["FileFsSqPath"]));
    }
    if (m.find("FileGtPath") != m.end() && !m["FileGtPath"].empty()) {
      fileGtPath = make_shared<string>(boost::any_cast<string>(m["FileGtPath"]));
    }
    if (m.find("FileYgPath") != m.end() && !m["FileYgPath"].empty()) {
      fileYgPath = make_shared<string>(boost::any_cast<string>(m["FileYgPath"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IdCardName") != m.end() && !m["IdCardName"].empty()) {
      idCardName = make_shared<string>(boost::any_cast<string>(m["IdCardName"]));
    }
    if (m.find("IdCardNumber") != m.end() && !m["IdCardNumber"].empty()) {
      idCardNumber = make_shared<string>(boost::any_cast<string>(m["IdCardNumber"]));
    }
    if (m.find("IdCardUrl") != m.end() && !m["IdCardUrl"].empty()) {
      idCardUrl = make_shared<string>(boost::any_cast<string>(m["IdCardUrl"]));
    }
    if (m.find("LegalNoticeKey") != m.end() && !m["LegalNoticeKey"].empty()) {
      legalNoticeKey = make_shared<string>(boost::any_cast<string>(m["LegalNoticeKey"]));
    }
    if (m.find("LegalNoticeUrl") != m.end() && !m["LegalNoticeUrl"].empty()) {
      legalNoticeUrl = make_shared<string>(boost::any_cast<string>(m["LegalNoticeUrl"]));
    }
    if (m.find("LoaStatus") != m.end() && !m["LoaStatus"].empty()) {
      loaStatus = make_shared<long>(boost::any_cast<long>(m["LoaStatus"]));
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("MaterialVersion") != m.end() && !m["MaterialVersion"].empty()) {
      materialVersion = make_shared<string>(boost::any_cast<string>(m["MaterialVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("PassportUrl") != m.end() && !m["PassportUrl"].empty()) {
      passportUrl = make_shared<string>(boost::any_cast<string>(m["PassportUrl"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<long>(boost::any_cast<long>(m["PersonalType"]));
    }
    if (m.find("PrincipalDescription") != m.end() && !m["PrincipalDescription"].empty()) {
      principalDescription = make_shared<string>(boost::any_cast<string>(m["PrincipalDescription"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReviewAdditionalFiles") != m.end() && !m["ReviewAdditionalFiles"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReviewAdditionalFiles"].type()) {
        QueryMaterialResponseBodyReviewAdditionalFiles model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReviewAdditionalFiles"]));
        reviewAdditionalFiles = make_shared<QueryMaterialResponseBodyReviewAdditionalFiles>(model1);
      }
    }
    if (m.find("ReviewApplicationFile") != m.end() && !m["ReviewApplicationFile"].empty()) {
      reviewApplicationFile = make_shared<string>(boost::any_cast<string>(m["ReviewApplicationFile"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SupplementEvidenceCatalogFile") != m.end() && !m["SupplementEvidenceCatalogFile"].empty()) {
      supplementEvidenceCatalogFile = make_shared<string>(boost::any_cast<string>(m["SupplementEvidenceCatalogFile"]));
    }
    if (m.find("SupplementEvidenceMaterialFile") != m.end() && !m["SupplementEvidenceMaterialFile"].empty()) {
      supplementEvidenceMaterialFile = make_shared<string>(boost::any_cast<string>(m["SupplementEvidenceMaterialFile"]));
    }
    if (m.find("SupplementReasonFile") != m.end() && !m["SupplementReasonFile"].empty()) {
      supplementReasonFile = make_shared<string>(boost::any_cast<string>(m["SupplementReasonFile"]));
    }
    if (m.find("SystemVersion") != m.end() && !m["SystemVersion"].empty()) {
      systemVersion = make_shared<string>(boost::any_cast<string>(m["SystemVersion"]));
    }
    if (m.find("Town") != m.end() && !m["Town"].empty()) {
      town = make_shared<string>(boost::any_cast<string>(m["Town"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("ValidDate") != m.end() && !m["ValidDate"].empty()) {
      validDate = make_shared<long>(boost::any_cast<long>(m["ValidDate"]));
    }
  }


  virtual ~QueryMaterialResponseBody() = default;
};
class QueryMaterialResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMaterialResponseBody> body{};

  QueryMaterialResponse() {}

  explicit QueryMaterialResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMaterialResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMaterialResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMaterialResponse() = default;
};
class QueryMaterialListRequest : public Darabonba::Model {
public:
  shared_ptr<string> cardNumber{};
  shared_ptr<long> materialId{};
  shared_ptr<string> materialVersion{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> principalName{};
  shared_ptr<long> region{};
  shared_ptr<long> status{};
  shared_ptr<string> systemVersion{};
  shared_ptr<long> type{};

  QueryMaterialListRequest() {}

  explicit QueryMaterialListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (materialVersion) {
      res["MaterialVersion"] = boost::any(*materialVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemVersion) {
      res["SystemVersion"] = boost::any(*systemVersion);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<long>(boost::any_cast<long>(m["MaterialId"]));
    }
    if (m.find("MaterialVersion") != m.end() && !m["MaterialVersion"].empty()) {
      materialVersion = make_shared<string>(boost::any_cast<string>(m["MaterialVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SystemVersion") != m.end() && !m["SystemVersion"].empty()) {
      systemVersion = make_shared<string>(boost::any_cast<string>(m["SystemVersion"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryMaterialListRequest() = default;
};
class QueryMaterialListResponseBodyDataTrademark : public Darabonba::Model {
public:
  shared_ptr<string> cardNumber{};
  shared_ptr<string> contactName{};
  shared_ptr<long> id{};
  shared_ptr<string> loaKey{};
  shared_ptr<long> loaStatus{};
  shared_ptr<string> materialVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> principalDescription{};
  shared_ptr<long> principalName{};
  shared_ptr<string> reason{};
  shared_ptr<long> region{};
  shared_ptr<long> status{};
  shared_ptr<string> systemVersion{};
  shared_ptr<long> type{};
  shared_ptr<long> validDate{};

  QueryMaterialListResponseBodyDataTrademark() {}

  explicit QueryMaterialListResponseBodyDataTrademark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (loaKey) {
      res["LoaKey"] = boost::any(*loaKey);
    }
    if (loaStatus) {
      res["LoaStatus"] = boost::any(*loaStatus);
    }
    if (materialVersion) {
      res["MaterialVersion"] = boost::any(*materialVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (principalDescription) {
      res["PrincipalDescription"] = boost::any(*principalDescription);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemVersion) {
      res["SystemVersion"] = boost::any(*systemVersion);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (validDate) {
      res["ValidDate"] = boost::any(*validDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LoaKey") != m.end() && !m["LoaKey"].empty()) {
      loaKey = make_shared<string>(boost::any_cast<string>(m["LoaKey"]));
    }
    if (m.find("LoaStatus") != m.end() && !m["LoaStatus"].empty()) {
      loaStatus = make_shared<long>(boost::any_cast<long>(m["LoaStatus"]));
    }
    if (m.find("MaterialVersion") != m.end() && !m["MaterialVersion"].empty()) {
      materialVersion = make_shared<string>(boost::any_cast<string>(m["MaterialVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PrincipalDescription") != m.end() && !m["PrincipalDescription"].empty()) {
      principalDescription = make_shared<string>(boost::any_cast<string>(m["PrincipalDescription"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SystemVersion") != m.end() && !m["SystemVersion"].empty()) {
      systemVersion = make_shared<string>(boost::any_cast<string>(m["SystemVersion"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("ValidDate") != m.end() && !m["ValidDate"].empty()) {
      validDate = make_shared<long>(boost::any_cast<long>(m["ValidDate"]));
    }
  }


  virtual ~QueryMaterialListResponseBodyDataTrademark() = default;
};
class QueryMaterialListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMaterialListResponseBodyDataTrademark>> trademark{};

  QueryMaterialListResponseBodyData() {}

  explicit QueryMaterialListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trademark) {
      vector<boost::any> temp1;
      for(auto item1:*trademark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Trademark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Trademark") != m.end() && !m["Trademark"].empty()) {
      if (typeid(vector<boost::any>) == m["Trademark"].type()) {
        vector<QueryMaterialListResponseBodyDataTrademark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Trademark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMaterialListResponseBodyDataTrademark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trademark = make_shared<vector<QueryMaterialListResponseBodyDataTrademark>>(expect1);
      }
    }
  }


  virtual ~QueryMaterialListResponseBodyData() = default;
};
class QueryMaterialListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<QueryMaterialListResponseBodyData> data{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryMaterialListResponseBody() {}

  explicit QueryMaterialListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryMaterialListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryMaterialListResponseBodyData>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryMaterialListResponseBody() = default;
};
class QueryMaterialListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMaterialListResponseBody> body{};

  QueryMaterialListResponse() {}

  explicit QueryMaterialListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMaterialListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMaterialListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMaterialListResponse() = default;
};
class QueryMonitorKeywordsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> keywords{};
  shared_ptr<long> ruleType{};

  QueryMonitorKeywordsRequest() {}

  explicit QueryMonitorKeywordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
  }


  virtual ~QueryMonitorKeywordsRequest() = default;
};
class QueryMonitorKeywordsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> keywords{};

  QueryMonitorKeywordsResponseBodyData() {}

  explicit QueryMonitorKeywordsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keywords = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMonitorKeywordsResponseBodyData() = default;
};
class QueryMonitorKeywordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMonitorKeywordsResponseBodyData> data{};
  shared_ptr<string> requestId{};

  QueryMonitorKeywordsResponseBody() {}

  explicit QueryMonitorKeywordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryMonitorKeywordsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryMonitorKeywordsResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMonitorKeywordsResponseBody() = default;
};
class QueryMonitorKeywordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMonitorKeywordsResponseBody> body{};

  QueryMonitorKeywordsResponse() {}

  explicit QueryMonitorKeywordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMonitorKeywordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMonitorKeywordsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMonitorKeywordsResponse() = default;
};
class QueryOfficialFileCustomListRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  QueryOfficialFileCustomListRequest() {}

  explicit QueryOfficialFileCustomListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryOfficialFileCustomListRequest() = default;
};
class QueryOfficialFileCustomListResponseBodyDataCustomList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<long> endAcceptTime{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> remark{};
  shared_ptr<long> startAcceptTime{};
  shared_ptr<string> status{};

  QueryOfficialFileCustomListResponseBodyDataCustomList() {}

  explicit QueryOfficialFileCustomListResponseBodyDataCustomList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (endAcceptTime) {
      res["EndAcceptTime"] = boost::any(*endAcceptTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (startAcceptTime) {
      res["StartAcceptTime"] = boost::any(*startAcceptTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("EndAcceptTime") != m.end() && !m["EndAcceptTime"].empty()) {
      endAcceptTime = make_shared<long>(boost::any_cast<long>(m["EndAcceptTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("StartAcceptTime") != m.end() && !m["StartAcceptTime"].empty()) {
      startAcceptTime = make_shared<long>(boost::any_cast<long>(m["StartAcceptTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~QueryOfficialFileCustomListResponseBodyDataCustomList() = default;
};
class QueryOfficialFileCustomListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOfficialFileCustomListResponseBodyDataCustomList>> customList{};

  QueryOfficialFileCustomListResponseBodyData() {}

  explicit QueryOfficialFileCustomListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customList) {
      vector<boost::any> temp1;
      for(auto item1:*customList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomList") != m.end() && !m["CustomList"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomList"].type()) {
        vector<QueryOfficialFileCustomListResponseBodyDataCustomList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOfficialFileCustomListResponseBodyDataCustomList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customList = make_shared<vector<QueryOfficialFileCustomListResponseBodyDataCustomList>>(expect1);
      }
    }
  }


  virtual ~QueryOfficialFileCustomListResponseBodyData() = default;
};
class QueryOfficialFileCustomListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<QueryOfficialFileCustomListResponseBodyData> data{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryOfficialFileCustomListResponseBody() {}

  explicit QueryOfficialFileCustomListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryOfficialFileCustomListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryOfficialFileCustomListResponseBodyData>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryOfficialFileCustomListResponseBody() = default;
};
class QueryOfficialFileCustomListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOfficialFileCustomListResponseBody> body{};

  QueryOfficialFileCustomListResponse() {}

  explicit QueryOfficialFileCustomListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOfficialFileCustomListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOfficialFileCustomListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOfficialFileCustomListResponse() = default;
};
class QueryOrderLogisticsListRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileType{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> produceOrderId{};
  shared_ptr<string> registerNumber{};

  QueryOrderLogisticsListRequest() {}

  explicit QueryOrderLogisticsListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (produceOrderId) {
      res["ProduceOrderId"] = boost::any(*produceOrderId);
    }
    if (registerNumber) {
      res["RegisterNumber"] = boost::any(*registerNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProduceOrderId") != m.end() && !m["ProduceOrderId"].empty()) {
      produceOrderId = make_shared<string>(boost::any_cast<string>(m["ProduceOrderId"]));
    }
    if (m.find("RegisterNumber") != m.end() && !m["RegisterNumber"].empty()) {
      registerNumber = make_shared<string>(boost::any_cast<string>(m["RegisterNumber"]));
    }
  }


  virtual ~QueryOrderLogisticsListRequest() = default;
};
class QueryOrderLogisticsListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> fileIdentifier{};
  shared_ptr<string> fileType{};
  shared_ptr<string> logisticsNo{};
  shared_ptr<string> produceOrderId{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNumber{};

  QueryOrderLogisticsListResponseBodyData() {}

  explicit QueryOrderLogisticsListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (fileIdentifier) {
      res["FileIdentifier"] = boost::any(*fileIdentifier);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (logisticsNo) {
      res["LogisticsNo"] = boost::any(*logisticsNo);
    }
    if (produceOrderId) {
      res["ProduceOrderId"] = boost::any(*produceOrderId);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("FileIdentifier") != m.end() && !m["FileIdentifier"].empty()) {
      fileIdentifier = make_shared<string>(boost::any_cast<string>(m["FileIdentifier"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("LogisticsNo") != m.end() && !m["LogisticsNo"].empty()) {
      logisticsNo = make_shared<string>(boost::any_cast<string>(m["LogisticsNo"]));
    }
    if (m.find("ProduceOrderId") != m.end() && !m["ProduceOrderId"].empty()) {
      produceOrderId = make_shared<string>(boost::any_cast<string>(m["ProduceOrderId"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
  }


  virtual ~QueryOrderLogisticsListResponseBodyData() = default;
};
class QueryOrderLogisticsListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<vector<QueryOrderLogisticsListResponseBodyData>> data{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryOrderLogisticsListResponseBody() {}

  explicit QueryOrderLogisticsListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryOrderLogisticsListResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderLogisticsListResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryOrderLogisticsListResponseBodyData>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryOrderLogisticsListResponseBody() = default;
};
class QueryOrderLogisticsListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrderLogisticsListResponseBody> body{};

  QueryOrderLogisticsListResponse() {}

  explicit QueryOrderLogisticsListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrderLogisticsListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrderLogisticsListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrderLogisticsListResponse() = default;
};
class QueryOssResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};

  QueryOssResourcesRequest() {}

  explicit QueryOssResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~QueryOssResourcesRequest() = default;
};
class QueryOssResourcesResponseBodyDataTaskList : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> name{};
  shared_ptr<string> ossUrl{};
  shared_ptr<long> updateTime{};

  QueryOssResourcesResponseBodyDataTaskList() {}

  explicit QueryOssResourcesResponseBodyDataTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~QueryOssResourcesResponseBodyDataTaskList() = default;
};
class QueryOssResourcesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOssResourcesResponseBodyDataTaskList>> taskList{};

  QueryOssResourcesResponseBodyData() {}

  explicit QueryOssResourcesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskList) {
      vector<boost::any> temp1;
      for(auto item1:*taskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskList"].type()) {
        vector<QueryOssResourcesResponseBodyDataTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOssResourcesResponseBodyDataTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskList = make_shared<vector<QueryOssResourcesResponseBodyDataTaskList>>(expect1);
      }
    }
  }


  virtual ~QueryOssResourcesResponseBodyData() = default;
};
class QueryOssResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryOssResourcesResponseBodyData> data{};
  shared_ptr<string> requestId{};

  QueryOssResourcesResponseBody() {}

  explicit QueryOssResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryOssResourcesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryOssResourcesResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryOssResourcesResponseBody() = default;
};
class QueryOssResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOssResourcesResponseBody> body{};

  QueryOssResourcesResponse() {}

  explicit QueryOssResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOssResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOssResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOssResourcesResponse() = default;
};
class QueryProduceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> applyNo{};
  shared_ptr<string> bizId{};
  shared_ptr<string> orderId{};

  QueryProduceDetailRequest() {}

  explicit QueryProduceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyNo) {
      res["ApplyNo"] = boost::any(*applyNo);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyNo") != m.end() && !m["ApplyNo"].empty()) {
      applyNo = make_shared<string>(boost::any_cast<string>(m["ApplyNo"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~QueryProduceDetailRequest() = default;
};
class QueryProduceDetailResponseBodyFlags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> flags{};

  QueryProduceDetailResponseBodyFlags() {}

  explicit QueryProduceDetailResponseBodyFlags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flags) {
      res["Flags"] = boost::any(*flags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flags") != m.end() && !m["Flags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Flags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Flags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      flags = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryProduceDetailResponseBodyFlags() = default;
};
class QueryProduceDetailResponseBodyLeafCodesLeafCodes : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  QueryProduceDetailResponseBodyLeafCodesLeafCodes() {}

  explicit QueryProduceDetailResponseBodyLeafCodesLeafCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~QueryProduceDetailResponseBodyLeafCodesLeafCodes() = default;
};
class QueryProduceDetailResponseBodyLeafCodes : public Darabonba::Model {
public:
  shared_ptr<vector<QueryProduceDetailResponseBodyLeafCodesLeafCodes>> leafCodes{};

  QueryProduceDetailResponseBodyLeafCodes() {}

  explicit QueryProduceDetailResponseBodyLeafCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (leafCodes) {
      vector<boost::any> temp1;
      for(auto item1:*leafCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LeafCodes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LeafCodes") != m.end() && !m["LeafCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["LeafCodes"].type()) {
        vector<QueryProduceDetailResponseBodyLeafCodesLeafCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LeafCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryProduceDetailResponseBodyLeafCodesLeafCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        leafCodes = make_shared<vector<QueryProduceDetailResponseBodyLeafCodesLeafCodes>>(expect1);
      }
    }
  }


  virtual ~QueryProduceDetailResponseBodyLeafCodes() = default;
};
class QueryProduceDetailResponseBodyMaterialDetail : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> businessLicenceUrl{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> city{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactNumber{};
  shared_ptr<string> contactZipcode{};
  shared_ptr<string> country{};
  shared_ptr<string> EAddress{};
  shared_ptr<string> EName{};
  shared_ptr<string> expirationDate{};
  shared_ptr<string> idCardUrl{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> passportUrl{};
  shared_ptr<string> province{};
  shared_ptr<long> region{};
  shared_ptr<long> status{};
  shared_ptr<string> town{};
  shared_ptr<long> type{};

  QueryProduceDetailResponseBodyMaterialDetail() {}

  explicit QueryProduceDetailResponseBodyMaterialDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (businessLicenceUrl) {
      res["BusinessLicenceUrl"] = boost::any(*businessLicenceUrl);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactNumber) {
      res["ContactNumber"] = boost::any(*contactNumber);
    }
    if (contactZipcode) {
      res["ContactZipcode"] = boost::any(*contactZipcode);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (EAddress) {
      res["EAddress"] = boost::any(*EAddress);
    }
    if (EName) {
      res["EName"] = boost::any(*EName);
    }
    if (expirationDate) {
      res["ExpirationDate"] = boost::any(*expirationDate);
    }
    if (idCardUrl) {
      res["IdCardUrl"] = boost::any(*idCardUrl);
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportUrl) {
      res["PassportUrl"] = boost::any(*passportUrl);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (town) {
      res["Town"] = boost::any(*town);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BusinessLicenceUrl") != m.end() && !m["BusinessLicenceUrl"].empty()) {
      businessLicenceUrl = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceUrl"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactNumber") != m.end() && !m["ContactNumber"].empty()) {
      contactNumber = make_shared<string>(boost::any_cast<string>(m["ContactNumber"]));
    }
    if (m.find("ContactZipcode") != m.end() && !m["ContactZipcode"].empty()) {
      contactZipcode = make_shared<string>(boost::any_cast<string>(m["ContactZipcode"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("EAddress") != m.end() && !m["EAddress"].empty()) {
      EAddress = make_shared<string>(boost::any_cast<string>(m["EAddress"]));
    }
    if (m.find("EName") != m.end() && !m["EName"].empty()) {
      EName = make_shared<string>(boost::any_cast<string>(m["EName"]));
    }
    if (m.find("ExpirationDate") != m.end() && !m["ExpirationDate"].empty()) {
      expirationDate = make_shared<string>(boost::any_cast<string>(m["ExpirationDate"]));
    }
    if (m.find("IdCardUrl") != m.end() && !m["IdCardUrl"].empty()) {
      idCardUrl = make_shared<string>(boost::any_cast<string>(m["IdCardUrl"]));
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportUrl") != m.end() && !m["PassportUrl"].empty()) {
      passportUrl = make_shared<string>(boost::any_cast<string>(m["PassportUrl"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Town") != m.end() && !m["Town"].empty()) {
      town = make_shared<string>(boost::any_cast<string>(m["Town"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryProduceDetailResponseBodyMaterialDetail() = default;
};
class QueryProduceDetailResponseBodyRootCode : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  QueryProduceDetailResponseBodyRootCode() {}

  explicit QueryProduceDetailResponseBodyRootCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~QueryProduceDetailResponseBodyRootCode() = default;
};
class QueryProduceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceptUrl{};
  shared_ptr<string> agreementId{};
  shared_ptr<string> bizId{};
  shared_ptr<string> cnInfoUrl{};
  shared_ptr<map<string, boost::any>> extendInfo{};
  shared_ptr<QueryProduceDetailResponseBodyFlags> flags{};
  shared_ptr<string> grayIconUrl{};
  shared_ptr<string> issueDate{};
  shared_ptr<QueryProduceDetailResponseBodyLeafCodes> leafCodes{};
  shared_ptr<string> loaUrl{};
  shared_ptr<QueryProduceDetailResponseBodyMaterialDetail> materialDetail{};
  shared_ptr<string> note{};
  shared_ptr<string> orderId{};
  shared_ptr<long> principalName{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryProduceDetailResponseBodyRootCode> rootCode{};
  shared_ptr<long> status{};
  shared_ptr<long> submitCount{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<long> tmNameType{};
  shared_ptr<string> tmNumber{};
  shared_ptr<string> tmOrderId{};
  shared_ptr<long> type{};

  QueryProduceDetailResponseBody() {}

  explicit QueryProduceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptUrl) {
      res["AcceptUrl"] = boost::any(*acceptUrl);
    }
    if (agreementId) {
      res["AgreementId"] = boost::any(*agreementId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (cnInfoUrl) {
      res["CnInfoUrl"] = boost::any(*cnInfoUrl);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (flags) {
      res["Flags"] = flags ? boost::any(flags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (grayIconUrl) {
      res["GrayIconUrl"] = boost::any(*grayIconUrl);
    }
    if (issueDate) {
      res["IssueDate"] = boost::any(*issueDate);
    }
    if (leafCodes) {
      res["LeafCodes"] = leafCodes ? boost::any(leafCodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (materialDetail) {
      res["MaterialDetail"] = materialDetail ? boost::any(materialDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rootCode) {
      res["RootCode"] = rootCode ? boost::any(rootCode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitCount) {
      res["SubmitCount"] = boost::any(*submitCount);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNameType) {
      res["TmNameType"] = boost::any(*tmNameType);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (tmOrderId) {
      res["TmOrderId"] = boost::any(*tmOrderId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptUrl") != m.end() && !m["AcceptUrl"].empty()) {
      acceptUrl = make_shared<string>(boost::any_cast<string>(m["AcceptUrl"]));
    }
    if (m.find("AgreementId") != m.end() && !m["AgreementId"].empty()) {
      agreementId = make_shared<string>(boost::any_cast<string>(m["AgreementId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CnInfoUrl") != m.end() && !m["CnInfoUrl"].empty()) {
      cnInfoUrl = make_shared<string>(boost::any_cast<string>(m["CnInfoUrl"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtendInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extendInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Flags") != m.end() && !m["Flags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Flags"].type()) {
        QueryProduceDetailResponseBodyFlags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Flags"]));
        flags = make_shared<QueryProduceDetailResponseBodyFlags>(model1);
      }
    }
    if (m.find("GrayIconUrl") != m.end() && !m["GrayIconUrl"].empty()) {
      grayIconUrl = make_shared<string>(boost::any_cast<string>(m["GrayIconUrl"]));
    }
    if (m.find("IssueDate") != m.end() && !m["IssueDate"].empty()) {
      issueDate = make_shared<string>(boost::any_cast<string>(m["IssueDate"]));
    }
    if (m.find("LeafCodes") != m.end() && !m["LeafCodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["LeafCodes"].type()) {
        QueryProduceDetailResponseBodyLeafCodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LeafCodes"]));
        leafCodes = make_shared<QueryProduceDetailResponseBodyLeafCodes>(model1);
      }
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("MaterialDetail") != m.end() && !m["MaterialDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaterialDetail"].type()) {
        QueryProduceDetailResponseBodyMaterialDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaterialDetail"]));
        materialDetail = make_shared<QueryProduceDetailResponseBodyMaterialDetail>(model1);
      }
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RootCode") != m.end() && !m["RootCode"].empty()) {
      if (typeid(map<string, boost::any>) == m["RootCode"].type()) {
        QueryProduceDetailResponseBodyRootCode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RootCode"]));
        rootCode = make_shared<QueryProduceDetailResponseBodyRootCode>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SubmitCount") != m.end() && !m["SubmitCount"].empty()) {
      submitCount = make_shared<long>(boost::any_cast<long>(m["SubmitCount"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNameType") != m.end() && !m["TmNameType"].empty()) {
      tmNameType = make_shared<long>(boost::any_cast<long>(m["TmNameType"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("TmOrderId") != m.end() && !m["TmOrderId"].empty()) {
      tmOrderId = make_shared<string>(boost::any_cast<string>(m["TmOrderId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryProduceDetailResponseBody() = default;
};
class QueryProduceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryProduceDetailResponseBody> body{};

  QueryProduceDetailResponse() {}

  explicit QueryProduceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryProduceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryProduceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryProduceDetailResponse() = default;
};
class QueryProduceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> createTimeLeft{};
  shared_ptr<long> createTimeRight{};
  shared_ptr<string> materialName{};
  shared_ptr<string> orderId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> status{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNumber{};
  shared_ptr<long> type{};
  shared_ptr<string> userId{};

  QueryProduceListRequest() {}

  explicit QueryProduceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (createTimeLeft) {
      res["CreateTimeLeft"] = boost::any(*createTimeLeft);
    }
    if (createTimeRight) {
      res["CreateTimeRight"] = boost::any(*createTimeRight);
    }
    if (materialName) {
      res["MaterialName"] = boost::any(*materialName);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CreateTimeLeft") != m.end() && !m["CreateTimeLeft"].empty()) {
      createTimeLeft = make_shared<long>(boost::any_cast<long>(m["CreateTimeLeft"]));
    }
    if (m.find("CreateTimeRight") != m.end() && !m["CreateTimeRight"].empty()) {
      createTimeRight = make_shared<long>(boost::any_cast<long>(m["CreateTimeRight"]));
    }
    if (m.find("MaterialName") != m.end() && !m["MaterialName"].empty()) {
      materialName = make_shared<string>(boost::any_cast<string>(m["MaterialName"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryProduceListRequest() = default;
};
class QueryProduceListResponseBodyDataTmProducesClassification : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryProduceListResponseBodyDataTmProducesClassification() {}

  explicit QueryProduceListResponseBodyDataTmProducesClassification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryProduceListResponseBodyDataTmProducesClassification() = default;
};
class QueryProduceListResponseBodyDataTmProduces : public Darabonba::Model {
public:
  shared_ptr<string> agreementId{};
  shared_ptr<string> bizId{};
  shared_ptr<QueryProduceListResponseBodyDataTmProducesClassification> classification{};
  shared_ptr<long> createTime{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> materialName{};
  shared_ptr<string> note{};
  shared_ptr<string> orderId{};
  shared_ptr<double> orderPrice{};
  shared_ptr<long> principalName{};
  shared_ptr<string> receiptUrl{};
  shared_ptr<long> status{};
  shared_ptr<long> submitCount{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNumber{};
  shared_ptr<long> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  QueryProduceListResponseBodyDataTmProduces() {}

  explicit QueryProduceListResponseBodyDataTmProduces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementId) {
      res["AgreementId"] = boost::any(*agreementId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (classification) {
      res["Classification"] = classification ? boost::any(classification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (materialName) {
      res["MaterialName"] = boost::any(*materialName);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (orderPrice) {
      res["OrderPrice"] = boost::any(*orderPrice);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (receiptUrl) {
      res["ReceiptUrl"] = boost::any(*receiptUrl);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitCount) {
      res["SubmitCount"] = boost::any(*submitCount);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementId") != m.end() && !m["AgreementId"].empty()) {
      agreementId = make_shared<string>(boost::any_cast<string>(m["AgreementId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Classification"].type()) {
        QueryProduceListResponseBodyDataTmProducesClassification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Classification"]));
        classification = make_shared<QueryProduceListResponseBodyDataTmProducesClassification>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("MaterialName") != m.end() && !m["MaterialName"].empty()) {
      materialName = make_shared<string>(boost::any_cast<string>(m["MaterialName"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OrderPrice") != m.end() && !m["OrderPrice"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["OrderPrice"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("ReceiptUrl") != m.end() && !m["ReceiptUrl"].empty()) {
      receiptUrl = make_shared<string>(boost::any_cast<string>(m["ReceiptUrl"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SubmitCount") != m.end() && !m["SubmitCount"].empty()) {
      submitCount = make_shared<long>(boost::any_cast<long>(m["SubmitCount"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryProduceListResponseBodyDataTmProduces() = default;
};
class QueryProduceListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryProduceListResponseBodyDataTmProduces>> tmProduces{};

  QueryProduceListResponseBodyData() {}

  explicit QueryProduceListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tmProduces) {
      vector<boost::any> temp1;
      for(auto item1:*tmProduces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TmProduces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TmProduces") != m.end() && !m["TmProduces"].empty()) {
      if (typeid(vector<boost::any>) == m["TmProduces"].type()) {
        vector<QueryProduceListResponseBodyDataTmProduces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TmProduces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryProduceListResponseBodyDataTmProduces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tmProduces = make_shared<vector<QueryProduceListResponseBodyDataTmProduces>>(expect1);
      }
    }
  }


  virtual ~QueryProduceListResponseBodyData() = default;
};
class QueryProduceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<QueryProduceListResponseBodyData> data{};
  shared_ptr<bool> nextPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> prePage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryProduceListResponseBody() {}

  explicit QueryProduceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPage) {
      res["NextPage"] = boost::any(*nextPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prePage) {
      res["PrePage"] = boost::any(*prePage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryProduceListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryProduceListResponseBodyData>(model1);
      }
    }
    if (m.find("NextPage") != m.end() && !m["NextPage"].empty()) {
      nextPage = make_shared<bool>(boost::any_cast<bool>(m["NextPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PrePage") != m.end() && !m["PrePage"].empty()) {
      prePage = make_shared<bool>(boost::any_cast<bool>(m["PrePage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryProduceListResponseBody() = default;
};
class QueryProduceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryProduceListResponseBody> body{};

  QueryProduceListResponse() {}

  explicit QueryProduceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryProduceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryProduceListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryProduceListResponse() = default;
};
class QueryQrCodeUploadStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> fieldKey{};
  shared_ptr<string> ossKey{};
  shared_ptr<string> uuid{};

  QueryQrCodeUploadStatusRequest() {}

  explicit QueryQrCodeUploadStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldKey) {
      res["FieldKey"] = boost::any(*fieldKey);
    }
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldKey") != m.end() && !m["FieldKey"].empty()) {
      fieldKey = make_shared<string>(boost::any_cast<string>(m["FieldKey"]));
    }
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["OssKey"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~QueryQrCodeUploadStatusRequest() = default;
};
class QueryQrCodeUploadStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ossKey{};
  shared_ptr<string> ossUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<long> status{};
  shared_ptr<bool> success{};

  QueryQrCodeUploadStatusResponseBody() {}

  explicit QueryQrCodeUploadStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["OssKey"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryQrCodeUploadStatusResponseBody() = default;
};
class QueryQrCodeUploadStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryQrCodeUploadStatusResponseBody> body{};

  QueryQrCodeUploadStatusResponse() {}

  explicit QueryQrCodeUploadStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryQrCodeUploadStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryQrCodeUploadStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryQrCodeUploadStatusResponse() = default;
};
class QuerySbjRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> ruleId{};

  QuerySbjRuleRequest() {}

  explicit QuerySbjRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~QuerySbjRuleRequest() = default;
};
class QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptionsFrontendOption : public Darabonba::Model {
public:
  shared_ptr<string> title{};
  shared_ptr<string> value{};

  QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptionsFrontendOption() {}

  explicit QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptionsFrontendOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptionsFrontendOption() = default;
};
class QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptions : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptionsFrontendOption>> frontendOption{};

  QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptions() {}

  explicit QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frontendOption) {
      vector<boost::any> temp1;
      for(auto item1:*frontendOption){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FrontendOption"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrontendOption") != m.end() && !m["FrontendOption"].empty()) {
      if (typeid(vector<boost::any>) == m["FrontendOption"].type()) {
        vector<QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptionsFrontendOption> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FrontendOption"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptionsFrontendOption model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        frontendOption = make_shared<vector<QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptionsFrontendOption>>(expect1);
      }
    }
  }


  virtual ~QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptions() = default;
};
class QuerySbjRuleResponseBodySbjRuleListSbjRuleItem : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<string> espExtFieldName{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fileType{};
  shared_ptr<QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptions> frontendOptions{};
  shared_ptr<string> frontendType{};
  shared_ptr<string> requiredExpression{};
  shared_ptr<string> sbjFieldId{};
  shared_ptr<string> showExpression{};
  shared_ptr<string> trademarkServiceExpression{};
  shared_ptr<string> validateRegularExpression{};

  QuerySbjRuleResponseBodySbjRuleListSbjRuleItem() {}

  explicit QuerySbjRuleResponseBodySbjRuleListSbjRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (espExtFieldName) {
      res["EspExtFieldName"] = boost::any(*espExtFieldName);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (frontendOptions) {
      res["FrontendOptions"] = frontendOptions ? boost::any(frontendOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (frontendType) {
      res["FrontendType"] = boost::any(*frontendType);
    }
    if (requiredExpression) {
      res["RequiredExpression"] = boost::any(*requiredExpression);
    }
    if (sbjFieldId) {
      res["SbjFieldId"] = boost::any(*sbjFieldId);
    }
    if (showExpression) {
      res["ShowExpression"] = boost::any(*showExpression);
    }
    if (trademarkServiceExpression) {
      res["TrademarkServiceExpression"] = boost::any(*trademarkServiceExpression);
    }
    if (validateRegularExpression) {
      res["ValidateRegularExpression"] = boost::any(*validateRegularExpression);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("EspExtFieldName") != m.end() && !m["EspExtFieldName"].empty()) {
      espExtFieldName = make_shared<string>(boost::any_cast<string>(m["EspExtFieldName"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FrontendOptions") != m.end() && !m["FrontendOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["FrontendOptions"].type()) {
        QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FrontendOptions"]));
        frontendOptions = make_shared<QuerySbjRuleResponseBodySbjRuleListSbjRuleItemFrontendOptions>(model1);
      }
    }
    if (m.find("FrontendType") != m.end() && !m["FrontendType"].empty()) {
      frontendType = make_shared<string>(boost::any_cast<string>(m["FrontendType"]));
    }
    if (m.find("RequiredExpression") != m.end() && !m["RequiredExpression"].empty()) {
      requiredExpression = make_shared<string>(boost::any_cast<string>(m["RequiredExpression"]));
    }
    if (m.find("SbjFieldId") != m.end() && !m["SbjFieldId"].empty()) {
      sbjFieldId = make_shared<string>(boost::any_cast<string>(m["SbjFieldId"]));
    }
    if (m.find("ShowExpression") != m.end() && !m["ShowExpression"].empty()) {
      showExpression = make_shared<string>(boost::any_cast<string>(m["ShowExpression"]));
    }
    if (m.find("TrademarkServiceExpression") != m.end() && !m["TrademarkServiceExpression"].empty()) {
      trademarkServiceExpression = make_shared<string>(boost::any_cast<string>(m["TrademarkServiceExpression"]));
    }
    if (m.find("ValidateRegularExpression") != m.end() && !m["ValidateRegularExpression"].empty()) {
      validateRegularExpression = make_shared<string>(boost::any_cast<string>(m["ValidateRegularExpression"]));
    }
  }


  virtual ~QuerySbjRuleResponseBodySbjRuleListSbjRuleItem() = default;
};
class QuerySbjRuleResponseBodySbjRuleList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySbjRuleResponseBodySbjRuleListSbjRuleItem>> sbjRuleItem{};

  QuerySbjRuleResponseBodySbjRuleList() {}

  explicit QuerySbjRuleResponseBodySbjRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sbjRuleItem) {
      vector<boost::any> temp1;
      for(auto item1:*sbjRuleItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SbjRuleItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SbjRuleItem") != m.end() && !m["SbjRuleItem"].empty()) {
      if (typeid(vector<boost::any>) == m["SbjRuleItem"].type()) {
        vector<QuerySbjRuleResponseBodySbjRuleListSbjRuleItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SbjRuleItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySbjRuleResponseBodySbjRuleListSbjRuleItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sbjRuleItem = make_shared<vector<QuerySbjRuleResponseBodySbjRuleListSbjRuleItem>>(expect1);
      }
    }
  }


  virtual ~QuerySbjRuleResponseBodySbjRuleList() = default;
};
class QuerySbjRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> ruleId{};
  shared_ptr<QuerySbjRuleResponseBodySbjRuleList> sbjRuleList{};

  QuerySbjRuleResponseBody() {}

  explicit QuerySbjRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (sbjRuleList) {
      res["SbjRuleList"] = sbjRuleList ? boost::any(sbjRuleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("SbjRuleList") != m.end() && !m["SbjRuleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SbjRuleList"].type()) {
        QuerySbjRuleResponseBodySbjRuleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SbjRuleList"]));
        sbjRuleList = make_shared<QuerySbjRuleResponseBodySbjRuleList>(model1);
      }
    }
  }


  virtual ~QuerySbjRuleResponseBody() = default;
};
class QuerySbjRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySbjRuleResponseBody> body{};

  QuerySbjRuleResponse() {}

  explicit QuerySbjRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySbjRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySbjRuleResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySbjRuleResponse() = default;
};
class QuerySupplementDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  QuerySupplementDetailRequest() {}

  explicit QuerySupplementDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~QuerySupplementDetailRequest() = default;
};
class QuerySupplementDetailResponseBodyFileTemplateUrls : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fileTemplateUrls{};

  QuerySupplementDetailResponseBodyFileTemplateUrls() {}

  explicit QuerySupplementDetailResponseBodyFileTemplateUrls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileTemplateUrls) {
      res["FileTemplateUrls"] = boost::any(*fileTemplateUrls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileTemplateUrls") != m.end() && !m["FileTemplateUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileTemplateUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileTemplateUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileTemplateUrls = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySupplementDetailResponseBodyFileTemplateUrls() = default;
};
class QuerySupplementDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> acceptDeadTime{};
  shared_ptr<long> acceptTime{};
  shared_ptr<string> content{};
  shared_ptr<string> fileName{};
  shared_ptr<QuerySupplementDetailResponseBodyFileTemplateUrls> fileTemplateUrls{};
  shared_ptr<long> id{};
  shared_ptr<long> operateTime{};
  shared_ptr<string> reason{};
  shared_ptr<string> requestId{};
  shared_ptr<long> sbjDeadTime{};
  shared_ptr<long> sendTime{};
  shared_ptr<string> serialNumber{};
  shared_ptr<long> status{};
  shared_ptr<string> tmNumber{};
  shared_ptr<long> type{};
  shared_ptr<string> uploadFileTemplateUrl{};

  QuerySupplementDetailResponseBody() {}

  explicit QuerySupplementDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptDeadTime) {
      res["AcceptDeadTime"] = boost::any(*acceptDeadTime);
    }
    if (acceptTime) {
      res["AcceptTime"] = boost::any(*acceptTime);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileTemplateUrls) {
      res["FileTemplateUrls"] = fileTemplateUrls ? boost::any(fileTemplateUrls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (operateTime) {
      res["OperateTime"] = boost::any(*operateTime);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sbjDeadTime) {
      res["SbjDeadTime"] = boost::any(*sbjDeadTime);
    }
    if (sendTime) {
      res["SendTime"] = boost::any(*sendTime);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uploadFileTemplateUrl) {
      res["UploadFileTemplateUrl"] = boost::any(*uploadFileTemplateUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptDeadTime") != m.end() && !m["AcceptDeadTime"].empty()) {
      acceptDeadTime = make_shared<long>(boost::any_cast<long>(m["AcceptDeadTime"]));
    }
    if (m.find("AcceptTime") != m.end() && !m["AcceptTime"].empty()) {
      acceptTime = make_shared<long>(boost::any_cast<long>(m["AcceptTime"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileTemplateUrls") != m.end() && !m["FileTemplateUrls"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileTemplateUrls"].type()) {
        QuerySupplementDetailResponseBodyFileTemplateUrls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileTemplateUrls"]));
        fileTemplateUrls = make_shared<QuerySupplementDetailResponseBodyFileTemplateUrls>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OperateTime") != m.end() && !m["OperateTime"].empty()) {
      operateTime = make_shared<long>(boost::any_cast<long>(m["OperateTime"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SbjDeadTime") != m.end() && !m["SbjDeadTime"].empty()) {
      sbjDeadTime = make_shared<long>(boost::any_cast<long>(m["SbjDeadTime"]));
    }
    if (m.find("SendTime") != m.end() && !m["SendTime"].empty()) {
      sendTime = make_shared<long>(boost::any_cast<long>(m["SendTime"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UploadFileTemplateUrl") != m.end() && !m["UploadFileTemplateUrl"].empty()) {
      uploadFileTemplateUrl = make_shared<string>(boost::any_cast<string>(m["UploadFileTemplateUrl"]));
    }
  }


  virtual ~QuerySupplementDetailResponseBody() = default;
};
class QuerySupplementDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySupplementDetailResponseBody> body{};

  QuerySupplementDetailResponse() {}

  explicit QuerySupplementDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySupplementDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySupplementDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySupplementDetailResponse() = default;
};
class QueryTaskListRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  QueryTaskListRequest() {}

  explicit QueryTaskListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryTaskListRequest() = default;
};
class QueryTaskListResponseBodyDataTaskList : public Darabonba::Model {
public:
  shared_ptr<long> completeTime{};
  shared_ptr<long> createTime{};
  shared_ptr<string> errMsg{};
  shared_ptr<string> fileName{};
  shared_ptr<string> result{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> taskType{};

  QueryTaskListResponseBodyDataTaskList() {}

  explicit QueryTaskListResponseBodyDataTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<long>(boost::any_cast<long>(m["CompleteTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~QueryTaskListResponseBodyDataTaskList() = default;
};
class QueryTaskListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTaskListResponseBodyDataTaskList>> taskList{};

  QueryTaskListResponseBodyData() {}

  explicit QueryTaskListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskList) {
      vector<boost::any> temp1;
      for(auto item1:*taskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskList"].type()) {
        vector<QueryTaskListResponseBodyDataTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTaskListResponseBodyDataTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskList = make_shared<vector<QueryTaskListResponseBodyDataTaskList>>(expect1);
      }
    }
  }


  virtual ~QueryTaskListResponseBodyData() = default;
};
class QueryTaskListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<QueryTaskListResponseBodyData> data{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryTaskListResponseBody() {}

  explicit QueryTaskListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTaskListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTaskListResponseBodyData>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryTaskListResponseBody() = default;
};
class QueryTaskListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTaskListResponseBody> body{};

  QueryTaskListResponse() {}

  explicit QueryTaskListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTaskListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTaskListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTaskListResponse() = default;
};
class QueryTmCollectionPageListRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  QueryTmCollectionPageListRequest() {}

  explicit QueryTmCollectionPageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryTmCollectionPageListRequest() = default;
};
class QueryTmCollectionPageListResponseBodyDataTrademark : public Darabonba::Model {
public:
  shared_ptr<string> classification{};
  shared_ptr<bool> collected{};
  shared_ptr<string> collectionContent{};
  shared_ptr<long> id{};
  shared_ptr<string> itemId{};
  shared_ptr<string> tmName{};

  QueryTmCollectionPageListResponseBodyDataTrademark() {}

  explicit QueryTmCollectionPageListResponseBodyDataTrademark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (collected) {
      res["Collected"] = boost::any(*collected);
    }
    if (collectionContent) {
      res["CollectionContent"] = boost::any(*collectionContent);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("Collected") != m.end() && !m["Collected"].empty()) {
      collected = make_shared<bool>(boost::any_cast<bool>(m["Collected"]));
    }
    if (m.find("CollectionContent") != m.end() && !m["CollectionContent"].empty()) {
      collectionContent = make_shared<string>(boost::any_cast<string>(m["CollectionContent"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
  }


  virtual ~QueryTmCollectionPageListResponseBodyDataTrademark() = default;
};
class QueryTmCollectionPageListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTmCollectionPageListResponseBodyDataTrademark>> trademark{};

  QueryTmCollectionPageListResponseBodyData() {}

  explicit QueryTmCollectionPageListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trademark) {
      vector<boost::any> temp1;
      for(auto item1:*trademark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Trademark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Trademark") != m.end() && !m["Trademark"].empty()) {
      if (typeid(vector<boost::any>) == m["Trademark"].type()) {
        vector<QueryTmCollectionPageListResponseBodyDataTrademark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Trademark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTmCollectionPageListResponseBodyDataTrademark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trademark = make_shared<vector<QueryTmCollectionPageListResponseBodyDataTrademark>>(expect1);
      }
    }
  }


  virtual ~QueryTmCollectionPageListResponseBodyData() = default;
};
class QueryTmCollectionPageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<QueryTmCollectionPageListResponseBodyData> data{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryTmCollectionPageListResponseBody() {}

  explicit QueryTmCollectionPageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTmCollectionPageListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTmCollectionPageListResponseBodyData>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryTmCollectionPageListResponseBody() = default;
};
class QueryTmCollectionPageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTmCollectionPageListResponseBody> body{};

  QueryTmCollectionPageListResponse() {}

  explicit QueryTmCollectionPageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTmCollectionPageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTmCollectionPageListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTmCollectionPageListResponse() = default;
};
class QueryTmSbjProduceRequest : public Darabonba::Model {
public:
  shared_ptr<string> highPriorityBizTypeStr{};
  shared_ptr<string> highPriorityMaterialNameStr{};
  shared_ptr<string> highPriorityOrderIdStr{};
  shared_ptr<string> highPriorityUserIdStr{};
  shared_ptr<string> principalKey{};
  shared_ptr<string> principalName{};
  shared_ptr<string> producerType{};
  shared_ptr<long> queryOrderPageSize{};

  QueryTmSbjProduceRequest() {}

  explicit QueryTmSbjProduceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (highPriorityBizTypeStr) {
      res["HighPriorityBizTypeStr"] = boost::any(*highPriorityBizTypeStr);
    }
    if (highPriorityMaterialNameStr) {
      res["HighPriorityMaterialNameStr"] = boost::any(*highPriorityMaterialNameStr);
    }
    if (highPriorityOrderIdStr) {
      res["HighPriorityOrderIdStr"] = boost::any(*highPriorityOrderIdStr);
    }
    if (highPriorityUserIdStr) {
      res["HighPriorityUserIdStr"] = boost::any(*highPriorityUserIdStr);
    }
    if (principalKey) {
      res["PrincipalKey"] = boost::any(*principalKey);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (producerType) {
      res["ProducerType"] = boost::any(*producerType);
    }
    if (queryOrderPageSize) {
      res["QueryOrderPageSize"] = boost::any(*queryOrderPageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HighPriorityBizTypeStr") != m.end() && !m["HighPriorityBizTypeStr"].empty()) {
      highPriorityBizTypeStr = make_shared<string>(boost::any_cast<string>(m["HighPriorityBizTypeStr"]));
    }
    if (m.find("HighPriorityMaterialNameStr") != m.end() && !m["HighPriorityMaterialNameStr"].empty()) {
      highPriorityMaterialNameStr = make_shared<string>(boost::any_cast<string>(m["HighPriorityMaterialNameStr"]));
    }
    if (m.find("HighPriorityOrderIdStr") != m.end() && !m["HighPriorityOrderIdStr"].empty()) {
      highPriorityOrderIdStr = make_shared<string>(boost::any_cast<string>(m["HighPriorityOrderIdStr"]));
    }
    if (m.find("HighPriorityUserIdStr") != m.end() && !m["HighPriorityUserIdStr"].empty()) {
      highPriorityUserIdStr = make_shared<string>(boost::any_cast<string>(m["HighPriorityUserIdStr"]));
    }
    if (m.find("PrincipalKey") != m.end() && !m["PrincipalKey"].empty()) {
      principalKey = make_shared<string>(boost::any_cast<string>(m["PrincipalKey"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("ProducerType") != m.end() && !m["ProducerType"].empty()) {
      producerType = make_shared<string>(boost::any_cast<string>(m["ProducerType"]));
    }
    if (m.find("QueryOrderPageSize") != m.end() && !m["QueryOrderPageSize"].empty()) {
      queryOrderPageSize = make_shared<long>(boost::any_cast<long>(m["QueryOrderPageSize"]));
    }
  }


  virtual ~QueryTmSbjProduceRequest() = default;
};
class QueryTmSbjProduceResponseBodyMoudleTmSbjProduceListExtend : public Darabonba::Model {
public:
  shared_ptr<long> bid{};
  shared_ptr<bool> blackIcon{};
  shared_ptr<string> loaOssKey{};
  shared_ptr<string> logoGoodsId{};
  shared_ptr<string> materialId{};
  shared_ptr<long> submitCount{};
  shared_ptr<long> tmNametype{};

  QueryTmSbjProduceResponseBodyMoudleTmSbjProduceListExtend() {}

  explicit QueryTmSbjProduceResponseBodyMoudleTmSbjProduceListExtend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (blackIcon) {
      res["BlackIcon"] = boost::any(*blackIcon);
    }
    if (loaOssKey) {
      res["LoaOssKey"] = boost::any(*loaOssKey);
    }
    if (logoGoodsId) {
      res["LogoGoodsId"] = boost::any(*logoGoodsId);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (submitCount) {
      res["SubmitCount"] = boost::any(*submitCount);
    }
    if (tmNametype) {
      res["TmNametype"] = boost::any(*tmNametype);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<long>(boost::any_cast<long>(m["Bid"]));
    }
    if (m.find("BlackIcon") != m.end() && !m["BlackIcon"].empty()) {
      blackIcon = make_shared<bool>(boost::any_cast<bool>(m["BlackIcon"]));
    }
    if (m.find("LoaOssKey") != m.end() && !m["LoaOssKey"].empty()) {
      loaOssKey = make_shared<string>(boost::any_cast<string>(m["LoaOssKey"]));
    }
    if (m.find("LogoGoodsId") != m.end() && !m["LogoGoodsId"].empty()) {
      logoGoodsId = make_shared<string>(boost::any_cast<string>(m["LogoGoodsId"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("SubmitCount") != m.end() && !m["SubmitCount"].empty()) {
      submitCount = make_shared<long>(boost::any_cast<long>(m["SubmitCount"]));
    }
    if (m.find("TmNametype") != m.end() && !m["TmNametype"].empty()) {
      tmNametype = make_shared<long>(boost::any_cast<long>(m["TmNametype"]));
    }
  }


  virtual ~QueryTmSbjProduceResponseBodyMoudleTmSbjProduceListExtend() = default;
};
class QueryTmSbjProduceResponseBodyMoudleTmSbjProduceList : public Darabonba::Model {
public:
  shared_ptr<long> bitFlag{};
  shared_ptr<string> bizId{};
  shared_ptr<string> classificationCode{};
  shared_ptr<string> deleteFlag{};
  shared_ptr<string> env{};
  shared_ptr<QueryTmSbjProduceResponseBodyMoudleTmSbjProduceListExtend> extend{};
  shared_ptr<long> loaId{};
  shared_ptr<string> mainOrderId{};
  shared_ptr<long> materialId{};
  shared_ptr<string> materialName{};
  shared_ptr<string> orderId{};
  shared_ptr<double> orderPrice{};
  shared_ptr<string> principalKey{};
  shared_ptr<string> principalName{};
  shared_ptr<string> productType{};
  shared_ptr<string> riskSource{};
  shared_ptr<string> status{};
  shared_ptr<long> submitAuditTime{};
  shared_ptr<string> submitStatus{};
  shared_ptr<long> submitTime{};
  shared_ptr<long> submitTimes{};
  shared_ptr<string> tmCode{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<string> type{};
  shared_ptr<string> userId{};

  QueryTmSbjProduceResponseBodyMoudleTmSbjProduceList() {}

  explicit QueryTmSbjProduceResponseBodyMoudleTmSbjProduceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitFlag) {
      res["BitFlag"] = boost::any(*bitFlag);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (deleteFlag) {
      res["DeleteFlag"] = boost::any(*deleteFlag);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (extend) {
      res["Extend"] = extend ? boost::any(extend->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (loaId) {
      res["LoaId"] = boost::any(*loaId);
    }
    if (mainOrderId) {
      res["MainOrderId"] = boost::any(*mainOrderId);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (materialName) {
      res["MaterialName"] = boost::any(*materialName);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (orderPrice) {
      res["OrderPrice"] = boost::any(*orderPrice);
    }
    if (principalKey) {
      res["PrincipalKey"] = boost::any(*principalKey);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (riskSource) {
      res["RiskSource"] = boost::any(*riskSource);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitAuditTime) {
      res["SubmitAuditTime"] = boost::any(*submitAuditTime);
    }
    if (submitStatus) {
      res["SubmitStatus"] = boost::any(*submitStatus);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (submitTimes) {
      res["SubmitTimes"] = boost::any(*submitTimes);
    }
    if (tmCode) {
      res["TmCode"] = boost::any(*tmCode);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BitFlag") != m.end() && !m["BitFlag"].empty()) {
      bitFlag = make_shared<long>(boost::any_cast<long>(m["BitFlag"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("DeleteFlag") != m.end() && !m["DeleteFlag"].empty()) {
      deleteFlag = make_shared<string>(boost::any_cast<string>(m["DeleteFlag"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      if (typeid(map<string, boost::any>) == m["Extend"].type()) {
        QueryTmSbjProduceResponseBodyMoudleTmSbjProduceListExtend model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Extend"]));
        extend = make_shared<QueryTmSbjProduceResponseBodyMoudleTmSbjProduceListExtend>(model1);
      }
    }
    if (m.find("LoaId") != m.end() && !m["LoaId"].empty()) {
      loaId = make_shared<long>(boost::any_cast<long>(m["LoaId"]));
    }
    if (m.find("MainOrderId") != m.end() && !m["MainOrderId"].empty()) {
      mainOrderId = make_shared<string>(boost::any_cast<string>(m["MainOrderId"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<long>(boost::any_cast<long>(m["MaterialId"]));
    }
    if (m.find("MaterialName") != m.end() && !m["MaterialName"].empty()) {
      materialName = make_shared<string>(boost::any_cast<string>(m["MaterialName"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OrderPrice") != m.end() && !m["OrderPrice"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["OrderPrice"]));
    }
    if (m.find("PrincipalKey") != m.end() && !m["PrincipalKey"].empty()) {
      principalKey = make_shared<string>(boost::any_cast<string>(m["PrincipalKey"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("RiskSource") != m.end() && !m["RiskSource"].empty()) {
      riskSource = make_shared<string>(boost::any_cast<string>(m["RiskSource"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitAuditTime") != m.end() && !m["SubmitAuditTime"].empty()) {
      submitAuditTime = make_shared<long>(boost::any_cast<long>(m["SubmitAuditTime"]));
    }
    if (m.find("SubmitStatus") != m.end() && !m["SubmitStatus"].empty()) {
      submitStatus = make_shared<string>(boost::any_cast<string>(m["SubmitStatus"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<long>(boost::any_cast<long>(m["SubmitTime"]));
    }
    if (m.find("SubmitTimes") != m.end() && !m["SubmitTimes"].empty()) {
      submitTimes = make_shared<long>(boost::any_cast<long>(m["SubmitTimes"]));
    }
    if (m.find("TmCode") != m.end() && !m["TmCode"].empty()) {
      tmCode = make_shared<string>(boost::any_cast<string>(m["TmCode"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryTmSbjProduceResponseBodyMoudleTmSbjProduceList() = default;
};
class QueryTmSbjProduceResponseBodyMoudle : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTmSbjProduceResponseBodyMoudleTmSbjProduceList>> tmSbjProduceList{};

  QueryTmSbjProduceResponseBodyMoudle() {}

  explicit QueryTmSbjProduceResponseBodyMoudle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tmSbjProduceList) {
      vector<boost::any> temp1;
      for(auto item1:*tmSbjProduceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TmSbjProduceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TmSbjProduceList") != m.end() && !m["TmSbjProduceList"].empty()) {
      if (typeid(vector<boost::any>) == m["TmSbjProduceList"].type()) {
        vector<QueryTmSbjProduceResponseBodyMoudleTmSbjProduceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TmSbjProduceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTmSbjProduceResponseBodyMoudleTmSbjProduceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tmSbjProduceList = make_shared<vector<QueryTmSbjProduceResponseBodyMoudleTmSbjProduceList>>(expect1);
      }
    }
  }


  virtual ~QueryTmSbjProduceResponseBodyMoudle() = default;
};
class QueryTmSbjProduceResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTmSbjProduceResponseBodyMoudle> moudle{};
  shared_ptr<string> requestId{};

  QueryTmSbjProduceResponseBody() {}

  explicit QueryTmSbjProduceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moudle) {
      res["Moudle"] = moudle ? boost::any(moudle->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Moudle") != m.end() && !m["Moudle"].empty()) {
      if (typeid(map<string, boost::any>) == m["Moudle"].type()) {
        QueryTmSbjProduceResponseBodyMoudle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Moudle"]));
        moudle = make_shared<QueryTmSbjProduceResponseBodyMoudle>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryTmSbjProduceResponseBody() = default;
};
class QueryTmSbjProduceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTmSbjProduceResponseBody> body{};

  QueryTmSbjProduceResponse() {}

  explicit QueryTmSbjProduceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTmSbjProduceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTmSbjProduceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTmSbjProduceResponse() = default;
};
class QueryTmSbjProduceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> orderId{};

  QueryTmSbjProduceDetailRequest() {}

  explicit QueryTmSbjProduceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~QueryTmSbjProduceDetailRequest() = default;
};
class QueryTmSbjProduceDetailResponseBodyFlags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> flags{};

  QueryTmSbjProduceDetailResponseBodyFlags() {}

  explicit QueryTmSbjProduceDetailResponseBodyFlags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flags) {
      res["Flags"] = boost::any(*flags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flags") != m.end() && !m["Flags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Flags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Flags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      flags = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryTmSbjProduceDetailResponseBodyFlags() = default;
};
class QueryTmSbjProduceDetailResponseBodyLeafCodesLeafCodes : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  QueryTmSbjProduceDetailResponseBodyLeafCodesLeafCodes() {}

  explicit QueryTmSbjProduceDetailResponseBodyLeafCodesLeafCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~QueryTmSbjProduceDetailResponseBodyLeafCodesLeafCodes() = default;
};
class QueryTmSbjProduceDetailResponseBodyLeafCodes : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTmSbjProduceDetailResponseBodyLeafCodesLeafCodes>> leafCodes{};

  QueryTmSbjProduceDetailResponseBodyLeafCodes() {}

  explicit QueryTmSbjProduceDetailResponseBodyLeafCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (leafCodes) {
      vector<boost::any> temp1;
      for(auto item1:*leafCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LeafCodes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LeafCodes") != m.end() && !m["LeafCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["LeafCodes"].type()) {
        vector<QueryTmSbjProduceDetailResponseBodyLeafCodesLeafCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LeafCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTmSbjProduceDetailResponseBodyLeafCodesLeafCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        leafCodes = make_shared<vector<QueryTmSbjProduceDetailResponseBodyLeafCodesLeafCodes>>(expect1);
      }
    }
  }


  virtual ~QueryTmSbjProduceDetailResponseBodyLeafCodes() = default;
};
class QueryTmSbjProduceDetailResponseBodyMaterialDetail : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> businessLicenceUrl{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> city{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactNumber{};
  shared_ptr<string> contactProvince{};
  shared_ptr<string> contactZipcode{};
  shared_ptr<string> country{};
  shared_ptr<string> detailedContactAddress{};
  shared_ptr<string> EAddress{};
  shared_ptr<string> EName{};
  shared_ptr<string> expirationDate{};
  shared_ptr<string> idCardNumber{};
  shared_ptr<string> idCardUrl{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> passportUrl{};
  shared_ptr<long> personalType{};
  shared_ptr<string> province{};
  shared_ptr<long> region{};
  shared_ptr<long> status{};
  shared_ptr<string> town{};
  shared_ptr<long> type{};

  QueryTmSbjProduceDetailResponseBodyMaterialDetail() {}

  explicit QueryTmSbjProduceDetailResponseBodyMaterialDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (businessLicenceUrl) {
      res["BusinessLicenceUrl"] = boost::any(*businessLicenceUrl);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactNumber) {
      res["ContactNumber"] = boost::any(*contactNumber);
    }
    if (contactProvince) {
      res["ContactProvince"] = boost::any(*contactProvince);
    }
    if (contactZipcode) {
      res["ContactZipcode"] = boost::any(*contactZipcode);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (detailedContactAddress) {
      res["DetailedContactAddress"] = boost::any(*detailedContactAddress);
    }
    if (EAddress) {
      res["EAddress"] = boost::any(*EAddress);
    }
    if (EName) {
      res["EName"] = boost::any(*EName);
    }
    if (expirationDate) {
      res["ExpirationDate"] = boost::any(*expirationDate);
    }
    if (idCardNumber) {
      res["IdCardNumber"] = boost::any(*idCardNumber);
    }
    if (idCardUrl) {
      res["IdCardUrl"] = boost::any(*idCardUrl);
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportUrl) {
      res["PassportUrl"] = boost::any(*passportUrl);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (town) {
      res["Town"] = boost::any(*town);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BusinessLicenceUrl") != m.end() && !m["BusinessLicenceUrl"].empty()) {
      businessLicenceUrl = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceUrl"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactNumber") != m.end() && !m["ContactNumber"].empty()) {
      contactNumber = make_shared<string>(boost::any_cast<string>(m["ContactNumber"]));
    }
    if (m.find("ContactProvince") != m.end() && !m["ContactProvince"].empty()) {
      contactProvince = make_shared<string>(boost::any_cast<string>(m["ContactProvince"]));
    }
    if (m.find("ContactZipcode") != m.end() && !m["ContactZipcode"].empty()) {
      contactZipcode = make_shared<string>(boost::any_cast<string>(m["ContactZipcode"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("DetailedContactAddress") != m.end() && !m["DetailedContactAddress"].empty()) {
      detailedContactAddress = make_shared<string>(boost::any_cast<string>(m["DetailedContactAddress"]));
    }
    if (m.find("EAddress") != m.end() && !m["EAddress"].empty()) {
      EAddress = make_shared<string>(boost::any_cast<string>(m["EAddress"]));
    }
    if (m.find("EName") != m.end() && !m["EName"].empty()) {
      EName = make_shared<string>(boost::any_cast<string>(m["EName"]));
    }
    if (m.find("ExpirationDate") != m.end() && !m["ExpirationDate"].empty()) {
      expirationDate = make_shared<string>(boost::any_cast<string>(m["ExpirationDate"]));
    }
    if (m.find("IdCardNumber") != m.end() && !m["IdCardNumber"].empty()) {
      idCardNumber = make_shared<string>(boost::any_cast<string>(m["IdCardNumber"]));
    }
    if (m.find("IdCardUrl") != m.end() && !m["IdCardUrl"].empty()) {
      idCardUrl = make_shared<string>(boost::any_cast<string>(m["IdCardUrl"]));
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportUrl") != m.end() && !m["PassportUrl"].empty()) {
      passportUrl = make_shared<string>(boost::any_cast<string>(m["PassportUrl"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<long>(boost::any_cast<long>(m["PersonalType"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Town") != m.end() && !m["Town"].empty()) {
      town = make_shared<string>(boost::any_cast<string>(m["Town"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryTmSbjProduceDetailResponseBodyMaterialDetail() = default;
};
class QueryTmSbjProduceDetailResponseBodyRootCode : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  QueryTmSbjProduceDetailResponseBodyRootCode() {}

  explicit QueryTmSbjProduceDetailResponseBodyRootCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~QueryTmSbjProduceDetailResponseBodyRootCode() = default;
};
class QueryTmSbjProduceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceptUrl{};
  shared_ptr<string> bizId{};
  shared_ptr<string> cnInfoUrl{};
  shared_ptr<map<string, boost::any>> extendInfo{};
  shared_ptr<QueryTmSbjProduceDetailResponseBodyFlags> flags{};
  shared_ptr<string> grayIconUrl{};
  shared_ptr<string> issueDate{};
  shared_ptr<QueryTmSbjProduceDetailResponseBodyLeafCodes> leafCodes{};
  shared_ptr<string> loaUrl{};
  shared_ptr<QueryTmSbjProduceDetailResponseBodyMaterialDetail> materialDetail{};
  shared_ptr<string> materialName{};
  shared_ptr<string> note{};
  shared_ptr<string> orderId{};
  shared_ptr<long> principalName{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryTmSbjProduceDetailResponseBodyRootCode> rootCode{};
  shared_ptr<long> status{};
  shared_ptr<long> submitCount{};
  shared_ptr<string> submitStatus{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<long> tmNameType{};
  shared_ptr<string> tmNumber{};
  shared_ptr<string> tmOrderId{};
  shared_ptr<long> type{};

  QueryTmSbjProduceDetailResponseBody() {}

  explicit QueryTmSbjProduceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptUrl) {
      res["AcceptUrl"] = boost::any(*acceptUrl);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (cnInfoUrl) {
      res["CnInfoUrl"] = boost::any(*cnInfoUrl);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (flags) {
      res["Flags"] = flags ? boost::any(flags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (grayIconUrl) {
      res["GrayIconUrl"] = boost::any(*grayIconUrl);
    }
    if (issueDate) {
      res["IssueDate"] = boost::any(*issueDate);
    }
    if (leafCodes) {
      res["LeafCodes"] = leafCodes ? boost::any(leafCodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (materialDetail) {
      res["MaterialDetail"] = materialDetail ? boost::any(materialDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (materialName) {
      res["MaterialName"] = boost::any(*materialName);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rootCode) {
      res["RootCode"] = rootCode ? boost::any(rootCode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitCount) {
      res["SubmitCount"] = boost::any(*submitCount);
    }
    if (submitStatus) {
      res["SubmitStatus"] = boost::any(*submitStatus);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNameType) {
      res["TmNameType"] = boost::any(*tmNameType);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (tmOrderId) {
      res["TmOrderId"] = boost::any(*tmOrderId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptUrl") != m.end() && !m["AcceptUrl"].empty()) {
      acceptUrl = make_shared<string>(boost::any_cast<string>(m["AcceptUrl"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CnInfoUrl") != m.end() && !m["CnInfoUrl"].empty()) {
      cnInfoUrl = make_shared<string>(boost::any_cast<string>(m["CnInfoUrl"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtendInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extendInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Flags") != m.end() && !m["Flags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Flags"].type()) {
        QueryTmSbjProduceDetailResponseBodyFlags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Flags"]));
        flags = make_shared<QueryTmSbjProduceDetailResponseBodyFlags>(model1);
      }
    }
    if (m.find("GrayIconUrl") != m.end() && !m["GrayIconUrl"].empty()) {
      grayIconUrl = make_shared<string>(boost::any_cast<string>(m["GrayIconUrl"]));
    }
    if (m.find("IssueDate") != m.end() && !m["IssueDate"].empty()) {
      issueDate = make_shared<string>(boost::any_cast<string>(m["IssueDate"]));
    }
    if (m.find("LeafCodes") != m.end() && !m["LeafCodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["LeafCodes"].type()) {
        QueryTmSbjProduceDetailResponseBodyLeafCodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LeafCodes"]));
        leafCodes = make_shared<QueryTmSbjProduceDetailResponseBodyLeafCodes>(model1);
      }
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("MaterialDetail") != m.end() && !m["MaterialDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaterialDetail"].type()) {
        QueryTmSbjProduceDetailResponseBodyMaterialDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaterialDetail"]));
        materialDetail = make_shared<QueryTmSbjProduceDetailResponseBodyMaterialDetail>(model1);
      }
    }
    if (m.find("MaterialName") != m.end() && !m["MaterialName"].empty()) {
      materialName = make_shared<string>(boost::any_cast<string>(m["MaterialName"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RootCode") != m.end() && !m["RootCode"].empty()) {
      if (typeid(map<string, boost::any>) == m["RootCode"].type()) {
        QueryTmSbjProduceDetailResponseBodyRootCode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RootCode"]));
        rootCode = make_shared<QueryTmSbjProduceDetailResponseBodyRootCode>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SubmitCount") != m.end() && !m["SubmitCount"].empty()) {
      submitCount = make_shared<long>(boost::any_cast<long>(m["SubmitCount"]));
    }
    if (m.find("SubmitStatus") != m.end() && !m["SubmitStatus"].empty()) {
      submitStatus = make_shared<string>(boost::any_cast<string>(m["SubmitStatus"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNameType") != m.end() && !m["TmNameType"].empty()) {
      tmNameType = make_shared<long>(boost::any_cast<long>(m["TmNameType"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("TmOrderId") != m.end() && !m["TmOrderId"].empty()) {
      tmOrderId = make_shared<string>(boost::any_cast<string>(m["TmOrderId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryTmSbjProduceDetailResponseBody() = default;
};
class QueryTmSbjProduceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTmSbjProduceDetailResponseBody> body{};

  QueryTmSbjProduceDetailResponse() {}

  explicit QueryTmSbjProduceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTmSbjProduceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTmSbjProduceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTmSbjProduceDetailResponse() = default;
};
class QueryTradeIntentionUserListRequest : public Darabonba::Model {
public:
  shared_ptr<long> begin{};
  shared_ptr<string> bizId{};
  shared_ptr<long> end{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> status{};
  shared_ptr<long> type{};

  QueryTradeIntentionUserListRequest() {}

  explicit QueryTradeIntentionUserListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (begin) {
      res["Begin"] = boost::any(*begin);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Begin") != m.end() && !m["Begin"].empty()) {
      begin = make_shared<long>(boost::any_cast<long>(m["Begin"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryTradeIntentionUserListRequest() = default;
};
class QueryTradeIntentionUserListResponseBodyDataTrademark : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> classification{};
  shared_ptr<string> description{};
  shared_ptr<string> documentDate{};
  shared_ptr<string> documentName{};
  shared_ptr<string> documentUrl{};
  shared_ptr<long> grade{};
  shared_ptr<string> mobile{};
  shared_ptr<string> registerNumber{};
  shared_ptr<long> status{};
  shared_ptr<long> type{};
  shared_ptr<string> userName{};

  QueryTradeIntentionUserListResponseBodyDataTrademark() {}

  explicit QueryTradeIntentionUserListResponseBodyDataTrademark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (documentDate) {
      res["DocumentDate"] = boost::any(*documentDate);
    }
    if (documentName) {
      res["DocumentName"] = boost::any(*documentName);
    }
    if (documentUrl) {
      res["DocumentUrl"] = boost::any(*documentUrl);
    }
    if (grade) {
      res["Grade"] = boost::any(*grade);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (registerNumber) {
      res["RegisterNumber"] = boost::any(*registerNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocumentDate") != m.end() && !m["DocumentDate"].empty()) {
      documentDate = make_shared<string>(boost::any_cast<string>(m["DocumentDate"]));
    }
    if (m.find("DocumentName") != m.end() && !m["DocumentName"].empty()) {
      documentName = make_shared<string>(boost::any_cast<string>(m["DocumentName"]));
    }
    if (m.find("DocumentUrl") != m.end() && !m["DocumentUrl"].empty()) {
      documentUrl = make_shared<string>(boost::any_cast<string>(m["DocumentUrl"]));
    }
    if (m.find("Grade") != m.end() && !m["Grade"].empty()) {
      grade = make_shared<long>(boost::any_cast<long>(m["Grade"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("RegisterNumber") != m.end() && !m["RegisterNumber"].empty()) {
      registerNumber = make_shared<string>(boost::any_cast<string>(m["RegisterNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~QueryTradeIntentionUserListResponseBodyDataTrademark() = default;
};
class QueryTradeIntentionUserListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTradeIntentionUserListResponseBodyDataTrademark>> trademark{};

  QueryTradeIntentionUserListResponseBodyData() {}

  explicit QueryTradeIntentionUserListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trademark) {
      vector<boost::any> temp1;
      for(auto item1:*trademark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Trademark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Trademark") != m.end() && !m["Trademark"].empty()) {
      if (typeid(vector<boost::any>) == m["Trademark"].type()) {
        vector<QueryTradeIntentionUserListResponseBodyDataTrademark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Trademark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTradeIntentionUserListResponseBodyDataTrademark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trademark = make_shared<vector<QueryTradeIntentionUserListResponseBodyDataTrademark>>(expect1);
      }
    }
  }


  virtual ~QueryTradeIntentionUserListResponseBodyData() = default;
};
class QueryTradeIntentionUserListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<QueryTradeIntentionUserListResponseBodyData> data{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryTradeIntentionUserListResponseBody() {}

  explicit QueryTradeIntentionUserListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTradeIntentionUserListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTradeIntentionUserListResponseBodyData>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryTradeIntentionUserListResponseBody() = default;
};
class QueryTradeIntentionUserListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTradeIntentionUserListResponseBody> body{};

  QueryTradeIntentionUserListResponse() {}

  explicit QueryTradeIntentionUserListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTradeIntentionUserListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTradeIntentionUserListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTradeIntentionUserListResponse() = default;
};
class QueryTradeMarkApplicationDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};

  QueryTradeMarkApplicationDetailRequest() {}

  explicit QueryTradeMarkApplicationDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~QueryTradeMarkApplicationDetailRequest() = default;
};
class QueryTradeMarkApplicationDetailResponseBodyAdminUploads : public Darabonba::Model {
public:
  shared_ptr<string> licensePicUrl{};
  shared_ptr<string> loaPicUrl{};

  QueryTradeMarkApplicationDetailResponseBodyAdminUploads() {}

  explicit QueryTradeMarkApplicationDetailResponseBodyAdminUploads(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (licensePicUrl) {
      res["LicensePicUrl"] = boost::any(*licensePicUrl);
    }
    if (loaPicUrl) {
      res["LoaPicUrl"] = boost::any(*loaPicUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LicensePicUrl") != m.end() && !m["LicensePicUrl"].empty()) {
      licensePicUrl = make_shared<string>(boost::any_cast<string>(m["LicensePicUrl"]));
    }
    if (m.find("LoaPicUrl") != m.end() && !m["LoaPicUrl"].empty()) {
      loaPicUrl = make_shared<string>(boost::any_cast<string>(m["LoaPicUrl"]));
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodyAdminUploads() = default;
};
class QueryTradeMarkApplicationDetailResponseBodyFirstClassification : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  QueryTradeMarkApplicationDetailResponseBodyFirstClassification() {}

  explicit QueryTradeMarkApplicationDetailResponseBodyFirstClassification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodyFirstClassification() = default;
};
class QueryTradeMarkApplicationDetailResponseBodyFlags : public Darabonba::Model {
public:
  shared_ptr<vector<long>> flag{};

  QueryTradeMarkApplicationDetailResponseBodyFlags() {}

  explicit QueryTradeMarkApplicationDetailResponseBodyFlags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Flag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Flag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      flag = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodyFlags() = default;
};
class QueryTradeMarkApplicationDetailResponseBodyJudgeResultUrl : public Darabonba::Model {
public:
  shared_ptr<vector<string>> judgeResultUrl{};

  QueryTradeMarkApplicationDetailResponseBodyJudgeResultUrl() {}

  explicit QueryTradeMarkApplicationDetailResponseBodyJudgeResultUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (judgeResultUrl) {
      res["JudgeResultUrl"] = boost::any(*judgeResultUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JudgeResultUrl") != m.end() && !m["JudgeResultUrl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JudgeResultUrl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JudgeResultUrl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      judgeResultUrl = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodyJudgeResultUrl() = default;
};
class QueryTradeMarkApplicationDetailResponseBodyMaterialDetailReviewAdditionalFiles : public Darabonba::Model {
public:
  shared_ptr<vector<string>> reviewAdditionalFile{};

  QueryTradeMarkApplicationDetailResponseBodyMaterialDetailReviewAdditionalFiles() {}

  explicit QueryTradeMarkApplicationDetailResponseBodyMaterialDetailReviewAdditionalFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reviewAdditionalFile) {
      res["ReviewAdditionalFile"] = boost::any(*reviewAdditionalFile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReviewAdditionalFile") != m.end() && !m["ReviewAdditionalFile"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReviewAdditionalFile"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReviewAdditionalFile"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reviewAdditionalFile = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodyMaterialDetailReviewAdditionalFiles() = default;
};
class QueryTradeMarkApplicationDetailResponseBodyMaterialDetail : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> businessLicenceUrl{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> city{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactCity{};
  shared_ptr<string> contactDistrict{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactNumber{};
  shared_ptr<string> contactProvince{};
  shared_ptr<string> contactZipcode{};
  shared_ptr<string> country{};
  shared_ptr<string> detailedContactAddress{};
  shared_ptr<string> EAddress{};
  shared_ptr<string> EName{};
  shared_ptr<string> expirationDate{};
  shared_ptr<string> factAndReasonPdfPath{};
  shared_ptr<string> idCardName{};
  shared_ptr<string> idCardNumber{};
  shared_ptr<string> idCardUrl{};
  shared_ptr<string> legalNoticeUrl{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> materialVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> passportUrl{};
  shared_ptr<long> personalType{};
  shared_ptr<long> principalName{};
  shared_ptr<string> province{};
  shared_ptr<long> region{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBodyMaterialDetailReviewAdditionalFiles> reviewAdditionalFiles{};
  shared_ptr<string> reviewApplicationFile{};
  shared_ptr<long> status{};
  shared_ptr<string> supplementEvidenceCatalogFile{};
  shared_ptr<string> supplementEvidenceMaterialFile{};
  shared_ptr<string> supplementReasonFile{};
  shared_ptr<string> town{};
  shared_ptr<long> type{};

  QueryTradeMarkApplicationDetailResponseBodyMaterialDetail() {}

  explicit QueryTradeMarkApplicationDetailResponseBodyMaterialDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (businessLicenceUrl) {
      res["BusinessLicenceUrl"] = boost::any(*businessLicenceUrl);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactCity) {
      res["ContactCity"] = boost::any(*contactCity);
    }
    if (contactDistrict) {
      res["ContactDistrict"] = boost::any(*contactDistrict);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactNumber) {
      res["ContactNumber"] = boost::any(*contactNumber);
    }
    if (contactProvince) {
      res["ContactProvince"] = boost::any(*contactProvince);
    }
    if (contactZipcode) {
      res["ContactZipcode"] = boost::any(*contactZipcode);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (detailedContactAddress) {
      res["DetailedContactAddress"] = boost::any(*detailedContactAddress);
    }
    if (EAddress) {
      res["EAddress"] = boost::any(*EAddress);
    }
    if (EName) {
      res["EName"] = boost::any(*EName);
    }
    if (expirationDate) {
      res["ExpirationDate"] = boost::any(*expirationDate);
    }
    if (factAndReasonPdfPath) {
      res["FactAndReasonPdfPath"] = boost::any(*factAndReasonPdfPath);
    }
    if (idCardName) {
      res["IdCardName"] = boost::any(*idCardName);
    }
    if (idCardNumber) {
      res["IdCardNumber"] = boost::any(*idCardNumber);
    }
    if (idCardUrl) {
      res["IdCardUrl"] = boost::any(*idCardUrl);
    }
    if (legalNoticeUrl) {
      res["LegalNoticeUrl"] = boost::any(*legalNoticeUrl);
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (materialVersion) {
      res["MaterialVersion"] = boost::any(*materialVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportUrl) {
      res["PassportUrl"] = boost::any(*passportUrl);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (reviewAdditionalFiles) {
      res["ReviewAdditionalFiles"] = reviewAdditionalFiles ? boost::any(reviewAdditionalFiles->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reviewApplicationFile) {
      res["ReviewApplicationFile"] = boost::any(*reviewApplicationFile);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (supplementEvidenceCatalogFile) {
      res["SupplementEvidenceCatalogFile"] = boost::any(*supplementEvidenceCatalogFile);
    }
    if (supplementEvidenceMaterialFile) {
      res["SupplementEvidenceMaterialFile"] = boost::any(*supplementEvidenceMaterialFile);
    }
    if (supplementReasonFile) {
      res["SupplementReasonFile"] = boost::any(*supplementReasonFile);
    }
    if (town) {
      res["Town"] = boost::any(*town);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BusinessLicenceUrl") != m.end() && !m["BusinessLicenceUrl"].empty()) {
      businessLicenceUrl = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceUrl"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactCity") != m.end() && !m["ContactCity"].empty()) {
      contactCity = make_shared<string>(boost::any_cast<string>(m["ContactCity"]));
    }
    if (m.find("ContactDistrict") != m.end() && !m["ContactDistrict"].empty()) {
      contactDistrict = make_shared<string>(boost::any_cast<string>(m["ContactDistrict"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactNumber") != m.end() && !m["ContactNumber"].empty()) {
      contactNumber = make_shared<string>(boost::any_cast<string>(m["ContactNumber"]));
    }
    if (m.find("ContactProvince") != m.end() && !m["ContactProvince"].empty()) {
      contactProvince = make_shared<string>(boost::any_cast<string>(m["ContactProvince"]));
    }
    if (m.find("ContactZipcode") != m.end() && !m["ContactZipcode"].empty()) {
      contactZipcode = make_shared<string>(boost::any_cast<string>(m["ContactZipcode"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("DetailedContactAddress") != m.end() && !m["DetailedContactAddress"].empty()) {
      detailedContactAddress = make_shared<string>(boost::any_cast<string>(m["DetailedContactAddress"]));
    }
    if (m.find("EAddress") != m.end() && !m["EAddress"].empty()) {
      EAddress = make_shared<string>(boost::any_cast<string>(m["EAddress"]));
    }
    if (m.find("EName") != m.end() && !m["EName"].empty()) {
      EName = make_shared<string>(boost::any_cast<string>(m["EName"]));
    }
    if (m.find("ExpirationDate") != m.end() && !m["ExpirationDate"].empty()) {
      expirationDate = make_shared<string>(boost::any_cast<string>(m["ExpirationDate"]));
    }
    if (m.find("FactAndReasonPdfPath") != m.end() && !m["FactAndReasonPdfPath"].empty()) {
      factAndReasonPdfPath = make_shared<string>(boost::any_cast<string>(m["FactAndReasonPdfPath"]));
    }
    if (m.find("IdCardName") != m.end() && !m["IdCardName"].empty()) {
      idCardName = make_shared<string>(boost::any_cast<string>(m["IdCardName"]));
    }
    if (m.find("IdCardNumber") != m.end() && !m["IdCardNumber"].empty()) {
      idCardNumber = make_shared<string>(boost::any_cast<string>(m["IdCardNumber"]));
    }
    if (m.find("IdCardUrl") != m.end() && !m["IdCardUrl"].empty()) {
      idCardUrl = make_shared<string>(boost::any_cast<string>(m["IdCardUrl"]));
    }
    if (m.find("LegalNoticeUrl") != m.end() && !m["LegalNoticeUrl"].empty()) {
      legalNoticeUrl = make_shared<string>(boost::any_cast<string>(m["LegalNoticeUrl"]));
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("MaterialVersion") != m.end() && !m["MaterialVersion"].empty()) {
      materialVersion = make_shared<string>(boost::any_cast<string>(m["MaterialVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportUrl") != m.end() && !m["PassportUrl"].empty()) {
      passportUrl = make_shared<string>(boost::any_cast<string>(m["PassportUrl"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<long>(boost::any_cast<long>(m["PersonalType"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("ReviewAdditionalFiles") != m.end() && !m["ReviewAdditionalFiles"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReviewAdditionalFiles"].type()) {
        QueryTradeMarkApplicationDetailResponseBodyMaterialDetailReviewAdditionalFiles model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReviewAdditionalFiles"]));
        reviewAdditionalFiles = make_shared<QueryTradeMarkApplicationDetailResponseBodyMaterialDetailReviewAdditionalFiles>(model1);
      }
    }
    if (m.find("ReviewApplicationFile") != m.end() && !m["ReviewApplicationFile"].empty()) {
      reviewApplicationFile = make_shared<string>(boost::any_cast<string>(m["ReviewApplicationFile"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SupplementEvidenceCatalogFile") != m.end() && !m["SupplementEvidenceCatalogFile"].empty()) {
      supplementEvidenceCatalogFile = make_shared<string>(boost::any_cast<string>(m["SupplementEvidenceCatalogFile"]));
    }
    if (m.find("SupplementEvidenceMaterialFile") != m.end() && !m["SupplementEvidenceMaterialFile"].empty()) {
      supplementEvidenceMaterialFile = make_shared<string>(boost::any_cast<string>(m["SupplementEvidenceMaterialFile"]));
    }
    if (m.find("SupplementReasonFile") != m.end() && !m["SupplementReasonFile"].empty()) {
      supplementReasonFile = make_shared<string>(boost::any_cast<string>(m["SupplementReasonFile"]));
    }
    if (m.find("Town") != m.end() && !m["Town"].empty()) {
      town = make_shared<string>(boost::any_cast<string>(m["Town"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodyMaterialDetail() = default;
};
class QueryTradeMarkApplicationDetailResponseBodyReceiptUrl : public Darabonba::Model {
public:
  shared_ptr<vector<string>> receiptUrl{};

  QueryTradeMarkApplicationDetailResponseBodyReceiptUrl() {}

  explicit QueryTradeMarkApplicationDetailResponseBodyReceiptUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (receiptUrl) {
      res["ReceiptUrl"] = boost::any(*receiptUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReceiptUrl") != m.end() && !m["ReceiptUrl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiptUrl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiptUrl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiptUrl = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodyReceiptUrl() = default;
};
class QueryTradeMarkApplicationDetailResponseBodyRenewResponse : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> engAddress{};
  shared_ptr<string> engName{};
  shared_ptr<string> name{};
  shared_ptr<long> registerTime{};
  shared_ptr<long> submitSbjtime{};

  QueryTradeMarkApplicationDetailResponseBodyRenewResponse() {}

  explicit QueryTradeMarkApplicationDetailResponseBodyRenewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (engAddress) {
      res["EngAddress"] = boost::any(*engAddress);
    }
    if (engName) {
      res["EngName"] = boost::any(*engName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (registerTime) {
      res["RegisterTime"] = boost::any(*registerTime);
    }
    if (submitSbjtime) {
      res["SubmitSbjtime"] = boost::any(*submitSbjtime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("EngAddress") != m.end() && !m["EngAddress"].empty()) {
      engAddress = make_shared<string>(boost::any_cast<string>(m["EngAddress"]));
    }
    if (m.find("EngName") != m.end() && !m["EngName"].empty()) {
      engName = make_shared<string>(boost::any_cast<string>(m["EngName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegisterTime") != m.end() && !m["RegisterTime"].empty()) {
      registerTime = make_shared<long>(boost::any_cast<long>(m["RegisterTime"]));
    }
    if (m.find("SubmitSbjtime") != m.end() && !m["SubmitSbjtime"].empty()) {
      submitSbjtime = make_shared<long>(boost::any_cast<long>(m["SubmitSbjtime"]));
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodyRenewResponse() = default;
};
class QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFilesReviewSupplements : public Darabonba::Model {
public:
  shared_ptr<vector<string>> reviewSupplement{};

  QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFilesReviewSupplements() {}

  explicit QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFilesReviewSupplements(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reviewSupplement) {
      res["ReviewSupplement"] = boost::any(*reviewSupplement);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReviewSupplement") != m.end() && !m["ReviewSupplement"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReviewSupplement"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReviewSupplement"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reviewSupplement = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFilesReviewSupplements() = default;
};
class QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFiles : public Darabonba::Model {
public:
  shared_ptr<string> reviewAudit{};
  shared_ptr<string> reviewKeep{};
  shared_ptr<string> reviewPart{};
  shared_ptr<string> reviewPass{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFilesReviewSupplements> reviewSupplements{};

  QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFiles() {}

  explicit QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reviewAudit) {
      res["ReviewAudit"] = boost::any(*reviewAudit);
    }
    if (reviewKeep) {
      res["ReviewKeep"] = boost::any(*reviewKeep);
    }
    if (reviewPart) {
      res["ReviewPart"] = boost::any(*reviewPart);
    }
    if (reviewPass) {
      res["ReviewPass"] = boost::any(*reviewPass);
    }
    if (reviewSupplements) {
      res["ReviewSupplements"] = reviewSupplements ? boost::any(reviewSupplements->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReviewAudit") != m.end() && !m["ReviewAudit"].empty()) {
      reviewAudit = make_shared<string>(boost::any_cast<string>(m["ReviewAudit"]));
    }
    if (m.find("ReviewKeep") != m.end() && !m["ReviewKeep"].empty()) {
      reviewKeep = make_shared<string>(boost::any_cast<string>(m["ReviewKeep"]));
    }
    if (m.find("ReviewPart") != m.end() && !m["ReviewPart"].empty()) {
      reviewPart = make_shared<string>(boost::any_cast<string>(m["ReviewPart"]));
    }
    if (m.find("ReviewPass") != m.end() && !m["ReviewPass"].empty()) {
      reviewPass = make_shared<string>(boost::any_cast<string>(m["ReviewPass"]));
    }
    if (m.find("ReviewSupplements") != m.end() && !m["ReviewSupplements"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReviewSupplements"].type()) {
        QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFilesReviewSupplements model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReviewSupplements"]));
        reviewSupplements = make_shared<QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFilesReviewSupplements>(model1);
      }
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFiles() = default;
};
class QueryTradeMarkApplicationDetailResponseBodySupplementsSupplementsFileTemplateUrls : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fileTemplateUrls{};

  QueryTradeMarkApplicationDetailResponseBodySupplementsSupplementsFileTemplateUrls() {}

  explicit QueryTradeMarkApplicationDetailResponseBodySupplementsSupplementsFileTemplateUrls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileTemplateUrls) {
      res["FileTemplateUrls"] = boost::any(*fileTemplateUrls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileTemplateUrls") != m.end() && !m["FileTemplateUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileTemplateUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileTemplateUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileTemplateUrls = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodySupplementsSupplementsFileTemplateUrls() = default;
};
class QueryTradeMarkApplicationDetailResponseBodySupplementsSupplements : public Darabonba::Model {
public:
  shared_ptr<long> acceptDeadTime{};
  shared_ptr<long> acceptTime{};
  shared_ptr<string> batchNum{};
  shared_ptr<string> content{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBodySupplementsSupplementsFileTemplateUrls> fileTemplateUrls{};
  shared_ptr<string> filename{};
  shared_ptr<long> id{};
  shared_ptr<long> operateTime{};
  shared_ptr<string> orderId{};
  shared_ptr<long> sbjDeadTime{};
  shared_ptr<long> sendTime{};
  shared_ptr<string> serialNumber{};
  shared_ptr<long> status{};
  shared_ptr<string> tmNumber{};
  shared_ptr<long> type{};
  shared_ptr<string> uploadFileTemplateUrl{};

  QueryTradeMarkApplicationDetailResponseBodySupplementsSupplements() {}

  explicit QueryTradeMarkApplicationDetailResponseBodySupplementsSupplements(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptDeadTime) {
      res["AcceptDeadTime"] = boost::any(*acceptDeadTime);
    }
    if (acceptTime) {
      res["AcceptTime"] = boost::any(*acceptTime);
    }
    if (batchNum) {
      res["BatchNum"] = boost::any(*batchNum);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fileTemplateUrls) {
      res["FileTemplateUrls"] = fileTemplateUrls ? boost::any(fileTemplateUrls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filename) {
      res["Filename"] = boost::any(*filename);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (operateTime) {
      res["OperateTime"] = boost::any(*operateTime);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (sbjDeadTime) {
      res["SbjDeadTime"] = boost::any(*sbjDeadTime);
    }
    if (sendTime) {
      res["SendTime"] = boost::any(*sendTime);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uploadFileTemplateUrl) {
      res["UploadFileTemplateUrl"] = boost::any(*uploadFileTemplateUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptDeadTime") != m.end() && !m["AcceptDeadTime"].empty()) {
      acceptDeadTime = make_shared<long>(boost::any_cast<long>(m["AcceptDeadTime"]));
    }
    if (m.find("AcceptTime") != m.end() && !m["AcceptTime"].empty()) {
      acceptTime = make_shared<long>(boost::any_cast<long>(m["AcceptTime"]));
    }
    if (m.find("BatchNum") != m.end() && !m["BatchNum"].empty()) {
      batchNum = make_shared<string>(boost::any_cast<string>(m["BatchNum"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FileTemplateUrls") != m.end() && !m["FileTemplateUrls"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileTemplateUrls"].type()) {
        QueryTradeMarkApplicationDetailResponseBodySupplementsSupplementsFileTemplateUrls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileTemplateUrls"]));
        fileTemplateUrls = make_shared<QueryTradeMarkApplicationDetailResponseBodySupplementsSupplementsFileTemplateUrls>(model1);
      }
    }
    if (m.find("Filename") != m.end() && !m["Filename"].empty()) {
      filename = make_shared<string>(boost::any_cast<string>(m["Filename"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OperateTime") != m.end() && !m["OperateTime"].empty()) {
      operateTime = make_shared<long>(boost::any_cast<long>(m["OperateTime"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("SbjDeadTime") != m.end() && !m["SbjDeadTime"].empty()) {
      sbjDeadTime = make_shared<long>(boost::any_cast<long>(m["SbjDeadTime"]));
    }
    if (m.find("SendTime") != m.end() && !m["SendTime"].empty()) {
      sendTime = make_shared<long>(boost::any_cast<long>(m["SendTime"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UploadFileTemplateUrl") != m.end() && !m["UploadFileTemplateUrl"].empty()) {
      uploadFileTemplateUrl = make_shared<string>(boost::any_cast<string>(m["UploadFileTemplateUrl"]));
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodySupplementsSupplements() = default;
};
class QueryTradeMarkApplicationDetailResponseBodySupplements : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTradeMarkApplicationDetailResponseBodySupplementsSupplements>> supplements{};

  QueryTradeMarkApplicationDetailResponseBodySupplements() {}

  explicit QueryTradeMarkApplicationDetailResponseBodySupplements(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supplements) {
      vector<boost::any> temp1;
      for(auto item1:*supplements){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Supplements"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Supplements") != m.end() && !m["Supplements"].empty()) {
      if (typeid(vector<boost::any>) == m["Supplements"].type()) {
        vector<QueryTradeMarkApplicationDetailResponseBodySupplementsSupplements> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Supplements"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTradeMarkApplicationDetailResponseBodySupplementsSupplements model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supplements = make_shared<vector<QueryTradeMarkApplicationDetailResponseBodySupplementsSupplements>>(expect1);
      }
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodySupplements() = default;
};
class QueryTradeMarkApplicationDetailResponseBodyThirdClassificationThirdClassifications : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  QueryTradeMarkApplicationDetailResponseBodyThirdClassificationThirdClassifications() {}

  explicit QueryTradeMarkApplicationDetailResponseBodyThirdClassificationThirdClassifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodyThirdClassificationThirdClassifications() = default;
};
class QueryTradeMarkApplicationDetailResponseBodyThirdClassification : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTradeMarkApplicationDetailResponseBodyThirdClassificationThirdClassifications>> thirdClassifications{};

  QueryTradeMarkApplicationDetailResponseBodyThirdClassification() {}

  explicit QueryTradeMarkApplicationDetailResponseBodyThirdClassification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thirdClassifications) {
      vector<boost::any> temp1;
      for(auto item1:*thirdClassifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ThirdClassifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThirdClassifications") != m.end() && !m["ThirdClassifications"].empty()) {
      if (typeid(vector<boost::any>) == m["ThirdClassifications"].type()) {
        vector<QueryTradeMarkApplicationDetailResponseBodyThirdClassificationThirdClassifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ThirdClassifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTradeMarkApplicationDetailResponseBodyThirdClassificationThirdClassifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        thirdClassifications = make_shared<vector<QueryTradeMarkApplicationDetailResponseBodyThirdClassificationThirdClassifications>>(expect1);
      }
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBodyThirdClassification() = default;
};
class QueryTradeMarkApplicationDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceptUrl{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBodyAdminUploads> adminUploads{};
  shared_ptr<string> bizId{};
  shared_ptr<long> createTime{};
  shared_ptr<map<string, boost::any>> extendInfo{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBodyFirstClassification> firstClassification{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBodyFlags> flags{};
  shared_ptr<string> grayIconUrl{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBodyJudgeResultUrl> judgeResultUrl{};
  shared_ptr<string> legalNoticeUrl{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> logisticsCertificateUrl{};
  shared_ptr<string> logisticsNo{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBodyMaterialDetail> materialDetail{};
  shared_ptr<long> materialId{};
  shared_ptr<string> notAcceptUrl{};
  shared_ptr<string> note{};
  shared_ptr<string> orderId{};
  shared_ptr<double> orderPrice{};
  shared_ptr<string> partnerCode{};
  shared_ptr<string> partnerMobile{};
  shared_ptr<string> partnerName{};
  shared_ptr<long> principalName{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBodyReceiptUrl> receiptUrl{};
  shared_ptr<string> recvUserLogistics{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBodyRenewResponse> renewResponse{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFiles> reviewOfficialFiles{};
  shared_ptr<string> sendSbjLogistics{};
  shared_ptr<string> sendTime{};
  shared_ptr<string> sendUserLogistics{};
  shared_ptr<double> servicePrice{};
  shared_ptr<long> specification{};
  shared_ptr<long> status{};
  shared_ptr<long> submitAuditTime{};
  shared_ptr<long> submitTime{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBodySupplements> supplements{};
  shared_ptr<string> systemVersion{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBodyThirdClassification> thirdClassification{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<long> tmNameType{};
  shared_ptr<string> tmNumber{};
  shared_ptr<double> totalPrice{};
  shared_ptr<long> type{};
  shared_ptr<long> updateTime{};

  QueryTradeMarkApplicationDetailResponseBody() {}

  explicit QueryTradeMarkApplicationDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptUrl) {
      res["AcceptUrl"] = boost::any(*acceptUrl);
    }
    if (adminUploads) {
      res["AdminUploads"] = adminUploads ? boost::any(adminUploads->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (firstClassification) {
      res["FirstClassification"] = firstClassification ? boost::any(firstClassification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flags) {
      res["Flags"] = flags ? boost::any(flags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (grayIconUrl) {
      res["GrayIconUrl"] = boost::any(*grayIconUrl);
    }
    if (judgeResultUrl) {
      res["JudgeResultUrl"] = judgeResultUrl ? boost::any(judgeResultUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (legalNoticeUrl) {
      res["LegalNoticeUrl"] = boost::any(*legalNoticeUrl);
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (logisticsCertificateUrl) {
      res["LogisticsCertificateUrl"] = boost::any(*logisticsCertificateUrl);
    }
    if (logisticsNo) {
      res["LogisticsNo"] = boost::any(*logisticsNo);
    }
    if (materialDetail) {
      res["MaterialDetail"] = materialDetail ? boost::any(materialDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (notAcceptUrl) {
      res["NotAcceptUrl"] = boost::any(*notAcceptUrl);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (orderPrice) {
      res["OrderPrice"] = boost::any(*orderPrice);
    }
    if (partnerCode) {
      res["PartnerCode"] = boost::any(*partnerCode);
    }
    if (partnerMobile) {
      res["PartnerMobile"] = boost::any(*partnerMobile);
    }
    if (partnerName) {
      res["PartnerName"] = boost::any(*partnerName);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (receiptUrl) {
      res["ReceiptUrl"] = receiptUrl ? boost::any(receiptUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recvUserLogistics) {
      res["RecvUserLogistics"] = boost::any(*recvUserLogistics);
    }
    if (renewResponse) {
      res["RenewResponse"] = renewResponse ? boost::any(renewResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reviewOfficialFiles) {
      res["ReviewOfficialFiles"] = reviewOfficialFiles ? boost::any(reviewOfficialFiles->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sendSbjLogistics) {
      res["SendSbjLogistics"] = boost::any(*sendSbjLogistics);
    }
    if (sendTime) {
      res["SendTime"] = boost::any(*sendTime);
    }
    if (sendUserLogistics) {
      res["SendUserLogistics"] = boost::any(*sendUserLogistics);
    }
    if (servicePrice) {
      res["ServicePrice"] = boost::any(*servicePrice);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitAuditTime) {
      res["SubmitAuditTime"] = boost::any(*submitAuditTime);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (supplements) {
      res["Supplements"] = supplements ? boost::any(supplements->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemVersion) {
      res["SystemVersion"] = boost::any(*systemVersion);
    }
    if (thirdClassification) {
      res["ThirdClassification"] = thirdClassification ? boost::any(thirdClassification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNameType) {
      res["TmNameType"] = boost::any(*tmNameType);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (totalPrice) {
      res["TotalPrice"] = boost::any(*totalPrice);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptUrl") != m.end() && !m["AcceptUrl"].empty()) {
      acceptUrl = make_shared<string>(boost::any_cast<string>(m["AcceptUrl"]));
    }
    if (m.find("AdminUploads") != m.end() && !m["AdminUploads"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdminUploads"].type()) {
        QueryTradeMarkApplicationDetailResponseBodyAdminUploads model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdminUploads"]));
        adminUploads = make_shared<QueryTradeMarkApplicationDetailResponseBodyAdminUploads>(model1);
      }
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtendInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extendInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("FirstClassification") != m.end() && !m["FirstClassification"].empty()) {
      if (typeid(map<string, boost::any>) == m["FirstClassification"].type()) {
        QueryTradeMarkApplicationDetailResponseBodyFirstClassification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FirstClassification"]));
        firstClassification = make_shared<QueryTradeMarkApplicationDetailResponseBodyFirstClassification>(model1);
      }
    }
    if (m.find("Flags") != m.end() && !m["Flags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Flags"].type()) {
        QueryTradeMarkApplicationDetailResponseBodyFlags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Flags"]));
        flags = make_shared<QueryTradeMarkApplicationDetailResponseBodyFlags>(model1);
      }
    }
    if (m.find("GrayIconUrl") != m.end() && !m["GrayIconUrl"].empty()) {
      grayIconUrl = make_shared<string>(boost::any_cast<string>(m["GrayIconUrl"]));
    }
    if (m.find("JudgeResultUrl") != m.end() && !m["JudgeResultUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["JudgeResultUrl"].type()) {
        QueryTradeMarkApplicationDetailResponseBodyJudgeResultUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JudgeResultUrl"]));
        judgeResultUrl = make_shared<QueryTradeMarkApplicationDetailResponseBodyJudgeResultUrl>(model1);
      }
    }
    if (m.find("LegalNoticeUrl") != m.end() && !m["LegalNoticeUrl"].empty()) {
      legalNoticeUrl = make_shared<string>(boost::any_cast<string>(m["LegalNoticeUrl"]));
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("LogisticsCertificateUrl") != m.end() && !m["LogisticsCertificateUrl"].empty()) {
      logisticsCertificateUrl = make_shared<string>(boost::any_cast<string>(m["LogisticsCertificateUrl"]));
    }
    if (m.find("LogisticsNo") != m.end() && !m["LogisticsNo"].empty()) {
      logisticsNo = make_shared<string>(boost::any_cast<string>(m["LogisticsNo"]));
    }
    if (m.find("MaterialDetail") != m.end() && !m["MaterialDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaterialDetail"].type()) {
        QueryTradeMarkApplicationDetailResponseBodyMaterialDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaterialDetail"]));
        materialDetail = make_shared<QueryTradeMarkApplicationDetailResponseBodyMaterialDetail>(model1);
      }
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<long>(boost::any_cast<long>(m["MaterialId"]));
    }
    if (m.find("NotAcceptUrl") != m.end() && !m["NotAcceptUrl"].empty()) {
      notAcceptUrl = make_shared<string>(boost::any_cast<string>(m["NotAcceptUrl"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OrderPrice") != m.end() && !m["OrderPrice"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["OrderPrice"]));
    }
    if (m.find("PartnerCode") != m.end() && !m["PartnerCode"].empty()) {
      partnerCode = make_shared<string>(boost::any_cast<string>(m["PartnerCode"]));
    }
    if (m.find("PartnerMobile") != m.end() && !m["PartnerMobile"].empty()) {
      partnerMobile = make_shared<string>(boost::any_cast<string>(m["PartnerMobile"]));
    }
    if (m.find("PartnerName") != m.end() && !m["PartnerName"].empty()) {
      partnerName = make_shared<string>(boost::any_cast<string>(m["PartnerName"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("ReceiptUrl") != m.end() && !m["ReceiptUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReceiptUrl"].type()) {
        QueryTradeMarkApplicationDetailResponseBodyReceiptUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReceiptUrl"]));
        receiptUrl = make_shared<QueryTradeMarkApplicationDetailResponseBodyReceiptUrl>(model1);
      }
    }
    if (m.find("RecvUserLogistics") != m.end() && !m["RecvUserLogistics"].empty()) {
      recvUserLogistics = make_shared<string>(boost::any_cast<string>(m["RecvUserLogistics"]));
    }
    if (m.find("RenewResponse") != m.end() && !m["RenewResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["RenewResponse"].type()) {
        QueryTradeMarkApplicationDetailResponseBodyRenewResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RenewResponse"]));
        renewResponse = make_shared<QueryTradeMarkApplicationDetailResponseBodyRenewResponse>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReviewOfficialFiles") != m.end() && !m["ReviewOfficialFiles"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReviewOfficialFiles"].type()) {
        QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFiles model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReviewOfficialFiles"]));
        reviewOfficialFiles = make_shared<QueryTradeMarkApplicationDetailResponseBodyReviewOfficialFiles>(model1);
      }
    }
    if (m.find("SendSbjLogistics") != m.end() && !m["SendSbjLogistics"].empty()) {
      sendSbjLogistics = make_shared<string>(boost::any_cast<string>(m["SendSbjLogistics"]));
    }
    if (m.find("SendTime") != m.end() && !m["SendTime"].empty()) {
      sendTime = make_shared<string>(boost::any_cast<string>(m["SendTime"]));
    }
    if (m.find("SendUserLogistics") != m.end() && !m["SendUserLogistics"].empty()) {
      sendUserLogistics = make_shared<string>(boost::any_cast<string>(m["SendUserLogistics"]));
    }
    if (m.find("ServicePrice") != m.end() && !m["ServicePrice"].empty()) {
      servicePrice = make_shared<double>(boost::any_cast<double>(m["ServicePrice"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<long>(boost::any_cast<long>(m["Specification"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SubmitAuditTime") != m.end() && !m["SubmitAuditTime"].empty()) {
      submitAuditTime = make_shared<long>(boost::any_cast<long>(m["SubmitAuditTime"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<long>(boost::any_cast<long>(m["SubmitTime"]));
    }
    if (m.find("Supplements") != m.end() && !m["Supplements"].empty()) {
      if (typeid(map<string, boost::any>) == m["Supplements"].type()) {
        QueryTradeMarkApplicationDetailResponseBodySupplements model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Supplements"]));
        supplements = make_shared<QueryTradeMarkApplicationDetailResponseBodySupplements>(model1);
      }
    }
    if (m.find("SystemVersion") != m.end() && !m["SystemVersion"].empty()) {
      systemVersion = make_shared<string>(boost::any_cast<string>(m["SystemVersion"]));
    }
    if (m.find("ThirdClassification") != m.end() && !m["ThirdClassification"].empty()) {
      if (typeid(map<string, boost::any>) == m["ThirdClassification"].type()) {
        QueryTradeMarkApplicationDetailResponseBodyThirdClassification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ThirdClassification"]));
        thirdClassification = make_shared<QueryTradeMarkApplicationDetailResponseBodyThirdClassification>(model1);
      }
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNameType") != m.end() && !m["TmNameType"].empty()) {
      tmNameType = make_shared<long>(boost::any_cast<long>(m["TmNameType"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("TotalPrice") != m.end() && !m["TotalPrice"].empty()) {
      totalPrice = make_shared<double>(boost::any_cast<double>(m["TotalPrice"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponseBody() = default;
};
class QueryTradeMarkApplicationDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTradeMarkApplicationDetailResponseBody> body{};

  QueryTradeMarkApplicationDetailResponse() {}

  explicit QueryTradeMarkApplicationDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTradeMarkApplicationDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTradeMarkApplicationDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTradeMarkApplicationDetailResponse() = default;
};
class QueryTradeMarkApplicationLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};

  QueryTradeMarkApplicationLogsRequest() {}

  explicit QueryTradeMarkApplicationLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~QueryTradeMarkApplicationLogsRequest() = default;
};
class QueryTradeMarkApplicationLogsResponseBodyDataData : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> bizStatus{};
  shared_ptr<string> extendContent{};
  shared_ptr<string> note{};
  shared_ptr<long> operateTime{};
  shared_ptr<long> operateType{};
  shared_ptr<long> toBizStatus{};

  QueryTradeMarkApplicationLogsResponseBodyDataData() {}

  explicit QueryTradeMarkApplicationLogsResponseBodyDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizStatus) {
      res["BizStatus"] = boost::any(*bizStatus);
    }
    if (extendContent) {
      res["ExtendContent"] = boost::any(*extendContent);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (operateTime) {
      res["OperateTime"] = boost::any(*operateTime);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (toBizStatus) {
      res["ToBizStatus"] = boost::any(*toBizStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizStatus") != m.end() && !m["BizStatus"].empty()) {
      bizStatus = make_shared<long>(boost::any_cast<long>(m["BizStatus"]));
    }
    if (m.find("ExtendContent") != m.end() && !m["ExtendContent"].empty()) {
      extendContent = make_shared<string>(boost::any_cast<string>(m["ExtendContent"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("OperateTime") != m.end() && !m["OperateTime"].empty()) {
      operateTime = make_shared<long>(boost::any_cast<long>(m["OperateTime"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<long>(boost::any_cast<long>(m["OperateType"]));
    }
    if (m.find("ToBizStatus") != m.end() && !m["ToBizStatus"].empty()) {
      toBizStatus = make_shared<long>(boost::any_cast<long>(m["ToBizStatus"]));
    }
  }


  virtual ~QueryTradeMarkApplicationLogsResponseBodyDataData() = default;
};
class QueryTradeMarkApplicationLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTradeMarkApplicationLogsResponseBodyDataData>> data{};

  QueryTradeMarkApplicationLogsResponseBodyData() {}

  explicit QueryTradeMarkApplicationLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryTradeMarkApplicationLogsResponseBodyDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTradeMarkApplicationLogsResponseBodyDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryTradeMarkApplicationLogsResponseBodyDataData>>(expect1);
      }
    }
  }


  virtual ~QueryTradeMarkApplicationLogsResponseBodyData() = default;
};
class QueryTradeMarkApplicationLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTradeMarkApplicationLogsResponseBodyData> data{};
  shared_ptr<string> requestId{};

  QueryTradeMarkApplicationLogsResponseBody() {}

  explicit QueryTradeMarkApplicationLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTradeMarkApplicationLogsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTradeMarkApplicationLogsResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryTradeMarkApplicationLogsResponseBody() = default;
};
class QueryTradeMarkApplicationLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTradeMarkApplicationLogsResponseBody> body{};

  QueryTradeMarkApplicationLogsResponse() {}

  explicit QueryTradeMarkApplicationLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTradeMarkApplicationLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTradeMarkApplicationLogsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTradeMarkApplicationLogsResponse() = default;
};
class QueryTradeMarkApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> classificationCode{};
  shared_ptr<long> hidden{};
  shared_ptr<string> intentionBizId{};
  shared_ptr<string> logisticsNo{};
  shared_ptr<string> materialName{};
  shared_ptr<string> orderId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> productType{};
  shared_ptr<string> sortFiled{};
  shared_ptr<string> sortOrder{};
  shared_ptr<long> specification{};
  shared_ptr<long> status{};
  shared_ptr<vector<long>> statusList{};
  shared_ptr<long> supplementStatus{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNumber{};
  shared_ptr<string> type{};

  QueryTradeMarkApplicationsRequest() {}

  explicit QueryTradeMarkApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (hidden) {
      res["Hidden"] = boost::any(*hidden);
    }
    if (intentionBizId) {
      res["IntentionBizId"] = boost::any(*intentionBizId);
    }
    if (logisticsNo) {
      res["LogisticsNo"] = boost::any(*logisticsNo);
    }
    if (materialName) {
      res["MaterialName"] = boost::any(*materialName);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (sortFiled) {
      res["SortFiled"] = boost::any(*sortFiled);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (supplementStatus) {
      res["SupplementStatus"] = boost::any(*supplementStatus);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("Hidden") != m.end() && !m["Hidden"].empty()) {
      hidden = make_shared<long>(boost::any_cast<long>(m["Hidden"]));
    }
    if (m.find("IntentionBizId") != m.end() && !m["IntentionBizId"].empty()) {
      intentionBizId = make_shared<string>(boost::any_cast<string>(m["IntentionBizId"]));
    }
    if (m.find("LogisticsNo") != m.end() && !m["LogisticsNo"].empty()) {
      logisticsNo = make_shared<string>(boost::any_cast<string>(m["LogisticsNo"]));
    }
    if (m.find("MaterialName") != m.end() && !m["MaterialName"].empty()) {
      materialName = make_shared<string>(boost::any_cast<string>(m["MaterialName"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["ProductType"]));
    }
    if (m.find("SortFiled") != m.end() && !m["SortFiled"].empty()) {
      sortFiled = make_shared<string>(boost::any_cast<string>(m["SortFiled"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<long>(boost::any_cast<long>(m["Specification"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      statusList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SupplementStatus") != m.end() && !m["SupplementStatus"].empty()) {
      supplementStatus = make_shared<long>(boost::any_cast<long>(m["SupplementStatus"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryTradeMarkApplicationsRequest() = default;
};
class QueryTradeMarkApplicationsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> classificationCode{};
  shared_ptr<long> hidden{};
  shared_ptr<string> intentionBizId{};
  shared_ptr<string> logisticsNo{};
  shared_ptr<string> materialName{};
  shared_ptr<string> orderId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> productType{};
  shared_ptr<string> sortFiled{};
  shared_ptr<string> sortOrder{};
  shared_ptr<long> specification{};
  shared_ptr<long> status{};
  shared_ptr<string> statusListShrink{};
  shared_ptr<long> supplementStatus{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNumber{};
  shared_ptr<string> type{};

  QueryTradeMarkApplicationsShrinkRequest() {}

  explicit QueryTradeMarkApplicationsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (hidden) {
      res["Hidden"] = boost::any(*hidden);
    }
    if (intentionBizId) {
      res["IntentionBizId"] = boost::any(*intentionBizId);
    }
    if (logisticsNo) {
      res["LogisticsNo"] = boost::any(*logisticsNo);
    }
    if (materialName) {
      res["MaterialName"] = boost::any(*materialName);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (sortFiled) {
      res["SortFiled"] = boost::any(*sortFiled);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusListShrink) {
      res["StatusList"] = boost::any(*statusListShrink);
    }
    if (supplementStatus) {
      res["SupplementStatus"] = boost::any(*supplementStatus);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("Hidden") != m.end() && !m["Hidden"].empty()) {
      hidden = make_shared<long>(boost::any_cast<long>(m["Hidden"]));
    }
    if (m.find("IntentionBizId") != m.end() && !m["IntentionBizId"].empty()) {
      intentionBizId = make_shared<string>(boost::any_cast<string>(m["IntentionBizId"]));
    }
    if (m.find("LogisticsNo") != m.end() && !m["LogisticsNo"].empty()) {
      logisticsNo = make_shared<string>(boost::any_cast<string>(m["LogisticsNo"]));
    }
    if (m.find("MaterialName") != m.end() && !m["MaterialName"].empty()) {
      materialName = make_shared<string>(boost::any_cast<string>(m["MaterialName"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["ProductType"]));
    }
    if (m.find("SortFiled") != m.end() && !m["SortFiled"].empty()) {
      sortFiled = make_shared<string>(boost::any_cast<string>(m["SortFiled"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<long>(boost::any_cast<long>(m["Specification"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      statusListShrink = make_shared<string>(boost::any_cast<string>(m["StatusList"]));
    }
    if (m.find("SupplementStatus") != m.end() && !m["SupplementStatus"].empty()) {
      supplementStatus = make_shared<long>(boost::any_cast<long>(m["SupplementStatus"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryTradeMarkApplicationsShrinkRequest() = default;
};
class QueryTradeMarkApplicationsResponseBodyDataTmProducesFirstClassification : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTradeMarkApplicationsResponseBodyDataTmProducesFirstClassification() {}

  explicit QueryTradeMarkApplicationsResponseBodyDataTmProducesFirstClassification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTradeMarkApplicationsResponseBodyDataTmProducesFirstClassification() = default;
};
class QueryTradeMarkApplicationsResponseBodyDataTmProducesFlags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> flags{};

  QueryTradeMarkApplicationsResponseBodyDataTmProducesFlags() {}

  explicit QueryTradeMarkApplicationsResponseBodyDataTmProducesFlags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flags) {
      res["Flags"] = boost::any(*flags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flags") != m.end() && !m["Flags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Flags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Flags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      flags = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryTradeMarkApplicationsResponseBodyDataTmProducesFlags() = default;
};
class QueryTradeMarkApplicationsResponseBodyDataTmProducesRenewResponse : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> engAddress{};
  shared_ptr<string> engName{};
  shared_ptr<string> name{};
  shared_ptr<long> registerTime{};
  shared_ptr<long> submitSbjtime{};

  QueryTradeMarkApplicationsResponseBodyDataTmProducesRenewResponse() {}

  explicit QueryTradeMarkApplicationsResponseBodyDataTmProducesRenewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (engAddress) {
      res["EngAddress"] = boost::any(*engAddress);
    }
    if (engName) {
      res["EngName"] = boost::any(*engName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (registerTime) {
      res["RegisterTime"] = boost::any(*registerTime);
    }
    if (submitSbjtime) {
      res["SubmitSbjtime"] = boost::any(*submitSbjtime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("EngAddress") != m.end() && !m["EngAddress"].empty()) {
      engAddress = make_shared<string>(boost::any_cast<string>(m["EngAddress"]));
    }
    if (m.find("EngName") != m.end() && !m["EngName"].empty()) {
      engName = make_shared<string>(boost::any_cast<string>(m["EngName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegisterTime") != m.end() && !m["RegisterTime"].empty()) {
      registerTime = make_shared<long>(boost::any_cast<long>(m["RegisterTime"]));
    }
    if (m.find("SubmitSbjtime") != m.end() && !m["SubmitSbjtime"].empty()) {
      submitSbjtime = make_shared<long>(boost::any_cast<long>(m["SubmitSbjtime"]));
    }
  }


  virtual ~QueryTradeMarkApplicationsResponseBodyDataTmProducesRenewResponse() = default;
};
class QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassificationThirdClassifications : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassificationThirdClassifications() {}

  explicit QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassificationThirdClassifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassificationThirdClassifications() = default;
};
class QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassification : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassificationThirdClassifications>> thirdClassifications{};

  QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassification() {}

  explicit QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thirdClassifications) {
      vector<boost::any> temp1;
      for(auto item1:*thirdClassifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ThirdClassifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThirdClassifications") != m.end() && !m["ThirdClassifications"].empty()) {
      if (typeid(vector<boost::any>) == m["ThirdClassifications"].type()) {
        vector<QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassificationThirdClassifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ThirdClassifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassificationThirdClassifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        thirdClassifications = make_shared<vector<QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassificationThirdClassifications>>(expect1);
      }
    }
  }


  virtual ~QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassification() = default;
};
class QueryTradeMarkApplicationsResponseBodyDataTmProduces : public Darabonba::Model {
public:
  shared_ptr<string> agreementId{};
  shared_ptr<string> bizId{};
  shared_ptr<long> createTime{};
  shared_ptr<QueryTradeMarkApplicationsResponseBodyDataTmProducesFirstClassification> firstClassification{};
  shared_ptr<QueryTradeMarkApplicationsResponseBodyDataTmProducesFlags> flags{};
  shared_ptr<string> loaUrl{};
  shared_ptr<long> materialId{};
  shared_ptr<string> materialName{};
  shared_ptr<string> note{};
  shared_ptr<string> orderId{};
  shared_ptr<double> orderPrice{};
  shared_ptr<long> principalName{};
  shared_ptr<string> remark{};
  shared_ptr<QueryTradeMarkApplicationsResponseBodyDataTmProducesRenewResponse> renewResponse{};
  shared_ptr<double> servicePrice{};
  shared_ptr<bool> showGoToDefendButton{};
  shared_ptr<long> specification{};
  shared_ptr<long> status{};
  shared_ptr<long> submitAuditTime{};
  shared_ptr<long> submitTime{};
  shared_ptr<long> supplementId{};
  shared_ptr<long> supplementStatus{};
  shared_ptr<string> systemVersion{};
  shared_ptr<QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassification> thirdClassification{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNumber{};
  shared_ptr<double> totalPrice{};
  shared_ptr<long> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  QueryTradeMarkApplicationsResponseBodyDataTmProduces() {}

  explicit QueryTradeMarkApplicationsResponseBodyDataTmProduces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementId) {
      res["AgreementId"] = boost::any(*agreementId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (firstClassification) {
      res["FirstClassification"] = firstClassification ? boost::any(firstClassification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flags) {
      res["Flags"] = flags ? boost::any(flags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (materialName) {
      res["MaterialName"] = boost::any(*materialName);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (orderPrice) {
      res["OrderPrice"] = boost::any(*orderPrice);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (renewResponse) {
      res["RenewResponse"] = renewResponse ? boost::any(renewResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (servicePrice) {
      res["ServicePrice"] = boost::any(*servicePrice);
    }
    if (showGoToDefendButton) {
      res["ShowGoToDefendButton"] = boost::any(*showGoToDefendButton);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitAuditTime) {
      res["SubmitAuditTime"] = boost::any(*submitAuditTime);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (supplementId) {
      res["SupplementId"] = boost::any(*supplementId);
    }
    if (supplementStatus) {
      res["SupplementStatus"] = boost::any(*supplementStatus);
    }
    if (systemVersion) {
      res["SystemVersion"] = boost::any(*systemVersion);
    }
    if (thirdClassification) {
      res["ThirdClassification"] = thirdClassification ? boost::any(thirdClassification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (totalPrice) {
      res["TotalPrice"] = boost::any(*totalPrice);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementId") != m.end() && !m["AgreementId"].empty()) {
      agreementId = make_shared<string>(boost::any_cast<string>(m["AgreementId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FirstClassification") != m.end() && !m["FirstClassification"].empty()) {
      if (typeid(map<string, boost::any>) == m["FirstClassification"].type()) {
        QueryTradeMarkApplicationsResponseBodyDataTmProducesFirstClassification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FirstClassification"]));
        firstClassification = make_shared<QueryTradeMarkApplicationsResponseBodyDataTmProducesFirstClassification>(model1);
      }
    }
    if (m.find("Flags") != m.end() && !m["Flags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Flags"].type()) {
        QueryTradeMarkApplicationsResponseBodyDataTmProducesFlags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Flags"]));
        flags = make_shared<QueryTradeMarkApplicationsResponseBodyDataTmProducesFlags>(model1);
      }
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<long>(boost::any_cast<long>(m["MaterialId"]));
    }
    if (m.find("MaterialName") != m.end() && !m["MaterialName"].empty()) {
      materialName = make_shared<string>(boost::any_cast<string>(m["MaterialName"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OrderPrice") != m.end() && !m["OrderPrice"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["OrderPrice"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RenewResponse") != m.end() && !m["RenewResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["RenewResponse"].type()) {
        QueryTradeMarkApplicationsResponseBodyDataTmProducesRenewResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RenewResponse"]));
        renewResponse = make_shared<QueryTradeMarkApplicationsResponseBodyDataTmProducesRenewResponse>(model1);
      }
    }
    if (m.find("ServicePrice") != m.end() && !m["ServicePrice"].empty()) {
      servicePrice = make_shared<double>(boost::any_cast<double>(m["ServicePrice"]));
    }
    if (m.find("ShowGoToDefendButton") != m.end() && !m["ShowGoToDefendButton"].empty()) {
      showGoToDefendButton = make_shared<bool>(boost::any_cast<bool>(m["ShowGoToDefendButton"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<long>(boost::any_cast<long>(m["Specification"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SubmitAuditTime") != m.end() && !m["SubmitAuditTime"].empty()) {
      submitAuditTime = make_shared<long>(boost::any_cast<long>(m["SubmitAuditTime"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<long>(boost::any_cast<long>(m["SubmitTime"]));
    }
    if (m.find("SupplementId") != m.end() && !m["SupplementId"].empty()) {
      supplementId = make_shared<long>(boost::any_cast<long>(m["SupplementId"]));
    }
    if (m.find("SupplementStatus") != m.end() && !m["SupplementStatus"].empty()) {
      supplementStatus = make_shared<long>(boost::any_cast<long>(m["SupplementStatus"]));
    }
    if (m.find("SystemVersion") != m.end() && !m["SystemVersion"].empty()) {
      systemVersion = make_shared<string>(boost::any_cast<string>(m["SystemVersion"]));
    }
    if (m.find("ThirdClassification") != m.end() && !m["ThirdClassification"].empty()) {
      if (typeid(map<string, boost::any>) == m["ThirdClassification"].type()) {
        QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ThirdClassification"]));
        thirdClassification = make_shared<QueryTradeMarkApplicationsResponseBodyDataTmProducesThirdClassification>(model1);
      }
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("TotalPrice") != m.end() && !m["TotalPrice"].empty()) {
      totalPrice = make_shared<double>(boost::any_cast<double>(m["TotalPrice"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryTradeMarkApplicationsResponseBodyDataTmProduces() = default;
};
class QueryTradeMarkApplicationsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTradeMarkApplicationsResponseBodyDataTmProduces>> tmProduces{};

  QueryTradeMarkApplicationsResponseBodyData() {}

  explicit QueryTradeMarkApplicationsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tmProduces) {
      vector<boost::any> temp1;
      for(auto item1:*tmProduces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TmProduces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TmProduces") != m.end() && !m["TmProduces"].empty()) {
      if (typeid(vector<boost::any>) == m["TmProduces"].type()) {
        vector<QueryTradeMarkApplicationsResponseBodyDataTmProduces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TmProduces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTradeMarkApplicationsResponseBodyDataTmProduces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tmProduces = make_shared<vector<QueryTradeMarkApplicationsResponseBodyDataTmProduces>>(expect1);
      }
    }
  }


  virtual ~QueryTradeMarkApplicationsResponseBodyData() = default;
};
class QueryTradeMarkApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<QueryTradeMarkApplicationsResponseBodyData> data{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryTradeMarkApplicationsResponseBody() {}

  explicit QueryTradeMarkApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTradeMarkApplicationsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTradeMarkApplicationsResponseBodyData>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryTradeMarkApplicationsResponseBody() = default;
};
class QueryTradeMarkApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTradeMarkApplicationsResponseBody> body{};

  QueryTradeMarkApplicationsResponse() {}

  explicit QueryTradeMarkApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTradeMarkApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTradeMarkApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTradeMarkApplicationsResponse() = default;
};
class QueryTradeMarkApplicationsByIntentionRequest : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<string> intentionBizId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tmProduceStatus{};

  QueryTradeMarkApplicationsByIntentionRequest() {}

  explicit QueryTradeMarkApplicationsByIntentionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (intentionBizId) {
      res["IntentionBizId"] = boost::any(*intentionBizId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tmProduceStatus) {
      res["TmProduceStatus"] = boost::any(*tmProduceStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("IntentionBizId") != m.end() && !m["IntentionBizId"].empty()) {
      intentionBizId = make_shared<string>(boost::any_cast<string>(m["IntentionBizId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TmProduceStatus") != m.end() && !m["TmProduceStatus"].empty()) {
      tmProduceStatus = make_shared<string>(boost::any_cast<string>(m["TmProduceStatus"]));
    }
  }


  virtual ~QueryTradeMarkApplicationsByIntentionRequest() = default;
};
class QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesFirstClassification : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesFirstClassification() {}

  explicit QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesFirstClassification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesFirstClassification() = default;
};
class QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassificationThirdClassifications : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassificationThirdClassifications() {}

  explicit QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassificationThirdClassifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassificationThirdClassifications() = default;
};
class QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassification : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassificationThirdClassifications>> thirdClassifications{};

  QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassification() {}

  explicit QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thirdClassifications) {
      vector<boost::any> temp1;
      for(auto item1:*thirdClassifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ThirdClassifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThirdClassifications") != m.end() && !m["ThirdClassifications"].empty()) {
      if (typeid(vector<boost::any>) == m["ThirdClassifications"].type()) {
        vector<QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassificationThirdClassifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ThirdClassifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassificationThirdClassifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        thirdClassifications = make_shared<vector<QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassificationThirdClassifications>>(expect1);
      }
    }
  }


  virtual ~QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassification() = default;
};
class QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProduces : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> createTime{};
  shared_ptr<QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesFirstClassification> firstClassification{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> materialId{};
  shared_ptr<string> materialName{};
  shared_ptr<string> note{};
  shared_ptr<double> orderPrice{};
  shared_ptr<string> principalDescription{};
  shared_ptr<long> principalValue{};
  shared_ptr<double> servicePrice{};
  shared_ptr<long> status{};
  shared_ptr<long> supplementId{};
  shared_ptr<long> supplementStatus{};
  shared_ptr<QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassification> thirdClassification{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNumber{};
  shared_ptr<double> totalPrice{};
  shared_ptr<long> type{};
  shared_ptr<long> updateTime{};

  QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProduces() {}

  explicit QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProduces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (firstClassification) {
      res["FirstClassification"] = firstClassification ? boost::any(firstClassification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (materialName) {
      res["MaterialName"] = boost::any(*materialName);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (orderPrice) {
      res["OrderPrice"] = boost::any(*orderPrice);
    }
    if (principalDescription) {
      res["PrincipalDescription"] = boost::any(*principalDescription);
    }
    if (principalValue) {
      res["PrincipalValue"] = boost::any(*principalValue);
    }
    if (servicePrice) {
      res["ServicePrice"] = boost::any(*servicePrice);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (supplementId) {
      res["SupplementId"] = boost::any(*supplementId);
    }
    if (supplementStatus) {
      res["SupplementStatus"] = boost::any(*supplementStatus);
    }
    if (thirdClassification) {
      res["ThirdClassification"] = thirdClassification ? boost::any(thirdClassification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (totalPrice) {
      res["TotalPrice"] = boost::any(*totalPrice);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FirstClassification") != m.end() && !m["FirstClassification"].empty()) {
      if (typeid(map<string, boost::any>) == m["FirstClassification"].type()) {
        QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesFirstClassification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FirstClassification"]));
        firstClassification = make_shared<QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesFirstClassification>(model1);
      }
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("MaterialName") != m.end() && !m["MaterialName"].empty()) {
      materialName = make_shared<string>(boost::any_cast<string>(m["MaterialName"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("OrderPrice") != m.end() && !m["OrderPrice"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["OrderPrice"]));
    }
    if (m.find("PrincipalDescription") != m.end() && !m["PrincipalDescription"].empty()) {
      principalDescription = make_shared<string>(boost::any_cast<string>(m["PrincipalDescription"]));
    }
    if (m.find("PrincipalValue") != m.end() && !m["PrincipalValue"].empty()) {
      principalValue = make_shared<long>(boost::any_cast<long>(m["PrincipalValue"]));
    }
    if (m.find("ServicePrice") != m.end() && !m["ServicePrice"].empty()) {
      servicePrice = make_shared<double>(boost::any_cast<double>(m["ServicePrice"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SupplementId") != m.end() && !m["SupplementId"].empty()) {
      supplementId = make_shared<long>(boost::any_cast<long>(m["SupplementId"]));
    }
    if (m.find("SupplementStatus") != m.end() && !m["SupplementStatus"].empty()) {
      supplementStatus = make_shared<long>(boost::any_cast<long>(m["SupplementStatus"]));
    }
    if (m.find("ThirdClassification") != m.end() && !m["ThirdClassification"].empty()) {
      if (typeid(map<string, boost::any>) == m["ThirdClassification"].type()) {
        QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ThirdClassification"]));
        thirdClassification = make_shared<QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProducesThirdClassification>(model1);
      }
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("TotalPrice") != m.end() && !m["TotalPrice"].empty()) {
      totalPrice = make_shared<double>(boost::any_cast<double>(m["TotalPrice"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProduces() = default;
};
class QueryTradeMarkApplicationsByIntentionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProduces>> tmProduces{};

  QueryTradeMarkApplicationsByIntentionResponseBodyData() {}

  explicit QueryTradeMarkApplicationsByIntentionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tmProduces) {
      vector<boost::any> temp1;
      for(auto item1:*tmProduces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TmProduces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TmProduces") != m.end() && !m["TmProduces"].empty()) {
      if (typeid(vector<boost::any>) == m["TmProduces"].type()) {
        vector<QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProduces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TmProduces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProduces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tmProduces = make_shared<vector<QueryTradeMarkApplicationsByIntentionResponseBodyDataTmProduces>>(expect1);
      }
    }
  }


  virtual ~QueryTradeMarkApplicationsByIntentionResponseBodyData() = default;
};
class QueryTradeMarkApplicationsByIntentionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<QueryTradeMarkApplicationsByIntentionResponseBodyData> data{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryTradeMarkApplicationsByIntentionResponseBody() {}

  explicit QueryTradeMarkApplicationsByIntentionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTradeMarkApplicationsByIntentionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTradeMarkApplicationsByIntentionResponseBodyData>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryTradeMarkApplicationsByIntentionResponseBody() = default;
};
class QueryTradeMarkApplicationsByIntentionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTradeMarkApplicationsByIntentionResponseBody> body{};

  QueryTradeMarkApplicationsByIntentionResponse() {}

  explicit QueryTradeMarkApplicationsByIntentionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTradeMarkApplicationsByIntentionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTradeMarkApplicationsByIntentionResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTradeMarkApplicationsByIntentionResponse() = default;
};
class QueryTradeProduceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};

  QueryTradeProduceDetailRequest() {}

  explicit QueryTradeProduceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~QueryTradeProduceDetailRequest() = default;
};
class QueryTradeProduceDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> allowCancel{};
  shared_ptr<string> bizId{};
  shared_ptr<long> buyerStatus{};
  shared_ptr<string> classification{};
  shared_ptr<double> confiscateAmount{};
  shared_ptr<long> createTime{};
  shared_ptr<string> exclusiveDateLimit{};
  shared_ptr<map<string, boost::any>> extend{};
  shared_ptr<double> finalAmount{};
  shared_ptr<string> icon{};
  shared_ptr<string> operateNote{};
  shared_ptr<double> paidAmount{};
  shared_ptr<double> preAmount{};
  shared_ptr<string> preOrderId{};
  shared_ptr<double> refundAmount{};
  shared_ptr<string> registerNumber{};
  shared_ptr<string> share{};
  shared_ptr<long> source{};
  shared_ptr<string> thirdCode{};
  shared_ptr<string> tmName{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  QueryTradeProduceDetailResponseBodyData() {}

  explicit QueryTradeProduceDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowCancel) {
      res["AllowCancel"] = boost::any(*allowCancel);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (buyerStatus) {
      res["BuyerStatus"] = boost::any(*buyerStatus);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (confiscateAmount) {
      res["ConfiscateAmount"] = boost::any(*confiscateAmount);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (exclusiveDateLimit) {
      res["ExclusiveDateLimit"] = boost::any(*exclusiveDateLimit);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (finalAmount) {
      res["FinalAmount"] = boost::any(*finalAmount);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (operateNote) {
      res["OperateNote"] = boost::any(*operateNote);
    }
    if (paidAmount) {
      res["PaidAmount"] = boost::any(*paidAmount);
    }
    if (preAmount) {
      res["PreAmount"] = boost::any(*preAmount);
    }
    if (preOrderId) {
      res["PreOrderId"] = boost::any(*preOrderId);
    }
    if (refundAmount) {
      res["RefundAmount"] = boost::any(*refundAmount);
    }
    if (registerNumber) {
      res["RegisterNumber"] = boost::any(*registerNumber);
    }
    if (share) {
      res["Share"] = boost::any(*share);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (thirdCode) {
      res["ThirdCode"] = boost::any(*thirdCode);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowCancel") != m.end() && !m["AllowCancel"].empty()) {
      allowCancel = make_shared<bool>(boost::any_cast<bool>(m["AllowCancel"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BuyerStatus") != m.end() && !m["BuyerStatus"].empty()) {
      buyerStatus = make_shared<long>(boost::any_cast<long>(m["BuyerStatus"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("ConfiscateAmount") != m.end() && !m["ConfiscateAmount"].empty()) {
      confiscateAmount = make_shared<double>(boost::any_cast<double>(m["ConfiscateAmount"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExclusiveDateLimit") != m.end() && !m["ExclusiveDateLimit"].empty()) {
      exclusiveDateLimit = make_shared<string>(boost::any_cast<string>(m["ExclusiveDateLimit"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Extend"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extend = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("FinalAmount") != m.end() && !m["FinalAmount"].empty()) {
      finalAmount = make_shared<double>(boost::any_cast<double>(m["FinalAmount"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("OperateNote") != m.end() && !m["OperateNote"].empty()) {
      operateNote = make_shared<string>(boost::any_cast<string>(m["OperateNote"]));
    }
    if (m.find("PaidAmount") != m.end() && !m["PaidAmount"].empty()) {
      paidAmount = make_shared<double>(boost::any_cast<double>(m["PaidAmount"]));
    }
    if (m.find("PreAmount") != m.end() && !m["PreAmount"].empty()) {
      preAmount = make_shared<double>(boost::any_cast<double>(m["PreAmount"]));
    }
    if (m.find("PreOrderId") != m.end() && !m["PreOrderId"].empty()) {
      preOrderId = make_shared<string>(boost::any_cast<string>(m["PreOrderId"]));
    }
    if (m.find("RefundAmount") != m.end() && !m["RefundAmount"].empty()) {
      refundAmount = make_shared<double>(boost::any_cast<double>(m["RefundAmount"]));
    }
    if (m.find("RegisterNumber") != m.end() && !m["RegisterNumber"].empty()) {
      registerNumber = make_shared<string>(boost::any_cast<string>(m["RegisterNumber"]));
    }
    if (m.find("Share") != m.end() && !m["Share"].empty()) {
      share = make_shared<string>(boost::any_cast<string>(m["Share"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<long>(boost::any_cast<long>(m["Source"]));
    }
    if (m.find("ThirdCode") != m.end() && !m["ThirdCode"].empty()) {
      thirdCode = make_shared<string>(boost::any_cast<string>(m["ThirdCode"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryTradeProduceDetailResponseBodyData() = default;
};
class QueryTradeProduceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTradeProduceDetailResponseBodyData> data{};
  shared_ptr<string> requestId{};

  QueryTradeProduceDetailResponseBody() {}

  explicit QueryTradeProduceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTradeProduceDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTradeProduceDetailResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryTradeProduceDetailResponseBody() = default;
};
class QueryTradeProduceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTradeProduceDetailResponseBody> body{};

  QueryTradeProduceDetailResponse() {}

  explicit QueryTradeProduceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTradeProduceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTradeProduceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTradeProduceDetailResponse() = default;
};
class QueryTradeProduceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> buyerStatus{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> preOrderId{};
  shared_ptr<string> registerNumber{};
  shared_ptr<string> sortFiled{};
  shared_ptr<string> sortOrder{};

  QueryTradeProduceListRequest() {}

  explicit QueryTradeProduceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (buyerStatus) {
      res["BuyerStatus"] = boost::any(*buyerStatus);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (preOrderId) {
      res["PreOrderId"] = boost::any(*preOrderId);
    }
    if (registerNumber) {
      res["RegisterNumber"] = boost::any(*registerNumber);
    }
    if (sortFiled) {
      res["SortFiled"] = boost::any(*sortFiled);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BuyerStatus") != m.end() && !m["BuyerStatus"].empty()) {
      buyerStatus = make_shared<long>(boost::any_cast<long>(m["BuyerStatus"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PreOrderId") != m.end() && !m["PreOrderId"].empty()) {
      preOrderId = make_shared<string>(boost::any_cast<string>(m["PreOrderId"]));
    }
    if (m.find("RegisterNumber") != m.end() && !m["RegisterNumber"].empty()) {
      registerNumber = make_shared<string>(boost::any_cast<string>(m["RegisterNumber"]));
    }
    if (m.find("SortFiled") != m.end() && !m["SortFiled"].empty()) {
      sortFiled = make_shared<string>(boost::any_cast<string>(m["SortFiled"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
  }


  virtual ~QueryTradeProduceListRequest() = default;
};
class QueryTradeProduceListResponseBodyDataTradeProduces : public Darabonba::Model {
public:
  shared_ptr<bool> allowCancel{};
  shared_ptr<string> bizId{};
  shared_ptr<long> buyerStatus{};
  shared_ptr<string> classification{};
  shared_ptr<long> createTime{};
  shared_ptr<long> failReason{};
  shared_ptr<double> finalAmount{};
  shared_ptr<string> icon{};
  shared_ptr<string> operateNote{};
  shared_ptr<double> preAmount{};
  shared_ptr<string> preOrderId{};
  shared_ptr<string> registerNumber{};
  shared_ptr<long> source{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  QueryTradeProduceListResponseBodyDataTradeProduces() {}

  explicit QueryTradeProduceListResponseBodyDataTradeProduces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowCancel) {
      res["AllowCancel"] = boost::any(*allowCancel);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (buyerStatus) {
      res["BuyerStatus"] = boost::any(*buyerStatus);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (failReason) {
      res["FailReason"] = boost::any(*failReason);
    }
    if (finalAmount) {
      res["FinalAmount"] = boost::any(*finalAmount);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (operateNote) {
      res["OperateNote"] = boost::any(*operateNote);
    }
    if (preAmount) {
      res["PreAmount"] = boost::any(*preAmount);
    }
    if (preOrderId) {
      res["PreOrderId"] = boost::any(*preOrderId);
    }
    if (registerNumber) {
      res["RegisterNumber"] = boost::any(*registerNumber);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowCancel") != m.end() && !m["AllowCancel"].empty()) {
      allowCancel = make_shared<bool>(boost::any_cast<bool>(m["AllowCancel"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BuyerStatus") != m.end() && !m["BuyerStatus"].empty()) {
      buyerStatus = make_shared<long>(boost::any_cast<long>(m["BuyerStatus"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FailReason") != m.end() && !m["FailReason"].empty()) {
      failReason = make_shared<long>(boost::any_cast<long>(m["FailReason"]));
    }
    if (m.find("FinalAmount") != m.end() && !m["FinalAmount"].empty()) {
      finalAmount = make_shared<double>(boost::any_cast<double>(m["FinalAmount"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("OperateNote") != m.end() && !m["OperateNote"].empty()) {
      operateNote = make_shared<string>(boost::any_cast<string>(m["OperateNote"]));
    }
    if (m.find("PreAmount") != m.end() && !m["PreAmount"].empty()) {
      preAmount = make_shared<double>(boost::any_cast<double>(m["PreAmount"]));
    }
    if (m.find("PreOrderId") != m.end() && !m["PreOrderId"].empty()) {
      preOrderId = make_shared<string>(boost::any_cast<string>(m["PreOrderId"]));
    }
    if (m.find("RegisterNumber") != m.end() && !m["RegisterNumber"].empty()) {
      registerNumber = make_shared<string>(boost::any_cast<string>(m["RegisterNumber"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<long>(boost::any_cast<long>(m["Source"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryTradeProduceListResponseBodyDataTradeProduces() = default;
};
class QueryTradeProduceListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTradeProduceListResponseBodyDataTradeProduces>> tradeProduces{};

  QueryTradeProduceListResponseBodyData() {}

  explicit QueryTradeProduceListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tradeProduces) {
      vector<boost::any> temp1;
      for(auto item1:*tradeProduces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TradeProduces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TradeProduces") != m.end() && !m["TradeProduces"].empty()) {
      if (typeid(vector<boost::any>) == m["TradeProduces"].type()) {
        vector<QueryTradeProduceListResponseBodyDataTradeProduces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TradeProduces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTradeProduceListResponseBodyDataTradeProduces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tradeProduces = make_shared<vector<QueryTradeProduceListResponseBodyDataTradeProduces>>(expect1);
      }
    }
  }


  virtual ~QueryTradeProduceListResponseBodyData() = default;
};
class QueryTradeProduceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<QueryTradeProduceListResponseBodyData> data{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryTradeProduceListResponseBody() {}

  explicit QueryTradeProduceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTradeProduceListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTradeProduceListResponseBodyData>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryTradeProduceListResponseBody() = default;
};
class QueryTradeProduceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTradeProduceListResponseBody> body{};

  QueryTradeProduceListResponse() {}

  explicit QueryTradeProduceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTradeProduceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTradeProduceListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTradeProduceListResponse() = default;
};
class QueryTrademarkDetailByApplyNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> applyNumber{};
  shared_ptr<string> env{};

  QueryTrademarkDetailByApplyNumberRequest() {}

  explicit QueryTrademarkDetailByApplyNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyNumber) {
      res["ApplyNumber"] = boost::any(*applyNumber);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyNumber") != m.end() && !m["ApplyNumber"].empty()) {
      applyNumber = make_shared<string>(boost::any_cast<string>(m["ApplyNumber"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberRequest() = default;
};
class QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodesLeafCode : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodesLeafCode() {}

  explicit QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodesLeafCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodesLeafCode() = default;
};
class QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodes : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodesLeafCode>> leafCode{};

  QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodes() {}

  explicit QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (leafCode) {
      vector<boost::any> temp1;
      for(auto item1:*leafCode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["leafCode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("leafCode") != m.end() && !m["leafCode"].empty()) {
      if (typeid(vector<boost::any>) == m["leafCode"].type()) {
        vector<QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodesLeafCode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["leafCode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodesLeafCode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        leafCode = make_shared<vector<QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodesLeafCode>>(expect1);
      }
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodes() = default;
};
class QueryTrademarkDetailByApplyNumberResponseBodyMoudleMaterialInfo : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> businessLicenceUrl{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> cnInfoUrl{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhoneNumber{};
  shared_ptr<string> contactZipCode{};
  shared_ptr<string> country{};
  shared_ptr<string> EAddress{};
  shared_ptr<string> EName{};
  shared_ptr<string> idCardNumber{};
  shared_ptr<string> idCardUrl{};
  shared_ptr<string> loaKey{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> passportUrl{};
  shared_ptr<long> personalType{};
  shared_ptr<string> postCode{};
  shared_ptr<string> province{};
  shared_ptr<string> reasonFileOssKey{};
  shared_ptr<long> region{};
  shared_ptr<map<string, boost::any>> reviewFileMap{};
  shared_ptr<long> type{};

  QueryTrademarkDetailByApplyNumberResponseBodyMoudleMaterialInfo() {}

  explicit QueryTrademarkDetailByApplyNumberResponseBodyMoudleMaterialInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (businessLicenceUrl) {
      res["BusinessLicenceUrl"] = boost::any(*businessLicenceUrl);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (cnInfoUrl) {
      res["CnInfoUrl"] = boost::any(*cnInfoUrl);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactPhoneNumber) {
      res["ContactPhoneNumber"] = boost::any(*contactPhoneNumber);
    }
    if (contactZipCode) {
      res["ContactZipCode"] = boost::any(*contactZipCode);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (EAddress) {
      res["EAddress"] = boost::any(*EAddress);
    }
    if (EName) {
      res["EName"] = boost::any(*EName);
    }
    if (idCardNumber) {
      res["IdCardNumber"] = boost::any(*idCardNumber);
    }
    if (idCardUrl) {
      res["IdCardUrl"] = boost::any(*idCardUrl);
    }
    if (loaKey) {
      res["LoaKey"] = boost::any(*loaKey);
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportUrl) {
      res["PassportUrl"] = boost::any(*passportUrl);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (postCode) {
      res["PostCode"] = boost::any(*postCode);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (reasonFileOssKey) {
      res["ReasonFileOssKey"] = boost::any(*reasonFileOssKey);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (reviewFileMap) {
      res["ReviewFileMap"] = boost::any(*reviewFileMap);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BusinessLicenceUrl") != m.end() && !m["BusinessLicenceUrl"].empty()) {
      businessLicenceUrl = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceUrl"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("CnInfoUrl") != m.end() && !m["CnInfoUrl"].empty()) {
      cnInfoUrl = make_shared<string>(boost::any_cast<string>(m["CnInfoUrl"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactPhoneNumber") != m.end() && !m["ContactPhoneNumber"].empty()) {
      contactPhoneNumber = make_shared<string>(boost::any_cast<string>(m["ContactPhoneNumber"]));
    }
    if (m.find("ContactZipCode") != m.end() && !m["ContactZipCode"].empty()) {
      contactZipCode = make_shared<string>(boost::any_cast<string>(m["ContactZipCode"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("EAddress") != m.end() && !m["EAddress"].empty()) {
      EAddress = make_shared<string>(boost::any_cast<string>(m["EAddress"]));
    }
    if (m.find("EName") != m.end() && !m["EName"].empty()) {
      EName = make_shared<string>(boost::any_cast<string>(m["EName"]));
    }
    if (m.find("IdCardNumber") != m.end() && !m["IdCardNumber"].empty()) {
      idCardNumber = make_shared<string>(boost::any_cast<string>(m["IdCardNumber"]));
    }
    if (m.find("IdCardUrl") != m.end() && !m["IdCardUrl"].empty()) {
      idCardUrl = make_shared<string>(boost::any_cast<string>(m["IdCardUrl"]));
    }
    if (m.find("LoaKey") != m.end() && !m["LoaKey"].empty()) {
      loaKey = make_shared<string>(boost::any_cast<string>(m["LoaKey"]));
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportUrl") != m.end() && !m["PassportUrl"].empty()) {
      passportUrl = make_shared<string>(boost::any_cast<string>(m["PassportUrl"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<long>(boost::any_cast<long>(m["PersonalType"]));
    }
    if (m.find("PostCode") != m.end() && !m["PostCode"].empty()) {
      postCode = make_shared<string>(boost::any_cast<string>(m["PostCode"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("ReasonFileOssKey") != m.end() && !m["ReasonFileOssKey"].empty()) {
      reasonFileOssKey = make_shared<string>(boost::any_cast<string>(m["ReasonFileOssKey"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("ReviewFileMap") != m.end() && !m["ReviewFileMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ReviewFileMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reviewFileMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberResponseBodyMoudleMaterialInfo() = default;
};
class QueryTrademarkDetailByApplyNumberResponseBodyMoudleRootCode : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTrademarkDetailByApplyNumberResponseBodyMoudleRootCode() {}

  explicit QueryTrademarkDetailByApplyNumberResponseBodyMoudleRootCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberResponseBodyMoudleRootCode() = default;
};
class QueryTrademarkDetailByApplyNumberResponseBodyMoudle : public Darabonba::Model {
public:
  shared_ptr<long> bitFlag{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};
  shared_ptr<map<string, boost::any>> extendInfo{};
  shared_ptr<string> grayIconUrl{};
  shared_ptr<string> icon{};
  shared_ptr<QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodes> leafCodes{};
  shared_ptr<QueryTrademarkDetailByApplyNumberResponseBodyMoudleMaterialInfo> materialInfo{};
  shared_ptr<string> orderId{};
  shared_ptr<string> partnerCode{};
  shared_ptr<string> principalKey{};
  shared_ptr<string> principalName{};
  shared_ptr<string> produceType{};
  shared_ptr<QueryTrademarkDetailByApplyNumberResponseBodyMoudleRootCode> rootCode{};
  shared_ptr<string> status{};
  shared_ptr<string> statusStr{};
  shared_ptr<string> submitAuditTimeStr{};
  shared_ptr<long> submitAuditTimeValue{};
  shared_ptr<string> submitStatus{};
  shared_ptr<string> submitTimeStr{};
  shared_ptr<long> submitTimeValue{};
  shared_ptr<long> submitTimes{};
  shared_ptr<string> trademarkName{};
  shared_ptr<long> trademarkNameType{};
  shared_ptr<string> trademarkNumber{};

  QueryTrademarkDetailByApplyNumberResponseBodyMoudle() {}

  explicit QueryTrademarkDetailByApplyNumberResponseBodyMoudle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitFlag) {
      res["BitFlag"] = boost::any(*bitFlag);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (grayIconUrl) {
      res["GrayIconUrl"] = boost::any(*grayIconUrl);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (leafCodes) {
      res["LeafCodes"] = leafCodes ? boost::any(leafCodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (materialInfo) {
      res["MaterialInfo"] = materialInfo ? boost::any(materialInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (partnerCode) {
      res["PartnerCode"] = boost::any(*partnerCode);
    }
    if (principalKey) {
      res["PrincipalKey"] = boost::any(*principalKey);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (produceType) {
      res["ProduceType"] = boost::any(*produceType);
    }
    if (rootCode) {
      res["RootCode"] = rootCode ? boost::any(rootCode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusStr) {
      res["StatusStr"] = boost::any(*statusStr);
    }
    if (submitAuditTimeStr) {
      res["SubmitAuditTimeStr"] = boost::any(*submitAuditTimeStr);
    }
    if (submitAuditTimeValue) {
      res["SubmitAuditTimeValue"] = boost::any(*submitAuditTimeValue);
    }
    if (submitStatus) {
      res["SubmitStatus"] = boost::any(*submitStatus);
    }
    if (submitTimeStr) {
      res["SubmitTimeStr"] = boost::any(*submitTimeStr);
    }
    if (submitTimeValue) {
      res["SubmitTimeValue"] = boost::any(*submitTimeValue);
    }
    if (submitTimes) {
      res["SubmitTimes"] = boost::any(*submitTimes);
    }
    if (trademarkName) {
      res["TrademarkName"] = boost::any(*trademarkName);
    }
    if (trademarkNameType) {
      res["TrademarkNameType"] = boost::any(*trademarkNameType);
    }
    if (trademarkNumber) {
      res["TrademarkNumber"] = boost::any(*trademarkNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BitFlag") != m.end() && !m["BitFlag"].empty()) {
      bitFlag = make_shared<long>(boost::any_cast<long>(m["BitFlag"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtendInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extendInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GrayIconUrl") != m.end() && !m["GrayIconUrl"].empty()) {
      grayIconUrl = make_shared<string>(boost::any_cast<string>(m["GrayIconUrl"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("LeafCodes") != m.end() && !m["LeafCodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["LeafCodes"].type()) {
        QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LeafCodes"]));
        leafCodes = make_shared<QueryTrademarkDetailByApplyNumberResponseBodyMoudleLeafCodes>(model1);
      }
    }
    if (m.find("MaterialInfo") != m.end() && !m["MaterialInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaterialInfo"].type()) {
        QueryTrademarkDetailByApplyNumberResponseBodyMoudleMaterialInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaterialInfo"]));
        materialInfo = make_shared<QueryTrademarkDetailByApplyNumberResponseBodyMoudleMaterialInfo>(model1);
      }
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PartnerCode") != m.end() && !m["PartnerCode"].empty()) {
      partnerCode = make_shared<string>(boost::any_cast<string>(m["PartnerCode"]));
    }
    if (m.find("PrincipalKey") != m.end() && !m["PrincipalKey"].empty()) {
      principalKey = make_shared<string>(boost::any_cast<string>(m["PrincipalKey"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("ProduceType") != m.end() && !m["ProduceType"].empty()) {
      produceType = make_shared<string>(boost::any_cast<string>(m["ProduceType"]));
    }
    if (m.find("RootCode") != m.end() && !m["RootCode"].empty()) {
      if (typeid(map<string, boost::any>) == m["RootCode"].type()) {
        QueryTrademarkDetailByApplyNumberResponseBodyMoudleRootCode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RootCode"]));
        rootCode = make_shared<QueryTrademarkDetailByApplyNumberResponseBodyMoudleRootCode>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusStr") != m.end() && !m["StatusStr"].empty()) {
      statusStr = make_shared<string>(boost::any_cast<string>(m["StatusStr"]));
    }
    if (m.find("SubmitAuditTimeStr") != m.end() && !m["SubmitAuditTimeStr"].empty()) {
      submitAuditTimeStr = make_shared<string>(boost::any_cast<string>(m["SubmitAuditTimeStr"]));
    }
    if (m.find("SubmitAuditTimeValue") != m.end() && !m["SubmitAuditTimeValue"].empty()) {
      submitAuditTimeValue = make_shared<long>(boost::any_cast<long>(m["SubmitAuditTimeValue"]));
    }
    if (m.find("SubmitStatus") != m.end() && !m["SubmitStatus"].empty()) {
      submitStatus = make_shared<string>(boost::any_cast<string>(m["SubmitStatus"]));
    }
    if (m.find("SubmitTimeStr") != m.end() && !m["SubmitTimeStr"].empty()) {
      submitTimeStr = make_shared<string>(boost::any_cast<string>(m["SubmitTimeStr"]));
    }
    if (m.find("SubmitTimeValue") != m.end() && !m["SubmitTimeValue"].empty()) {
      submitTimeValue = make_shared<long>(boost::any_cast<long>(m["SubmitTimeValue"]));
    }
    if (m.find("SubmitTimes") != m.end() && !m["SubmitTimes"].empty()) {
      submitTimes = make_shared<long>(boost::any_cast<long>(m["SubmitTimes"]));
    }
    if (m.find("TrademarkName") != m.end() && !m["TrademarkName"].empty()) {
      trademarkName = make_shared<string>(boost::any_cast<string>(m["TrademarkName"]));
    }
    if (m.find("TrademarkNameType") != m.end() && !m["TrademarkNameType"].empty()) {
      trademarkNameType = make_shared<long>(boost::any_cast<long>(m["TrademarkNameType"]));
    }
    if (m.find("TrademarkNumber") != m.end() && !m["TrademarkNumber"].empty()) {
      trademarkNumber = make_shared<string>(boost::any_cast<string>(m["TrademarkNumber"]));
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberResponseBodyMoudle() = default;
};
class QueryTrademarkDetailByApplyNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTrademarkDetailByApplyNumberResponseBodyMoudle> moudle{};
  shared_ptr<string> requestId{};

  QueryTrademarkDetailByApplyNumberResponseBody() {}

  explicit QueryTrademarkDetailByApplyNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moudle) {
      res["Moudle"] = moudle ? boost::any(moudle->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Moudle") != m.end() && !m["Moudle"].empty()) {
      if (typeid(map<string, boost::any>) == m["Moudle"].type()) {
        QueryTrademarkDetailByApplyNumberResponseBodyMoudle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Moudle"]));
        moudle = make_shared<QueryTrademarkDetailByApplyNumberResponseBodyMoudle>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberResponseBody() = default;
};
class QueryTrademarkDetailByApplyNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTrademarkDetailByApplyNumberResponseBody> body{};

  QueryTrademarkDetailByApplyNumberResponse() {}

  explicit QueryTrademarkDetailByApplyNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTrademarkDetailByApplyNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTrademarkDetailByApplyNumberResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberResponse() = default;
};
class QueryTrademarkDetailByApplyNumberEspRequest : public Darabonba::Model {
public:
  shared_ptr<string> applyNumber{};
  shared_ptr<string> bizType{};

  QueryTrademarkDetailByApplyNumberEspRequest() {}

  explicit QueryTrademarkDetailByApplyNumberEspRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyNumber) {
      res["ApplyNumber"] = boost::any(*applyNumber);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyNumber") != m.end() && !m["ApplyNumber"].empty()) {
      applyNumber = make_shared<string>(boost::any_cast<string>(m["ApplyNumber"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberEspRequest() = default;
};
class QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodesLeafCode : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodesLeafCode() {}

  explicit QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodesLeafCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodesLeafCode() = default;
};
class QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodes : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodesLeafCode>> leafCode{};

  QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodes() {}

  explicit QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (leafCode) {
      vector<boost::any> temp1;
      for(auto item1:*leafCode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["leafCode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("leafCode") != m.end() && !m["leafCode"].empty()) {
      if (typeid(vector<boost::any>) == m["leafCode"].type()) {
        vector<QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodesLeafCode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["leafCode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodesLeafCode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        leafCode = make_shared<vector<QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodesLeafCode>>(expect1);
      }
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodes() = default;
};
class QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleMaterialInfo : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> businessLicenceUrl{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> cnInfoUrl{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhoneNumber{};
  shared_ptr<string> contactZipCode{};
  shared_ptr<string> country{};
  shared_ptr<string> EAddress{};
  shared_ptr<string> EName{};
  shared_ptr<string> idCardNumber{};
  shared_ptr<string> idCardUrl{};
  shared_ptr<string> loaKey{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> passportUrl{};
  shared_ptr<long> personalType{};
  shared_ptr<string> postCode{};
  shared_ptr<string> province{};
  shared_ptr<string> reasonFileOssKey{};
  shared_ptr<long> region{};
  shared_ptr<map<string, boost::any>> reviewFileMap{};
  shared_ptr<long> type{};

  QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleMaterialInfo() {}

  explicit QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleMaterialInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (businessLicenceUrl) {
      res["BusinessLicenceUrl"] = boost::any(*businessLicenceUrl);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (cnInfoUrl) {
      res["CnInfoUrl"] = boost::any(*cnInfoUrl);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactPhoneNumber) {
      res["ContactPhoneNumber"] = boost::any(*contactPhoneNumber);
    }
    if (contactZipCode) {
      res["ContactZipCode"] = boost::any(*contactZipCode);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (EAddress) {
      res["EAddress"] = boost::any(*EAddress);
    }
    if (EName) {
      res["EName"] = boost::any(*EName);
    }
    if (idCardNumber) {
      res["IdCardNumber"] = boost::any(*idCardNumber);
    }
    if (idCardUrl) {
      res["IdCardUrl"] = boost::any(*idCardUrl);
    }
    if (loaKey) {
      res["LoaKey"] = boost::any(*loaKey);
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportUrl) {
      res["PassportUrl"] = boost::any(*passportUrl);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (postCode) {
      res["PostCode"] = boost::any(*postCode);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (reasonFileOssKey) {
      res["ReasonFileOssKey"] = boost::any(*reasonFileOssKey);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (reviewFileMap) {
      res["ReviewFileMap"] = boost::any(*reviewFileMap);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BusinessLicenceUrl") != m.end() && !m["BusinessLicenceUrl"].empty()) {
      businessLicenceUrl = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceUrl"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("CnInfoUrl") != m.end() && !m["CnInfoUrl"].empty()) {
      cnInfoUrl = make_shared<string>(boost::any_cast<string>(m["CnInfoUrl"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactPhoneNumber") != m.end() && !m["ContactPhoneNumber"].empty()) {
      contactPhoneNumber = make_shared<string>(boost::any_cast<string>(m["ContactPhoneNumber"]));
    }
    if (m.find("ContactZipCode") != m.end() && !m["ContactZipCode"].empty()) {
      contactZipCode = make_shared<string>(boost::any_cast<string>(m["ContactZipCode"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("EAddress") != m.end() && !m["EAddress"].empty()) {
      EAddress = make_shared<string>(boost::any_cast<string>(m["EAddress"]));
    }
    if (m.find("EName") != m.end() && !m["EName"].empty()) {
      EName = make_shared<string>(boost::any_cast<string>(m["EName"]));
    }
    if (m.find("IdCardNumber") != m.end() && !m["IdCardNumber"].empty()) {
      idCardNumber = make_shared<string>(boost::any_cast<string>(m["IdCardNumber"]));
    }
    if (m.find("IdCardUrl") != m.end() && !m["IdCardUrl"].empty()) {
      idCardUrl = make_shared<string>(boost::any_cast<string>(m["IdCardUrl"]));
    }
    if (m.find("LoaKey") != m.end() && !m["LoaKey"].empty()) {
      loaKey = make_shared<string>(boost::any_cast<string>(m["LoaKey"]));
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportUrl") != m.end() && !m["PassportUrl"].empty()) {
      passportUrl = make_shared<string>(boost::any_cast<string>(m["PassportUrl"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<long>(boost::any_cast<long>(m["PersonalType"]));
    }
    if (m.find("PostCode") != m.end() && !m["PostCode"].empty()) {
      postCode = make_shared<string>(boost::any_cast<string>(m["PostCode"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("ReasonFileOssKey") != m.end() && !m["ReasonFileOssKey"].empty()) {
      reasonFileOssKey = make_shared<string>(boost::any_cast<string>(m["ReasonFileOssKey"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("ReviewFileMap") != m.end() && !m["ReviewFileMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ReviewFileMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reviewFileMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleMaterialInfo() = default;
};
class QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleRootCode : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleRootCode() {}

  explicit QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleRootCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleRootCode() = default;
};
class QueryTrademarkDetailByApplyNumberEspResponseBodyMoudle : public Darabonba::Model {
public:
  shared_ptr<long> bitFlag{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};
  shared_ptr<map<string, boost::any>> extendInfo{};
  shared_ptr<string> grayIconUrl{};
  shared_ptr<string> icon{};
  shared_ptr<QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodes> leafCodes{};
  shared_ptr<QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleMaterialInfo> materialInfo{};
  shared_ptr<string> orderId{};
  shared_ptr<string> partnerCode{};
  shared_ptr<string> principalKey{};
  shared_ptr<string> principalName{};
  shared_ptr<string> produceType{};
  shared_ptr<QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleRootCode> rootCode{};
  shared_ptr<string> status{};
  shared_ptr<string> statusStr{};
  shared_ptr<string> submitAuditTimeStr{};
  shared_ptr<long> submitAuditTimeValue{};
  shared_ptr<string> submitStatus{};
  shared_ptr<string> submitTimeStr{};
  shared_ptr<long> submitTimeValue{};
  shared_ptr<long> submitTimes{};
  shared_ptr<string> trademarkName{};
  shared_ptr<long> trademarkNameType{};
  shared_ptr<string> trademarkNumber{};

  QueryTrademarkDetailByApplyNumberEspResponseBodyMoudle() {}

  explicit QueryTrademarkDetailByApplyNumberEspResponseBodyMoudle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitFlag) {
      res["BitFlag"] = boost::any(*bitFlag);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (grayIconUrl) {
      res["GrayIconUrl"] = boost::any(*grayIconUrl);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (leafCodes) {
      res["LeafCodes"] = leafCodes ? boost::any(leafCodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (materialInfo) {
      res["MaterialInfo"] = materialInfo ? boost::any(materialInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (partnerCode) {
      res["PartnerCode"] = boost::any(*partnerCode);
    }
    if (principalKey) {
      res["PrincipalKey"] = boost::any(*principalKey);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (produceType) {
      res["ProduceType"] = boost::any(*produceType);
    }
    if (rootCode) {
      res["RootCode"] = rootCode ? boost::any(rootCode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusStr) {
      res["StatusStr"] = boost::any(*statusStr);
    }
    if (submitAuditTimeStr) {
      res["SubmitAuditTimeStr"] = boost::any(*submitAuditTimeStr);
    }
    if (submitAuditTimeValue) {
      res["SubmitAuditTimeValue"] = boost::any(*submitAuditTimeValue);
    }
    if (submitStatus) {
      res["SubmitStatus"] = boost::any(*submitStatus);
    }
    if (submitTimeStr) {
      res["SubmitTimeStr"] = boost::any(*submitTimeStr);
    }
    if (submitTimeValue) {
      res["SubmitTimeValue"] = boost::any(*submitTimeValue);
    }
    if (submitTimes) {
      res["SubmitTimes"] = boost::any(*submitTimes);
    }
    if (trademarkName) {
      res["TrademarkName"] = boost::any(*trademarkName);
    }
    if (trademarkNameType) {
      res["TrademarkNameType"] = boost::any(*trademarkNameType);
    }
    if (trademarkNumber) {
      res["TrademarkNumber"] = boost::any(*trademarkNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BitFlag") != m.end() && !m["BitFlag"].empty()) {
      bitFlag = make_shared<long>(boost::any_cast<long>(m["BitFlag"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtendInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extendInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GrayIconUrl") != m.end() && !m["GrayIconUrl"].empty()) {
      grayIconUrl = make_shared<string>(boost::any_cast<string>(m["GrayIconUrl"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("LeafCodes") != m.end() && !m["LeafCodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["LeafCodes"].type()) {
        QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LeafCodes"]));
        leafCodes = make_shared<QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleLeafCodes>(model1);
      }
    }
    if (m.find("MaterialInfo") != m.end() && !m["MaterialInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaterialInfo"].type()) {
        QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleMaterialInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaterialInfo"]));
        materialInfo = make_shared<QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleMaterialInfo>(model1);
      }
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PartnerCode") != m.end() && !m["PartnerCode"].empty()) {
      partnerCode = make_shared<string>(boost::any_cast<string>(m["PartnerCode"]));
    }
    if (m.find("PrincipalKey") != m.end() && !m["PrincipalKey"].empty()) {
      principalKey = make_shared<string>(boost::any_cast<string>(m["PrincipalKey"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("ProduceType") != m.end() && !m["ProduceType"].empty()) {
      produceType = make_shared<string>(boost::any_cast<string>(m["ProduceType"]));
    }
    if (m.find("RootCode") != m.end() && !m["RootCode"].empty()) {
      if (typeid(map<string, boost::any>) == m["RootCode"].type()) {
        QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleRootCode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RootCode"]));
        rootCode = make_shared<QueryTrademarkDetailByApplyNumberEspResponseBodyMoudleRootCode>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusStr") != m.end() && !m["StatusStr"].empty()) {
      statusStr = make_shared<string>(boost::any_cast<string>(m["StatusStr"]));
    }
    if (m.find("SubmitAuditTimeStr") != m.end() && !m["SubmitAuditTimeStr"].empty()) {
      submitAuditTimeStr = make_shared<string>(boost::any_cast<string>(m["SubmitAuditTimeStr"]));
    }
    if (m.find("SubmitAuditTimeValue") != m.end() && !m["SubmitAuditTimeValue"].empty()) {
      submitAuditTimeValue = make_shared<long>(boost::any_cast<long>(m["SubmitAuditTimeValue"]));
    }
    if (m.find("SubmitStatus") != m.end() && !m["SubmitStatus"].empty()) {
      submitStatus = make_shared<string>(boost::any_cast<string>(m["SubmitStatus"]));
    }
    if (m.find("SubmitTimeStr") != m.end() && !m["SubmitTimeStr"].empty()) {
      submitTimeStr = make_shared<string>(boost::any_cast<string>(m["SubmitTimeStr"]));
    }
    if (m.find("SubmitTimeValue") != m.end() && !m["SubmitTimeValue"].empty()) {
      submitTimeValue = make_shared<long>(boost::any_cast<long>(m["SubmitTimeValue"]));
    }
    if (m.find("SubmitTimes") != m.end() && !m["SubmitTimes"].empty()) {
      submitTimes = make_shared<long>(boost::any_cast<long>(m["SubmitTimes"]));
    }
    if (m.find("TrademarkName") != m.end() && !m["TrademarkName"].empty()) {
      trademarkName = make_shared<string>(boost::any_cast<string>(m["TrademarkName"]));
    }
    if (m.find("TrademarkNameType") != m.end() && !m["TrademarkNameType"].empty()) {
      trademarkNameType = make_shared<long>(boost::any_cast<long>(m["TrademarkNameType"]));
    }
    if (m.find("TrademarkNumber") != m.end() && !m["TrademarkNumber"].empty()) {
      trademarkNumber = make_shared<string>(boost::any_cast<string>(m["TrademarkNumber"]));
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberEspResponseBodyMoudle() = default;
};
class QueryTrademarkDetailByApplyNumberEspResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTrademarkDetailByApplyNumberEspResponseBodyMoudle> moudle{};
  shared_ptr<string> requestId{};

  QueryTrademarkDetailByApplyNumberEspResponseBody() {}

  explicit QueryTrademarkDetailByApplyNumberEspResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moudle) {
      res["Moudle"] = moudle ? boost::any(moudle->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Moudle") != m.end() && !m["Moudle"].empty()) {
      if (typeid(map<string, boost::any>) == m["Moudle"].type()) {
        QueryTrademarkDetailByApplyNumberEspResponseBodyMoudle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Moudle"]));
        moudle = make_shared<QueryTrademarkDetailByApplyNumberEspResponseBodyMoudle>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberEspResponseBody() = default;
};
class QueryTrademarkDetailByApplyNumberEspResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTrademarkDetailByApplyNumberEspResponseBody> body{};

  QueryTrademarkDetailByApplyNumberEspResponse() {}

  explicit QueryTrademarkDetailByApplyNumberEspResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTrademarkDetailByApplyNumberEspResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTrademarkDetailByApplyNumberEspResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTrademarkDetailByApplyNumberEspResponse() = default;
};
class QueryTrademarkModelDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> env{};
  shared_ptr<string> orderId{};
  shared_ptr<bool> reviewSupplementMaterial{};

  QueryTrademarkModelDetailRequest() {}

  explicit QueryTrademarkModelDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (reviewSupplementMaterial) {
      res["ReviewSupplementMaterial"] = boost::any(*reviewSupplementMaterial);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("ReviewSupplementMaterial") != m.end() && !m["ReviewSupplementMaterial"].empty()) {
      reviewSupplementMaterial = make_shared<bool>(boost::any_cast<bool>(m["ReviewSupplementMaterial"]));
    }
  }


  virtual ~QueryTrademarkModelDetailRequest() = default;
};
class QueryTrademarkModelDetailResponseBodyMoudleLeafCodesLeafCode : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTrademarkModelDetailResponseBodyMoudleLeafCodesLeafCode() {}

  explicit QueryTrademarkModelDetailResponseBodyMoudleLeafCodesLeafCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTrademarkModelDetailResponseBodyMoudleLeafCodesLeafCode() = default;
};
class QueryTrademarkModelDetailResponseBodyMoudleLeafCodes : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTrademarkModelDetailResponseBodyMoudleLeafCodesLeafCode>> leafCode{};

  QueryTrademarkModelDetailResponseBodyMoudleLeafCodes() {}

  explicit QueryTrademarkModelDetailResponseBodyMoudleLeafCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (leafCode) {
      vector<boost::any> temp1;
      for(auto item1:*leafCode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["leafCode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("leafCode") != m.end() && !m["leafCode"].empty()) {
      if (typeid(vector<boost::any>) == m["leafCode"].type()) {
        vector<QueryTrademarkModelDetailResponseBodyMoudleLeafCodesLeafCode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["leafCode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTrademarkModelDetailResponseBodyMoudleLeafCodesLeafCode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        leafCode = make_shared<vector<QueryTrademarkModelDetailResponseBodyMoudleLeafCodesLeafCode>>(expect1);
      }
    }
  }


  virtual ~QueryTrademarkModelDetailResponseBodyMoudleLeafCodes() = default;
};
class QueryTrademarkModelDetailResponseBodyMoudleMaterialInfo : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> businessLicenceUrl{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> cnInfoUrl{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhoneNumber{};
  shared_ptr<string> contactZipCode{};
  shared_ptr<string> country{};
  shared_ptr<string> EAddress{};
  shared_ptr<string> EName{};
  shared_ptr<string> idCardNumber{};
  shared_ptr<string> idCardUrl{};
  shared_ptr<string> loaKey{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> passportUrl{};
  shared_ptr<long> personalType{};
  shared_ptr<string> postCode{};
  shared_ptr<string> province{};
  shared_ptr<string> reasonFileOssKey{};
  shared_ptr<long> region{};
  shared_ptr<map<string, boost::any>> reviewFileMap{};
  shared_ptr<long> type{};

  QueryTrademarkModelDetailResponseBodyMoudleMaterialInfo() {}

  explicit QueryTrademarkModelDetailResponseBodyMoudleMaterialInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (businessLicenceUrl) {
      res["BusinessLicenceUrl"] = boost::any(*businessLicenceUrl);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (cnInfoUrl) {
      res["CnInfoUrl"] = boost::any(*cnInfoUrl);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactPhoneNumber) {
      res["ContactPhoneNumber"] = boost::any(*contactPhoneNumber);
    }
    if (contactZipCode) {
      res["ContactZipCode"] = boost::any(*contactZipCode);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (EAddress) {
      res["EAddress"] = boost::any(*EAddress);
    }
    if (EName) {
      res["EName"] = boost::any(*EName);
    }
    if (idCardNumber) {
      res["IdCardNumber"] = boost::any(*idCardNumber);
    }
    if (idCardUrl) {
      res["IdCardUrl"] = boost::any(*idCardUrl);
    }
    if (loaKey) {
      res["LoaKey"] = boost::any(*loaKey);
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportUrl) {
      res["PassportUrl"] = boost::any(*passportUrl);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (postCode) {
      res["PostCode"] = boost::any(*postCode);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (reasonFileOssKey) {
      res["ReasonFileOssKey"] = boost::any(*reasonFileOssKey);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (reviewFileMap) {
      res["ReviewFileMap"] = boost::any(*reviewFileMap);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BusinessLicenceUrl") != m.end() && !m["BusinessLicenceUrl"].empty()) {
      businessLicenceUrl = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceUrl"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("CnInfoUrl") != m.end() && !m["CnInfoUrl"].empty()) {
      cnInfoUrl = make_shared<string>(boost::any_cast<string>(m["CnInfoUrl"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactPhoneNumber") != m.end() && !m["ContactPhoneNumber"].empty()) {
      contactPhoneNumber = make_shared<string>(boost::any_cast<string>(m["ContactPhoneNumber"]));
    }
    if (m.find("ContactZipCode") != m.end() && !m["ContactZipCode"].empty()) {
      contactZipCode = make_shared<string>(boost::any_cast<string>(m["ContactZipCode"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("EAddress") != m.end() && !m["EAddress"].empty()) {
      EAddress = make_shared<string>(boost::any_cast<string>(m["EAddress"]));
    }
    if (m.find("EName") != m.end() && !m["EName"].empty()) {
      EName = make_shared<string>(boost::any_cast<string>(m["EName"]));
    }
    if (m.find("IdCardNumber") != m.end() && !m["IdCardNumber"].empty()) {
      idCardNumber = make_shared<string>(boost::any_cast<string>(m["IdCardNumber"]));
    }
    if (m.find("IdCardUrl") != m.end() && !m["IdCardUrl"].empty()) {
      idCardUrl = make_shared<string>(boost::any_cast<string>(m["IdCardUrl"]));
    }
    if (m.find("LoaKey") != m.end() && !m["LoaKey"].empty()) {
      loaKey = make_shared<string>(boost::any_cast<string>(m["LoaKey"]));
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportUrl") != m.end() && !m["PassportUrl"].empty()) {
      passportUrl = make_shared<string>(boost::any_cast<string>(m["PassportUrl"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<long>(boost::any_cast<long>(m["PersonalType"]));
    }
    if (m.find("PostCode") != m.end() && !m["PostCode"].empty()) {
      postCode = make_shared<string>(boost::any_cast<string>(m["PostCode"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("ReasonFileOssKey") != m.end() && !m["ReasonFileOssKey"].empty()) {
      reasonFileOssKey = make_shared<string>(boost::any_cast<string>(m["ReasonFileOssKey"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("ReviewFileMap") != m.end() && !m["ReviewFileMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ReviewFileMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reviewFileMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryTrademarkModelDetailResponseBodyMoudleMaterialInfo() = default;
};
class QueryTrademarkModelDetailResponseBodyMoudleRootCode : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTrademarkModelDetailResponseBodyMoudleRootCode() {}

  explicit QueryTrademarkModelDetailResponseBodyMoudleRootCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTrademarkModelDetailResponseBodyMoudleRootCode() = default;
};
class QueryTrademarkModelDetailResponseBodyMoudle : public Darabonba::Model {
public:
  shared_ptr<long> bitFlag{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};
  shared_ptr<map<string, boost::any>> extendInfo{};
  shared_ptr<string> grayIconUrl{};
  shared_ptr<string> icon{};
  shared_ptr<QueryTrademarkModelDetailResponseBodyMoudleLeafCodes> leafCodes{};
  shared_ptr<QueryTrademarkModelDetailResponseBodyMoudleMaterialInfo> materialInfo{};
  shared_ptr<string> orderId{};
  shared_ptr<string> partnerCode{};
  shared_ptr<string> principalKey{};
  shared_ptr<string> principalName{};
  shared_ptr<string> produceType{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryTrademarkModelDetailResponseBodyMoudleRootCode> rootCode{};
  shared_ptr<string> status{};
  shared_ptr<string> statusStr{};
  shared_ptr<string> submitAuditTimeStr{};
  shared_ptr<long> submitAuditTimeValue{};
  shared_ptr<string> submitStatus{};
  shared_ptr<string> submitTimeStr{};
  shared_ptr<long> submitTimeValue{};
  shared_ptr<long> submitTimes{};
  shared_ptr<string> trademarkName{};
  shared_ptr<long> trademarkNameType{};
  shared_ptr<string> trademarkNumber{};

  QueryTrademarkModelDetailResponseBodyMoudle() {}

  explicit QueryTrademarkModelDetailResponseBodyMoudle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitFlag) {
      res["BitFlag"] = boost::any(*bitFlag);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (grayIconUrl) {
      res["GrayIconUrl"] = boost::any(*grayIconUrl);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (leafCodes) {
      res["LeafCodes"] = leafCodes ? boost::any(leafCodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (materialInfo) {
      res["MaterialInfo"] = materialInfo ? boost::any(materialInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (partnerCode) {
      res["PartnerCode"] = boost::any(*partnerCode);
    }
    if (principalKey) {
      res["PrincipalKey"] = boost::any(*principalKey);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (produceType) {
      res["ProduceType"] = boost::any(*produceType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rootCode) {
      res["RootCode"] = rootCode ? boost::any(rootCode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusStr) {
      res["StatusStr"] = boost::any(*statusStr);
    }
    if (submitAuditTimeStr) {
      res["SubmitAuditTimeStr"] = boost::any(*submitAuditTimeStr);
    }
    if (submitAuditTimeValue) {
      res["SubmitAuditTimeValue"] = boost::any(*submitAuditTimeValue);
    }
    if (submitStatus) {
      res["SubmitStatus"] = boost::any(*submitStatus);
    }
    if (submitTimeStr) {
      res["SubmitTimeStr"] = boost::any(*submitTimeStr);
    }
    if (submitTimeValue) {
      res["SubmitTimeValue"] = boost::any(*submitTimeValue);
    }
    if (submitTimes) {
      res["SubmitTimes"] = boost::any(*submitTimes);
    }
    if (trademarkName) {
      res["TrademarkName"] = boost::any(*trademarkName);
    }
    if (trademarkNameType) {
      res["TrademarkNameType"] = boost::any(*trademarkNameType);
    }
    if (trademarkNumber) {
      res["TrademarkNumber"] = boost::any(*trademarkNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BitFlag") != m.end() && !m["BitFlag"].empty()) {
      bitFlag = make_shared<long>(boost::any_cast<long>(m["BitFlag"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtendInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extendInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GrayIconUrl") != m.end() && !m["GrayIconUrl"].empty()) {
      grayIconUrl = make_shared<string>(boost::any_cast<string>(m["GrayIconUrl"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("LeafCodes") != m.end() && !m["LeafCodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["LeafCodes"].type()) {
        QueryTrademarkModelDetailResponseBodyMoudleLeafCodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LeafCodes"]));
        leafCodes = make_shared<QueryTrademarkModelDetailResponseBodyMoudleLeafCodes>(model1);
      }
    }
    if (m.find("MaterialInfo") != m.end() && !m["MaterialInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaterialInfo"].type()) {
        QueryTrademarkModelDetailResponseBodyMoudleMaterialInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaterialInfo"]));
        materialInfo = make_shared<QueryTrademarkModelDetailResponseBodyMoudleMaterialInfo>(model1);
      }
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PartnerCode") != m.end() && !m["PartnerCode"].empty()) {
      partnerCode = make_shared<string>(boost::any_cast<string>(m["PartnerCode"]));
    }
    if (m.find("PrincipalKey") != m.end() && !m["PrincipalKey"].empty()) {
      principalKey = make_shared<string>(boost::any_cast<string>(m["PrincipalKey"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("ProduceType") != m.end() && !m["ProduceType"].empty()) {
      produceType = make_shared<string>(boost::any_cast<string>(m["ProduceType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RootCode") != m.end() && !m["RootCode"].empty()) {
      if (typeid(map<string, boost::any>) == m["RootCode"].type()) {
        QueryTrademarkModelDetailResponseBodyMoudleRootCode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RootCode"]));
        rootCode = make_shared<QueryTrademarkModelDetailResponseBodyMoudleRootCode>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusStr") != m.end() && !m["StatusStr"].empty()) {
      statusStr = make_shared<string>(boost::any_cast<string>(m["StatusStr"]));
    }
    if (m.find("SubmitAuditTimeStr") != m.end() && !m["SubmitAuditTimeStr"].empty()) {
      submitAuditTimeStr = make_shared<string>(boost::any_cast<string>(m["SubmitAuditTimeStr"]));
    }
    if (m.find("SubmitAuditTimeValue") != m.end() && !m["SubmitAuditTimeValue"].empty()) {
      submitAuditTimeValue = make_shared<long>(boost::any_cast<long>(m["SubmitAuditTimeValue"]));
    }
    if (m.find("SubmitStatus") != m.end() && !m["SubmitStatus"].empty()) {
      submitStatus = make_shared<string>(boost::any_cast<string>(m["SubmitStatus"]));
    }
    if (m.find("SubmitTimeStr") != m.end() && !m["SubmitTimeStr"].empty()) {
      submitTimeStr = make_shared<string>(boost::any_cast<string>(m["SubmitTimeStr"]));
    }
    if (m.find("SubmitTimeValue") != m.end() && !m["SubmitTimeValue"].empty()) {
      submitTimeValue = make_shared<long>(boost::any_cast<long>(m["SubmitTimeValue"]));
    }
    if (m.find("SubmitTimes") != m.end() && !m["SubmitTimes"].empty()) {
      submitTimes = make_shared<long>(boost::any_cast<long>(m["SubmitTimes"]));
    }
    if (m.find("TrademarkName") != m.end() && !m["TrademarkName"].empty()) {
      trademarkName = make_shared<string>(boost::any_cast<string>(m["TrademarkName"]));
    }
    if (m.find("TrademarkNameType") != m.end() && !m["TrademarkNameType"].empty()) {
      trademarkNameType = make_shared<long>(boost::any_cast<long>(m["TrademarkNameType"]));
    }
    if (m.find("TrademarkNumber") != m.end() && !m["TrademarkNumber"].empty()) {
      trademarkNumber = make_shared<string>(boost::any_cast<string>(m["TrademarkNumber"]));
    }
  }


  virtual ~QueryTrademarkModelDetailResponseBodyMoudle() = default;
};
class QueryTrademarkModelDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTrademarkModelDetailResponseBodyMoudle> moudle{};

  QueryTrademarkModelDetailResponseBody() {}

  explicit QueryTrademarkModelDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moudle) {
      res["Moudle"] = moudle ? boost::any(moudle->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Moudle") != m.end() && !m["Moudle"].empty()) {
      if (typeid(map<string, boost::any>) == m["Moudle"].type()) {
        QueryTrademarkModelDetailResponseBodyMoudle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Moudle"]));
        moudle = make_shared<QueryTrademarkModelDetailResponseBodyMoudle>(model1);
      }
    }
  }


  virtual ~QueryTrademarkModelDetailResponseBody() = default;
};
class QueryTrademarkModelDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTrademarkModelDetailResponseBody> body{};

  QueryTrademarkModelDetailResponse() {}

  explicit QueryTrademarkModelDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTrademarkModelDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTrademarkModelDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTrademarkModelDetailResponse() = default;
};
class QueryTrademarkModelEspDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};

  QueryTrademarkModelEspDetailRequest() {}

  explicit QueryTrademarkModelEspDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
  }


  virtual ~QueryTrademarkModelEspDetailRequest() = default;
};
class QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodesLeafCode : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodesLeafCode() {}

  explicit QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodesLeafCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodesLeafCode() = default;
};
class QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodes : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodesLeafCode>> leafCode{};

  QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodes() {}

  explicit QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (leafCode) {
      vector<boost::any> temp1;
      for(auto item1:*leafCode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["leafCode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("leafCode") != m.end() && !m["leafCode"].empty()) {
      if (typeid(vector<boost::any>) == m["leafCode"].type()) {
        vector<QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodesLeafCode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["leafCode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodesLeafCode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        leafCode = make_shared<vector<QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodesLeafCode>>(expect1);
      }
    }
  }


  virtual ~QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodes() = default;
};
class QueryTrademarkModelEspDetailResponseBodyMoudleMaterialInfo : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> businessLicenceUrl{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> cnInfoUrl{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactZipCode{};
  shared_ptr<string> country{};
  shared_ptr<string> EAddress{};
  shared_ptr<string> EName{};
  shared_ptr<string> idCardNumber{};
  shared_ptr<string> idCardUrl{};
  shared_ptr<string> loaKey{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> passportUrl{};
  shared_ptr<string> personalType{};
  shared_ptr<string> postCode{};
  shared_ptr<string> province{};
  shared_ptr<string> reasonFileOssKey{};
  shared_ptr<long> region{};
  shared_ptr<long> type{};

  QueryTrademarkModelEspDetailResponseBodyMoudleMaterialInfo() {}

  explicit QueryTrademarkModelEspDetailResponseBodyMoudleMaterialInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (businessLicenceUrl) {
      res["BusinessLicenceUrl"] = boost::any(*businessLicenceUrl);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (cnInfoUrl) {
      res["CnInfoUrl"] = boost::any(*cnInfoUrl);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactZipCode) {
      res["ContactZipCode"] = boost::any(*contactZipCode);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (EAddress) {
      res["EAddress"] = boost::any(*EAddress);
    }
    if (EName) {
      res["EName"] = boost::any(*EName);
    }
    if (idCardNumber) {
      res["IdCardNumber"] = boost::any(*idCardNumber);
    }
    if (idCardUrl) {
      res["IdCardUrl"] = boost::any(*idCardUrl);
    }
    if (loaKey) {
      res["LoaKey"] = boost::any(*loaKey);
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportUrl) {
      res["PassportUrl"] = boost::any(*passportUrl);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (postCode) {
      res["PostCode"] = boost::any(*postCode);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (reasonFileOssKey) {
      res["ReasonFileOssKey"] = boost::any(*reasonFileOssKey);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BusinessLicenceUrl") != m.end() && !m["BusinessLicenceUrl"].empty()) {
      businessLicenceUrl = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceUrl"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("CnInfoUrl") != m.end() && !m["CnInfoUrl"].empty()) {
      cnInfoUrl = make_shared<string>(boost::any_cast<string>(m["CnInfoUrl"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactZipCode") != m.end() && !m["ContactZipCode"].empty()) {
      contactZipCode = make_shared<string>(boost::any_cast<string>(m["ContactZipCode"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("EAddress") != m.end() && !m["EAddress"].empty()) {
      EAddress = make_shared<string>(boost::any_cast<string>(m["EAddress"]));
    }
    if (m.find("EName") != m.end() && !m["EName"].empty()) {
      EName = make_shared<string>(boost::any_cast<string>(m["EName"]));
    }
    if (m.find("IdCardNumber") != m.end() && !m["IdCardNumber"].empty()) {
      idCardNumber = make_shared<string>(boost::any_cast<string>(m["IdCardNumber"]));
    }
    if (m.find("IdCardUrl") != m.end() && !m["IdCardUrl"].empty()) {
      idCardUrl = make_shared<string>(boost::any_cast<string>(m["IdCardUrl"]));
    }
    if (m.find("LoaKey") != m.end() && !m["LoaKey"].empty()) {
      loaKey = make_shared<string>(boost::any_cast<string>(m["LoaKey"]));
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportUrl") != m.end() && !m["PassportUrl"].empty()) {
      passportUrl = make_shared<string>(boost::any_cast<string>(m["PassportUrl"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<string>(boost::any_cast<string>(m["PersonalType"]));
    }
    if (m.find("PostCode") != m.end() && !m["PostCode"].empty()) {
      postCode = make_shared<string>(boost::any_cast<string>(m["PostCode"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("ReasonFileOssKey") != m.end() && !m["ReasonFileOssKey"].empty()) {
      reasonFileOssKey = make_shared<string>(boost::any_cast<string>(m["ReasonFileOssKey"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryTrademarkModelEspDetailResponseBodyMoudleMaterialInfo() = default;
};
class QueryTrademarkModelEspDetailResponseBodyMoudleRootCode : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTrademarkModelEspDetailResponseBodyMoudleRootCode() {}

  explicit QueryTrademarkModelEspDetailResponseBodyMoudleRootCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTrademarkModelEspDetailResponseBodyMoudleRootCode() = default;
};
class QueryTrademarkModelEspDetailResponseBodyMoudle : public Darabonba::Model {
public:
  shared_ptr<long> bitFlag{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};
  shared_ptr<map<string, boost::any>> extendInfo{};
  shared_ptr<string> grayIconUrl{};
  shared_ptr<string> icon{};
  shared_ptr<QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodes> leafCodes{};
  shared_ptr<QueryTrademarkModelEspDetailResponseBodyMoudleMaterialInfo> materialInfo{};
  shared_ptr<string> orderId{};
  shared_ptr<string> partnerCode{};
  shared_ptr<string> principalKey{};
  shared_ptr<string> principalName{};
  shared_ptr<string> produceType{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryTrademarkModelEspDetailResponseBodyMoudleRootCode> rootCode{};
  shared_ptr<string> status{};
  shared_ptr<string> statusStr{};
  shared_ptr<long> submitAuditTime{};
  shared_ptr<string> submitStatus{};
  shared_ptr<long> submitTime{};
  shared_ptr<long> submitTimes{};
  shared_ptr<string> trademarkName{};
  shared_ptr<long> trademarkNameType{};
  shared_ptr<string> trademarkNumber{};

  QueryTrademarkModelEspDetailResponseBodyMoudle() {}

  explicit QueryTrademarkModelEspDetailResponseBodyMoudle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitFlag) {
      res["BitFlag"] = boost::any(*bitFlag);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (grayIconUrl) {
      res["GrayIconUrl"] = boost::any(*grayIconUrl);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (leafCodes) {
      res["LeafCodes"] = leafCodes ? boost::any(leafCodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (materialInfo) {
      res["MaterialInfo"] = materialInfo ? boost::any(materialInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (partnerCode) {
      res["PartnerCode"] = boost::any(*partnerCode);
    }
    if (principalKey) {
      res["PrincipalKey"] = boost::any(*principalKey);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (produceType) {
      res["ProduceType"] = boost::any(*produceType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rootCode) {
      res["RootCode"] = rootCode ? boost::any(rootCode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusStr) {
      res["StatusStr"] = boost::any(*statusStr);
    }
    if (submitAuditTime) {
      res["SubmitAuditTime"] = boost::any(*submitAuditTime);
    }
    if (submitStatus) {
      res["SubmitStatus"] = boost::any(*submitStatus);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (submitTimes) {
      res["SubmitTimes"] = boost::any(*submitTimes);
    }
    if (trademarkName) {
      res["TrademarkName"] = boost::any(*trademarkName);
    }
    if (trademarkNameType) {
      res["TrademarkNameType"] = boost::any(*trademarkNameType);
    }
    if (trademarkNumber) {
      res["TrademarkNumber"] = boost::any(*trademarkNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BitFlag") != m.end() && !m["BitFlag"].empty()) {
      bitFlag = make_shared<long>(boost::any_cast<long>(m["BitFlag"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtendInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extendInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GrayIconUrl") != m.end() && !m["GrayIconUrl"].empty()) {
      grayIconUrl = make_shared<string>(boost::any_cast<string>(m["GrayIconUrl"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("LeafCodes") != m.end() && !m["LeafCodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["LeafCodes"].type()) {
        QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LeafCodes"]));
        leafCodes = make_shared<QueryTrademarkModelEspDetailResponseBodyMoudleLeafCodes>(model1);
      }
    }
    if (m.find("MaterialInfo") != m.end() && !m["MaterialInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaterialInfo"].type()) {
        QueryTrademarkModelEspDetailResponseBodyMoudleMaterialInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaterialInfo"]));
        materialInfo = make_shared<QueryTrademarkModelEspDetailResponseBodyMoudleMaterialInfo>(model1);
      }
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PartnerCode") != m.end() && !m["PartnerCode"].empty()) {
      partnerCode = make_shared<string>(boost::any_cast<string>(m["PartnerCode"]));
    }
    if (m.find("PrincipalKey") != m.end() && !m["PrincipalKey"].empty()) {
      principalKey = make_shared<string>(boost::any_cast<string>(m["PrincipalKey"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("ProduceType") != m.end() && !m["ProduceType"].empty()) {
      produceType = make_shared<string>(boost::any_cast<string>(m["ProduceType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RootCode") != m.end() && !m["RootCode"].empty()) {
      if (typeid(map<string, boost::any>) == m["RootCode"].type()) {
        QueryTrademarkModelEspDetailResponseBodyMoudleRootCode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RootCode"]));
        rootCode = make_shared<QueryTrademarkModelEspDetailResponseBodyMoudleRootCode>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusStr") != m.end() && !m["StatusStr"].empty()) {
      statusStr = make_shared<string>(boost::any_cast<string>(m["StatusStr"]));
    }
    if (m.find("SubmitAuditTime") != m.end() && !m["SubmitAuditTime"].empty()) {
      submitAuditTime = make_shared<long>(boost::any_cast<long>(m["SubmitAuditTime"]));
    }
    if (m.find("SubmitStatus") != m.end() && !m["SubmitStatus"].empty()) {
      submitStatus = make_shared<string>(boost::any_cast<string>(m["SubmitStatus"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<long>(boost::any_cast<long>(m["SubmitTime"]));
    }
    if (m.find("SubmitTimes") != m.end() && !m["SubmitTimes"].empty()) {
      submitTimes = make_shared<long>(boost::any_cast<long>(m["SubmitTimes"]));
    }
    if (m.find("TrademarkName") != m.end() && !m["TrademarkName"].empty()) {
      trademarkName = make_shared<string>(boost::any_cast<string>(m["TrademarkName"]));
    }
    if (m.find("TrademarkNameType") != m.end() && !m["TrademarkNameType"].empty()) {
      trademarkNameType = make_shared<long>(boost::any_cast<long>(m["TrademarkNameType"]));
    }
    if (m.find("TrademarkNumber") != m.end() && !m["TrademarkNumber"].empty()) {
      trademarkNumber = make_shared<string>(boost::any_cast<string>(m["TrademarkNumber"]));
    }
  }


  virtual ~QueryTrademarkModelEspDetailResponseBodyMoudle() = default;
};
class QueryTrademarkModelEspDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTrademarkModelEspDetailResponseBodyMoudle> moudle{};

  QueryTrademarkModelEspDetailResponseBody() {}

  explicit QueryTrademarkModelEspDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moudle) {
      res["Moudle"] = moudle ? boost::any(moudle->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Moudle") != m.end() && !m["Moudle"].empty()) {
      if (typeid(map<string, boost::any>) == m["Moudle"].type()) {
        QueryTrademarkModelEspDetailResponseBodyMoudle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Moudle"]));
        moudle = make_shared<QueryTrademarkModelEspDetailResponseBodyMoudle>(model1);
      }
    }
  }


  virtual ~QueryTrademarkModelEspDetailResponseBody() = default;
};
class QueryTrademarkModelEspDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTrademarkModelEspDetailResponseBody> body{};

  QueryTrademarkModelEspDetailResponse() {}

  explicit QueryTrademarkModelEspDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTrademarkModelEspDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTrademarkModelEspDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTrademarkModelEspDetailResponse() = default;
};
class QueryTrademarkModelEspListRequest : public Darabonba::Model {
public:
  shared_ptr<string> additionalSubmitStatus{};
  shared_ptr<string> additionalSubmitTime{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};
  shared_ptr<string> env{};
  shared_ptr<vector<string>> existStatus{};
  shared_ptr<string> orderId{};
  shared_ptr<string> orderIdsStr{};
  shared_ptr<string> orderInstanceId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> principalKey{};
  shared_ptr<string> principalName{};
  shared_ptr<string> status{};
  shared_ptr<string> submitStatus{};
  shared_ptr<string> submitTime{};

  QueryTrademarkModelEspListRequest() {}

  explicit QueryTrademarkModelEspListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalSubmitStatus) {
      res["AdditionalSubmitStatus"] = boost::any(*additionalSubmitStatus);
    }
    if (additionalSubmitTime) {
      res["AdditionalSubmitTime"] = boost::any(*additionalSubmitTime);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (existStatus) {
      res["ExistStatus"] = boost::any(*existStatus);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (orderIdsStr) {
      res["OrderIdsStr"] = boost::any(*orderIdsStr);
    }
    if (orderInstanceId) {
      res["OrderInstanceId"] = boost::any(*orderInstanceId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (principalKey) {
      res["PrincipalKey"] = boost::any(*principalKey);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitStatus) {
      res["SubmitStatus"] = boost::any(*submitStatus);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalSubmitStatus") != m.end() && !m["AdditionalSubmitStatus"].empty()) {
      additionalSubmitStatus = make_shared<string>(boost::any_cast<string>(m["AdditionalSubmitStatus"]));
    }
    if (m.find("AdditionalSubmitTime") != m.end() && !m["AdditionalSubmitTime"].empty()) {
      additionalSubmitTime = make_shared<string>(boost::any_cast<string>(m["AdditionalSubmitTime"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("ExistStatus") != m.end() && !m["ExistStatus"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExistStatus"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExistStatus"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      existStatus = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OrderIdsStr") != m.end() && !m["OrderIdsStr"].empty()) {
      orderIdsStr = make_shared<string>(boost::any_cast<string>(m["OrderIdsStr"]));
    }
    if (m.find("OrderInstanceId") != m.end() && !m["OrderInstanceId"].empty()) {
      orderInstanceId = make_shared<string>(boost::any_cast<string>(m["OrderInstanceId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PrincipalKey") != m.end() && !m["PrincipalKey"].empty()) {
      principalKey = make_shared<string>(boost::any_cast<string>(m["PrincipalKey"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitStatus") != m.end() && !m["SubmitStatus"].empty()) {
      submitStatus = make_shared<string>(boost::any_cast<string>(m["SubmitStatus"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
  }


  virtual ~QueryTrademarkModelEspListRequest() = default;
};
class QueryTrademarkModelEspListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> additionalSubmitStatus{};
  shared_ptr<string> additionalSubmitTime{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};
  shared_ptr<string> env{};
  shared_ptr<string> existStatusShrink{};
  shared_ptr<string> orderId{};
  shared_ptr<string> orderIdsStr{};
  shared_ptr<string> orderInstanceId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> principalKey{};
  shared_ptr<string> principalName{};
  shared_ptr<string> status{};
  shared_ptr<string> submitStatus{};
  shared_ptr<string> submitTime{};

  QueryTrademarkModelEspListShrinkRequest() {}

  explicit QueryTrademarkModelEspListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalSubmitStatus) {
      res["AdditionalSubmitStatus"] = boost::any(*additionalSubmitStatus);
    }
    if (additionalSubmitTime) {
      res["AdditionalSubmitTime"] = boost::any(*additionalSubmitTime);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (existStatusShrink) {
      res["ExistStatus"] = boost::any(*existStatusShrink);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (orderIdsStr) {
      res["OrderIdsStr"] = boost::any(*orderIdsStr);
    }
    if (orderInstanceId) {
      res["OrderInstanceId"] = boost::any(*orderInstanceId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (principalKey) {
      res["PrincipalKey"] = boost::any(*principalKey);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitStatus) {
      res["SubmitStatus"] = boost::any(*submitStatus);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalSubmitStatus") != m.end() && !m["AdditionalSubmitStatus"].empty()) {
      additionalSubmitStatus = make_shared<string>(boost::any_cast<string>(m["AdditionalSubmitStatus"]));
    }
    if (m.find("AdditionalSubmitTime") != m.end() && !m["AdditionalSubmitTime"].empty()) {
      additionalSubmitTime = make_shared<string>(boost::any_cast<string>(m["AdditionalSubmitTime"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("ExistStatus") != m.end() && !m["ExistStatus"].empty()) {
      existStatusShrink = make_shared<string>(boost::any_cast<string>(m["ExistStatus"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OrderIdsStr") != m.end() && !m["OrderIdsStr"].empty()) {
      orderIdsStr = make_shared<string>(boost::any_cast<string>(m["OrderIdsStr"]));
    }
    if (m.find("OrderInstanceId") != m.end() && !m["OrderInstanceId"].empty()) {
      orderInstanceId = make_shared<string>(boost::any_cast<string>(m["OrderInstanceId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PrincipalKey") != m.end() && !m["PrincipalKey"].empty()) {
      principalKey = make_shared<string>(boost::any_cast<string>(m["PrincipalKey"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitStatus") != m.end() && !m["SubmitStatus"].empty()) {
      submitStatus = make_shared<string>(boost::any_cast<string>(m["SubmitStatus"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
  }


  virtual ~QueryTrademarkModelEspListShrinkRequest() = default;
};
class QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodesLeafCode : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodesLeafCode() {}

  explicit QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodesLeafCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodesLeafCode() = default;
};
class QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodes : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodesLeafCode>> leafCode{};

  QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodes() {}

  explicit QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (leafCode) {
      vector<boost::any> temp1;
      for(auto item1:*leafCode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["leafCode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("leafCode") != m.end() && !m["leafCode"].empty()) {
      if (typeid(vector<boost::any>) == m["leafCode"].type()) {
        vector<QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodesLeafCode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["leafCode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodesLeafCode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        leafCode = make_shared<vector<QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodesLeafCode>>(expect1);
      }
    }
  }


  virtual ~QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodes() = default;
};
class QueryTrademarkModelEspListResponseBodyMoudleDataItemMaterialInfo : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> businessLicenceUrl{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> cnInfoUrl{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactZipCode{};
  shared_ptr<string> country{};
  shared_ptr<string> EAddress{};
  shared_ptr<string> EName{};
  shared_ptr<string> idCardNumber{};
  shared_ptr<string> idCardUrl{};
  shared_ptr<string> loaKey{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> passportUrl{};
  shared_ptr<string> personalType{};
  shared_ptr<string> postCode{};
  shared_ptr<string> province{};
  shared_ptr<string> reasonFileOssKey{};
  shared_ptr<long> region{};
  shared_ptr<long> type{};

  QueryTrademarkModelEspListResponseBodyMoudleDataItemMaterialInfo() {}

  explicit QueryTrademarkModelEspListResponseBodyMoudleDataItemMaterialInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (businessLicenceUrl) {
      res["BusinessLicenceUrl"] = boost::any(*businessLicenceUrl);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (cnInfoUrl) {
      res["CnInfoUrl"] = boost::any(*cnInfoUrl);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactZipCode) {
      res["ContactZipCode"] = boost::any(*contactZipCode);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (EAddress) {
      res["EAddress"] = boost::any(*EAddress);
    }
    if (EName) {
      res["EName"] = boost::any(*EName);
    }
    if (idCardNumber) {
      res["IdCardNumber"] = boost::any(*idCardNumber);
    }
    if (idCardUrl) {
      res["IdCardUrl"] = boost::any(*idCardUrl);
    }
    if (loaKey) {
      res["LoaKey"] = boost::any(*loaKey);
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportUrl) {
      res["PassportUrl"] = boost::any(*passportUrl);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (postCode) {
      res["PostCode"] = boost::any(*postCode);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (reasonFileOssKey) {
      res["ReasonFileOssKey"] = boost::any(*reasonFileOssKey);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BusinessLicenceUrl") != m.end() && !m["BusinessLicenceUrl"].empty()) {
      businessLicenceUrl = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceUrl"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("CnInfoUrl") != m.end() && !m["CnInfoUrl"].empty()) {
      cnInfoUrl = make_shared<string>(boost::any_cast<string>(m["CnInfoUrl"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactZipCode") != m.end() && !m["ContactZipCode"].empty()) {
      contactZipCode = make_shared<string>(boost::any_cast<string>(m["ContactZipCode"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("EAddress") != m.end() && !m["EAddress"].empty()) {
      EAddress = make_shared<string>(boost::any_cast<string>(m["EAddress"]));
    }
    if (m.find("EName") != m.end() && !m["EName"].empty()) {
      EName = make_shared<string>(boost::any_cast<string>(m["EName"]));
    }
    if (m.find("IdCardNumber") != m.end() && !m["IdCardNumber"].empty()) {
      idCardNumber = make_shared<string>(boost::any_cast<string>(m["IdCardNumber"]));
    }
    if (m.find("IdCardUrl") != m.end() && !m["IdCardUrl"].empty()) {
      idCardUrl = make_shared<string>(boost::any_cast<string>(m["IdCardUrl"]));
    }
    if (m.find("LoaKey") != m.end() && !m["LoaKey"].empty()) {
      loaKey = make_shared<string>(boost::any_cast<string>(m["LoaKey"]));
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportUrl") != m.end() && !m["PassportUrl"].empty()) {
      passportUrl = make_shared<string>(boost::any_cast<string>(m["PassportUrl"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<string>(boost::any_cast<string>(m["PersonalType"]));
    }
    if (m.find("PostCode") != m.end() && !m["PostCode"].empty()) {
      postCode = make_shared<string>(boost::any_cast<string>(m["PostCode"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("ReasonFileOssKey") != m.end() && !m["ReasonFileOssKey"].empty()) {
      reasonFileOssKey = make_shared<string>(boost::any_cast<string>(m["ReasonFileOssKey"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryTrademarkModelEspListResponseBodyMoudleDataItemMaterialInfo() = default;
};
class QueryTrademarkModelEspListResponseBodyMoudleDataItemRootCode : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTrademarkModelEspListResponseBodyMoudleDataItemRootCode() {}

  explicit QueryTrademarkModelEspListResponseBodyMoudleDataItemRootCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTrademarkModelEspListResponseBodyMoudleDataItemRootCode() = default;
};
class QueryTrademarkModelEspListResponseBodyMoudleDataItem : public Darabonba::Model {
public:
  shared_ptr<long> bitFlag{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};
  shared_ptr<map<string, boost::any>> extendInfo{};
  shared_ptr<string> grayIconUrl{};
  shared_ptr<string> icon{};
  shared_ptr<QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodes> leafCodes{};
  shared_ptr<QueryTrademarkModelEspListResponseBodyMoudleDataItemMaterialInfo> materialInfo{};
  shared_ptr<string> orderId{};
  shared_ptr<string> partnerCode{};
  shared_ptr<string> principalKey{};
  shared_ptr<string> principalName{};
  shared_ptr<string> produceType{};
  shared_ptr<QueryTrademarkModelEspListResponseBodyMoudleDataItemRootCode> rootCode{};
  shared_ptr<string> status{};
  shared_ptr<string> statusStr{};
  shared_ptr<long> submitAuditTime{};
  shared_ptr<string> submitStatus{};
  shared_ptr<long> submitTime{};
  shared_ptr<long> submitTimes{};
  shared_ptr<string> trademarkName{};
  shared_ptr<long> trademarkNameType{};
  shared_ptr<string> trademarkNumber{};

  QueryTrademarkModelEspListResponseBodyMoudleDataItem() {}

  explicit QueryTrademarkModelEspListResponseBodyMoudleDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitFlag) {
      res["BitFlag"] = boost::any(*bitFlag);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (grayIconUrl) {
      res["GrayIconUrl"] = boost::any(*grayIconUrl);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (leafCodes) {
      res["LeafCodes"] = leafCodes ? boost::any(leafCodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (materialInfo) {
      res["MaterialInfo"] = materialInfo ? boost::any(materialInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (partnerCode) {
      res["PartnerCode"] = boost::any(*partnerCode);
    }
    if (principalKey) {
      res["PrincipalKey"] = boost::any(*principalKey);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (produceType) {
      res["ProduceType"] = boost::any(*produceType);
    }
    if (rootCode) {
      res["RootCode"] = rootCode ? boost::any(rootCode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusStr) {
      res["StatusStr"] = boost::any(*statusStr);
    }
    if (submitAuditTime) {
      res["SubmitAuditTime"] = boost::any(*submitAuditTime);
    }
    if (submitStatus) {
      res["SubmitStatus"] = boost::any(*submitStatus);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (submitTimes) {
      res["SubmitTimes"] = boost::any(*submitTimes);
    }
    if (trademarkName) {
      res["TrademarkName"] = boost::any(*trademarkName);
    }
    if (trademarkNameType) {
      res["TrademarkNameType"] = boost::any(*trademarkNameType);
    }
    if (trademarkNumber) {
      res["TrademarkNumber"] = boost::any(*trademarkNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BitFlag") != m.end() && !m["BitFlag"].empty()) {
      bitFlag = make_shared<long>(boost::any_cast<long>(m["BitFlag"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtendInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extendInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GrayIconUrl") != m.end() && !m["GrayIconUrl"].empty()) {
      grayIconUrl = make_shared<string>(boost::any_cast<string>(m["GrayIconUrl"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("LeafCodes") != m.end() && !m["LeafCodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["LeafCodes"].type()) {
        QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LeafCodes"]));
        leafCodes = make_shared<QueryTrademarkModelEspListResponseBodyMoudleDataItemLeafCodes>(model1);
      }
    }
    if (m.find("MaterialInfo") != m.end() && !m["MaterialInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaterialInfo"].type()) {
        QueryTrademarkModelEspListResponseBodyMoudleDataItemMaterialInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaterialInfo"]));
        materialInfo = make_shared<QueryTrademarkModelEspListResponseBodyMoudleDataItemMaterialInfo>(model1);
      }
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PartnerCode") != m.end() && !m["PartnerCode"].empty()) {
      partnerCode = make_shared<string>(boost::any_cast<string>(m["PartnerCode"]));
    }
    if (m.find("PrincipalKey") != m.end() && !m["PrincipalKey"].empty()) {
      principalKey = make_shared<string>(boost::any_cast<string>(m["PrincipalKey"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("ProduceType") != m.end() && !m["ProduceType"].empty()) {
      produceType = make_shared<string>(boost::any_cast<string>(m["ProduceType"]));
    }
    if (m.find("RootCode") != m.end() && !m["RootCode"].empty()) {
      if (typeid(map<string, boost::any>) == m["RootCode"].type()) {
        QueryTrademarkModelEspListResponseBodyMoudleDataItemRootCode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RootCode"]));
        rootCode = make_shared<QueryTrademarkModelEspListResponseBodyMoudleDataItemRootCode>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusStr") != m.end() && !m["StatusStr"].empty()) {
      statusStr = make_shared<string>(boost::any_cast<string>(m["StatusStr"]));
    }
    if (m.find("SubmitAuditTime") != m.end() && !m["SubmitAuditTime"].empty()) {
      submitAuditTime = make_shared<long>(boost::any_cast<long>(m["SubmitAuditTime"]));
    }
    if (m.find("SubmitStatus") != m.end() && !m["SubmitStatus"].empty()) {
      submitStatus = make_shared<string>(boost::any_cast<string>(m["SubmitStatus"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<long>(boost::any_cast<long>(m["SubmitTime"]));
    }
    if (m.find("SubmitTimes") != m.end() && !m["SubmitTimes"].empty()) {
      submitTimes = make_shared<long>(boost::any_cast<long>(m["SubmitTimes"]));
    }
    if (m.find("TrademarkName") != m.end() && !m["TrademarkName"].empty()) {
      trademarkName = make_shared<string>(boost::any_cast<string>(m["TrademarkName"]));
    }
    if (m.find("TrademarkNameType") != m.end() && !m["TrademarkNameType"].empty()) {
      trademarkNameType = make_shared<long>(boost::any_cast<long>(m["TrademarkNameType"]));
    }
    if (m.find("TrademarkNumber") != m.end() && !m["TrademarkNumber"].empty()) {
      trademarkNumber = make_shared<string>(boost::any_cast<string>(m["TrademarkNumber"]));
    }
  }


  virtual ~QueryTrademarkModelEspListResponseBodyMoudleDataItem() = default;
};
class QueryTrademarkModelEspListResponseBodyMoudleData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTrademarkModelEspListResponseBodyMoudleDataItem>> item{};

  QueryTrademarkModelEspListResponseBodyMoudleData() {}

  explicit QueryTrademarkModelEspListResponseBodyMoudleData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("item") != m.end() && !m["item"].empty()) {
      if (typeid(vector<boost::any>) == m["item"].type()) {
        vector<QueryTrademarkModelEspListResponseBodyMoudleDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTrademarkModelEspListResponseBodyMoudleDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<QueryTrademarkModelEspListResponseBodyMoudleDataItem>>(expect1);
      }
    }
  }


  virtual ~QueryTrademarkModelEspListResponseBodyMoudleData() = default;
};
class QueryTrademarkModelEspListResponseBodyMoudle : public Darabonba::Model {
public:
  shared_ptr<QueryTrademarkModelEspListResponseBodyMoudleData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalPageNum{};

  QueryTrademarkModelEspListResponseBodyMoudle() {}

  explicit QueryTrademarkModelEspListResponseBodyMoudle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTrademarkModelEspListResponseBodyMoudleData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTrademarkModelEspListResponseBodyMoudleData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryTrademarkModelEspListResponseBodyMoudle() = default;
};
class QueryTrademarkModelEspListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTrademarkModelEspListResponseBodyMoudle> moudle{};

  QueryTrademarkModelEspListResponseBody() {}

  explicit QueryTrademarkModelEspListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moudle) {
      res["Moudle"] = moudle ? boost::any(moudle->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Moudle") != m.end() && !m["Moudle"].empty()) {
      if (typeid(map<string, boost::any>) == m["Moudle"].type()) {
        QueryTrademarkModelEspListResponseBodyMoudle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Moudle"]));
        moudle = make_shared<QueryTrademarkModelEspListResponseBodyMoudle>(model1);
      }
    }
  }


  virtual ~QueryTrademarkModelEspListResponseBody() = default;
};
class QueryTrademarkModelEspListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTrademarkModelEspListResponseBody> body{};

  QueryTrademarkModelEspListResponse() {}

  explicit QueryTrademarkModelEspListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTrademarkModelEspListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTrademarkModelEspListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTrademarkModelEspListResponse() = default;
};
class QueryTrademarkModelListRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<string> orderIdsStr{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> principalKey{};
  shared_ptr<string> principalName{};
  shared_ptr<string> produceTypesStr{};
  shared_ptr<string> status{};
  shared_ptr<string> submitStart{};
  shared_ptr<string> submitStatus{};
  shared_ptr<string> submitTime{};

  QueryTrademarkModelListRequest() {}

  explicit QueryTrademarkModelListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (orderIdsStr) {
      res["OrderIdsStr"] = boost::any(*orderIdsStr);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (principalKey) {
      res["PrincipalKey"] = boost::any(*principalKey);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (produceTypesStr) {
      res["ProduceTypesStr"] = boost::any(*produceTypesStr);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitStart) {
      res["SubmitStart"] = boost::any(*submitStart);
    }
    if (submitStatus) {
      res["SubmitStatus"] = boost::any(*submitStatus);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OrderIdsStr") != m.end() && !m["OrderIdsStr"].empty()) {
      orderIdsStr = make_shared<string>(boost::any_cast<string>(m["OrderIdsStr"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PrincipalKey") != m.end() && !m["PrincipalKey"].empty()) {
      principalKey = make_shared<string>(boost::any_cast<string>(m["PrincipalKey"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("ProduceTypesStr") != m.end() && !m["ProduceTypesStr"].empty()) {
      produceTypesStr = make_shared<string>(boost::any_cast<string>(m["ProduceTypesStr"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitStart") != m.end() && !m["SubmitStart"].empty()) {
      submitStart = make_shared<string>(boost::any_cast<string>(m["SubmitStart"]));
    }
    if (m.find("SubmitStatus") != m.end() && !m["SubmitStatus"].empty()) {
      submitStatus = make_shared<string>(boost::any_cast<string>(m["SubmitStatus"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
  }


  virtual ~QueryTrademarkModelListRequest() = default;
};
class QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodesLeafCode : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodesLeafCode() {}

  explicit QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodesLeafCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodesLeafCode() = default;
};
class QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodes : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodesLeafCode>> leafCode{};

  QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodes() {}

  explicit QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (leafCode) {
      vector<boost::any> temp1;
      for(auto item1:*leafCode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["leafCode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("leafCode") != m.end() && !m["leafCode"].empty()) {
      if (typeid(vector<boost::any>) == m["leafCode"].type()) {
        vector<QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodesLeafCode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["leafCode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodesLeafCode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        leafCode = make_shared<vector<QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodesLeafCode>>(expect1);
      }
    }
  }


  virtual ~QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodes() = default;
};
class QueryTrademarkModelListResponseBodyMoudleDataItemMaterialInfo : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> businessLicenceUrl{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> cnInfoUrl{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactZipCode{};
  shared_ptr<string> country{};
  shared_ptr<string> EAddress{};
  shared_ptr<string> EName{};
  shared_ptr<string> idCardNumber{};
  shared_ptr<string> idCardUrl{};
  shared_ptr<string> loaKey{};
  shared_ptr<string> loaUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> passportUrl{};
  shared_ptr<long> personalType{};
  shared_ptr<string> postCode{};
  shared_ptr<string> province{};
  shared_ptr<string> reasonFileOssKey{};
  shared_ptr<long> region{};
  shared_ptr<long> type{};

  QueryTrademarkModelListResponseBodyMoudleDataItemMaterialInfo() {}

  explicit QueryTrademarkModelListResponseBodyMoudleDataItemMaterialInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (businessLicenceUrl) {
      res["BusinessLicenceUrl"] = boost::any(*businessLicenceUrl);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (cnInfoUrl) {
      res["CnInfoUrl"] = boost::any(*cnInfoUrl);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactZipCode) {
      res["ContactZipCode"] = boost::any(*contactZipCode);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (EAddress) {
      res["EAddress"] = boost::any(*EAddress);
    }
    if (EName) {
      res["EName"] = boost::any(*EName);
    }
    if (idCardNumber) {
      res["IdCardNumber"] = boost::any(*idCardNumber);
    }
    if (idCardUrl) {
      res["IdCardUrl"] = boost::any(*idCardUrl);
    }
    if (loaKey) {
      res["LoaKey"] = boost::any(*loaKey);
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportUrl) {
      res["PassportUrl"] = boost::any(*passportUrl);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (postCode) {
      res["PostCode"] = boost::any(*postCode);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (reasonFileOssKey) {
      res["ReasonFileOssKey"] = boost::any(*reasonFileOssKey);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BusinessLicenceUrl") != m.end() && !m["BusinessLicenceUrl"].empty()) {
      businessLicenceUrl = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceUrl"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("CnInfoUrl") != m.end() && !m["CnInfoUrl"].empty()) {
      cnInfoUrl = make_shared<string>(boost::any_cast<string>(m["CnInfoUrl"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactZipCode") != m.end() && !m["ContactZipCode"].empty()) {
      contactZipCode = make_shared<string>(boost::any_cast<string>(m["ContactZipCode"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("EAddress") != m.end() && !m["EAddress"].empty()) {
      EAddress = make_shared<string>(boost::any_cast<string>(m["EAddress"]));
    }
    if (m.find("EName") != m.end() && !m["EName"].empty()) {
      EName = make_shared<string>(boost::any_cast<string>(m["EName"]));
    }
    if (m.find("IdCardNumber") != m.end() && !m["IdCardNumber"].empty()) {
      idCardNumber = make_shared<string>(boost::any_cast<string>(m["IdCardNumber"]));
    }
    if (m.find("IdCardUrl") != m.end() && !m["IdCardUrl"].empty()) {
      idCardUrl = make_shared<string>(boost::any_cast<string>(m["IdCardUrl"]));
    }
    if (m.find("LoaKey") != m.end() && !m["LoaKey"].empty()) {
      loaKey = make_shared<string>(boost::any_cast<string>(m["LoaKey"]));
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportUrl") != m.end() && !m["PassportUrl"].empty()) {
      passportUrl = make_shared<string>(boost::any_cast<string>(m["PassportUrl"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<long>(boost::any_cast<long>(m["PersonalType"]));
    }
    if (m.find("PostCode") != m.end() && !m["PostCode"].empty()) {
      postCode = make_shared<string>(boost::any_cast<string>(m["PostCode"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("ReasonFileOssKey") != m.end() && !m["ReasonFileOssKey"].empty()) {
      reasonFileOssKey = make_shared<string>(boost::any_cast<string>(m["ReasonFileOssKey"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryTrademarkModelListResponseBodyMoudleDataItemMaterialInfo() = default;
};
class QueryTrademarkModelListResponseBodyMoudleDataItemRootCode : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};

  QueryTrademarkModelListResponseBodyMoudleDataItemRootCode() {}

  explicit QueryTrademarkModelListResponseBodyMoudleDataItemRootCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
  }


  virtual ~QueryTrademarkModelListResponseBodyMoudleDataItemRootCode() = default;
};
class QueryTrademarkModelListResponseBodyMoudleDataItem : public Darabonba::Model {
public:
  shared_ptr<long> bitFlag{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};
  shared_ptr<map<string, boost::any>> extendInfo{};
  shared_ptr<string> grayIconUrl{};
  shared_ptr<string> icon{};
  shared_ptr<QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodes> leafCodes{};
  shared_ptr<QueryTrademarkModelListResponseBodyMoudleDataItemMaterialInfo> materialInfo{};
  shared_ptr<string> orderId{};
  shared_ptr<string> partnerCode{};
  shared_ptr<string> principalKey{};
  shared_ptr<string> principalName{};
  shared_ptr<string> produceType{};
  shared_ptr<QueryTrademarkModelListResponseBodyMoudleDataItemRootCode> rootCode{};
  shared_ptr<string> status{};
  shared_ptr<string> statusStr{};
  shared_ptr<string> submitAuditTimeStr{};
  shared_ptr<long> submitAuditTimeValue{};
  shared_ptr<string> submitStatus{};
  shared_ptr<string> submitTimeStr{};
  shared_ptr<long> submitTimeValue{};
  shared_ptr<long> submitTimes{};
  shared_ptr<string> trademarkName{};
  shared_ptr<long> trademarkNameType{};
  shared_ptr<string> trademarkNumber{};

  QueryTrademarkModelListResponseBodyMoudleDataItem() {}

  explicit QueryTrademarkModelListResponseBodyMoudleDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitFlag) {
      res["BitFlag"] = boost::any(*bitFlag);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (grayIconUrl) {
      res["GrayIconUrl"] = boost::any(*grayIconUrl);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (leafCodes) {
      res["LeafCodes"] = leafCodes ? boost::any(leafCodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (materialInfo) {
      res["MaterialInfo"] = materialInfo ? boost::any(materialInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (partnerCode) {
      res["PartnerCode"] = boost::any(*partnerCode);
    }
    if (principalKey) {
      res["PrincipalKey"] = boost::any(*principalKey);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (produceType) {
      res["ProduceType"] = boost::any(*produceType);
    }
    if (rootCode) {
      res["RootCode"] = rootCode ? boost::any(rootCode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusStr) {
      res["StatusStr"] = boost::any(*statusStr);
    }
    if (submitAuditTimeStr) {
      res["SubmitAuditTimeStr"] = boost::any(*submitAuditTimeStr);
    }
    if (submitAuditTimeValue) {
      res["SubmitAuditTimeValue"] = boost::any(*submitAuditTimeValue);
    }
    if (submitStatus) {
      res["SubmitStatus"] = boost::any(*submitStatus);
    }
    if (submitTimeStr) {
      res["SubmitTimeStr"] = boost::any(*submitTimeStr);
    }
    if (submitTimeValue) {
      res["SubmitTimeValue"] = boost::any(*submitTimeValue);
    }
    if (submitTimes) {
      res["SubmitTimes"] = boost::any(*submitTimes);
    }
    if (trademarkName) {
      res["TrademarkName"] = boost::any(*trademarkName);
    }
    if (trademarkNameType) {
      res["TrademarkNameType"] = boost::any(*trademarkNameType);
    }
    if (trademarkNumber) {
      res["TrademarkNumber"] = boost::any(*trademarkNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BitFlag") != m.end() && !m["BitFlag"].empty()) {
      bitFlag = make_shared<long>(boost::any_cast<long>(m["BitFlag"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtendInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extendInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GrayIconUrl") != m.end() && !m["GrayIconUrl"].empty()) {
      grayIconUrl = make_shared<string>(boost::any_cast<string>(m["GrayIconUrl"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("LeafCodes") != m.end() && !m["LeafCodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["LeafCodes"].type()) {
        QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LeafCodes"]));
        leafCodes = make_shared<QueryTrademarkModelListResponseBodyMoudleDataItemLeafCodes>(model1);
      }
    }
    if (m.find("MaterialInfo") != m.end() && !m["MaterialInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaterialInfo"].type()) {
        QueryTrademarkModelListResponseBodyMoudleDataItemMaterialInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaterialInfo"]));
        materialInfo = make_shared<QueryTrademarkModelListResponseBodyMoudleDataItemMaterialInfo>(model1);
      }
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PartnerCode") != m.end() && !m["PartnerCode"].empty()) {
      partnerCode = make_shared<string>(boost::any_cast<string>(m["PartnerCode"]));
    }
    if (m.find("PrincipalKey") != m.end() && !m["PrincipalKey"].empty()) {
      principalKey = make_shared<string>(boost::any_cast<string>(m["PrincipalKey"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
    if (m.find("ProduceType") != m.end() && !m["ProduceType"].empty()) {
      produceType = make_shared<string>(boost::any_cast<string>(m["ProduceType"]));
    }
    if (m.find("RootCode") != m.end() && !m["RootCode"].empty()) {
      if (typeid(map<string, boost::any>) == m["RootCode"].type()) {
        QueryTrademarkModelListResponseBodyMoudleDataItemRootCode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RootCode"]));
        rootCode = make_shared<QueryTrademarkModelListResponseBodyMoudleDataItemRootCode>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusStr") != m.end() && !m["StatusStr"].empty()) {
      statusStr = make_shared<string>(boost::any_cast<string>(m["StatusStr"]));
    }
    if (m.find("SubmitAuditTimeStr") != m.end() && !m["SubmitAuditTimeStr"].empty()) {
      submitAuditTimeStr = make_shared<string>(boost::any_cast<string>(m["SubmitAuditTimeStr"]));
    }
    if (m.find("SubmitAuditTimeValue") != m.end() && !m["SubmitAuditTimeValue"].empty()) {
      submitAuditTimeValue = make_shared<long>(boost::any_cast<long>(m["SubmitAuditTimeValue"]));
    }
    if (m.find("SubmitStatus") != m.end() && !m["SubmitStatus"].empty()) {
      submitStatus = make_shared<string>(boost::any_cast<string>(m["SubmitStatus"]));
    }
    if (m.find("SubmitTimeStr") != m.end() && !m["SubmitTimeStr"].empty()) {
      submitTimeStr = make_shared<string>(boost::any_cast<string>(m["SubmitTimeStr"]));
    }
    if (m.find("SubmitTimeValue") != m.end() && !m["SubmitTimeValue"].empty()) {
      submitTimeValue = make_shared<long>(boost::any_cast<long>(m["SubmitTimeValue"]));
    }
    if (m.find("SubmitTimes") != m.end() && !m["SubmitTimes"].empty()) {
      submitTimes = make_shared<long>(boost::any_cast<long>(m["SubmitTimes"]));
    }
    if (m.find("TrademarkName") != m.end() && !m["TrademarkName"].empty()) {
      trademarkName = make_shared<string>(boost::any_cast<string>(m["TrademarkName"]));
    }
    if (m.find("TrademarkNameType") != m.end() && !m["TrademarkNameType"].empty()) {
      trademarkNameType = make_shared<long>(boost::any_cast<long>(m["TrademarkNameType"]));
    }
    if (m.find("TrademarkNumber") != m.end() && !m["TrademarkNumber"].empty()) {
      trademarkNumber = make_shared<string>(boost::any_cast<string>(m["TrademarkNumber"]));
    }
  }


  virtual ~QueryTrademarkModelListResponseBodyMoudleDataItem() = default;
};
class QueryTrademarkModelListResponseBodyMoudleData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTrademarkModelListResponseBodyMoudleDataItem>> item{};

  QueryTrademarkModelListResponseBodyMoudleData() {}

  explicit QueryTrademarkModelListResponseBodyMoudleData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("item") != m.end() && !m["item"].empty()) {
      if (typeid(vector<boost::any>) == m["item"].type()) {
        vector<QueryTrademarkModelListResponseBodyMoudleDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTrademarkModelListResponseBodyMoudleDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<QueryTrademarkModelListResponseBodyMoudleDataItem>>(expect1);
      }
    }
  }


  virtual ~QueryTrademarkModelListResponseBodyMoudleData() = default;
};
class QueryTrademarkModelListResponseBodyMoudle : public Darabonba::Model {
public:
  shared_ptr<QueryTrademarkModelListResponseBodyMoudleData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalPageNum{};

  QueryTrademarkModelListResponseBodyMoudle() {}

  explicit QueryTrademarkModelListResponseBodyMoudle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTrademarkModelListResponseBodyMoudleData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTrademarkModelListResponseBodyMoudleData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryTrademarkModelListResponseBodyMoudle() = default;
};
class QueryTrademarkModelListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTrademarkModelListResponseBodyMoudle> moudle{};

  QueryTrademarkModelListResponseBody() {}

  explicit QueryTrademarkModelListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moudle) {
      res["Moudle"] = moudle ? boost::any(moudle->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Moudle") != m.end() && !m["Moudle"].empty()) {
      if (typeid(map<string, boost::any>) == m["Moudle"].type()) {
        QueryTrademarkModelListResponseBodyMoudle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Moudle"]));
        moudle = make_shared<QueryTrademarkModelListResponseBodyMoudle>(model1);
      }
    }
  }


  virtual ~QueryTrademarkModelListResponseBody() = default;
};
class QueryTrademarkModelListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTrademarkModelListResponseBody> body{};

  QueryTrademarkModelListResponse() {}

  explicit QueryTrademarkModelListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTrademarkModelListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTrademarkModelListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTrademarkModelListResponse() = default;
};
class QueryTrademarkMonitorResultsRequest : public Darabonba::Model {
public:
  shared_ptr<long> actionType{};
  shared_ptr<string> applyYear{};
  shared_ptr<string> classification{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> procedureStatus{};
  shared_ptr<string> registrationNumber{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> tmName{};

  QueryTrademarkMonitorResultsRequest() {}

  explicit QueryTrademarkMonitorResultsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionType) {
      res["ActionType"] = boost::any(*actionType);
    }
    if (applyYear) {
      res["ApplyYear"] = boost::any(*applyYear);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (procedureStatus) {
      res["ProcedureStatus"] = boost::any(*procedureStatus);
    }
    if (registrationNumber) {
      res["RegistrationNumber"] = boost::any(*registrationNumber);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionType") != m.end() && !m["ActionType"].empty()) {
      actionType = make_shared<long>(boost::any_cast<long>(m["ActionType"]));
    }
    if (m.find("ApplyYear") != m.end() && !m["ApplyYear"].empty()) {
      applyYear = make_shared<string>(boost::any_cast<string>(m["ApplyYear"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProcedureStatus") != m.end() && !m["ProcedureStatus"].empty()) {
      procedureStatus = make_shared<long>(boost::any_cast<long>(m["ProcedureStatus"]));
    }
    if (m.find("RegistrationNumber") != m.end() && !m["RegistrationNumber"].empty()) {
      registrationNumber = make_shared<string>(boost::any_cast<string>(m["RegistrationNumber"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
  }


  virtual ~QueryTrademarkMonitorResultsRequest() = default;
};
class QueryTrademarkMonitorResultsResponseBodyDataTmMonitorResult : public Darabonba::Model {
public:
  shared_ptr<string> applyDate{};
  shared_ptr<string> chesanEndDate{};
  shared_ptr<string> classification{};
  shared_ptr<long> dataCreateTime{};
  shared_ptr<long> dataUpdateTime{};
  shared_ptr<string> ownerEnName{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> registrationNumber{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> tmImage{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmProcedureStatusDesc{};
  shared_ptr<string> tmUid{};
  shared_ptr<string> userId{};
  shared_ptr<string> wuxiaoEndDate{};
  shared_ptr<string> xuzhanEndDate{};
  shared_ptr<string> yiyiEndDate{};

  QueryTrademarkMonitorResultsResponseBodyDataTmMonitorResult() {}

  explicit QueryTrademarkMonitorResultsResponseBodyDataTmMonitorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyDate) {
      res["ApplyDate"] = boost::any(*applyDate);
    }
    if (chesanEndDate) {
      res["ChesanEndDate"] = boost::any(*chesanEndDate);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (dataCreateTime) {
      res["DataCreateTime"] = boost::any(*dataCreateTime);
    }
    if (dataUpdateTime) {
      res["DataUpdateTime"] = boost::any(*dataUpdateTime);
    }
    if (ownerEnName) {
      res["OwnerEnName"] = boost::any(*ownerEnName);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (registrationNumber) {
      res["RegistrationNumber"] = boost::any(*registrationNumber);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (tmImage) {
      res["TmImage"] = boost::any(*tmImage);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmProcedureStatusDesc) {
      res["TmProcedureStatusDesc"] = boost::any(*tmProcedureStatusDesc);
    }
    if (tmUid) {
      res["TmUid"] = boost::any(*tmUid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (wuxiaoEndDate) {
      res["WuxiaoEndDate"] = boost::any(*wuxiaoEndDate);
    }
    if (xuzhanEndDate) {
      res["XuzhanEndDate"] = boost::any(*xuzhanEndDate);
    }
    if (yiyiEndDate) {
      res["YiyiEndDate"] = boost::any(*yiyiEndDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyDate") != m.end() && !m["ApplyDate"].empty()) {
      applyDate = make_shared<string>(boost::any_cast<string>(m["ApplyDate"]));
    }
    if (m.find("ChesanEndDate") != m.end() && !m["ChesanEndDate"].empty()) {
      chesanEndDate = make_shared<string>(boost::any_cast<string>(m["ChesanEndDate"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("DataCreateTime") != m.end() && !m["DataCreateTime"].empty()) {
      dataCreateTime = make_shared<long>(boost::any_cast<long>(m["DataCreateTime"]));
    }
    if (m.find("DataUpdateTime") != m.end() && !m["DataUpdateTime"].empty()) {
      dataUpdateTime = make_shared<long>(boost::any_cast<long>(m["DataUpdateTime"]));
    }
    if (m.find("OwnerEnName") != m.end() && !m["OwnerEnName"].empty()) {
      ownerEnName = make_shared<string>(boost::any_cast<string>(m["OwnerEnName"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("RegistrationNumber") != m.end() && !m["RegistrationNumber"].empty()) {
      registrationNumber = make_shared<string>(boost::any_cast<string>(m["RegistrationNumber"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("TmImage") != m.end() && !m["TmImage"].empty()) {
      tmImage = make_shared<string>(boost::any_cast<string>(m["TmImage"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmProcedureStatusDesc") != m.end() && !m["TmProcedureStatusDesc"].empty()) {
      tmProcedureStatusDesc = make_shared<string>(boost::any_cast<string>(m["TmProcedureStatusDesc"]));
    }
    if (m.find("TmUid") != m.end() && !m["TmUid"].empty()) {
      tmUid = make_shared<string>(boost::any_cast<string>(m["TmUid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WuxiaoEndDate") != m.end() && !m["WuxiaoEndDate"].empty()) {
      wuxiaoEndDate = make_shared<string>(boost::any_cast<string>(m["WuxiaoEndDate"]));
    }
    if (m.find("XuzhanEndDate") != m.end() && !m["XuzhanEndDate"].empty()) {
      xuzhanEndDate = make_shared<string>(boost::any_cast<string>(m["XuzhanEndDate"]));
    }
    if (m.find("YiyiEndDate") != m.end() && !m["YiyiEndDate"].empty()) {
      yiyiEndDate = make_shared<string>(boost::any_cast<string>(m["YiyiEndDate"]));
    }
  }


  virtual ~QueryTrademarkMonitorResultsResponseBodyDataTmMonitorResult() = default;
};
class QueryTrademarkMonitorResultsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTrademarkMonitorResultsResponseBodyDataTmMonitorResult>> tmMonitorResult{};

  QueryTrademarkMonitorResultsResponseBodyData() {}

  explicit QueryTrademarkMonitorResultsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tmMonitorResult) {
      vector<boost::any> temp1;
      for(auto item1:*tmMonitorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TmMonitorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TmMonitorResult") != m.end() && !m["TmMonitorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["TmMonitorResult"].type()) {
        vector<QueryTrademarkMonitorResultsResponseBodyDataTmMonitorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TmMonitorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTrademarkMonitorResultsResponseBodyDataTmMonitorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tmMonitorResult = make_shared<vector<QueryTrademarkMonitorResultsResponseBodyDataTmMonitorResult>>(expect1);
      }
    }
  }


  virtual ~QueryTrademarkMonitorResultsResponseBodyData() = default;
};
class QueryTrademarkMonitorResultsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<QueryTrademarkMonitorResultsResponseBodyData> data{};
  shared_ptr<bool> nextPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> prePage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryTrademarkMonitorResultsResponseBody() {}

  explicit QueryTrademarkMonitorResultsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPage) {
      res["NextPage"] = boost::any(*nextPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prePage) {
      res["PrePage"] = boost::any(*prePage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTrademarkMonitorResultsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTrademarkMonitorResultsResponseBodyData>(model1);
      }
    }
    if (m.find("NextPage") != m.end() && !m["NextPage"].empty()) {
      nextPage = make_shared<bool>(boost::any_cast<bool>(m["NextPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PrePage") != m.end() && !m["PrePage"].empty()) {
      prePage = make_shared<bool>(boost::any_cast<bool>(m["PrePage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryTrademarkMonitorResultsResponseBody() = default;
};
class QueryTrademarkMonitorResultsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTrademarkMonitorResultsResponseBody> body{};

  QueryTrademarkMonitorResultsResponse() {}

  explicit QueryTrademarkMonitorResultsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTrademarkMonitorResultsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTrademarkMonitorResultsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTrademarkMonitorResultsResponse() = default;
};
class QueryTrademarkMonitorRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> notifyUpdate{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ruleName{};

  QueryTrademarkMonitorRulesRequest() {}

  explicit QueryTrademarkMonitorRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (notifyUpdate) {
      res["NotifyUpdate"] = boost::any(*notifyUpdate);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("NotifyUpdate") != m.end() && !m["NotifyUpdate"].empty()) {
      notifyUpdate = make_shared<long>(boost::any_cast<long>(m["NotifyUpdate"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~QueryTrademarkMonitorRulesRequest() = default;
};
class QueryTrademarkMonitorRulesResponseBodyDataTmMonitorRule : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> env{};
  shared_ptr<string> id{};
  shared_ptr<string> lastFinishTime{};
  shared_ptr<string> lastRunTime{};
  shared_ptr<string> lastUpdateTime{};
  shared_ptr<long> notifyUpdate{};
  shared_ptr<string> ruleDetail{};
  shared_ptr<string> ruleExtend{};
  shared_ptr<string> ruleKeyword{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleSource{};
  shared_ptr<string> ruleStatus{};
  shared_ptr<long> ruleType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<long> version{};

  QueryTrademarkMonitorRulesResponseBodyDataTmMonitorRule() {}

  explicit QueryTrademarkMonitorRulesResponseBodyDataTmMonitorRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastFinishTime) {
      res["LastFinishTime"] = boost::any(*lastFinishTime);
    }
    if (lastRunTime) {
      res["LastRunTime"] = boost::any(*lastRunTime);
    }
    if (lastUpdateTime) {
      res["LastUpdateTime"] = boost::any(*lastUpdateTime);
    }
    if (notifyUpdate) {
      res["NotifyUpdate"] = boost::any(*notifyUpdate);
    }
    if (ruleDetail) {
      res["RuleDetail"] = boost::any(*ruleDetail);
    }
    if (ruleExtend) {
      res["RuleExtend"] = boost::any(*ruleExtend);
    }
    if (ruleKeyword) {
      res["RuleKeyword"] = boost::any(*ruleKeyword);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleSource) {
      res["RuleSource"] = boost::any(*ruleSource);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LastFinishTime") != m.end() && !m["LastFinishTime"].empty()) {
      lastFinishTime = make_shared<string>(boost::any_cast<string>(m["LastFinishTime"]));
    }
    if (m.find("LastRunTime") != m.end() && !m["LastRunTime"].empty()) {
      lastRunTime = make_shared<string>(boost::any_cast<string>(m["LastRunTime"]));
    }
    if (m.find("LastUpdateTime") != m.end() && !m["LastUpdateTime"].empty()) {
      lastUpdateTime = make_shared<string>(boost::any_cast<string>(m["LastUpdateTime"]));
    }
    if (m.find("NotifyUpdate") != m.end() && !m["NotifyUpdate"].empty()) {
      notifyUpdate = make_shared<long>(boost::any_cast<long>(m["NotifyUpdate"]));
    }
    if (m.find("RuleDetail") != m.end() && !m["RuleDetail"].empty()) {
      ruleDetail = make_shared<string>(boost::any_cast<string>(m["RuleDetail"]));
    }
    if (m.find("RuleExtend") != m.end() && !m["RuleExtend"].empty()) {
      ruleExtend = make_shared<string>(boost::any_cast<string>(m["RuleExtend"]));
    }
    if (m.find("RuleKeyword") != m.end() && !m["RuleKeyword"].empty()) {
      ruleKeyword = make_shared<string>(boost::any_cast<string>(m["RuleKeyword"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleSource") != m.end() && !m["RuleSource"].empty()) {
      ruleSource = make_shared<string>(boost::any_cast<string>(m["RuleSource"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["RuleStatus"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~QueryTrademarkMonitorRulesResponseBodyDataTmMonitorRule() = default;
};
class QueryTrademarkMonitorRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTrademarkMonitorRulesResponseBodyDataTmMonitorRule>> tmMonitorRule{};

  QueryTrademarkMonitorRulesResponseBodyData() {}

  explicit QueryTrademarkMonitorRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tmMonitorRule) {
      vector<boost::any> temp1;
      for(auto item1:*tmMonitorRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TmMonitorRule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TmMonitorRule") != m.end() && !m["TmMonitorRule"].empty()) {
      if (typeid(vector<boost::any>) == m["TmMonitorRule"].type()) {
        vector<QueryTrademarkMonitorRulesResponseBodyDataTmMonitorRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TmMonitorRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTrademarkMonitorRulesResponseBodyDataTmMonitorRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tmMonitorRule = make_shared<vector<QueryTrademarkMonitorRulesResponseBodyDataTmMonitorRule>>(expect1);
      }
    }
  }


  virtual ~QueryTrademarkMonitorRulesResponseBodyData() = default;
};
class QueryTrademarkMonitorRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPageNum{};
  shared_ptr<QueryTrademarkMonitorRulesResponseBodyData> data{};
  shared_ptr<bool> nextPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> prePage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItemNum{};
  shared_ptr<long> totalPageNum{};

  QueryTrademarkMonitorRulesResponseBody() {}

  explicit QueryTrademarkMonitorRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPageNum) {
      res["CurrentPageNum"] = boost::any(*currentPageNum);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPage) {
      res["NextPage"] = boost::any(*nextPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prePage) {
      res["PrePage"] = boost::any(*prePage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItemNum) {
      res["TotalItemNum"] = boost::any(*totalItemNum);
    }
    if (totalPageNum) {
      res["TotalPageNum"] = boost::any(*totalPageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPageNum") != m.end() && !m["CurrentPageNum"].empty()) {
      currentPageNum = make_shared<long>(boost::any_cast<long>(m["CurrentPageNum"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTrademarkMonitorRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTrademarkMonitorRulesResponseBodyData>(model1);
      }
    }
    if (m.find("NextPage") != m.end() && !m["NextPage"].empty()) {
      nextPage = make_shared<bool>(boost::any_cast<bool>(m["NextPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PrePage") != m.end() && !m["PrePage"].empty()) {
      prePage = make_shared<bool>(boost::any_cast<bool>(m["PrePage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItemNum") != m.end() && !m["TotalItemNum"].empty()) {
      totalItemNum = make_shared<long>(boost::any_cast<long>(m["TotalItemNum"]));
    }
    if (m.find("TotalPageNum") != m.end() && !m["TotalPageNum"].empty()) {
      totalPageNum = make_shared<long>(boost::any_cast<long>(m["TotalPageNum"]));
    }
  }


  virtual ~QueryTrademarkMonitorRulesResponseBody() = default;
};
class QueryTrademarkMonitorRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTrademarkMonitorRulesResponseBody> body{};

  QueryTrademarkMonitorRulesResponse() {}

  explicit QueryTrademarkMonitorRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTrademarkMonitorRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTrademarkMonitorRulesResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTrademarkMonitorRulesResponse() = default;
};
class QueryTrademarkOnSaleRequest : public Darabonba::Model {
public:
  shared_ptr<string> classification{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> registerCode{};
  shared_ptr<string> registerNumber{};
  shared_ptr<string> tmType{};

  QueryTrademarkOnSaleRequest() {}

  explicit QueryTrademarkOnSaleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (registerCode) {
      res["RegisterCode"] = boost::any(*registerCode);
    }
    if (registerNumber) {
      res["RegisterNumber"] = boost::any(*registerNumber);
    }
    if (tmType) {
      res["TmType"] = boost::any(*tmType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegisterCode") != m.end() && !m["RegisterCode"].empty()) {
      registerCode = make_shared<string>(boost::any_cast<string>(m["RegisterCode"]));
    }
    if (m.find("RegisterNumber") != m.end() && !m["RegisterNumber"].empty()) {
      registerNumber = make_shared<string>(boost::any_cast<string>(m["RegisterNumber"]));
    }
    if (m.find("TmType") != m.end() && !m["TmType"].empty()) {
      tmType = make_shared<string>(boost::any_cast<string>(m["TmType"]));
    }
  }


  virtual ~QueryTrademarkOnSaleRequest() = default;
};
class QueryTrademarkOnSaleResponseBodyTrademarks : public Darabonba::Model {
public:
  shared_ptr<string> auditResult{};
  shared_ptr<string> classification{};
  shared_ptr<string> icon{};
  shared_ptr<string> orderPrice{};
  shared_ptr<string> registrationNumber{};
  shared_ptr<long> status{};
  shared_ptr<string> tmType{};
  shared_ptr<string> trademarkName{};

  QueryTrademarkOnSaleResponseBodyTrademarks() {}

  explicit QueryTrademarkOnSaleResponseBodyTrademarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditResult) {
      res["AuditResult"] = boost::any(*auditResult);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (orderPrice) {
      res["OrderPrice"] = boost::any(*orderPrice);
    }
    if (registrationNumber) {
      res["RegistrationNumber"] = boost::any(*registrationNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tmType) {
      res["TmType"] = boost::any(*tmType);
    }
    if (trademarkName) {
      res["TrademarkName"] = boost::any(*trademarkName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditResult") != m.end() && !m["AuditResult"].empty()) {
      auditResult = make_shared<string>(boost::any_cast<string>(m["AuditResult"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("OrderPrice") != m.end() && !m["OrderPrice"].empty()) {
      orderPrice = make_shared<string>(boost::any_cast<string>(m["OrderPrice"]));
    }
    if (m.find("RegistrationNumber") != m.end() && !m["RegistrationNumber"].empty()) {
      registrationNumber = make_shared<string>(boost::any_cast<string>(m["RegistrationNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TmType") != m.end() && !m["TmType"].empty()) {
      tmType = make_shared<string>(boost::any_cast<string>(m["TmType"]));
    }
    if (m.find("TrademarkName") != m.end() && !m["TrademarkName"].empty()) {
      trademarkName = make_shared<string>(boost::any_cast<string>(m["TrademarkName"]));
    }
  }


  virtual ~QueryTrademarkOnSaleResponseBodyTrademarks() = default;
};
class QueryTrademarkOnSaleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalPageNumber{};
  shared_ptr<vector<QueryTrademarkOnSaleResponseBodyTrademarks>> trademarks{};

  QueryTrademarkOnSaleResponseBody() {}

  explicit QueryTrademarkOnSaleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPageNumber) {
      res["TotalPageNumber"] = boost::any(*totalPageNumber);
    }
    if (trademarks) {
      vector<boost::any> temp1;
      for(auto item1:*trademarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Trademarks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPageNumber") != m.end() && !m["TotalPageNumber"].empty()) {
      totalPageNumber = make_shared<long>(boost::any_cast<long>(m["TotalPageNumber"]));
    }
    if (m.find("Trademarks") != m.end() && !m["Trademarks"].empty()) {
      if (typeid(vector<boost::any>) == m["Trademarks"].type()) {
        vector<QueryTrademarkOnSaleResponseBodyTrademarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Trademarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTrademarkOnSaleResponseBodyTrademarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trademarks = make_shared<vector<QueryTrademarkOnSaleResponseBodyTrademarks>>(expect1);
      }
    }
  }


  virtual ~QueryTrademarkOnSaleResponseBody() = default;
};
class QueryTrademarkOnSaleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTrademarkOnSaleResponseBody> body{};

  QueryTrademarkOnSaleResponse() {}

  explicit QueryTrademarkOnSaleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTrademarkOnSaleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTrademarkOnSaleResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTrademarkOnSaleResponse() = default;
};
class QueryTrademarkPriceRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> orderData{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<long> type{};
  shared_ptr<long> userId{};

  QueryTrademarkPriceRequest() {}

  explicit QueryTrademarkPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderData) {
      res["OrderData"] = boost::any(*orderData);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderData") != m.end() && !m["OrderData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["OrderData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      orderData = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~QueryTrademarkPriceRequest() = default;
};
class QueryTrademarkPriceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> orderDataShrink{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<long> type{};
  shared_ptr<long> userId{};

  QueryTrademarkPriceShrinkRequest() {}

  explicit QueryTrademarkPriceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderDataShrink) {
      res["OrderData"] = boost::any(*orderDataShrink);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderData") != m.end() && !m["OrderData"].empty()) {
      orderDataShrink = make_shared<string>(boost::any_cast<string>(m["OrderData"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~QueryTrademarkPriceShrinkRequest() = default;
};
class QueryTrademarkPriceResponseBodyPricesPrices : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> currency{};
  shared_ptr<double> discountPrice{};
  shared_ptr<double> originalPrice{};
  shared_ptr<double> tradePrice{};

  QueryTrademarkPriceResponseBodyPricesPrices() {}

  explicit QueryTrademarkPriceResponseBodyPricesPrices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~QueryTrademarkPriceResponseBodyPricesPrices() = default;
};
class QueryTrademarkPriceResponseBodyPrices : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTrademarkPriceResponseBodyPricesPrices>> prices{};

  QueryTrademarkPriceResponseBodyPrices() {}

  explicit QueryTrademarkPriceResponseBodyPrices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prices) {
      vector<boost::any> temp1;
      for(auto item1:*prices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Prices"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Prices") != m.end() && !m["Prices"].empty()) {
      if (typeid(vector<boost::any>) == m["Prices"].type()) {
        vector<QueryTrademarkPriceResponseBodyPricesPrices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Prices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTrademarkPriceResponseBodyPricesPrices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prices = make_shared<vector<QueryTrademarkPriceResponseBodyPricesPrices>>(expect1);
      }
    }
  }


  virtual ~QueryTrademarkPriceResponseBodyPrices() = default;
};
class QueryTrademarkPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<double> discountPrice{};
  shared_ptr<double> originalPrice{};
  shared_ptr<QueryTrademarkPriceResponseBodyPrices> prices{};
  shared_ptr<string> requestId{};
  shared_ptr<double> tradePrice{};

  QueryTrademarkPriceResponseBody() {}

  explicit QueryTrademarkPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (prices) {
      res["Prices"] = prices ? boost::any(prices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("Prices") != m.end() && !m["Prices"].empty()) {
      if (typeid(map<string, boost::any>) == m["Prices"].type()) {
        QueryTrademarkPriceResponseBodyPrices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Prices"]));
        prices = make_shared<QueryTrademarkPriceResponseBodyPrices>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~QueryTrademarkPriceResponseBody() = default;
};
class QueryTrademarkPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTrademarkPriceResponseBody> body{};

  QueryTrademarkPriceResponse() {}

  explicit QueryTrademarkPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTrademarkPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTrademarkPriceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTrademarkPriceResponse() = default;
};
class QueryTrademarkUploadAuditResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> classification{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> registerCode{};
  shared_ptr<string> registerNumber{};
  shared_ptr<string> tmType{};

  QueryTrademarkUploadAuditResultRequest() {}

  explicit QueryTrademarkUploadAuditResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (registerCode) {
      res["RegisterCode"] = boost::any(*registerCode);
    }
    if (registerNumber) {
      res["RegisterNumber"] = boost::any(*registerNumber);
    }
    if (tmType) {
      res["TmType"] = boost::any(*tmType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegisterCode") != m.end() && !m["RegisterCode"].empty()) {
      registerCode = make_shared<string>(boost::any_cast<string>(m["RegisterCode"]));
    }
    if (m.find("RegisterNumber") != m.end() && !m["RegisterNumber"].empty()) {
      registerNumber = make_shared<string>(boost::any_cast<string>(m["RegisterNumber"]));
    }
    if (m.find("TmType") != m.end() && !m["TmType"].empty()) {
      tmType = make_shared<string>(boost::any_cast<string>(m["TmType"]));
    }
  }


  virtual ~QueryTrademarkUploadAuditResultRequest() = default;
};
class QueryTrademarkUploadAuditResultResponseBodyTrademarks : public Darabonba::Model {
public:
  shared_ptr<string> auditResult{};
  shared_ptr<string> classification{};
  shared_ptr<string> icon{};
  shared_ptr<string> orderPrice{};
  shared_ptr<string> registrationNumber{};
  shared_ptr<long> status{};
  shared_ptr<string> tmType{};
  shared_ptr<string> trademarkName{};

  QueryTrademarkUploadAuditResultResponseBodyTrademarks() {}

  explicit QueryTrademarkUploadAuditResultResponseBodyTrademarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditResult) {
      res["AuditResult"] = boost::any(*auditResult);
    }
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (orderPrice) {
      res["OrderPrice"] = boost::any(*orderPrice);
    }
    if (registrationNumber) {
      res["RegistrationNumber"] = boost::any(*registrationNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tmType) {
      res["TmType"] = boost::any(*tmType);
    }
    if (trademarkName) {
      res["TrademarkName"] = boost::any(*trademarkName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditResult") != m.end() && !m["AuditResult"].empty()) {
      auditResult = make_shared<string>(boost::any_cast<string>(m["AuditResult"]));
    }
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("OrderPrice") != m.end() && !m["OrderPrice"].empty()) {
      orderPrice = make_shared<string>(boost::any_cast<string>(m["OrderPrice"]));
    }
    if (m.find("RegistrationNumber") != m.end() && !m["RegistrationNumber"].empty()) {
      registrationNumber = make_shared<string>(boost::any_cast<string>(m["RegistrationNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TmType") != m.end() && !m["TmType"].empty()) {
      tmType = make_shared<string>(boost::any_cast<string>(m["TmType"]));
    }
    if (m.find("TrademarkName") != m.end() && !m["TrademarkName"].empty()) {
      trademarkName = make_shared<string>(boost::any_cast<string>(m["TrademarkName"]));
    }
  }


  virtual ~QueryTrademarkUploadAuditResultResponseBodyTrademarks() = default;
};
class QueryTrademarkUploadAuditResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalPageNumber{};
  shared_ptr<vector<QueryTrademarkUploadAuditResultResponseBodyTrademarks>> trademarks{};

  QueryTrademarkUploadAuditResultResponseBody() {}

  explicit QueryTrademarkUploadAuditResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPageNumber) {
      res["TotalPageNumber"] = boost::any(*totalPageNumber);
    }
    if (trademarks) {
      vector<boost::any> temp1;
      for(auto item1:*trademarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Trademarks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPageNumber") != m.end() && !m["TotalPageNumber"].empty()) {
      totalPageNumber = make_shared<long>(boost::any_cast<long>(m["TotalPageNumber"]));
    }
    if (m.find("Trademarks") != m.end() && !m["Trademarks"].empty()) {
      if (typeid(vector<boost::any>) == m["Trademarks"].type()) {
        vector<QueryTrademarkUploadAuditResultResponseBodyTrademarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Trademarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTrademarkUploadAuditResultResponseBodyTrademarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trademarks = make_shared<vector<QueryTrademarkUploadAuditResultResponseBodyTrademarks>>(expect1);
      }
    }
  }


  virtual ~QueryTrademarkUploadAuditResultResponseBody() = default;
};
class QueryTrademarkUploadAuditResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTrademarkUploadAuditResultResponseBody> body{};

  QueryTrademarkUploadAuditResultResponse() {}

  explicit QueryTrademarkUploadAuditResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTrademarkUploadAuditResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTrademarkUploadAuditResultResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTrademarkUploadAuditResultResponse() = default;
};
class RecordBankBalanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> actionDate{};
  shared_ptr<string> balance{};
  shared_ptr<string> principalName{};

  RecordBankBalanceRequest() {}

  explicit RecordBankBalanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionDate) {
      res["ActionDate"] = boost::any(*actionDate);
    }
    if (balance) {
      res["Balance"] = boost::any(*balance);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionDate") != m.end() && !m["ActionDate"].empty()) {
      actionDate = make_shared<long>(boost::any_cast<long>(m["ActionDate"]));
    }
    if (m.find("Balance") != m.end() && !m["Balance"].empty()) {
      balance = make_shared<string>(boost::any_cast<string>(m["Balance"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<string>(boost::any_cast<string>(m["PrincipalName"]));
    }
  }


  virtual ~RecordBankBalanceRequest() = default;
};
class RecordBankBalanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  RecordBankBalanceResponseBody() {}

  explicit RecordBankBalanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~RecordBankBalanceResponseBody() = default;
};
class RecordBankBalanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecordBankBalanceResponseBody> body{};

  RecordBankBalanceResponse() {}

  explicit RecordBankBalanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecordBankBalanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecordBankBalanceResponseBody>(model1);
      }
    }
  }


  virtual ~RecordBankBalanceResponse() = default;
};
class RefundProduceRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> refundType{};

  RefundProduceRequest() {}

  explicit RefundProduceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (refundType) {
      res["RefundType"] = boost::any(*refundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("RefundType") != m.end() && !m["RefundType"].empty()) {
      refundType = make_shared<string>(boost::any_cast<string>(m["RefundType"]));
    }
  }


  virtual ~RefundProduceRequest() = default;
};
class RefundProduceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RefundProduceResponseBody() {}

  explicit RefundProduceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RefundProduceResponseBody() = default;
};
class RefundProduceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefundProduceResponseBody> body{};

  RefundProduceResponse() {}

  explicit RefundProduceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefundProduceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefundProduceResponseBody>(model1);
      }
    }
  }


  virtual ~RefundProduceResponse() = default;
};
class RefuseAdditionalMaterialRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> note{};

  RefuseAdditionalMaterialRequest() {}

  explicit RefuseAdditionalMaterialRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
  }


  virtual ~RefuseAdditionalMaterialRequest() = default;
};
class RefuseAdditionalMaterialResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RefuseAdditionalMaterialResponseBody() {}

  explicit RefuseAdditionalMaterialResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RefuseAdditionalMaterialResponseBody() = default;
};
class RefuseAdditionalMaterialResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefuseAdditionalMaterialResponseBody> body{};

  RefuseAdditionalMaterialResponse() {}

  explicit RefuseAdditionalMaterialResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefuseAdditionalMaterialResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefuseAdditionalMaterialResponseBody>(model1);
      }
    }
  }


  virtual ~RefuseAdditionalMaterialResponse() = default;
};
class RefuseApplicantRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> note{};

  RefuseApplicantRequest() {}

  explicit RefuseApplicantRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
  }


  virtual ~RefuseApplicantRequest() = default;
};
class RefuseApplicantResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RefuseApplicantResponseBody() {}

  explicit RefuseApplicantResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RefuseApplicantResponseBody() = default;
};
class RefuseApplicantResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefuseApplicantResponseBody> body{};

  RefuseApplicantResponse() {}

  explicit RefuseApplicantResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefuseApplicantResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefuseApplicantResponseBody>(model1);
      }
    }
  }


  virtual ~RefuseApplicantResponse() = default;
};
class RejectApplicantRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> note{};

  RejectApplicantRequest() {}

  explicit RejectApplicantRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
  }


  virtual ~RejectApplicantRequest() = default;
};
class RejectApplicantResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RejectApplicantResponseBody() {}

  explicit RejectApplicantResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RejectApplicantResponseBody() = default;
};
class RejectApplicantResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RejectApplicantResponseBody> body{};

  RejectApplicantResponse() {}

  explicit RejectApplicantResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RejectApplicantResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RejectApplicantResponseBody>(model1);
      }
    }
  }


  virtual ~RejectApplicantResponse() = default;
};
class SaveClassificationConditionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> condition{};
  shared_ptr<long> type{};

  SaveClassificationConditionsRequest() {}

  explicit SaveClassificationConditionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~SaveClassificationConditionsRequest() = default;
};
class SaveClassificationConditionsResponseBodyInvalidList : public Darabonba::Model {
public:
  shared_ptr<string> classificationCode{};
  shared_ptr<string> classificationName{};
  shared_ptr<string> officialCode{};
  shared_ptr<string> parentCode{};

  SaveClassificationConditionsResponseBodyInvalidList() {}

  explicit SaveClassificationConditionsResponseBodyInvalidList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (classificationName) {
      res["ClassificationName"] = boost::any(*classificationName);
    }
    if (officialCode) {
      res["OfficialCode"] = boost::any(*officialCode);
    }
    if (parentCode) {
      res["ParentCode"] = boost::any(*parentCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("ClassificationName") != m.end() && !m["ClassificationName"].empty()) {
      classificationName = make_shared<string>(boost::any_cast<string>(m["ClassificationName"]));
    }
    if (m.find("OfficialCode") != m.end() && !m["OfficialCode"].empty()) {
      officialCode = make_shared<string>(boost::any_cast<string>(m["OfficialCode"]));
    }
    if (m.find("ParentCode") != m.end() && !m["ParentCode"].empty()) {
      parentCode = make_shared<string>(boost::any_cast<string>(m["ParentCode"]));
    }
  }


  virtual ~SaveClassificationConditionsResponseBodyInvalidList() = default;
};
class SaveClassificationConditionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<vector<SaveClassificationConditionsResponseBodyInvalidList>> invalidList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> tagName{};

  SaveClassificationConditionsResponseBody() {}

  explicit SaveClassificationConditionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (invalidList) {
      vector<boost::any> temp1;
      for(auto item1:*invalidList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InvalidList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("InvalidList") != m.end() && !m["InvalidList"].empty()) {
      if (typeid(vector<boost::any>) == m["InvalidList"].type()) {
        vector<SaveClassificationConditionsResponseBodyInvalidList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InvalidList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SaveClassificationConditionsResponseBodyInvalidList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invalidList = make_shared<vector<SaveClassificationConditionsResponseBodyInvalidList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~SaveClassificationConditionsResponseBody() = default;
};
class SaveClassificationConditionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveClassificationConditionsResponseBody> body{};

  SaveClassificationConditionsResponse() {}

  explicit SaveClassificationConditionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveClassificationConditionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveClassificationConditionsResponseBody>(model1);
      }
    }
  }


  virtual ~SaveClassificationConditionsResponse() = default;
};
class SaveExtensionAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> attributeKey{};
  shared_ptr<string> attributeValue{};
  shared_ptr<string> bizId{};

  SaveExtensionAttributeRequest() {}

  explicit SaveExtensionAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeKey) {
      res["AttributeKey"] = boost::any(*attributeKey);
    }
    if (attributeValue) {
      res["AttributeValue"] = boost::any(*attributeValue);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeKey") != m.end() && !m["AttributeKey"].empty()) {
      attributeKey = make_shared<string>(boost::any_cast<string>(m["AttributeKey"]));
    }
    if (m.find("AttributeValue") != m.end() && !m["AttributeValue"].empty()) {
      attributeValue = make_shared<string>(boost::any_cast<string>(m["AttributeValue"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~SaveExtensionAttributeRequest() = default;
};
class SaveExtensionAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveExtensionAttributeResponseBody() {}

  explicit SaveExtensionAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveExtensionAttributeResponseBody() = default;
};
class SaveExtensionAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveExtensionAttributeResponseBody> body{};

  SaveExtensionAttributeResponse() {}

  explicit SaveExtensionAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveExtensionAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveExtensionAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~SaveExtensionAttributeResponse() = default;
};
class SaveTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> request{};

  SaveTaskRequest() {}

  explicit SaveTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (request) {
      res["Request"] = boost::any(*request);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      request = make_shared<string>(boost::any_cast<string>(m["Request"]));
    }
  }


  virtual ~SaveTaskRequest() = default;
};
class SaveTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SaveTaskResponseBody() {}

  explicit SaveTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SaveTaskResponseBody() = default;
};
class SaveTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveTaskResponseBody> body{};

  SaveTaskResponse() {}

  explicit SaveTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveTaskResponseBody>(model1);
      }
    }
  }


  virtual ~SaveTaskResponse() = default;
};
class SaveTaskForOfficialFileCustomRequest : public Darabonba::Model {
public:
  shared_ptr<long> endAcceptTime{};
  shared_ptr<long> startAcceptTime{};

  SaveTaskForOfficialFileCustomRequest() {}

  explicit SaveTaskForOfficialFileCustomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endAcceptTime) {
      res["EndAcceptTime"] = boost::any(*endAcceptTime);
    }
    if (startAcceptTime) {
      res["StartAcceptTime"] = boost::any(*startAcceptTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndAcceptTime") != m.end() && !m["EndAcceptTime"].empty()) {
      endAcceptTime = make_shared<long>(boost::any_cast<long>(m["EndAcceptTime"]));
    }
    if (m.find("StartAcceptTime") != m.end() && !m["StartAcceptTime"].empty()) {
      startAcceptTime = make_shared<long>(boost::any_cast<long>(m["StartAcceptTime"]));
    }
  }


  virtual ~SaveTaskForOfficialFileCustomRequest() = default;
};
class SaveTaskForOfficialFileCustomResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveTaskForOfficialFileCustomResponseBody() {}

  explicit SaveTaskForOfficialFileCustomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveTaskForOfficialFileCustomResponseBody() = default;
};
class SaveTaskForOfficialFileCustomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveTaskForOfficialFileCustomResponseBody> body{};

  SaveTaskForOfficialFileCustomResponse() {}

  explicit SaveTaskForOfficialFileCustomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveTaskForOfficialFileCustomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveTaskForOfficialFileCustomResponseBody>(model1);
      }
    }
  }


  virtual ~SaveTaskForOfficialFileCustomResponse() = default;
};
class SaveTradeMarkReviewMaterialDetailRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> additionalOssKeyList{};
  shared_ptr<string> address{};
  shared_ptr<string> applicationOssKey{};
  shared_ptr<string> bizId{};
  shared_ptr<string> businessLicenceOssKey{};
  shared_ptr<string> cardNumber{};
  shared_ptr<bool> changeName{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactNumber{};
  shared_ptr<string> country{};
  shared_ptr<string> engAddress{};
  shared_ptr<string> engName{};
  shared_ptr<string> idCardOssKey{};
  shared_ptr<string> legalNoticeOssKey{};
  shared_ptr<string> loaOssKey{};
  shared_ptr<string> name{};
  shared_ptr<string> passportOssKey{};
  shared_ptr<string> province{};
  shared_ptr<long> region{};
  shared_ptr<string> reviewMaterialAdditionalJson{};
  shared_ptr<bool> separate{};
  shared_ptr<bool> submitOnline{};
  shared_ptr<long> submitType{};
  shared_ptr<bool> supplementFlag{};
  shared_ptr<long> type{};

  SaveTradeMarkReviewMaterialDetailRequest() {}

  explicit SaveTradeMarkReviewMaterialDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalOssKeyList) {
      res["AdditionalOssKeyList"] = boost::any(*additionalOssKeyList);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (applicationOssKey) {
      res["ApplicationOssKey"] = boost::any(*applicationOssKey);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (businessLicenceOssKey) {
      res["BusinessLicenceOssKey"] = boost::any(*businessLicenceOssKey);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (changeName) {
      res["ChangeName"] = boost::any(*changeName);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactNumber) {
      res["ContactNumber"] = boost::any(*contactNumber);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (engAddress) {
      res["EngAddress"] = boost::any(*engAddress);
    }
    if (engName) {
      res["EngName"] = boost::any(*engName);
    }
    if (idCardOssKey) {
      res["IdCardOssKey"] = boost::any(*idCardOssKey);
    }
    if (legalNoticeOssKey) {
      res["LegalNoticeOssKey"] = boost::any(*legalNoticeOssKey);
    }
    if (loaOssKey) {
      res["LoaOssKey"] = boost::any(*loaOssKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportOssKey) {
      res["PassportOssKey"] = boost::any(*passportOssKey);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (reviewMaterialAdditionalJson) {
      res["ReviewMaterialAdditionalJson"] = boost::any(*reviewMaterialAdditionalJson);
    }
    if (separate) {
      res["Separate"] = boost::any(*separate);
    }
    if (submitOnline) {
      res["SubmitOnline"] = boost::any(*submitOnline);
    }
    if (submitType) {
      res["SubmitType"] = boost::any(*submitType);
    }
    if (supplementFlag) {
      res["SupplementFlag"] = boost::any(*supplementFlag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalOssKeyList") != m.end() && !m["AdditionalOssKeyList"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["AdditionalOssKeyList"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      additionalOssKeyList = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("ApplicationOssKey") != m.end() && !m["ApplicationOssKey"].empty()) {
      applicationOssKey = make_shared<string>(boost::any_cast<string>(m["ApplicationOssKey"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BusinessLicenceOssKey") != m.end() && !m["BusinessLicenceOssKey"].empty()) {
      businessLicenceOssKey = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceOssKey"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("ChangeName") != m.end() && !m["ChangeName"].empty()) {
      changeName = make_shared<bool>(boost::any_cast<bool>(m["ChangeName"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactNumber") != m.end() && !m["ContactNumber"].empty()) {
      contactNumber = make_shared<string>(boost::any_cast<string>(m["ContactNumber"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("EngAddress") != m.end() && !m["EngAddress"].empty()) {
      engAddress = make_shared<string>(boost::any_cast<string>(m["EngAddress"]));
    }
    if (m.find("EngName") != m.end() && !m["EngName"].empty()) {
      engName = make_shared<string>(boost::any_cast<string>(m["EngName"]));
    }
    if (m.find("IdCardOssKey") != m.end() && !m["IdCardOssKey"].empty()) {
      idCardOssKey = make_shared<string>(boost::any_cast<string>(m["IdCardOssKey"]));
    }
    if (m.find("LegalNoticeOssKey") != m.end() && !m["LegalNoticeOssKey"].empty()) {
      legalNoticeOssKey = make_shared<string>(boost::any_cast<string>(m["LegalNoticeOssKey"]));
    }
    if (m.find("LoaOssKey") != m.end() && !m["LoaOssKey"].empty()) {
      loaOssKey = make_shared<string>(boost::any_cast<string>(m["LoaOssKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportOssKey") != m.end() && !m["PassportOssKey"].empty()) {
      passportOssKey = make_shared<string>(boost::any_cast<string>(m["PassportOssKey"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("ReviewMaterialAdditionalJson") != m.end() && !m["ReviewMaterialAdditionalJson"].empty()) {
      reviewMaterialAdditionalJson = make_shared<string>(boost::any_cast<string>(m["ReviewMaterialAdditionalJson"]));
    }
    if (m.find("Separate") != m.end() && !m["Separate"].empty()) {
      separate = make_shared<bool>(boost::any_cast<bool>(m["Separate"]));
    }
    if (m.find("SubmitOnline") != m.end() && !m["SubmitOnline"].empty()) {
      submitOnline = make_shared<bool>(boost::any_cast<bool>(m["SubmitOnline"]));
    }
    if (m.find("SubmitType") != m.end() && !m["SubmitType"].empty()) {
      submitType = make_shared<long>(boost::any_cast<long>(m["SubmitType"]));
    }
    if (m.find("SupplementFlag") != m.end() && !m["SupplementFlag"].empty()) {
      supplementFlag = make_shared<bool>(boost::any_cast<bool>(m["SupplementFlag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~SaveTradeMarkReviewMaterialDetailRequest() = default;
};
class SaveTradeMarkReviewMaterialDetailShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> additionalOssKeyListShrink{};
  shared_ptr<string> address{};
  shared_ptr<string> applicationOssKey{};
  shared_ptr<string> bizId{};
  shared_ptr<string> businessLicenceOssKey{};
  shared_ptr<string> cardNumber{};
  shared_ptr<bool> changeName{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactNumber{};
  shared_ptr<string> country{};
  shared_ptr<string> engAddress{};
  shared_ptr<string> engName{};
  shared_ptr<string> idCardOssKey{};
  shared_ptr<string> legalNoticeOssKey{};
  shared_ptr<string> loaOssKey{};
  shared_ptr<string> name{};
  shared_ptr<string> passportOssKey{};
  shared_ptr<string> province{};
  shared_ptr<long> region{};
  shared_ptr<string> reviewMaterialAdditionalJson{};
  shared_ptr<bool> separate{};
  shared_ptr<bool> submitOnline{};
  shared_ptr<long> submitType{};
  shared_ptr<bool> supplementFlag{};
  shared_ptr<long> type{};

  SaveTradeMarkReviewMaterialDetailShrinkRequest() {}

  explicit SaveTradeMarkReviewMaterialDetailShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalOssKeyListShrink) {
      res["AdditionalOssKeyList"] = boost::any(*additionalOssKeyListShrink);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (applicationOssKey) {
      res["ApplicationOssKey"] = boost::any(*applicationOssKey);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (businessLicenceOssKey) {
      res["BusinessLicenceOssKey"] = boost::any(*businessLicenceOssKey);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (changeName) {
      res["ChangeName"] = boost::any(*changeName);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactNumber) {
      res["ContactNumber"] = boost::any(*contactNumber);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (engAddress) {
      res["EngAddress"] = boost::any(*engAddress);
    }
    if (engName) {
      res["EngName"] = boost::any(*engName);
    }
    if (idCardOssKey) {
      res["IdCardOssKey"] = boost::any(*idCardOssKey);
    }
    if (legalNoticeOssKey) {
      res["LegalNoticeOssKey"] = boost::any(*legalNoticeOssKey);
    }
    if (loaOssKey) {
      res["LoaOssKey"] = boost::any(*loaOssKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportOssKey) {
      res["PassportOssKey"] = boost::any(*passportOssKey);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (reviewMaterialAdditionalJson) {
      res["ReviewMaterialAdditionalJson"] = boost::any(*reviewMaterialAdditionalJson);
    }
    if (separate) {
      res["Separate"] = boost::any(*separate);
    }
    if (submitOnline) {
      res["SubmitOnline"] = boost::any(*submitOnline);
    }
    if (submitType) {
      res["SubmitType"] = boost::any(*submitType);
    }
    if (supplementFlag) {
      res["SupplementFlag"] = boost::any(*supplementFlag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalOssKeyList") != m.end() && !m["AdditionalOssKeyList"].empty()) {
      additionalOssKeyListShrink = make_shared<string>(boost::any_cast<string>(m["AdditionalOssKeyList"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("ApplicationOssKey") != m.end() && !m["ApplicationOssKey"].empty()) {
      applicationOssKey = make_shared<string>(boost::any_cast<string>(m["ApplicationOssKey"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BusinessLicenceOssKey") != m.end() && !m["BusinessLicenceOssKey"].empty()) {
      businessLicenceOssKey = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceOssKey"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("ChangeName") != m.end() && !m["ChangeName"].empty()) {
      changeName = make_shared<bool>(boost::any_cast<bool>(m["ChangeName"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactNumber") != m.end() && !m["ContactNumber"].empty()) {
      contactNumber = make_shared<string>(boost::any_cast<string>(m["ContactNumber"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("EngAddress") != m.end() && !m["EngAddress"].empty()) {
      engAddress = make_shared<string>(boost::any_cast<string>(m["EngAddress"]));
    }
    if (m.find("EngName") != m.end() && !m["EngName"].empty()) {
      engName = make_shared<string>(boost::any_cast<string>(m["EngName"]));
    }
    if (m.find("IdCardOssKey") != m.end() && !m["IdCardOssKey"].empty()) {
      idCardOssKey = make_shared<string>(boost::any_cast<string>(m["IdCardOssKey"]));
    }
    if (m.find("LegalNoticeOssKey") != m.end() && !m["LegalNoticeOssKey"].empty()) {
      legalNoticeOssKey = make_shared<string>(boost::any_cast<string>(m["LegalNoticeOssKey"]));
    }
    if (m.find("LoaOssKey") != m.end() && !m["LoaOssKey"].empty()) {
      loaOssKey = make_shared<string>(boost::any_cast<string>(m["LoaOssKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportOssKey") != m.end() && !m["PassportOssKey"].empty()) {
      passportOssKey = make_shared<string>(boost::any_cast<string>(m["PassportOssKey"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["Region"]));
    }
    if (m.find("ReviewMaterialAdditionalJson") != m.end() && !m["ReviewMaterialAdditionalJson"].empty()) {
      reviewMaterialAdditionalJson = make_shared<string>(boost::any_cast<string>(m["ReviewMaterialAdditionalJson"]));
    }
    if (m.find("Separate") != m.end() && !m["Separate"].empty()) {
      separate = make_shared<bool>(boost::any_cast<bool>(m["Separate"]));
    }
    if (m.find("SubmitOnline") != m.end() && !m["SubmitOnline"].empty()) {
      submitOnline = make_shared<bool>(boost::any_cast<bool>(m["SubmitOnline"]));
    }
    if (m.find("SubmitType") != m.end() && !m["SubmitType"].empty()) {
      submitType = make_shared<long>(boost::any_cast<long>(m["SubmitType"]));
    }
    if (m.find("SupplementFlag") != m.end() && !m["SupplementFlag"].empty()) {
      supplementFlag = make_shared<bool>(boost::any_cast<bool>(m["SupplementFlag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~SaveTradeMarkReviewMaterialDetailShrinkRequest() = default;
};
class SaveTradeMarkReviewMaterialDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveTradeMarkReviewMaterialDetailResponseBody() {}

  explicit SaveTradeMarkReviewMaterialDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveTradeMarkReviewMaterialDetailResponseBody() = default;
};
class SaveTradeMarkReviewMaterialDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveTradeMarkReviewMaterialDetailResponseBody> body{};

  SaveTradeMarkReviewMaterialDetailResponse() {}

  explicit SaveTradeMarkReviewMaterialDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveTradeMarkReviewMaterialDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveTradeMarkReviewMaterialDetailResponseBody>(model1);
      }
    }
  }


  virtual ~SaveTradeMarkReviewMaterialDetailResponse() = default;
};
class SbjOperateRequest : public Darabonba::Model {
public:
  shared_ptr<string> amount{};
  shared_ptr<string> applyNo{};
  shared_ptr<bool> auditStatus{};
  shared_ptr<string> bizId{};
  shared_ptr<string> fileDate{};
  shared_ptr<string> fileOssKey{};
  shared_ptr<string> message{};
  shared_ptr<string> operateType{};
  shared_ptr<string> orderNo{};
  shared_ptr<string> receiptOssKey{};
  shared_ptr<bool> submittedSuccess{};

  SbjOperateRequest() {}

  explicit SbjOperateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (applyNo) {
      res["ApplyNo"] = boost::any(*applyNo);
    }
    if (auditStatus) {
      res["AuditStatus"] = boost::any(*auditStatus);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (fileDate) {
      res["FileDate"] = boost::any(*fileDate);
    }
    if (fileOssKey) {
      res["FileOssKey"] = boost::any(*fileOssKey);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (orderNo) {
      res["OrderNo"] = boost::any(*orderNo);
    }
    if (receiptOssKey) {
      res["ReceiptOssKey"] = boost::any(*receiptOssKey);
    }
    if (submittedSuccess) {
      res["SubmittedSuccess"] = boost::any(*submittedSuccess);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<string>(boost::any_cast<string>(m["Amount"]));
    }
    if (m.find("ApplyNo") != m.end() && !m["ApplyNo"].empty()) {
      applyNo = make_shared<string>(boost::any_cast<string>(m["ApplyNo"]));
    }
    if (m.find("AuditStatus") != m.end() && !m["AuditStatus"].empty()) {
      auditStatus = make_shared<bool>(boost::any_cast<bool>(m["AuditStatus"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("FileDate") != m.end() && !m["FileDate"].empty()) {
      fileDate = make_shared<string>(boost::any_cast<string>(m["FileDate"]));
    }
    if (m.find("FileOssKey") != m.end() && !m["FileOssKey"].empty()) {
      fileOssKey = make_shared<string>(boost::any_cast<string>(m["FileOssKey"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("OrderNo") != m.end() && !m["OrderNo"].empty()) {
      orderNo = make_shared<string>(boost::any_cast<string>(m["OrderNo"]));
    }
    if (m.find("ReceiptOssKey") != m.end() && !m["ReceiptOssKey"].empty()) {
      receiptOssKey = make_shared<string>(boost::any_cast<string>(m["ReceiptOssKey"]));
    }
    if (m.find("SubmittedSuccess") != m.end() && !m["SubmittedSuccess"].empty()) {
      submittedSuccess = make_shared<bool>(boost::any_cast<bool>(m["SubmittedSuccess"]));
    }
  }


  virtual ~SbjOperateRequest() = default;
};
class SbjOperateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SbjOperateResponseBody() {}

  explicit SbjOperateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SbjOperateResponseBody() = default;
};
class SbjOperateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SbjOperateResponseBody> body{};

  SbjOperateResponse() {}

  explicit SbjOperateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SbjOperateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SbjOperateResponseBody>(model1);
      }
    }
  }


  virtual ~SbjOperateResponse() = default;
};
class SbjOperateNewRequest : public Darabonba::Model {
public:
  shared_ptr<bool> addSubmitCount{};
  shared_ptr<bool> allowResubmit{};
  shared_ptr<string> amount{};
  shared_ptr<string> applyNo{};
  shared_ptr<bool> auditStatus{};
  shared_ptr<string> bizId{};
  shared_ptr<bool> changeStatus{};
  shared_ptr<string> errorMsgScreenshot{};
  shared_ptr<string> fileDate{};
  shared_ptr<string> fileOssKey{};
  shared_ptr<string> message{};
  shared_ptr<string> operateType{};
  shared_ptr<string> orderNo{};
  shared_ptr<string> receiptOssKey{};
  shared_ptr<bool> submittedSuccess{};
  shared_ptr<string> successType{};

  SbjOperateNewRequest() {}

  explicit SbjOperateNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addSubmitCount) {
      res["AddSubmitCount"] = boost::any(*addSubmitCount);
    }
    if (allowResubmit) {
      res["AllowResubmit"] = boost::any(*allowResubmit);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (applyNo) {
      res["ApplyNo"] = boost::any(*applyNo);
    }
    if (auditStatus) {
      res["AuditStatus"] = boost::any(*auditStatus);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (changeStatus) {
      res["ChangeStatus"] = boost::any(*changeStatus);
    }
    if (errorMsgScreenshot) {
      res["ErrorMsgScreenshot"] = boost::any(*errorMsgScreenshot);
    }
    if (fileDate) {
      res["FileDate"] = boost::any(*fileDate);
    }
    if (fileOssKey) {
      res["FileOssKey"] = boost::any(*fileOssKey);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (orderNo) {
      res["OrderNo"] = boost::any(*orderNo);
    }
    if (receiptOssKey) {
      res["ReceiptOssKey"] = boost::any(*receiptOssKey);
    }
    if (submittedSuccess) {
      res["SubmittedSuccess"] = boost::any(*submittedSuccess);
    }
    if (successType) {
      res["SuccessType"] = boost::any(*successType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddSubmitCount") != m.end() && !m["AddSubmitCount"].empty()) {
      addSubmitCount = make_shared<bool>(boost::any_cast<bool>(m["AddSubmitCount"]));
    }
    if (m.find("AllowResubmit") != m.end() && !m["AllowResubmit"].empty()) {
      allowResubmit = make_shared<bool>(boost::any_cast<bool>(m["AllowResubmit"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<string>(boost::any_cast<string>(m["Amount"]));
    }
    if (m.find("ApplyNo") != m.end() && !m["ApplyNo"].empty()) {
      applyNo = make_shared<string>(boost::any_cast<string>(m["ApplyNo"]));
    }
    if (m.find("AuditStatus") != m.end() && !m["AuditStatus"].empty()) {
      auditStatus = make_shared<bool>(boost::any_cast<bool>(m["AuditStatus"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ChangeStatus") != m.end() && !m["ChangeStatus"].empty()) {
      changeStatus = make_shared<bool>(boost::any_cast<bool>(m["ChangeStatus"]));
    }
    if (m.find("ErrorMsgScreenshot") != m.end() && !m["ErrorMsgScreenshot"].empty()) {
      errorMsgScreenshot = make_shared<string>(boost::any_cast<string>(m["ErrorMsgScreenshot"]));
    }
    if (m.find("FileDate") != m.end() && !m["FileDate"].empty()) {
      fileDate = make_shared<string>(boost::any_cast<string>(m["FileDate"]));
    }
    if (m.find("FileOssKey") != m.end() && !m["FileOssKey"].empty()) {
      fileOssKey = make_shared<string>(boost::any_cast<string>(m["FileOssKey"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("OrderNo") != m.end() && !m["OrderNo"].empty()) {
      orderNo = make_shared<string>(boost::any_cast<string>(m["OrderNo"]));
    }
    if (m.find("ReceiptOssKey") != m.end() && !m["ReceiptOssKey"].empty()) {
      receiptOssKey = make_shared<string>(boost::any_cast<string>(m["ReceiptOssKey"]));
    }
    if (m.find("SubmittedSuccess") != m.end() && !m["SubmittedSuccess"].empty()) {
      submittedSuccess = make_shared<bool>(boost::any_cast<bool>(m["SubmittedSuccess"]));
    }
    if (m.find("SuccessType") != m.end() && !m["SuccessType"].empty()) {
      successType = make_shared<string>(boost::any_cast<string>(m["SuccessType"]));
    }
  }


  virtual ~SbjOperateNewRequest() = default;
};
class SbjOperateNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SbjOperateNewResponseBody() {}

  explicit SbjOperateNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SbjOperateNewResponseBody() = default;
};
class SbjOperateNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SbjOperateNewResponseBody> body{};

  SbjOperateNewResponse() {}

  explicit SbjOperateNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SbjOperateNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SbjOperateNewResponseBody>(model1);
      }
    }
  }


  virtual ~SbjOperateNewResponse() = default;
};
class SbrainServiceExecuteRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> executeParams{};
  shared_ptr<string> productCode{};
  shared_ptr<string> referenceNo{};
  shared_ptr<string> referenceType{};
  shared_ptr<string> sceneCode{};
  shared_ptr<long> schemeId{};
  shared_ptr<string> servicePlace{};
  shared_ptr<string> source{};
  shared_ptr<string> target{};

  SbrainServiceExecuteRequest() {}

  explicit SbrainServiceExecuteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executeParams) {
      res["ExecuteParams"] = boost::any(*executeParams);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (referenceNo) {
      res["ReferenceNo"] = boost::any(*referenceNo);
    }
    if (referenceType) {
      res["ReferenceType"] = boost::any(*referenceType);
    }
    if (sceneCode) {
      res["SceneCode"] = boost::any(*sceneCode);
    }
    if (schemeId) {
      res["SchemeId"] = boost::any(*schemeId);
    }
    if (servicePlace) {
      res["ServicePlace"] = boost::any(*servicePlace);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecuteParams") != m.end() && !m["ExecuteParams"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExecuteParams"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      executeParams = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("ReferenceNo") != m.end() && !m["ReferenceNo"].empty()) {
      referenceNo = make_shared<string>(boost::any_cast<string>(m["ReferenceNo"]));
    }
    if (m.find("ReferenceType") != m.end() && !m["ReferenceType"].empty()) {
      referenceType = make_shared<string>(boost::any_cast<string>(m["ReferenceType"]));
    }
    if (m.find("SceneCode") != m.end() && !m["SceneCode"].empty()) {
      sceneCode = make_shared<string>(boost::any_cast<string>(m["SceneCode"]));
    }
    if (m.find("SchemeId") != m.end() && !m["SchemeId"].empty()) {
      schemeId = make_shared<long>(boost::any_cast<long>(m["SchemeId"]));
    }
    if (m.find("ServicePlace") != m.end() && !m["ServicePlace"].empty()) {
      servicePlace = make_shared<string>(boost::any_cast<string>(m["ServicePlace"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~SbrainServiceExecuteRequest() = default;
};
class SbrainServiceExecuteShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> executeParamsShrink{};
  shared_ptr<string> productCode{};
  shared_ptr<string> referenceNo{};
  shared_ptr<string> referenceType{};
  shared_ptr<string> sceneCode{};
  shared_ptr<long> schemeId{};
  shared_ptr<string> servicePlace{};
  shared_ptr<string> source{};
  shared_ptr<string> target{};

  SbrainServiceExecuteShrinkRequest() {}

  explicit SbrainServiceExecuteShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executeParamsShrink) {
      res["ExecuteParams"] = boost::any(*executeParamsShrink);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (referenceNo) {
      res["ReferenceNo"] = boost::any(*referenceNo);
    }
    if (referenceType) {
      res["ReferenceType"] = boost::any(*referenceType);
    }
    if (sceneCode) {
      res["SceneCode"] = boost::any(*sceneCode);
    }
    if (schemeId) {
      res["SchemeId"] = boost::any(*schemeId);
    }
    if (servicePlace) {
      res["ServicePlace"] = boost::any(*servicePlace);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecuteParams") != m.end() && !m["ExecuteParams"].empty()) {
      executeParamsShrink = make_shared<string>(boost::any_cast<string>(m["ExecuteParams"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("ReferenceNo") != m.end() && !m["ReferenceNo"].empty()) {
      referenceNo = make_shared<string>(boost::any_cast<string>(m["ReferenceNo"]));
    }
    if (m.find("ReferenceType") != m.end() && !m["ReferenceType"].empty()) {
      referenceType = make_shared<string>(boost::any_cast<string>(m["ReferenceType"]));
    }
    if (m.find("SceneCode") != m.end() && !m["SceneCode"].empty()) {
      sceneCode = make_shared<string>(boost::any_cast<string>(m["SceneCode"]));
    }
    if (m.find("SchemeId") != m.end() && !m["SchemeId"].empty()) {
      schemeId = make_shared<long>(boost::any_cast<long>(m["SchemeId"]));
    }
    if (m.find("ServicePlace") != m.end() && !m["ServicePlace"].empty()) {
      servicePlace = make_shared<string>(boost::any_cast<string>(m["ServicePlace"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~SbrainServiceExecuteShrinkRequest() = default;
};
class SbrainServiceExecuteResponseBody : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SbrainServiceExecuteResponseBody() {}

  explicit SbrainServiceExecuteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SbrainServiceExecuteResponseBody() = default;
};
class SbrainServiceExecuteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SbrainServiceExecuteResponseBody> body{};

  SbrainServiceExecuteResponse() {}

  explicit SbrainServiceExecuteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SbrainServiceExecuteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SbrainServiceExecuteResponseBody>(model1);
      }
    }
  }


  virtual ~SbrainServiceExecuteResponse() = default;
};
class SbrainServiceHasRunningTaskBatchQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> productCode{};
  shared_ptr<vector<string>> referenceNos{};
  shared_ptr<string> referenceType{};
  shared_ptr<string> source{};
  shared_ptr<string> taskType{};

  SbrainServiceHasRunningTaskBatchQueryRequest() {}

  explicit SbrainServiceHasRunningTaskBatchQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (referenceNos) {
      res["ReferenceNos"] = boost::any(*referenceNos);
    }
    if (referenceType) {
      res["ReferenceType"] = boost::any(*referenceType);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("ReferenceNos") != m.end() && !m["ReferenceNos"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReferenceNos"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReferenceNos"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      referenceNos = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ReferenceType") != m.end() && !m["ReferenceType"].empty()) {
      referenceType = make_shared<string>(boost::any_cast<string>(m["ReferenceType"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~SbrainServiceHasRunningTaskBatchQueryRequest() = default;
};
class SbrainServiceHasRunningTaskBatchQueryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> productCode{};
  shared_ptr<string> referenceNosShrink{};
  shared_ptr<string> referenceType{};
  shared_ptr<string> source{};
  shared_ptr<string> taskType{};

  SbrainServiceHasRunningTaskBatchQueryShrinkRequest() {}

  explicit SbrainServiceHasRunningTaskBatchQueryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (referenceNosShrink) {
      res["ReferenceNos"] = boost::any(*referenceNosShrink);
    }
    if (referenceType) {
      res["ReferenceType"] = boost::any(*referenceType);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("ReferenceNos") != m.end() && !m["ReferenceNos"].empty()) {
      referenceNosShrink = make_shared<string>(boost::any_cast<string>(m["ReferenceNos"]));
    }
    if (m.find("ReferenceType") != m.end() && !m["ReferenceType"].empty()) {
      referenceType = make_shared<string>(boost::any_cast<string>(m["ReferenceType"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~SbrainServiceHasRunningTaskBatchQueryShrinkRequest() = default;
};
class SbrainServiceHasRunningTaskBatchQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SbrainServiceHasRunningTaskBatchQueryResponseBody() {}

  explicit SbrainServiceHasRunningTaskBatchQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SbrainServiceHasRunningTaskBatchQueryResponseBody() = default;
};
class SbrainServiceHasRunningTaskBatchQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SbrainServiceHasRunningTaskBatchQueryResponseBody> body{};

  SbrainServiceHasRunningTaskBatchQueryResponse() {}

  explicit SbrainServiceHasRunningTaskBatchQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SbrainServiceHasRunningTaskBatchQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SbrainServiceHasRunningTaskBatchQueryResponseBody>(model1);
      }
    }
  }


  virtual ~SbrainServiceHasRunningTaskBatchQueryResponse() = default;
};
class SbrainServiceSchemeMatchRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> matchParams{};
  shared_ptr<string> productCode{};
  shared_ptr<string> referenceNo{};
  shared_ptr<string> referenceType{};
  shared_ptr<string> sceneCode{};
  shared_ptr<string> source{};

  SbrainServiceSchemeMatchRequest() {}

  explicit SbrainServiceSchemeMatchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchParams) {
      res["MatchParams"] = boost::any(*matchParams);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (referenceNo) {
      res["ReferenceNo"] = boost::any(*referenceNo);
    }
    if (referenceType) {
      res["ReferenceType"] = boost::any(*referenceType);
    }
    if (sceneCode) {
      res["SceneCode"] = boost::any(*sceneCode);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchParams") != m.end() && !m["MatchParams"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["MatchParams"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      matchParams = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("ReferenceNo") != m.end() && !m["ReferenceNo"].empty()) {
      referenceNo = make_shared<string>(boost::any_cast<string>(m["ReferenceNo"]));
    }
    if (m.find("ReferenceType") != m.end() && !m["ReferenceType"].empty()) {
      referenceType = make_shared<string>(boost::any_cast<string>(m["ReferenceType"]));
    }
    if (m.find("SceneCode") != m.end() && !m["SceneCode"].empty()) {
      sceneCode = make_shared<string>(boost::any_cast<string>(m["SceneCode"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~SbrainServiceSchemeMatchRequest() = default;
};
class SbrainServiceSchemeMatchShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> matchParamsShrink{};
  shared_ptr<string> productCode{};
  shared_ptr<string> referenceNo{};
  shared_ptr<string> referenceType{};
  shared_ptr<string> sceneCode{};
  shared_ptr<string> source{};

  SbrainServiceSchemeMatchShrinkRequest() {}

  explicit SbrainServiceSchemeMatchShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchParamsShrink) {
      res["MatchParams"] = boost::any(*matchParamsShrink);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (referenceNo) {
      res["ReferenceNo"] = boost::any(*referenceNo);
    }
    if (referenceType) {
      res["ReferenceType"] = boost::any(*referenceType);
    }
    if (sceneCode) {
      res["SceneCode"] = boost::any(*sceneCode);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchParams") != m.end() && !m["MatchParams"].empty()) {
      matchParamsShrink = make_shared<string>(boost::any_cast<string>(m["MatchParams"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("ReferenceNo") != m.end() && !m["ReferenceNo"].empty()) {
      referenceNo = make_shared<string>(boost::any_cast<string>(m["ReferenceNo"]));
    }
    if (m.find("ReferenceType") != m.end() && !m["ReferenceType"].empty()) {
      referenceType = make_shared<string>(boost::any_cast<string>(m["ReferenceType"]));
    }
    if (m.find("SceneCode") != m.end() && !m["SceneCode"].empty()) {
      sceneCode = make_shared<string>(boost::any_cast<string>(m["SceneCode"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~SbrainServiceSchemeMatchShrinkRequest() = default;
};
class SbrainServiceSchemeMatchResponseBodyDataSchemeContentContentModules : public Darabonba::Model {
public:
  shared_ptr<string> tag{};
  shared_ptr<string> action{};
  shared_ptr<string> moduleData{};
  shared_ptr<string> moduleDataSource{};
  shared_ptr<string> moduleDataSourceType{};
  shared_ptr<string> name{};
  shared_ptr<string> target{};

  SbrainServiceSchemeMatchResponseBodyDataSchemeContentContentModules() {}

  explicit SbrainServiceSchemeMatchResponseBodyDataSchemeContentContentModules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (moduleData) {
      res["moduleData"] = boost::any(*moduleData);
    }
    if (moduleDataSource) {
      res["moduleDataSource"] = boost::any(*moduleDataSource);
    }
    if (moduleDataSourceType) {
      res["moduleDataSourceType"] = boost::any(*moduleDataSourceType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (target) {
      res["target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("moduleData") != m.end() && !m["moduleData"].empty()) {
      moduleData = make_shared<string>(boost::any_cast<string>(m["moduleData"]));
    }
    if (m.find("moduleDataSource") != m.end() && !m["moduleDataSource"].empty()) {
      moduleDataSource = make_shared<string>(boost::any_cast<string>(m["moduleDataSource"]));
    }
    if (m.find("moduleDataSourceType") != m.end() && !m["moduleDataSourceType"].empty()) {
      moduleDataSourceType = make_shared<string>(boost::any_cast<string>(m["moduleDataSourceType"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("target") != m.end() && !m["target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["target"]));
    }
  }


  virtual ~SbrainServiceSchemeMatchResponseBodyDataSchemeContentContentModules() = default;
};
class SbrainServiceSchemeMatchResponseBodyDataSchemeContent : public Darabonba::Model {
public:
  shared_ptr<long> contentIndex{};
  shared_ptr<vector<SbrainServiceSchemeMatchResponseBodyDataSchemeContentContentModules>> contentModules{};
  shared_ptr<string> display{};

  SbrainServiceSchemeMatchResponseBodyDataSchemeContent() {}

  explicit SbrainServiceSchemeMatchResponseBodyDataSchemeContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentIndex) {
      res["ContentIndex"] = boost::any(*contentIndex);
    }
    if (contentModules) {
      vector<boost::any> temp1;
      for(auto item1:*contentModules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContentModules"] = boost::any(temp1);
    }
    if (display) {
      res["Display"] = boost::any(*display);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentIndex") != m.end() && !m["ContentIndex"].empty()) {
      contentIndex = make_shared<long>(boost::any_cast<long>(m["ContentIndex"]));
    }
    if (m.find("ContentModules") != m.end() && !m["ContentModules"].empty()) {
      if (typeid(vector<boost::any>) == m["ContentModules"].type()) {
        vector<SbrainServiceSchemeMatchResponseBodyDataSchemeContentContentModules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContentModules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SbrainServiceSchemeMatchResponseBodyDataSchemeContentContentModules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contentModules = make_shared<vector<SbrainServiceSchemeMatchResponseBodyDataSchemeContentContentModules>>(expect1);
      }
    }
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<string>(boost::any_cast<string>(m["Display"]));
    }
  }


  virtual ~SbrainServiceSchemeMatchResponseBodyDataSchemeContent() = default;
};
class SbrainServiceSchemeMatchResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> sceneCode{};
  shared_ptr<SbrainServiceSchemeMatchResponseBodyDataSchemeContent> schemeContent{};
  shared_ptr<long> schemeId{};

  SbrainServiceSchemeMatchResponseBodyData() {}

  explicit SbrainServiceSchemeMatchResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sceneCode) {
      res["SceneCode"] = boost::any(*sceneCode);
    }
    if (schemeContent) {
      res["SchemeContent"] = schemeContent ? boost::any(schemeContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schemeId) {
      res["SchemeId"] = boost::any(*schemeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SceneCode") != m.end() && !m["SceneCode"].empty()) {
      sceneCode = make_shared<string>(boost::any_cast<string>(m["SceneCode"]));
    }
    if (m.find("SchemeContent") != m.end() && !m["SchemeContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchemeContent"].type()) {
        SbrainServiceSchemeMatchResponseBodyDataSchemeContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchemeContent"]));
        schemeContent = make_shared<SbrainServiceSchemeMatchResponseBodyDataSchemeContent>(model1);
      }
    }
    if (m.find("SchemeId") != m.end() && !m["SchemeId"].empty()) {
      schemeId = make_shared<long>(boost::any_cast<long>(m["SchemeId"]));
    }
  }


  virtual ~SbrainServiceSchemeMatchResponseBodyData() = default;
};
class SbrainServiceSchemeMatchResponseBody : public Darabonba::Model {
public:
  shared_ptr<SbrainServiceSchemeMatchResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SbrainServiceSchemeMatchResponseBody() {}

  explicit SbrainServiceSchemeMatchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SbrainServiceSchemeMatchResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SbrainServiceSchemeMatchResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SbrainServiceSchemeMatchResponseBody() = default;
};
class SbrainServiceSchemeMatchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SbrainServiceSchemeMatchResponseBody> body{};

  SbrainServiceSchemeMatchResponse() {}

  explicit SbrainServiceSchemeMatchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SbrainServiceSchemeMatchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SbrainServiceSchemeMatchResponseBody>(model1);
      }
    }
  }


  virtual ~SbrainServiceSchemeMatchResponse() = default;
};
class SearchTmOnsalesRequest : public Darabonba::Model {
public:
  shared_ptr<string> classification{};
  shared_ptr<string> keyword{};
  shared_ptr<long> orderPriceLeft{};
  shared_ptr<long> orderPriceRight{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productCode{};
  shared_ptr<bool> queryAll{};
  shared_ptr<long> regLeft{};
  shared_ptr<long> regRight{};
  shared_ptr<string> registerNumber{};
  shared_ptr<string> sortName{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> tag{};
  shared_ptr<string> tmName{};
  shared_ptr<string> topSearch{};

  SearchTmOnsalesRequest() {}

  explicit SearchTmOnsalesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (orderPriceLeft) {
      res["OrderPriceLeft"] = boost::any(*orderPriceLeft);
    }
    if (orderPriceRight) {
      res["OrderPriceRight"] = boost::any(*orderPriceRight);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (queryAll) {
      res["QueryAll"] = boost::any(*queryAll);
    }
    if (regLeft) {
      res["RegLeft"] = boost::any(*regLeft);
    }
    if (regRight) {
      res["RegRight"] = boost::any(*regRight);
    }
    if (registerNumber) {
      res["RegisterNumber"] = boost::any(*registerNumber);
    }
    if (sortName) {
      res["SortName"] = boost::any(*sortName);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (topSearch) {
      res["TopSearch"] = boost::any(*topSearch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("OrderPriceLeft") != m.end() && !m["OrderPriceLeft"].empty()) {
      orderPriceLeft = make_shared<long>(boost::any_cast<long>(m["OrderPriceLeft"]));
    }
    if (m.find("OrderPriceRight") != m.end() && !m["OrderPriceRight"].empty()) {
      orderPriceRight = make_shared<long>(boost::any_cast<long>(m["OrderPriceRight"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("QueryAll") != m.end() && !m["QueryAll"].empty()) {
      queryAll = make_shared<bool>(boost::any_cast<bool>(m["QueryAll"]));
    }
    if (m.find("RegLeft") != m.end() && !m["RegLeft"].empty()) {
      regLeft = make_shared<long>(boost::any_cast<long>(m["RegLeft"]));
    }
    if (m.find("RegRight") != m.end() && !m["RegRight"].empty()) {
      regRight = make_shared<long>(boost::any_cast<long>(m["RegRight"]));
    }
    if (m.find("RegisterNumber") != m.end() && !m["RegisterNumber"].empty()) {
      registerNumber = make_shared<string>(boost::any_cast<string>(m["RegisterNumber"]));
    }
    if (m.find("SortName") != m.end() && !m["SortName"].empty()) {
      sortName = make_shared<string>(boost::any_cast<string>(m["SortName"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TopSearch") != m.end() && !m["TopSearch"].empty()) {
      topSearch = make_shared<string>(boost::any_cast<string>(m["TopSearch"]));
    }
  }


  virtual ~SearchTmOnsalesRequest() = default;
};
class SearchTmOnsalesResponseBodyTrademarks : public Darabonba::Model {
public:
  shared_ptr<string> classification{};
  shared_ptr<string> icon{};
  shared_ptr<string> orderPrice{};
  shared_ptr<string> partnerCode{};
  shared_ptr<string> productCode{};
  shared_ptr<string> productDesc{};
  shared_ptr<string> registrationNumber{};
  shared_ptr<long> status{};
  shared_ptr<string> trademarkName{};
  shared_ptr<string> uid{};

  SearchTmOnsalesResponseBodyTrademarks() {}

  explicit SearchTmOnsalesResponseBodyTrademarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classification) {
      res["Classification"] = boost::any(*classification);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (orderPrice) {
      res["OrderPrice"] = boost::any(*orderPrice);
    }
    if (partnerCode) {
      res["PartnerCode"] = boost::any(*partnerCode);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (productDesc) {
      res["ProductDesc"] = boost::any(*productDesc);
    }
    if (registrationNumber) {
      res["RegistrationNumber"] = boost::any(*registrationNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (trademarkName) {
      res["TrademarkName"] = boost::any(*trademarkName);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Classification") != m.end() && !m["Classification"].empty()) {
      classification = make_shared<string>(boost::any_cast<string>(m["Classification"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("OrderPrice") != m.end() && !m["OrderPrice"].empty()) {
      orderPrice = make_shared<string>(boost::any_cast<string>(m["OrderPrice"]));
    }
    if (m.find("PartnerCode") != m.end() && !m["PartnerCode"].empty()) {
      partnerCode = make_shared<string>(boost::any_cast<string>(m["PartnerCode"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("ProductDesc") != m.end() && !m["ProductDesc"].empty()) {
      productDesc = make_shared<string>(boost::any_cast<string>(m["ProductDesc"]));
    }
    if (m.find("RegistrationNumber") != m.end() && !m["RegistrationNumber"].empty()) {
      registrationNumber = make_shared<string>(boost::any_cast<string>(m["RegistrationNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TrademarkName") != m.end() && !m["TrademarkName"].empty()) {
      trademarkName = make_shared<string>(boost::any_cast<string>(m["TrademarkName"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
  }


  virtual ~SearchTmOnsalesResponseBodyTrademarks() = default;
};
class SearchTmOnsalesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalPageNumber{};
  shared_ptr<vector<SearchTmOnsalesResponseBodyTrademarks>> trademarks{};

  SearchTmOnsalesResponseBody() {}

  explicit SearchTmOnsalesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPageNumber) {
      res["TotalPageNumber"] = boost::any(*totalPageNumber);
    }
    if (trademarks) {
      vector<boost::any> temp1;
      for(auto item1:*trademarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Trademarks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPageNumber") != m.end() && !m["TotalPageNumber"].empty()) {
      totalPageNumber = make_shared<long>(boost::any_cast<long>(m["TotalPageNumber"]));
    }
    if (m.find("Trademarks") != m.end() && !m["Trademarks"].empty()) {
      if (typeid(vector<boost::any>) == m["Trademarks"].type()) {
        vector<SearchTmOnsalesResponseBodyTrademarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Trademarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTmOnsalesResponseBodyTrademarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trademarks = make_shared<vector<SearchTmOnsalesResponseBodyTrademarks>>(expect1);
      }
    }
  }


  virtual ~SearchTmOnsalesResponseBody() = default;
};
class SearchTmOnsalesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchTmOnsalesResponseBody> body{};

  SearchTmOnsalesResponse() {}

  explicit SearchTmOnsalesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTmOnsalesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTmOnsalesResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTmOnsalesResponse() = default;
};
class StartNotaryRequest : public Darabonba::Model {
public:
  shared_ptr<long> notaryOrderId{};

  StartNotaryRequest() {}

  explicit StartNotaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notaryOrderId) {
      res["NotaryOrderId"] = boost::any(*notaryOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotaryOrderId") != m.end() && !m["NotaryOrderId"].empty()) {
      notaryOrderId = make_shared<long>(boost::any_cast<long>(m["NotaryOrderId"]));
    }
  }


  virtual ~StartNotaryRequest() = default;
};
class StartNotaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> notaryUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StartNotaryResponseBody() {}

  explicit StartNotaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (notaryUrl) {
      res["NotaryUrl"] = boost::any(*notaryUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("NotaryUrl") != m.end() && !m["NotaryUrl"].empty()) {
      notaryUrl = make_shared<string>(boost::any_cast<string>(m["NotaryUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StartNotaryResponseBody() = default;
};
class StartNotaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartNotaryResponseBody> body{};

  StartNotaryResponse() {}

  explicit StartNotaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartNotaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartNotaryResponseBody>(model1);
      }
    }
  }


  virtual ~StartNotaryResponse() = default;
};
class StoreMaterialTemporarilyRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> businessLicenceOssKey{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> city{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactCity{};
  shared_ptr<string> contactCounty{};
  shared_ptr<string> contactDistrict{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactNumber{};
  shared_ptr<string> contactProvince{};
  shared_ptr<string> contactZipcode{};
  shared_ptr<string> country{};
  shared_ptr<string> EAddress{};
  shared_ptr<string> EName{};
  shared_ptr<string> idCardName{};
  shared_ptr<string> idCardNumber{};
  shared_ptr<string> idCardOssKey{};
  shared_ptr<string> legalNoticeOssKey{};
  shared_ptr<string> loaOssKey{};
  shared_ptr<string> name{};
  shared_ptr<string> passportOssKey{};
  shared_ptr<long> personalType{};
  shared_ptr<long> principalName{};
  shared_ptr<string> province{};
  shared_ptr<string> region{};
  shared_ptr<string> town{};
  shared_ptr<string> type{};

  StoreMaterialTemporarilyRequest() {}

  explicit StoreMaterialTemporarilyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (businessLicenceOssKey) {
      res["BusinessLicenceOssKey"] = boost::any(*businessLicenceOssKey);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactCity) {
      res["ContactCity"] = boost::any(*contactCity);
    }
    if (contactCounty) {
      res["ContactCounty"] = boost::any(*contactCounty);
    }
    if (contactDistrict) {
      res["ContactDistrict"] = boost::any(*contactDistrict);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactNumber) {
      res["ContactNumber"] = boost::any(*contactNumber);
    }
    if (contactProvince) {
      res["ContactProvince"] = boost::any(*contactProvince);
    }
    if (contactZipcode) {
      res["ContactZipcode"] = boost::any(*contactZipcode);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (EAddress) {
      res["EAddress"] = boost::any(*EAddress);
    }
    if (EName) {
      res["EName"] = boost::any(*EName);
    }
    if (idCardName) {
      res["IdCardName"] = boost::any(*idCardName);
    }
    if (idCardNumber) {
      res["IdCardNumber"] = boost::any(*idCardNumber);
    }
    if (idCardOssKey) {
      res["IdCardOssKey"] = boost::any(*idCardOssKey);
    }
    if (legalNoticeOssKey) {
      res["LegalNoticeOssKey"] = boost::any(*legalNoticeOssKey);
    }
    if (loaOssKey) {
      res["LoaOssKey"] = boost::any(*loaOssKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportOssKey) {
      res["PassportOssKey"] = boost::any(*passportOssKey);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (principalName) {
      res["PrincipalName"] = boost::any(*principalName);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (town) {
      res["Town"] = boost::any(*town);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BusinessLicenceOssKey") != m.end() && !m["BusinessLicenceOssKey"].empty()) {
      businessLicenceOssKey = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceOssKey"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactCity") != m.end() && !m["ContactCity"].empty()) {
      contactCity = make_shared<string>(boost::any_cast<string>(m["ContactCity"]));
    }
    if (m.find("ContactCounty") != m.end() && !m["ContactCounty"].empty()) {
      contactCounty = make_shared<string>(boost::any_cast<string>(m["ContactCounty"]));
    }
    if (m.find("ContactDistrict") != m.end() && !m["ContactDistrict"].empty()) {
      contactDistrict = make_shared<string>(boost::any_cast<string>(m["ContactDistrict"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactNumber") != m.end() && !m["ContactNumber"].empty()) {
      contactNumber = make_shared<string>(boost::any_cast<string>(m["ContactNumber"]));
    }
    if (m.find("ContactProvince") != m.end() && !m["ContactProvince"].empty()) {
      contactProvince = make_shared<string>(boost::any_cast<string>(m["ContactProvince"]));
    }
    if (m.find("ContactZipcode") != m.end() && !m["ContactZipcode"].empty()) {
      contactZipcode = make_shared<string>(boost::any_cast<string>(m["ContactZipcode"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("EAddress") != m.end() && !m["EAddress"].empty()) {
      EAddress = make_shared<string>(boost::any_cast<string>(m["EAddress"]));
    }
    if (m.find("EName") != m.end() && !m["EName"].empty()) {
      EName = make_shared<string>(boost::any_cast<string>(m["EName"]));
    }
    if (m.find("IdCardName") != m.end() && !m["IdCardName"].empty()) {
      idCardName = make_shared<string>(boost::any_cast<string>(m["IdCardName"]));
    }
    if (m.find("IdCardNumber") != m.end() && !m["IdCardNumber"].empty()) {
      idCardNumber = make_shared<string>(boost::any_cast<string>(m["IdCardNumber"]));
    }
    if (m.find("IdCardOssKey") != m.end() && !m["IdCardOssKey"].empty()) {
      idCardOssKey = make_shared<string>(boost::any_cast<string>(m["IdCardOssKey"]));
    }
    if (m.find("LegalNoticeOssKey") != m.end() && !m["LegalNoticeOssKey"].empty()) {
      legalNoticeOssKey = make_shared<string>(boost::any_cast<string>(m["LegalNoticeOssKey"]));
    }
    if (m.find("LoaOssKey") != m.end() && !m["LoaOssKey"].empty()) {
      loaOssKey = make_shared<string>(boost::any_cast<string>(m["LoaOssKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportOssKey") != m.end() && !m["PassportOssKey"].empty()) {
      passportOssKey = make_shared<string>(boost::any_cast<string>(m["PassportOssKey"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<long>(boost::any_cast<long>(m["PersonalType"]));
    }
    if (m.find("PrincipalName") != m.end() && !m["PrincipalName"].empty()) {
      principalName = make_shared<long>(boost::any_cast<long>(m["PrincipalName"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Town") != m.end() && !m["Town"].empty()) {
      town = make_shared<string>(boost::any_cast<string>(m["Town"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~StoreMaterialTemporarilyRequest() = default;
};
class StoreMaterialTemporarilyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StoreMaterialTemporarilyResponseBody() {}

  explicit StoreMaterialTemporarilyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StoreMaterialTemporarilyResponseBody() = default;
};
class StoreMaterialTemporarilyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StoreMaterialTemporarilyResponseBody> body{};

  StoreMaterialTemporarilyResponse() {}

  explicit StoreMaterialTemporarilyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StoreMaterialTemporarilyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StoreMaterialTemporarilyResponseBody>(model1);
      }
    }
  }


  virtual ~StoreMaterialTemporarilyResponse() = default;
};
class SubmitSupplementRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> id{};
  shared_ptr<string> operateType{};
  shared_ptr<map<string, boost::any>> uploadOssKeyList{};

  SubmitSupplementRequest() {}

  explicit SubmitSupplementRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (uploadOssKeyList) {
      res["UploadOssKeyList"] = boost::any(*uploadOssKeyList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("UploadOssKeyList") != m.end() && !m["UploadOssKeyList"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["UploadOssKeyList"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      uploadOssKeyList = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~SubmitSupplementRequest() = default;
};
class SubmitSupplementShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> id{};
  shared_ptr<string> operateType{};
  shared_ptr<string> uploadOssKeyListShrink{};

  SubmitSupplementShrinkRequest() {}

  explicit SubmitSupplementShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (uploadOssKeyListShrink) {
      res["UploadOssKeyList"] = boost::any(*uploadOssKeyListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("UploadOssKeyList") != m.end() && !m["UploadOssKeyList"].empty()) {
      uploadOssKeyListShrink = make_shared<string>(boost::any_cast<string>(m["UploadOssKeyList"]));
    }
  }


  virtual ~SubmitSupplementShrinkRequest() = default;
};
class SubmitSupplementResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitSupplementResponseBody() {}

  explicit SubmitSupplementResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitSupplementResponseBody() = default;
};
class SubmitSupplementResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSupplementResponseBody> body{};

  SubmitSupplementResponse() {}

  explicit SubmitSupplementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSupplementResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSupplementResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSupplementResponse() = default;
};
class SubmitTrademarkApplicationComplaintRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> content{};
  shared_ptr<map<string, boost::any>> files{};

  SubmitTrademarkApplicationComplaintRequest() {}

  explicit SubmitTrademarkApplicationComplaintRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (files) {
      res["Files"] = boost::any(*files);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Files"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      files = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~SubmitTrademarkApplicationComplaintRequest() = default;
};
class SubmitTrademarkApplicationComplaintShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> content{};
  shared_ptr<string> filesShrink{};

  SubmitTrademarkApplicationComplaintShrinkRequest() {}

  explicit SubmitTrademarkApplicationComplaintShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (filesShrink) {
      res["Files"] = boost::any(*filesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      filesShrink = make_shared<string>(boost::any_cast<string>(m["Files"]));
    }
  }


  virtual ~SubmitTrademarkApplicationComplaintShrinkRequest() = default;
};
class SubmitTrademarkApplicationComplaintResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SubmitTrademarkApplicationComplaintResponseBody() {}

  explicit SubmitTrademarkApplicationComplaintResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitTrademarkApplicationComplaintResponseBody() = default;
};
class SubmitTrademarkApplicationComplaintResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitTrademarkApplicationComplaintResponseBody> body{};

  SubmitTrademarkApplicationComplaintResponse() {}

  explicit SubmitTrademarkApplicationComplaintResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitTrademarkApplicationComplaintResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitTrademarkApplicationComplaintResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitTrademarkApplicationComplaintResponse() = default;
};
class SyncTrademarkRequest : public Darabonba::Model {
public:
  shared_ptr<long> beginTime{};
  shared_ptr<string> classificationCode{};
  shared_ptr<string> description{};
  shared_ptr<long> endTime{};
  shared_ptr<string> label{};
  shared_ptr<double> originalPrice{};
  shared_ptr<string> ownerEnName{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> reason{};
  shared_ptr<long> regAnnDate{};
  shared_ptr<string> secondaryClassification{};
  shared_ptr<string> status{};
  shared_ptr<string> thirdClassification{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNumber{};
  shared_ptr<string> type{};

  SyncTrademarkRequest() {}

  explicit SyncTrademarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (ownerEnName) {
      res["OwnerEnName"] = boost::any(*ownerEnName);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (regAnnDate) {
      res["RegAnnDate"] = boost::any(*regAnnDate);
    }
    if (secondaryClassification) {
      res["SecondaryClassification"] = boost::any(*secondaryClassification);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (thirdClassification) {
      res["ThirdClassification"] = boost::any(*thirdClassification);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("OwnerEnName") != m.end() && !m["OwnerEnName"].empty()) {
      ownerEnName = make_shared<string>(boost::any_cast<string>(m["OwnerEnName"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("RegAnnDate") != m.end() && !m["RegAnnDate"].empty()) {
      regAnnDate = make_shared<long>(boost::any_cast<long>(m["RegAnnDate"]));
    }
    if (m.find("SecondaryClassification") != m.end() && !m["SecondaryClassification"].empty()) {
      secondaryClassification = make_shared<string>(boost::any_cast<string>(m["SecondaryClassification"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ThirdClassification") != m.end() && !m["ThirdClassification"].empty()) {
      thirdClassification = make_shared<string>(boost::any_cast<string>(m["ThirdClassification"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SyncTrademarkRequest() = default;
};
class SyncTrademarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SyncTrademarkResponseBody() {}

  explicit SyncTrademarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SyncTrademarkResponseBody() = default;
};
class SyncTrademarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncTrademarkResponseBody> body{};

  SyncTrademarkResponse() {}

  explicit SyncTrademarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncTrademarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncTrademarkResponseBody>(model1);
      }
    }
  }


  virtual ~SyncTrademarkResponse() = default;
};
class UpdateApplicantContacterRequest : public Darabonba::Model {
public:
  shared_ptr<long> applicantId{};
  shared_ptr<string> bizId{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactCity{};
  shared_ptr<string> contactDistrict{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactNumber{};
  shared_ptr<string> contactProvince{};
  shared_ptr<string> contactZipCode{};

  UpdateApplicantContacterRequest() {}

  explicit UpdateApplicantContacterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicantId) {
      res["ApplicantId"] = boost::any(*applicantId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactCity) {
      res["ContactCity"] = boost::any(*contactCity);
    }
    if (contactDistrict) {
      res["ContactDistrict"] = boost::any(*contactDistrict);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactNumber) {
      res["ContactNumber"] = boost::any(*contactNumber);
    }
    if (contactProvince) {
      res["ContactProvince"] = boost::any(*contactProvince);
    }
    if (contactZipCode) {
      res["ContactZipCode"] = boost::any(*contactZipCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicantId") != m.end() && !m["ApplicantId"].empty()) {
      applicantId = make_shared<long>(boost::any_cast<long>(m["ApplicantId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactCity") != m.end() && !m["ContactCity"].empty()) {
      contactCity = make_shared<string>(boost::any_cast<string>(m["ContactCity"]));
    }
    if (m.find("ContactDistrict") != m.end() && !m["ContactDistrict"].empty()) {
      contactDistrict = make_shared<string>(boost::any_cast<string>(m["ContactDistrict"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactNumber") != m.end() && !m["ContactNumber"].empty()) {
      contactNumber = make_shared<string>(boost::any_cast<string>(m["ContactNumber"]));
    }
    if (m.find("ContactProvince") != m.end() && !m["ContactProvince"].empty()) {
      contactProvince = make_shared<string>(boost::any_cast<string>(m["ContactProvince"]));
    }
    if (m.find("ContactZipCode") != m.end() && !m["ContactZipCode"].empty()) {
      contactZipCode = make_shared<string>(boost::any_cast<string>(m["ContactZipCode"]));
    }
  }


  virtual ~UpdateApplicantContacterRequest() = default;
};
class UpdateApplicantContacterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateApplicantContacterResponseBody() {}

  explicit UpdateApplicantContacterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateApplicantContacterResponseBody() = default;
};
class UpdateApplicantContacterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateApplicantContacterResponseBody> body{};

  UpdateApplicantContacterResponse() {}

  explicit UpdateApplicantContacterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApplicantContacterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApplicantContacterResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApplicantContacterResponse() = default;
};
class UpdateMaterialRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> businessLicenceOssKey{};
  shared_ptr<string> cardNumber{};
  shared_ptr<string> city{};
  shared_ptr<string> contactAddress{};
  shared_ptr<string> contactCity{};
  shared_ptr<string> contactCounty{};
  shared_ptr<string> contactDistrict{};
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactNumber{};
  shared_ptr<string> contactProvince{};
  shared_ptr<string> contactZipcode{};
  shared_ptr<string> EAddress{};
  shared_ptr<string> EName{};
  shared_ptr<long> id{};
  shared_ptr<string> idCardName{};
  shared_ptr<string> idCardNumber{};
  shared_ptr<string> idCardOssKey{};
  shared_ptr<string> legalNoticeOssKey{};
  shared_ptr<long> loaId{};
  shared_ptr<string> loaOssKey{};
  shared_ptr<string> name{};
  shared_ptr<string> passportOssKey{};
  shared_ptr<long> personalType{};
  shared_ptr<string> province{};
  shared_ptr<string> town{};

  UpdateMaterialRequest() {}

  explicit UpdateMaterialRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (businessLicenceOssKey) {
      res["BusinessLicenceOssKey"] = boost::any(*businessLicenceOssKey);
    }
    if (cardNumber) {
      res["CardNumber"] = boost::any(*cardNumber);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactAddress) {
      res["ContactAddress"] = boost::any(*contactAddress);
    }
    if (contactCity) {
      res["ContactCity"] = boost::any(*contactCity);
    }
    if (contactCounty) {
      res["ContactCounty"] = boost::any(*contactCounty);
    }
    if (contactDistrict) {
      res["ContactDistrict"] = boost::any(*contactDistrict);
    }
    if (contactEmail) {
      res["ContactEmail"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (contactNumber) {
      res["ContactNumber"] = boost::any(*contactNumber);
    }
    if (contactProvince) {
      res["ContactProvince"] = boost::any(*contactProvince);
    }
    if (contactZipcode) {
      res["ContactZipcode"] = boost::any(*contactZipcode);
    }
    if (EAddress) {
      res["EAddress"] = boost::any(*EAddress);
    }
    if (EName) {
      res["EName"] = boost::any(*EName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (idCardName) {
      res["IdCardName"] = boost::any(*idCardName);
    }
    if (idCardNumber) {
      res["IdCardNumber"] = boost::any(*idCardNumber);
    }
    if (idCardOssKey) {
      res["IdCardOssKey"] = boost::any(*idCardOssKey);
    }
    if (legalNoticeOssKey) {
      res["LegalNoticeOssKey"] = boost::any(*legalNoticeOssKey);
    }
    if (loaId) {
      res["LoaId"] = boost::any(*loaId);
    }
    if (loaOssKey) {
      res["LoaOssKey"] = boost::any(*loaOssKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passportOssKey) {
      res["PassportOssKey"] = boost::any(*passportOssKey);
    }
    if (personalType) {
      res["PersonalType"] = boost::any(*personalType);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (town) {
      res["Town"] = boost::any(*town);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BusinessLicenceOssKey") != m.end() && !m["BusinessLicenceOssKey"].empty()) {
      businessLicenceOssKey = make_shared<string>(boost::any_cast<string>(m["BusinessLicenceOssKey"]));
    }
    if (m.find("CardNumber") != m.end() && !m["CardNumber"].empty()) {
      cardNumber = make_shared<string>(boost::any_cast<string>(m["CardNumber"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactAddress") != m.end() && !m["ContactAddress"].empty()) {
      contactAddress = make_shared<string>(boost::any_cast<string>(m["ContactAddress"]));
    }
    if (m.find("ContactCity") != m.end() && !m["ContactCity"].empty()) {
      contactCity = make_shared<string>(boost::any_cast<string>(m["ContactCity"]));
    }
    if (m.find("ContactCounty") != m.end() && !m["ContactCounty"].empty()) {
      contactCounty = make_shared<string>(boost::any_cast<string>(m["ContactCounty"]));
    }
    if (m.find("ContactDistrict") != m.end() && !m["ContactDistrict"].empty()) {
      contactDistrict = make_shared<string>(boost::any_cast<string>(m["ContactDistrict"]));
    }
    if (m.find("ContactEmail") != m.end() && !m["ContactEmail"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["ContactEmail"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("ContactNumber") != m.end() && !m["ContactNumber"].empty()) {
      contactNumber = make_shared<string>(boost::any_cast<string>(m["ContactNumber"]));
    }
    if (m.find("ContactProvince") != m.end() && !m["ContactProvince"].empty()) {
      contactProvince = make_shared<string>(boost::any_cast<string>(m["ContactProvince"]));
    }
    if (m.find("ContactZipcode") != m.end() && !m["ContactZipcode"].empty()) {
      contactZipcode = make_shared<string>(boost::any_cast<string>(m["ContactZipcode"]));
    }
    if (m.find("EAddress") != m.end() && !m["EAddress"].empty()) {
      EAddress = make_shared<string>(boost::any_cast<string>(m["EAddress"]));
    }
    if (m.find("EName") != m.end() && !m["EName"].empty()) {
      EName = make_shared<string>(boost::any_cast<string>(m["EName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IdCardName") != m.end() && !m["IdCardName"].empty()) {
      idCardName = make_shared<string>(boost::any_cast<string>(m["IdCardName"]));
    }
    if (m.find("IdCardNumber") != m.end() && !m["IdCardNumber"].empty()) {
      idCardNumber = make_shared<string>(boost::any_cast<string>(m["IdCardNumber"]));
    }
    if (m.find("IdCardOssKey") != m.end() && !m["IdCardOssKey"].empty()) {
      idCardOssKey = make_shared<string>(boost::any_cast<string>(m["IdCardOssKey"]));
    }
    if (m.find("LegalNoticeOssKey") != m.end() && !m["LegalNoticeOssKey"].empty()) {
      legalNoticeOssKey = make_shared<string>(boost::any_cast<string>(m["LegalNoticeOssKey"]));
    }
    if (m.find("LoaId") != m.end() && !m["LoaId"].empty()) {
      loaId = make_shared<long>(boost::any_cast<long>(m["LoaId"]));
    }
    if (m.find("LoaOssKey") != m.end() && !m["LoaOssKey"].empty()) {
      loaOssKey = make_shared<string>(boost::any_cast<string>(m["LoaOssKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassportOssKey") != m.end() && !m["PassportOssKey"].empty()) {
      passportOssKey = make_shared<string>(boost::any_cast<string>(m["PassportOssKey"]));
    }
    if (m.find("PersonalType") != m.end() && !m["PersonalType"].empty()) {
      personalType = make_shared<long>(boost::any_cast<long>(m["PersonalType"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Town") != m.end() && !m["Town"].empty()) {
      town = make_shared<string>(boost::any_cast<string>(m["Town"]));
    }
  }


  virtual ~UpdateMaterialRequest() = default;
};
class UpdateMaterialResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateMaterialResponseBody() {}

  explicit UpdateMaterialResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateMaterialResponseBody() = default;
};
class UpdateMaterialResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMaterialResponseBody> body{};

  UpdateMaterialResponse() {}

  explicit UpdateMaterialResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMaterialResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMaterialResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMaterialResponse() = default;
};
class UpdateProduceRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};
  shared_ptr<string> extMap{};
  shared_ptr<string> operateType{};

  UpdateProduceRequest() {}

  explicit UpdateProduceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (extMap) {
      res["ExtMap"] = boost::any(*extMap);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExtMap") != m.end() && !m["ExtMap"].empty()) {
      extMap = make_shared<string>(boost::any_cast<string>(m["ExtMap"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
  }


  virtual ~UpdateProduceRequest() = default;
};
class UpdateProduceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateProduceResponseBody() {}

  explicit UpdateProduceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateProduceResponseBody() = default;
};
class UpdateProduceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProduceResponseBody> body{};

  UpdateProduceResponse() {}

  explicit UpdateProduceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProduceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProduceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProduceResponse() = default;
};
class UpdateProduceLoaIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> loaOssKey{};

  UpdateProduceLoaIdRequest() {}

  explicit UpdateProduceLoaIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (loaOssKey) {
      res["LoaOssKey"] = boost::any(*loaOssKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("LoaOssKey") != m.end() && !m["LoaOssKey"].empty()) {
      loaOssKey = make_shared<string>(boost::any_cast<string>(m["LoaOssKey"]));
    }
  }


  virtual ~UpdateProduceLoaIdRequest() = default;
};
class UpdateProduceLoaIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateProduceLoaIdResponseBody() {}

  explicit UpdateProduceLoaIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateProduceLoaIdResponseBody() = default;
};
class UpdateProduceLoaIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProduceLoaIdResponseBody> body{};

  UpdateProduceLoaIdResponse() {}

  explicit UpdateProduceLoaIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProduceLoaIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProduceLoaIdResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProduceLoaIdResponse() = default;
};
class UpdateSendMaterialNumRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> num{};
  shared_ptr<long> operateType{};

  UpdateSendMaterialNumRequest() {}

  explicit UpdateSendMaterialNumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (num) {
      res["Num"] = boost::any(*num);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Num") != m.end() && !m["Num"].empty()) {
      num = make_shared<string>(boost::any_cast<string>(m["Num"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<long>(boost::any_cast<long>(m["OperateType"]));
    }
  }


  virtual ~UpdateSendMaterialNumRequest() = default;
};
class UpdateSendMaterialNumResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateSendMaterialNumResponseBody() {}

  explicit UpdateSendMaterialNumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateSendMaterialNumResponseBody() = default;
};
class UpdateSendMaterialNumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSendMaterialNumResponseBody> body{};

  UpdateSendMaterialNumResponse() {}

  explicit UpdateSendMaterialNumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSendMaterialNumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSendMaterialNumResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSendMaterialNumResponse() = default;
};
class UpdateTrademarkNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> tmComment{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<long> type{};

  UpdateTrademarkNameRequest() {}

  explicit UpdateTrademarkNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (tmComment) {
      res["TmComment"] = boost::any(*tmComment);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("TmComment") != m.end() && !m["TmComment"].empty()) {
      tmComment = make_shared<string>(boost::any_cast<string>(m["TmComment"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~UpdateTrademarkNameRequest() = default;
};
class UpdateTrademarkNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTrademarkNameResponseBody() {}

  explicit UpdateTrademarkNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTrademarkNameResponseBody() = default;
};
class UpdateTrademarkNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTrademarkNameResponseBody> body{};

  UpdateTrademarkNameResponse() {}

  explicit UpdateTrademarkNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTrademarkNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTrademarkNameResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTrademarkNameResponse() = default;
};
class UpdateTrademarkOnsaleRequest : public Darabonba::Model {
public:
  shared_ptr<long> beginTime{};
  shared_ptr<string> classificationCode{};
  shared_ptr<string> description{};
  shared_ptr<long> endTime{};
  shared_ptr<string> label{};
  shared_ptr<double> originalPrice{};
  shared_ptr<string> ownerEnName{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> reason{};
  shared_ptr<long> regAnnDate{};
  shared_ptr<string> secondaryClassification{};
  shared_ptr<string> thirdClassification{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNumber{};
  shared_ptr<string> tmType{};
  shared_ptr<string> tradeTmDetailJson{};
  shared_ptr<string> type{};

  UpdateTrademarkOnsaleRequest() {}

  explicit UpdateTrademarkOnsaleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (ownerEnName) {
      res["OwnerEnName"] = boost::any(*ownerEnName);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (regAnnDate) {
      res["RegAnnDate"] = boost::any(*regAnnDate);
    }
    if (secondaryClassification) {
      res["SecondaryClassification"] = boost::any(*secondaryClassification);
    }
    if (thirdClassification) {
      res["ThirdClassification"] = boost::any(*thirdClassification);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (tmType) {
      res["TmType"] = boost::any(*tmType);
    }
    if (tradeTmDetailJson) {
      res["TradeTmDetailJson"] = boost::any(*tradeTmDetailJson);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("OwnerEnName") != m.end() && !m["OwnerEnName"].empty()) {
      ownerEnName = make_shared<string>(boost::any_cast<string>(m["OwnerEnName"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("RegAnnDate") != m.end() && !m["RegAnnDate"].empty()) {
      regAnnDate = make_shared<long>(boost::any_cast<long>(m["RegAnnDate"]));
    }
    if (m.find("SecondaryClassification") != m.end() && !m["SecondaryClassification"].empty()) {
      secondaryClassification = make_shared<string>(boost::any_cast<string>(m["SecondaryClassification"]));
    }
    if (m.find("ThirdClassification") != m.end() && !m["ThirdClassification"].empty()) {
      thirdClassification = make_shared<string>(boost::any_cast<string>(m["ThirdClassification"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("TmType") != m.end() && !m["TmType"].empty()) {
      tmType = make_shared<string>(boost::any_cast<string>(m["TmType"]));
    }
    if (m.find("TradeTmDetailJson") != m.end() && !m["TradeTmDetailJson"].empty()) {
      tradeTmDetailJson = make_shared<string>(boost::any_cast<string>(m["TradeTmDetailJson"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateTrademarkOnsaleRequest() = default;
};
class UpdateTrademarkOnsaleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateTrademarkOnsaleResponseBody() {}

  explicit UpdateTrademarkOnsaleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateTrademarkOnsaleResponseBody() = default;
};
class UpdateTrademarkOnsaleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTrademarkOnsaleResponseBody> body{};

  UpdateTrademarkOnsaleResponse() {}

  explicit UpdateTrademarkOnsaleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTrademarkOnsaleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTrademarkOnsaleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTrademarkOnsaleResponse() = default;
};
class UploadNotaryDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizOrderNo{};
  shared_ptr<long> notaryType{};
  shared_ptr<string> uploadContext{};

  UploadNotaryDataRequest() {}

  explicit UploadNotaryDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizOrderNo) {
      res["BizOrderNo"] = boost::any(*bizOrderNo);
    }
    if (notaryType) {
      res["NotaryType"] = boost::any(*notaryType);
    }
    if (uploadContext) {
      res["UploadContext"] = boost::any(*uploadContext);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizOrderNo") != m.end() && !m["BizOrderNo"].empty()) {
      bizOrderNo = make_shared<string>(boost::any_cast<string>(m["BizOrderNo"]));
    }
    if (m.find("NotaryType") != m.end() && !m["NotaryType"].empty()) {
      notaryType = make_shared<long>(boost::any_cast<long>(m["NotaryType"]));
    }
    if (m.find("UploadContext") != m.end() && !m["UploadContext"].empty()) {
      uploadContext = make_shared<string>(boost::any_cast<string>(m["UploadContext"]));
    }
  }


  virtual ~UploadNotaryDataRequest() = default;
};
class UploadNotaryDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> userAuthUrl{};

  UploadNotaryDataResponseBody() {}

  explicit UploadNotaryDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userAuthUrl) {
      res["UserAuthUrl"] = boost::any(*userAuthUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserAuthUrl") != m.end() && !m["UserAuthUrl"].empty()) {
      userAuthUrl = make_shared<string>(boost::any_cast<string>(m["UserAuthUrl"]));
    }
  }


  virtual ~UploadNotaryDataResponseBody() = default;
};
class UploadNotaryDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadNotaryDataResponseBody> body{};

  UploadNotaryDataResponse() {}

  explicit UploadNotaryDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadNotaryDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadNotaryDataResponseBody>(model1);
      }
    }
  }


  virtual ~UploadNotaryDataResponse() = default;
};
class UploadTrademarkOnSaleRequest : public Darabonba::Model {
public:
  shared_ptr<long> beginTime{};
  shared_ptr<string> classificationCode{};
  shared_ptr<string> description{};
  shared_ptr<long> endTime{};
  shared_ptr<string> label{};
  shared_ptr<double> originalPrice{};
  shared_ptr<string> ownerEnName{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> reason{};
  shared_ptr<long> regAnnDate{};
  shared_ptr<string> secondaryClassification{};
  shared_ptr<string> status{};
  shared_ptr<string> thirdClassification{};
  shared_ptr<string> tmIcon{};
  shared_ptr<string> tmName{};
  shared_ptr<string> tmNumber{};
  shared_ptr<string> tmType{};
  shared_ptr<string> tradeTmDetailJson{};
  shared_ptr<string> type{};

  UploadTrademarkOnSaleRequest() {}

  explicit UploadTrademarkOnSaleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (classificationCode) {
      res["ClassificationCode"] = boost::any(*classificationCode);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (ownerEnName) {
      res["OwnerEnName"] = boost::any(*ownerEnName);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (regAnnDate) {
      res["RegAnnDate"] = boost::any(*regAnnDate);
    }
    if (secondaryClassification) {
      res["SecondaryClassification"] = boost::any(*secondaryClassification);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (thirdClassification) {
      res["ThirdClassification"] = boost::any(*thirdClassification);
    }
    if (tmIcon) {
      res["TmIcon"] = boost::any(*tmIcon);
    }
    if (tmName) {
      res["TmName"] = boost::any(*tmName);
    }
    if (tmNumber) {
      res["TmNumber"] = boost::any(*tmNumber);
    }
    if (tmType) {
      res["TmType"] = boost::any(*tmType);
    }
    if (tradeTmDetailJson) {
      res["TradeTmDetailJson"] = boost::any(*tradeTmDetailJson);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("ClassificationCode") != m.end() && !m["ClassificationCode"].empty()) {
      classificationCode = make_shared<string>(boost::any_cast<string>(m["ClassificationCode"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("OwnerEnName") != m.end() && !m["OwnerEnName"].empty()) {
      ownerEnName = make_shared<string>(boost::any_cast<string>(m["OwnerEnName"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("RegAnnDate") != m.end() && !m["RegAnnDate"].empty()) {
      regAnnDate = make_shared<long>(boost::any_cast<long>(m["RegAnnDate"]));
    }
    if (m.find("SecondaryClassification") != m.end() && !m["SecondaryClassification"].empty()) {
      secondaryClassification = make_shared<string>(boost::any_cast<string>(m["SecondaryClassification"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ThirdClassification") != m.end() && !m["ThirdClassification"].empty()) {
      thirdClassification = make_shared<string>(boost::any_cast<string>(m["ThirdClassification"]));
    }
    if (m.find("TmIcon") != m.end() && !m["TmIcon"].empty()) {
      tmIcon = make_shared<string>(boost::any_cast<string>(m["TmIcon"]));
    }
    if (m.find("TmName") != m.end() && !m["TmName"].empty()) {
      tmName = make_shared<string>(boost::any_cast<string>(m["TmName"]));
    }
    if (m.find("TmNumber") != m.end() && !m["TmNumber"].empty()) {
      tmNumber = make_shared<string>(boost::any_cast<string>(m["TmNumber"]));
    }
    if (m.find("TmType") != m.end() && !m["TmType"].empty()) {
      tmType = make_shared<string>(boost::any_cast<string>(m["TmType"]));
    }
    if (m.find("TradeTmDetailJson") != m.end() && !m["TradeTmDetailJson"].empty()) {
      tradeTmDetailJson = make_shared<string>(boost::any_cast<string>(m["TradeTmDetailJson"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UploadTrademarkOnSaleRequest() = default;
};
class UploadTrademarkOnSaleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UploadTrademarkOnSaleResponseBody() {}

  explicit UploadTrademarkOnSaleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UploadTrademarkOnSaleResponseBody() = default;
};
class UploadTrademarkOnSaleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadTrademarkOnSaleResponseBody> body{};

  UploadTrademarkOnSaleResponse() {}

  explicit UploadTrademarkOnSaleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadTrademarkOnSaleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadTrademarkOnSaleResponseBody>(model1);
      }
    }
  }


  virtual ~UploadTrademarkOnSaleResponse() = default;
};
class WriteCommunicationLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> note{};
  shared_ptr<string> targetId{};

  WriteCommunicationLogRequest() {}

  explicit WriteCommunicationLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
  }


  virtual ~WriteCommunicationLogRequest() = default;
};
class WriteCommunicationLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  WriteCommunicationLogResponseBody() {}

  explicit WriteCommunicationLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~WriteCommunicationLogResponseBody() = default;
};
class WriteCommunicationLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WriteCommunicationLogResponseBody> body{};

  WriteCommunicationLogResponse() {}

  explicit WriteCommunicationLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WriteCommunicationLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WriteCommunicationLogResponseBody>(model1);
      }
    }
  }


  virtual ~WriteCommunicationLogResponse() = default;
};
class WriteIntentionCommunicationLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> note{};
  shared_ptr<bool> reject{};

  WriteIntentionCommunicationLogRequest() {}

  explicit WriteIntentionCommunicationLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (reject) {
      res["Reject"] = boost::any(*reject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("Reject") != m.end() && !m["Reject"].empty()) {
      reject = make_shared<bool>(boost::any_cast<bool>(m["Reject"]));
    }
  }


  virtual ~WriteIntentionCommunicationLogRequest() = default;
};
class WriteIntentionCommunicationLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  WriteIntentionCommunicationLogResponseBody() {}

  explicit WriteIntentionCommunicationLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~WriteIntentionCommunicationLogResponseBody() = default;
};
class WriteIntentionCommunicationLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WriteIntentionCommunicationLogResponseBody> body{};

  WriteIntentionCommunicationLogResponse() {}

  explicit WriteIntentionCommunicationLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WriteIntentionCommunicationLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WriteIntentionCommunicationLogResponseBody>(model1);
      }
    }
  }


  virtual ~WriteIntentionCommunicationLogResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AcceptPartnerNotificationResponse acceptPartnerNotificationWithOptions(shared_ptr<AcceptPartnerNotificationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AcceptPartnerNotificationResponse acceptPartnerNotification(shared_ptr<AcceptPartnerNotificationRequest> request);
  ApplyNotaryPostResponse applyNotaryPostWithOptions(shared_ptr<ApplyNotaryPostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyNotaryPostResponse applyNotaryPost(shared_ptr<ApplyNotaryPostRequest> request);
  AskAdjudicationFileResponse askAdjudicationFileWithOptions(shared_ptr<AskAdjudicationFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AskAdjudicationFileResponse askAdjudicationFile(shared_ptr<AskAdjudicationFileRequest> request);
  BindMaterialResponse bindMaterialWithOptions(shared_ptr<BindMaterialRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindMaterialResponse bindMaterial(shared_ptr<BindMaterialRequest> request);
  CancelTradeOrderResponse cancelTradeOrderWithOptions(shared_ptr<CancelTradeOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelTradeOrderResponse cancelTradeOrder(shared_ptr<CancelTradeOrderRequest> request);
  CheckFlsmFillResponse checkFlsmFillWithOptions(shared_ptr<CheckFlsmFillRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckFlsmFillResponse checkFlsmFill(shared_ptr<CheckFlsmFillRequest> request);
  CheckIfCollectedResponse checkIfCollectedWithOptions(shared_ptr<CheckIfCollectedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckIfCollectedResponse checkIfCollected(shared_ptr<CheckIfCollectedRequest> request);
  CheckLoaFillResponse checkLoaFillWithOptions(shared_ptr<CheckLoaFillRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckLoaFillResponse checkLoaFill(shared_ptr<CheckLoaFillRequest> request);
  CheckTrademarkIconResponse checkTrademarkIconWithOptions(shared_ptr<CheckTrademarkIconRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckTrademarkIconResponse checkTrademarkIcon(shared_ptr<CheckTrademarkIconRequest> request);
  CheckTrademarkOrderResponse checkTrademarkOrderWithOptions(shared_ptr<CheckTrademarkOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckTrademarkOrderResponse checkTrademarkOrder(shared_ptr<CheckTrademarkOrderRequest> request);
  CombineLoaResponse combineLoaWithOptions(shared_ptr<CombineLoaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CombineLoaResponse combineLoa(shared_ptr<CombineLoaRequest> request);
  CombineWTSResponse combineWTSWithOptions(shared_ptr<CombineWTSRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CombineWTSResponse combineWTS(shared_ptr<CombineWTSRequest> request);
  ComplementIntentionUserIdResponse complementIntentionUserIdWithOptions(shared_ptr<ComplementIntentionUserIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ComplementIntentionUserIdResponse complementIntentionUserId(shared_ptr<ComplementIntentionUserIdRequest> request);
  ConfirmAdditionalMaterialResponse confirmAdditionalMaterialWithOptions(shared_ptr<ConfirmAdditionalMaterialRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfirmAdditionalMaterialResponse confirmAdditionalMaterial(shared_ptr<ConfirmAdditionalMaterialRequest> request);
  ConfirmApplicantResponse confirmApplicantWithOptions(shared_ptr<ConfirmApplicantRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfirmApplicantResponse confirmApplicant(shared_ptr<ConfirmApplicantRequest> request);
  ConfirmDissentOriginalResponse confirmDissentOriginalWithOptions(shared_ptr<ConfirmDissentOriginalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfirmDissentOriginalResponse confirmDissentOriginal(shared_ptr<ConfirmDissentOriginalRequest> request);
  ConvertImageToGrayResponse convertImageToGrayWithOptions(shared_ptr<ConvertImageToGrayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConvertImageToGrayResponse convertImageToGray(shared_ptr<ConvertImageToGrayRequest> request);
  CopyApplicantResponse copyApplicantWithOptions(shared_ptr<CopyApplicantRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyApplicantResponse copyApplicant(shared_ptr<CopyApplicantRequest> request);
  CreateIntentionOrderResponse createIntentionOrderWithOptions(shared_ptr<CreateIntentionOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIntentionOrderResponse createIntentionOrder(shared_ptr<CreateIntentionOrderRequest> request);
  CreateIntentionOrderGeneratingPayResponse createIntentionOrderGeneratingPayWithOptions(shared_ptr<CreateIntentionOrderGeneratingPayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIntentionOrderGeneratingPayResponse createIntentionOrderGeneratingPay(shared_ptr<CreateIntentionOrderGeneratingPayRequest> request);
  CreateTrademarkOrderResponse createTrademarkOrderWithOptions(shared_ptr<CreateTrademarkOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTrademarkOrderResponse createTrademarkOrder(shared_ptr<CreateTrademarkOrderRequest> request);
  DeleteMaterialResponse deleteMaterialWithOptions(shared_ptr<DeleteMaterialRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMaterialResponse deleteMaterial(shared_ptr<DeleteMaterialRequest> request);
  DeleteTmMonitorRuleResponse deleteTmMonitorRuleWithOptions(shared_ptr<DeleteTmMonitorRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTmMonitorRuleResponse deleteTmMonitorRule(shared_ptr<DeleteTmMonitorRuleRequest> request);
  DeleteTrademarkApplicationResponse deleteTrademarkApplicationWithOptions(shared_ptr<DeleteTrademarkApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTrademarkApplicationResponse deleteTrademarkApplication(shared_ptr<DeleteTrademarkApplicationRequest> request);
  DenySupplementResponse denySupplementWithOptions(shared_ptr<DenySupplementRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DenySupplementResponse denySupplement(shared_ptr<DenySupplementRequest> request);
  DescirbeCombineTrademarkResponse descirbeCombineTrademarkWithOptions(shared_ptr<DescirbeCombineTrademarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescirbeCombineTrademarkResponse descirbeCombineTrademark(shared_ptr<DescirbeCombineTrademarkRequest> request);
  FillLogisticsResponse fillLogisticsWithOptions(shared_ptr<FillLogisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FillLogisticsResponse fillLogistics(shared_ptr<FillLogisticsRequest> request);
  FilterUnavailableCodesResponse filterUnavailableCodesWithOptions(shared_ptr<FilterUnavailableCodesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FilterUnavailableCodesResponse filterUnavailableCodes(shared_ptr<FilterUnavailableCodesRequest> request);
  ForceUploadTrademarkOnsaleResponse forceUploadTrademarkOnsaleWithOptions(shared_ptr<ForceUploadTrademarkOnsaleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ForceUploadTrademarkOnsaleResponse forceUploadTrademarkOnsale(shared_ptr<ForceUploadTrademarkOnsaleRequest> request);
  GenerateQrCodeResponse generateQrCodeWithOptions(shared_ptr<GenerateQrCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateQrCodeResponse generateQrCode(shared_ptr<GenerateQrCodeRequest> request);
  GenerateUploadFilePolicyResponse generateUploadFilePolicyWithOptions(shared_ptr<GenerateUploadFilePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateUploadFilePolicyResponse generateUploadFilePolicy(shared_ptr<GenerateUploadFilePolicyRequest> request);
  GetAuthorizationLetterVersionResponse getAuthorizationLetterVersionWithOptions(shared_ptr<GetAuthorizationLetterVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAuthorizationLetterVersionResponse getAuthorizationLetterVersion(shared_ptr<GetAuthorizationLetterVersionRequest> request);
  GetDefaultPrincipalResponse getDefaultPrincipalWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDefaultPrincipalResponse getDefaultPrincipal();
  GetDefaultPrincipalNameResponse getDefaultPrincipalNameWithOptions(shared_ptr<GetDefaultPrincipalNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDefaultPrincipalNameResponse getDefaultPrincipalName(shared_ptr<GetDefaultPrincipalNameRequest> request);
  GetNotaryOrderResponse getNotaryOrderWithOptions(shared_ptr<GetNotaryOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNotaryOrderResponse getNotaryOrder(shared_ptr<GetNotaryOrderRequest> request);
  GetSupportPrincipalNameResponse getSupportPrincipalNameWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSupportPrincipalNameResponse getSupportPrincipalName();
  InsertMaterialResponse insertMaterialWithOptions(shared_ptr<InsertMaterialRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertMaterialResponse insertMaterial(shared_ptr<InsertMaterialRequest> request);
  InsertRenewInfoResponse insertRenewInfoWithOptions(shared_ptr<InsertRenewInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertRenewInfoResponse insertRenewInfo(shared_ptr<InsertRenewInfoRequest> request);
  InsertTmMonitorRuleResponse insertTmMonitorRuleWithOptions(shared_ptr<InsertTmMonitorRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertTmMonitorRuleResponse insertTmMonitorRule(shared_ptr<InsertTmMonitorRuleRequest> request);
  ListNotaryInfosResponse listNotaryInfosWithOptions(shared_ptr<ListNotaryInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNotaryInfosResponse listNotaryInfos(shared_ptr<ListNotaryInfosRequest> request);
  ListNotaryOrdersResponse listNotaryOrdersWithOptions(shared_ptr<ListNotaryOrdersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNotaryOrdersResponse listNotaryOrders(shared_ptr<ListNotaryOrdersRequest> request);
  ListTrademarkSbjKeyResponse listTrademarkSbjKeyWithOptions(shared_ptr<ListTrademarkSbjKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTrademarkSbjKeyResponse listTrademarkSbjKey(shared_ptr<ListTrademarkSbjKeyRequest> request);
  ModifySubmitTransferMaterailResponse modifySubmitTransferMaterailWithOptions(shared_ptr<ModifySubmitTransferMaterailRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySubmitTransferMaterailResponse modifySubmitTransferMaterail(shared_ptr<ModifySubmitTransferMaterailRequest> request);
  OperateProduceResponse operateProduceWithOptions(shared_ptr<OperateProduceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateProduceResponse operateProduce(shared_ptr<OperateProduceRequest> request);
  PartnerUpdateTrademarkNameResponse partnerUpdateTrademarkNameWithOptions(shared_ptr<PartnerUpdateTrademarkNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PartnerUpdateTrademarkNameResponse partnerUpdateTrademarkName(shared_ptr<PartnerUpdateTrademarkNameRequest> request);
  QueryCommunicationLogsResponse queryCommunicationLogsWithOptions(shared_ptr<QueryCommunicationLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCommunicationLogsResponse queryCommunicationLogs(shared_ptr<QueryCommunicationLogsRequest> request);
  QueryCredentialsInfoResponse queryCredentialsInfoWithOptions(shared_ptr<QueryCredentialsInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCredentialsInfoResponse queryCredentialsInfo(shared_ptr<QueryCredentialsInfoRequest> request);
  QueryExtensionAttributeResponse queryExtensionAttributeWithOptions(shared_ptr<QueryExtensionAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryExtensionAttributeResponse queryExtensionAttribute(shared_ptr<QueryExtensionAttributeRequest> request);
  QueryIntentionDetailResponse queryIntentionDetailWithOptions(shared_ptr<QueryIntentionDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryIntentionDetailResponse queryIntentionDetail(shared_ptr<QueryIntentionDetailRequest> request);
  QueryIntentionListResponse queryIntentionListWithOptions(shared_ptr<QueryIntentionListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryIntentionListResponse queryIntentionList(shared_ptr<QueryIntentionListRequest> request);
  QueryIntentionOwnerResponse queryIntentionOwnerWithOptions(shared_ptr<QueryIntentionOwnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryIntentionOwnerResponse queryIntentionOwner(shared_ptr<QueryIntentionOwnerRequest> request);
  QueryIntentionPriceResponse queryIntentionPriceWithOptions(shared_ptr<QueryIntentionPriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryIntentionPriceResponse queryIntentionPrice(shared_ptr<QueryIntentionPriceRequest> request);
  QueryMaterialResponse queryMaterialWithOptions(shared_ptr<QueryMaterialRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMaterialResponse queryMaterial(shared_ptr<QueryMaterialRequest> request);
  QueryMaterialListResponse queryMaterialListWithOptions(shared_ptr<QueryMaterialListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMaterialListResponse queryMaterialList(shared_ptr<QueryMaterialListRequest> request);
  QueryMonitorKeywordsResponse queryMonitorKeywordsWithOptions(shared_ptr<QueryMonitorKeywordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMonitorKeywordsResponse queryMonitorKeywords(shared_ptr<QueryMonitorKeywordsRequest> request);
  QueryOfficialFileCustomListResponse queryOfficialFileCustomListWithOptions(shared_ptr<QueryOfficialFileCustomListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOfficialFileCustomListResponse queryOfficialFileCustomList(shared_ptr<QueryOfficialFileCustomListRequest> request);
  QueryOrderLogisticsListResponse queryOrderLogisticsListWithOptions(shared_ptr<QueryOrderLogisticsListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrderLogisticsListResponse queryOrderLogisticsList(shared_ptr<QueryOrderLogisticsListRequest> request);
  QueryOssResourcesResponse queryOssResourcesWithOptions(shared_ptr<QueryOssResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOssResourcesResponse queryOssResources(shared_ptr<QueryOssResourcesRequest> request);
  QueryProduceDetailResponse queryProduceDetailWithOptions(shared_ptr<QueryProduceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProduceDetailResponse queryProduceDetail(shared_ptr<QueryProduceDetailRequest> request);
  QueryProduceListResponse queryProduceListWithOptions(shared_ptr<QueryProduceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProduceListResponse queryProduceList(shared_ptr<QueryProduceListRequest> request);
  QueryQrCodeUploadStatusResponse queryQrCodeUploadStatusWithOptions(shared_ptr<QueryQrCodeUploadStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryQrCodeUploadStatusResponse queryQrCodeUploadStatus(shared_ptr<QueryQrCodeUploadStatusRequest> request);
  QuerySbjRuleResponse querySbjRuleWithOptions(shared_ptr<QuerySbjRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySbjRuleResponse querySbjRule(shared_ptr<QuerySbjRuleRequest> request);
  QuerySupplementDetailResponse querySupplementDetailWithOptions(shared_ptr<QuerySupplementDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySupplementDetailResponse querySupplementDetail(shared_ptr<QuerySupplementDetailRequest> request);
  QueryTaskListResponse queryTaskListWithOptions(shared_ptr<QueryTaskListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTaskListResponse queryTaskList(shared_ptr<QueryTaskListRequest> request);
  QueryTmCollectionPageListResponse queryTmCollectionPageListWithOptions(shared_ptr<QueryTmCollectionPageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTmCollectionPageListResponse queryTmCollectionPageList(shared_ptr<QueryTmCollectionPageListRequest> request);
  QueryTmSbjProduceResponse queryTmSbjProduceWithOptions(shared_ptr<QueryTmSbjProduceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTmSbjProduceResponse queryTmSbjProduce(shared_ptr<QueryTmSbjProduceRequest> request);
  QueryTmSbjProduceDetailResponse queryTmSbjProduceDetailWithOptions(shared_ptr<QueryTmSbjProduceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTmSbjProduceDetailResponse queryTmSbjProduceDetail(shared_ptr<QueryTmSbjProduceDetailRequest> request);
  QueryTradeIntentionUserListResponse queryTradeIntentionUserListWithOptions(shared_ptr<QueryTradeIntentionUserListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTradeIntentionUserListResponse queryTradeIntentionUserList(shared_ptr<QueryTradeIntentionUserListRequest> request);
  QueryTradeMarkApplicationDetailResponse queryTradeMarkApplicationDetailWithOptions(shared_ptr<QueryTradeMarkApplicationDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTradeMarkApplicationDetailResponse queryTradeMarkApplicationDetail(shared_ptr<QueryTradeMarkApplicationDetailRequest> request);
  QueryTradeMarkApplicationLogsResponse queryTradeMarkApplicationLogsWithOptions(shared_ptr<QueryTradeMarkApplicationLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTradeMarkApplicationLogsResponse queryTradeMarkApplicationLogs(shared_ptr<QueryTradeMarkApplicationLogsRequest> request);
  QueryTradeMarkApplicationsResponse queryTradeMarkApplicationsWithOptions(shared_ptr<QueryTradeMarkApplicationsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTradeMarkApplicationsResponse queryTradeMarkApplications(shared_ptr<QueryTradeMarkApplicationsRequest> request);
  QueryTradeMarkApplicationsByIntentionResponse queryTradeMarkApplicationsByIntentionWithOptions(shared_ptr<QueryTradeMarkApplicationsByIntentionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTradeMarkApplicationsByIntentionResponse queryTradeMarkApplicationsByIntention(shared_ptr<QueryTradeMarkApplicationsByIntentionRequest> request);
  QueryTradeProduceDetailResponse queryTradeProduceDetailWithOptions(shared_ptr<QueryTradeProduceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTradeProduceDetailResponse queryTradeProduceDetail(shared_ptr<QueryTradeProduceDetailRequest> request);
  QueryTradeProduceListResponse queryTradeProduceListWithOptions(shared_ptr<QueryTradeProduceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTradeProduceListResponse queryTradeProduceList(shared_ptr<QueryTradeProduceListRequest> request);
  QueryTrademarkDetailByApplyNumberResponse queryTrademarkDetailByApplyNumberWithOptions(shared_ptr<QueryTrademarkDetailByApplyNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTrademarkDetailByApplyNumberResponse queryTrademarkDetailByApplyNumber(shared_ptr<QueryTrademarkDetailByApplyNumberRequest> request);
  QueryTrademarkDetailByApplyNumberEspResponse queryTrademarkDetailByApplyNumberEspWithOptions(shared_ptr<QueryTrademarkDetailByApplyNumberEspRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTrademarkDetailByApplyNumberEspResponse queryTrademarkDetailByApplyNumberEsp(shared_ptr<QueryTrademarkDetailByApplyNumberEspRequest> request);
  QueryTrademarkModelDetailResponse queryTrademarkModelDetailWithOptions(shared_ptr<QueryTrademarkModelDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTrademarkModelDetailResponse queryTrademarkModelDetail(shared_ptr<QueryTrademarkModelDetailRequest> request);
  QueryTrademarkModelEspDetailResponse queryTrademarkModelEspDetailWithOptions(shared_ptr<QueryTrademarkModelEspDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTrademarkModelEspDetailResponse queryTrademarkModelEspDetail(shared_ptr<QueryTrademarkModelEspDetailRequest> request);
  QueryTrademarkModelEspListResponse queryTrademarkModelEspListWithOptions(shared_ptr<QueryTrademarkModelEspListRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTrademarkModelEspListResponse queryTrademarkModelEspList(shared_ptr<QueryTrademarkModelEspListRequest> request);
  QueryTrademarkModelListResponse queryTrademarkModelListWithOptions(shared_ptr<QueryTrademarkModelListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTrademarkModelListResponse queryTrademarkModelList(shared_ptr<QueryTrademarkModelListRequest> request);
  QueryTrademarkMonitorResultsResponse queryTrademarkMonitorResultsWithOptions(shared_ptr<QueryTrademarkMonitorResultsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTrademarkMonitorResultsResponse queryTrademarkMonitorResults(shared_ptr<QueryTrademarkMonitorResultsRequest> request);
  QueryTrademarkMonitorRulesResponse queryTrademarkMonitorRulesWithOptions(shared_ptr<QueryTrademarkMonitorRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTrademarkMonitorRulesResponse queryTrademarkMonitorRules(shared_ptr<QueryTrademarkMonitorRulesRequest> request);
  QueryTrademarkOnSaleResponse queryTrademarkOnSaleWithOptions(shared_ptr<QueryTrademarkOnSaleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTrademarkOnSaleResponse queryTrademarkOnSale(shared_ptr<QueryTrademarkOnSaleRequest> request);
  QueryTrademarkPriceResponse queryTrademarkPriceWithOptions(shared_ptr<QueryTrademarkPriceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTrademarkPriceResponse queryTrademarkPrice(shared_ptr<QueryTrademarkPriceRequest> request);
  QueryTrademarkUploadAuditResultResponse queryTrademarkUploadAuditResultWithOptions(shared_ptr<QueryTrademarkUploadAuditResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTrademarkUploadAuditResultResponse queryTrademarkUploadAuditResult(shared_ptr<QueryTrademarkUploadAuditResultRequest> request);
  RecordBankBalanceResponse recordBankBalanceWithOptions(shared_ptr<RecordBankBalanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecordBankBalanceResponse recordBankBalance(shared_ptr<RecordBankBalanceRequest> request);
  RefundProduceResponse refundProduceWithOptions(shared_ptr<RefundProduceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefundProduceResponse refundProduce(shared_ptr<RefundProduceRequest> request);
  RefuseAdditionalMaterialResponse refuseAdditionalMaterialWithOptions(shared_ptr<RefuseAdditionalMaterialRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefuseAdditionalMaterialResponse refuseAdditionalMaterial(shared_ptr<RefuseAdditionalMaterialRequest> request);
  RefuseApplicantResponse refuseApplicantWithOptions(shared_ptr<RefuseApplicantRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefuseApplicantResponse refuseApplicant(shared_ptr<RefuseApplicantRequest> request);
  RejectApplicantResponse rejectApplicantWithOptions(shared_ptr<RejectApplicantRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RejectApplicantResponse rejectApplicant(shared_ptr<RejectApplicantRequest> request);
  SaveClassificationConditionsResponse saveClassificationConditionsWithOptions(shared_ptr<SaveClassificationConditionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveClassificationConditionsResponse saveClassificationConditions(shared_ptr<SaveClassificationConditionsRequest> request);
  SaveExtensionAttributeResponse saveExtensionAttributeWithOptions(shared_ptr<SaveExtensionAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveExtensionAttributeResponse saveExtensionAttribute(shared_ptr<SaveExtensionAttributeRequest> request);
  SaveTaskResponse saveTaskWithOptions(shared_ptr<SaveTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveTaskResponse saveTask(shared_ptr<SaveTaskRequest> request);
  SaveTaskForOfficialFileCustomResponse saveTaskForOfficialFileCustomWithOptions(shared_ptr<SaveTaskForOfficialFileCustomRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveTaskForOfficialFileCustomResponse saveTaskForOfficialFileCustom(shared_ptr<SaveTaskForOfficialFileCustomRequest> request);
  SaveTradeMarkReviewMaterialDetailResponse saveTradeMarkReviewMaterialDetailWithOptions(shared_ptr<SaveTradeMarkReviewMaterialDetailRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveTradeMarkReviewMaterialDetailResponse saveTradeMarkReviewMaterialDetail(shared_ptr<SaveTradeMarkReviewMaterialDetailRequest> request);
  SbjOperateResponse sbjOperateWithOptions(shared_ptr<SbjOperateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SbjOperateResponse sbjOperate(shared_ptr<SbjOperateRequest> request);
  SbjOperateNewResponse sbjOperateNewWithOptions(shared_ptr<SbjOperateNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SbjOperateNewResponse sbjOperateNew(shared_ptr<SbjOperateNewRequest> request);
  SbrainServiceExecuteResponse sbrainServiceExecuteWithOptions(shared_ptr<SbrainServiceExecuteRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SbrainServiceExecuteResponse sbrainServiceExecute(shared_ptr<SbrainServiceExecuteRequest> request);
  SbrainServiceHasRunningTaskBatchQueryResponse sbrainServiceHasRunningTaskBatchQueryWithOptions(shared_ptr<SbrainServiceHasRunningTaskBatchQueryRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SbrainServiceHasRunningTaskBatchQueryResponse sbrainServiceHasRunningTaskBatchQuery(shared_ptr<SbrainServiceHasRunningTaskBatchQueryRequest> request);
  SbrainServiceSchemeMatchResponse sbrainServiceSchemeMatchWithOptions(shared_ptr<SbrainServiceSchemeMatchRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SbrainServiceSchemeMatchResponse sbrainServiceSchemeMatch(shared_ptr<SbrainServiceSchemeMatchRequest> request);
  SearchTmOnsalesResponse searchTmOnsalesWithOptions(shared_ptr<SearchTmOnsalesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTmOnsalesResponse searchTmOnsales(shared_ptr<SearchTmOnsalesRequest> request);
  StartNotaryResponse startNotaryWithOptions(shared_ptr<StartNotaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartNotaryResponse startNotary(shared_ptr<StartNotaryRequest> request);
  StoreMaterialTemporarilyResponse storeMaterialTemporarilyWithOptions(shared_ptr<StoreMaterialTemporarilyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StoreMaterialTemporarilyResponse storeMaterialTemporarily(shared_ptr<StoreMaterialTemporarilyRequest> request);
  SubmitSupplementResponse submitSupplementWithOptions(shared_ptr<SubmitSupplementRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSupplementResponse submitSupplement(shared_ptr<SubmitSupplementRequest> request);
  SubmitTrademarkApplicationComplaintResponse submitTrademarkApplicationComplaintWithOptions(shared_ptr<SubmitTrademarkApplicationComplaintRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitTrademarkApplicationComplaintResponse submitTrademarkApplicationComplaint(shared_ptr<SubmitTrademarkApplicationComplaintRequest> request);
  SyncTrademarkResponse syncTrademarkWithOptions(shared_ptr<SyncTrademarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncTrademarkResponse syncTrademark(shared_ptr<SyncTrademarkRequest> request);
  UpdateApplicantContacterResponse updateApplicantContacterWithOptions(shared_ptr<UpdateApplicantContacterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApplicantContacterResponse updateApplicantContacter(shared_ptr<UpdateApplicantContacterRequest> request);
  UpdateMaterialResponse updateMaterialWithOptions(shared_ptr<UpdateMaterialRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMaterialResponse updateMaterial(shared_ptr<UpdateMaterialRequest> request);
  UpdateProduceResponse updateProduceWithOptions(shared_ptr<UpdateProduceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProduceResponse updateProduce(shared_ptr<UpdateProduceRequest> request);
  UpdateProduceLoaIdResponse updateProduceLoaIdWithOptions(shared_ptr<UpdateProduceLoaIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProduceLoaIdResponse updateProduceLoaId(shared_ptr<UpdateProduceLoaIdRequest> request);
  UpdateSendMaterialNumResponse updateSendMaterialNumWithOptions(shared_ptr<UpdateSendMaterialNumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSendMaterialNumResponse updateSendMaterialNum(shared_ptr<UpdateSendMaterialNumRequest> request);
  UpdateTrademarkNameResponse updateTrademarkNameWithOptions(shared_ptr<UpdateTrademarkNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTrademarkNameResponse updateTrademarkName(shared_ptr<UpdateTrademarkNameRequest> request);
  UpdateTrademarkOnsaleResponse updateTrademarkOnsaleWithOptions(shared_ptr<UpdateTrademarkOnsaleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTrademarkOnsaleResponse updateTrademarkOnsale(shared_ptr<UpdateTrademarkOnsaleRequest> request);
  UploadNotaryDataResponse uploadNotaryDataWithOptions(shared_ptr<UploadNotaryDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadNotaryDataResponse uploadNotaryData(shared_ptr<UploadNotaryDataRequest> request);
  UploadTrademarkOnSaleResponse uploadTrademarkOnSaleWithOptions(shared_ptr<UploadTrademarkOnSaleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadTrademarkOnSaleResponse uploadTrademarkOnSale(shared_ptr<UploadTrademarkOnSaleRequest> request);
  WriteCommunicationLogResponse writeCommunicationLogWithOptions(shared_ptr<WriteCommunicationLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  WriteCommunicationLogResponse writeCommunicationLog(shared_ptr<WriteCommunicationLogRequest> request);
  WriteIntentionCommunicationLogResponse writeIntentionCommunicationLogWithOptions(shared_ptr<WriteIntentionCommunicationLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  WriteIntentionCommunicationLogResponse writeIntentionCommunicationLog(shared_ptr<WriteIntentionCommunicationLogRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Trademark20180724

#endif
