// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_BTRIPOPEN20220520_H_
#define ALIBABACLOUD_BTRIPOPEN20220520_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_BtripOpen20220520 {
class AccessTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> appSecret{};

  AccessTokenRequest() {}

  explicit AccessTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["app_key"] = boost::any(*appKey);
    }
    if (appSecret) {
      res["app_secret"] = boost::any(*appSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("app_key") != m.end() && !m["app_key"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["app_key"]));
    }
    if (m.find("app_secret") != m.end() && !m["app_secret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["app_secret"]));
    }
  }


  virtual ~AccessTokenRequest() = default;
};
class AccessTokenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> expire{};
  shared_ptr<string> token{};

  AccessTokenResponseBodyData() {}

  explicit AccessTokenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expire) {
      res["expire"] = boost::any(*expire);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expire") != m.end() && !m["expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["expire"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~AccessTokenResponseBodyData() = default;
};
class AccessTokenResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> expire{};
  shared_ptr<long> start{};
  shared_ptr<string> token{};

  AccessTokenResponseBodyModule() {}

  explicit AccessTokenResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expire) {
      res["expire"] = boost::any(*expire);
    }
    if (start) {
      res["start"] = boost::any(*start);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expire") != m.end() && !m["expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["expire"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["start"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~AccessTokenResponseBodyModule() = default;
};
class AccessTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<AccessTokenResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<AccessTokenResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<string> traceId{};

  AccessTokenResponseBody() {}

  explicit AccessTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        AccessTokenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<AccessTokenResponseBodyData>(model1);
      }
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        AccessTokenResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<AccessTokenResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~AccessTokenResponseBody() = default;
};
class AccessTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AccessTokenResponseBody> body{};

  AccessTokenResponse() {}

  explicit AccessTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AccessTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AccessTokenResponseBody>(model1);
      }
    }
  }


  virtual ~AccessTokenResponse() = default;
};
class AddressGetHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  AddressGetHeaders() {}

  explicit AddressGetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~AddressGetHeaders() = default;
};
class AddressGetRequest : public Darabonba::Model {
public:
  shared_ptr<long> actionType{};
  shared_ptr<string> itineraryId{};
  shared_ptr<string> phone{};
  shared_ptr<string> subCorpId{};
  shared_ptr<long> type{};
  shared_ptr<string> userId{};

  AddressGetRequest() {}

  explicit AddressGetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionType) {
      res["action_type"] = boost::any(*actionType);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action_type") != m.end() && !m["action_type"].empty()) {
      actionType = make_shared<long>(boost::any_cast<long>(m["action_type"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~AddressGetRequest() = default;
};
class AddressGetResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> url{};

  AddressGetResponseBodyModule() {}

  explicit AddressGetResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~AddressGetResponseBodyModule() = default;
};
class AddressGetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<AddressGetResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  AddressGetResponseBody() {}

  explicit AddressGetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        AddressGetResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<AddressGetResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~AddressGetResponseBody() = default;
};
class AddressGetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddressGetResponseBody> body{};

  AddressGetResponse() {}

  explicit AddressGetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddressGetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddressGetResponseBody>(model1);
      }
    }
  }


  virtual ~AddressGetResponse() = default;
};
class AirportSearchHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  AirportSearchHeaders() {}

  explicit AirportSearchHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~AirportSearchHeaders() = default;
};
class AirportSearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> type{};

  AirportSearchRequest() {}

  explicit AirportSearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["keyword"] = boost::any(*keyword);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("keyword") != m.end() && !m["keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["keyword"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~AirportSearchRequest() = default;
};
class AirportSearchResponseBodyModuleCities : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> distance{};
  shared_ptr<string> name{};
  shared_ptr<string> travelName{};

  AirportSearchResponseBodyModuleCities() {}

  explicit AirportSearchResponseBodyModuleCities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (distance) {
      res["distance"] = boost::any(*distance);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (travelName) {
      res["travel_name"] = boost::any(*travelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("distance") != m.end() && !m["distance"].empty()) {
      distance = make_shared<long>(boost::any_cast<long>(m["distance"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("travel_name") != m.end() && !m["travel_name"].empty()) {
      travelName = make_shared<string>(boost::any_cast<string>(m["travel_name"]));
    }
  }


  virtual ~AirportSearchResponseBodyModuleCities() = default;
};
class AirportSearchResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<AirportSearchResponseBodyModuleCities>> cities{};
  shared_ptr<bool> nearby{};

  AirportSearchResponseBodyModule() {}

  explicit AirportSearchResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cities) {
      vector<boost::any> temp1;
      for(auto item1:*cities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cities"] = boost::any(temp1);
    }
    if (nearby) {
      res["nearby"] = boost::any(*nearby);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cities") != m.end() && !m["cities"].empty()) {
      if (typeid(vector<boost::any>) == m["cities"].type()) {
        vector<AirportSearchResponseBodyModuleCities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AirportSearchResponseBodyModuleCities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cities = make_shared<vector<AirportSearchResponseBodyModuleCities>>(expect1);
      }
    }
    if (m.find("nearby") != m.end() && !m["nearby"].empty()) {
      nearby = make_shared<bool>(boost::any_cast<bool>(m["nearby"]));
    }
  }


  virtual ~AirportSearchResponseBodyModule() = default;
};
class AirportSearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<AirportSearchResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  AirportSearchResponseBody() {}

  explicit AirportSearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        AirportSearchResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<AirportSearchResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~AirportSearchResponseBody() = default;
};
class AirportSearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AirportSearchResponseBody> body{};

  AirportSearchResponse() {}

  explicit AirportSearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AirportSearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AirportSearchResponseBody>(model1);
      }
    }
  }


  virtual ~AirportSearchResponse() = default;
};
class AllBaseCityInfoQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripAccessToken{};

  AllBaseCityInfoQueryHeaders() {}

  explicit AllBaseCityInfoQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripAccessToken) {
      res["x-acs-btrip-access-token"] = boost::any(*xAcsBtripAccessToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-access-token") != m.end() && !m["x-acs-btrip-access-token"].empty()) {
      xAcsBtripAccessToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-access-token"]));
    }
  }


  virtual ~AllBaseCityInfoQueryHeaders() = default;
};
class AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList : public Darabonba::Model {
public:
  shared_ptr<string> adcode{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityLevel{};
  shared_ptr<string> cityName{};
  shared_ptr<string> cnNameTree{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> otherNameList{};

  AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList() {}

  explicit AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adcode) {
      res["adcode"] = boost::any(*adcode);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityLevel) {
      res["city_level"] = boost::any(*cityLevel);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (cnNameTree) {
      res["cn_name_tree"] = boost::any(*cnNameTree);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (otherNameList) {
      res["other_name_list"] = boost::any(*otherNameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("adcode") != m.end() && !m["adcode"].empty()) {
      adcode = make_shared<string>(boost::any_cast<string>(m["adcode"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_level") != m.end() && !m["city_level"].empty()) {
      cityLevel = make_shared<string>(boost::any_cast<string>(m["city_level"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("cn_name_tree") != m.end() && !m["cn_name_tree"].empty()) {
      cnNameTree = make_shared<string>(boost::any_cast<string>(m["cn_name_tree"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("other_name_list") != m.end() && !m["other_name_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["other_name_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["other_name_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      otherNameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList() = default;
};
class AllBaseCityInfoQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList>> allCityBaseInfoList{};

  AllBaseCityInfoQueryResponseBodyModule() {}

  explicit AllBaseCityInfoQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allCityBaseInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*allCityBaseInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["all_city_base_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_city_base_info_list") != m.end() && !m["all_city_base_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["all_city_base_info_list"].type()) {
        vector<AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["all_city_base_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allCityBaseInfoList = make_shared<vector<AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList>>(expect1);
      }
    }
  }


  virtual ~AllBaseCityInfoQueryResponseBodyModule() = default;
};
class AllBaseCityInfoQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<AllBaseCityInfoQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  AllBaseCityInfoQueryResponseBody() {}

  explicit AllBaseCityInfoQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        AllBaseCityInfoQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<AllBaseCityInfoQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~AllBaseCityInfoQueryResponseBody() = default;
};
class AllBaseCityInfoQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AllBaseCityInfoQueryResponseBody> body{};

  AllBaseCityInfoQueryResponse() {}

  explicit AllBaseCityInfoQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllBaseCityInfoQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllBaseCityInfoQueryResponseBody>(model1);
      }
    }
  }


  virtual ~AllBaseCityInfoQueryResponse() = default;
};
class ApplyAddHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ApplyAddHeaders() {}

  explicit ApplyAddHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ApplyAddHeaders() = default;
};
class ApplyAddRequestExternalTravelerList : public Darabonba::Model {
public:
  shared_ptr<string> userName{};

  ApplyAddRequestExternalTravelerList() {}

  explicit ApplyAddRequestExternalTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyAddRequestExternalTravelerList() = default;
};
class ApplyAddRequestExternalTravelerStandardHotelCitys : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> fee{};

  ApplyAddRequestExternalTravelerStandardHotelCitys() {}

  explicit ApplyAddRequestExternalTravelerStandardHotelCitys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
  }


  virtual ~ApplyAddRequestExternalTravelerStandardHotelCitys() = default;
};
class ApplyAddRequestExternalTravelerStandard : public Darabonba::Model {
public:
  shared_ptr<long> businessDiscount{};
  shared_ptr<long> economyDiscount{};
  shared_ptr<long> firstDiscount{};
  shared_ptr<string> flightCabins{};
  shared_ptr<vector<ApplyAddRequestExternalTravelerStandardHotelCitys>> hotelCitys{};
  shared_ptr<long> premiumEconomyDiscount{};
  shared_ptr<long> reserveType{};
  shared_ptr<string> trainSeats{};

  ApplyAddRequestExternalTravelerStandard() {}

  explicit ApplyAddRequestExternalTravelerStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessDiscount) {
      res["business_discount"] = boost::any(*businessDiscount);
    }
    if (economyDiscount) {
      res["economy_discount"] = boost::any(*economyDiscount);
    }
    if (firstDiscount) {
      res["first_discount"] = boost::any(*firstDiscount);
    }
    if (flightCabins) {
      res["flight_cabins"] = boost::any(*flightCabins);
    }
    if (hotelCitys) {
      vector<boost::any> temp1;
      for(auto item1:*hotelCitys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_citys"] = boost::any(temp1);
    }
    if (premiumEconomyDiscount) {
      res["premium_economy_discount"] = boost::any(*premiumEconomyDiscount);
    }
    if (reserveType) {
      res["reserve_type"] = boost::any(*reserveType);
    }
    if (trainSeats) {
      res["train_seats"] = boost::any(*trainSeats);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_discount") != m.end() && !m["business_discount"].empty()) {
      businessDiscount = make_shared<long>(boost::any_cast<long>(m["business_discount"]));
    }
    if (m.find("economy_discount") != m.end() && !m["economy_discount"].empty()) {
      economyDiscount = make_shared<long>(boost::any_cast<long>(m["economy_discount"]));
    }
    if (m.find("first_discount") != m.end() && !m["first_discount"].empty()) {
      firstDiscount = make_shared<long>(boost::any_cast<long>(m["first_discount"]));
    }
    if (m.find("flight_cabins") != m.end() && !m["flight_cabins"].empty()) {
      flightCabins = make_shared<string>(boost::any_cast<string>(m["flight_cabins"]));
    }
    if (m.find("hotel_citys") != m.end() && !m["hotel_citys"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_citys"].type()) {
        vector<ApplyAddRequestExternalTravelerStandardHotelCitys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_citys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestExternalTravelerStandardHotelCitys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelCitys = make_shared<vector<ApplyAddRequestExternalTravelerStandardHotelCitys>>(expect1);
      }
    }
    if (m.find("premium_economy_discount") != m.end() && !m["premium_economy_discount"].empty()) {
      premiumEconomyDiscount = make_shared<long>(boost::any_cast<long>(m["premium_economy_discount"]));
    }
    if (m.find("reserve_type") != m.end() && !m["reserve_type"].empty()) {
      reserveType = make_shared<long>(boost::any_cast<long>(m["reserve_type"]));
    }
    if (m.find("train_seats") != m.end() && !m["train_seats"].empty()) {
      trainSeats = make_shared<string>(boost::any_cast<string>(m["train_seats"]));
    }
  }


  virtual ~ApplyAddRequestExternalTravelerStandard() = default;
};
class ApplyAddRequestHotelShare : public Darabonba::Model {
public:
  shared_ptr<string> param{};
  shared_ptr<string> type{};

  ApplyAddRequestHotelShare() {}

  explicit ApplyAddRequestHotelShare(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (param) {
      res["param"] = boost::any(*param);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("param") != m.end() && !m["param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["param"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ApplyAddRequestHotelShare() = default;
};
class ApplyAddRequestItineraryList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrDate{};
  shared_ptr<long> costCenterId{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<long> invoiceId{};
  shared_ptr<string> itineraryId{};
  shared_ptr<bool> needHotel{};
  shared_ptr<bool> needTraffic{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<long> trafficType{};
  shared_ptr<long> tripWay{};

  ApplyAddRequestItineraryList() {}

  explicit ApplyAddRequestItineraryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceId) {
      res["invoice_id"] = boost::any(*invoiceId);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (needHotel) {
      res["need_hotel"] = boost::any(*needHotel);
    }
    if (needTraffic) {
      res["need_traffic"] = boost::any(*needTraffic);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    if (tripWay) {
      res["trip_way"] = boost::any(*tripWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_id") != m.end() && !m["invoice_id"].empty()) {
      invoiceId = make_shared<long>(boost::any_cast<long>(m["invoice_id"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("need_hotel") != m.end() && !m["need_hotel"].empty()) {
      needHotel = make_shared<bool>(boost::any_cast<bool>(m["need_hotel"]));
    }
    if (m.find("need_traffic") != m.end() && !m["need_traffic"].empty()) {
      needTraffic = make_shared<bool>(boost::any_cast<bool>(m["need_traffic"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
    if (m.find("trip_way") != m.end() && !m["trip_way"].empty()) {
      tripWay = make_shared<long>(boost::any_cast<long>(m["trip_way"]));
    }
  }


  virtual ~ApplyAddRequestItineraryList() = default;
};
class ApplyAddRequestItinerarySetList : public Darabonba::Model {
public:
  shared_ptr<string> arrDate{};
  shared_ptr<string> cityCodeSet{};
  shared_ptr<string> citySet{};
  shared_ptr<long> costCenterId{};
  shared_ptr<string> depDate{};
  shared_ptr<long> invoiceId{};
  shared_ptr<string> itineraryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<long> trafficType{};

  ApplyAddRequestItinerarySetList() {}

  explicit ApplyAddRequestItinerarySetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (cityCodeSet) {
      res["city_code_set"] = boost::any(*cityCodeSet);
    }
    if (citySet) {
      res["city_set"] = boost::any(*citySet);
    }
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceId) {
      res["invoice_id"] = boost::any(*invoiceId);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("city_code_set") != m.end() && !m["city_code_set"].empty()) {
      cityCodeSet = make_shared<string>(boost::any_cast<string>(m["city_code_set"]));
    }
    if (m.find("city_set") != m.end() && !m["city_set"].empty()) {
      citySet = make_shared<string>(boost::any_cast<string>(m["city_set"]));
    }
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_id") != m.end() && !m["invoice_id"].empty()) {
      invoiceId = make_shared<long>(boost::any_cast<long>(m["invoice_id"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
  }


  virtual ~ApplyAddRequestItinerarySetList() = default;
};
class ApplyAddRequestTravelerList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyAddRequestTravelerList() {}

  explicit ApplyAddRequestTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyAddRequestTravelerList() = default;
};
class ApplyAddRequestTravelerStandardHotelCitys : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> fee{};

  ApplyAddRequestTravelerStandardHotelCitys() {}

  explicit ApplyAddRequestTravelerStandardHotelCitys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
  }


  virtual ~ApplyAddRequestTravelerStandardHotelCitys() = default;
};
class ApplyAddRequestTravelerStandard : public Darabonba::Model {
public:
  shared_ptr<long> businessDiscount{};
  shared_ptr<long> economyDiscount{};
  shared_ptr<long> firstDiscount{};
  shared_ptr<string> flightCabins{};
  shared_ptr<vector<ApplyAddRequestTravelerStandardHotelCitys>> hotelCitys{};
  shared_ptr<long> premiumEconomyDiscount{};
  shared_ptr<long> reserveType{};
  shared_ptr<string> trainSeats{};
  shared_ptr<string> userId{};

  ApplyAddRequestTravelerStandard() {}

  explicit ApplyAddRequestTravelerStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessDiscount) {
      res["business_discount"] = boost::any(*businessDiscount);
    }
    if (economyDiscount) {
      res["economy_discount"] = boost::any(*economyDiscount);
    }
    if (firstDiscount) {
      res["first_discount"] = boost::any(*firstDiscount);
    }
    if (flightCabins) {
      res["flight_cabins"] = boost::any(*flightCabins);
    }
    if (hotelCitys) {
      vector<boost::any> temp1;
      for(auto item1:*hotelCitys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_citys"] = boost::any(temp1);
    }
    if (premiumEconomyDiscount) {
      res["premium_economy_discount"] = boost::any(*premiumEconomyDiscount);
    }
    if (reserveType) {
      res["reserve_type"] = boost::any(*reserveType);
    }
    if (trainSeats) {
      res["train_seats"] = boost::any(*trainSeats);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_discount") != m.end() && !m["business_discount"].empty()) {
      businessDiscount = make_shared<long>(boost::any_cast<long>(m["business_discount"]));
    }
    if (m.find("economy_discount") != m.end() && !m["economy_discount"].empty()) {
      economyDiscount = make_shared<long>(boost::any_cast<long>(m["economy_discount"]));
    }
    if (m.find("first_discount") != m.end() && !m["first_discount"].empty()) {
      firstDiscount = make_shared<long>(boost::any_cast<long>(m["first_discount"]));
    }
    if (m.find("flight_cabins") != m.end() && !m["flight_cabins"].empty()) {
      flightCabins = make_shared<string>(boost::any_cast<string>(m["flight_cabins"]));
    }
    if (m.find("hotel_citys") != m.end() && !m["hotel_citys"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_citys"].type()) {
        vector<ApplyAddRequestTravelerStandardHotelCitys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_citys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestTravelerStandardHotelCitys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelCitys = make_shared<vector<ApplyAddRequestTravelerStandardHotelCitys>>(expect1);
      }
    }
    if (m.find("premium_economy_discount") != m.end() && !m["premium_economy_discount"].empty()) {
      premiumEconomyDiscount = make_shared<long>(boost::any_cast<long>(m["premium_economy_discount"]));
    }
    if (m.find("reserve_type") != m.end() && !m["reserve_type"].empty()) {
      reserveType = make_shared<long>(boost::any_cast<long>(m["reserve_type"]));
    }
    if (m.find("train_seats") != m.end() && !m["train_seats"].empty()) {
      trainSeats = make_shared<string>(boost::any_cast<string>(m["train_seats"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~ApplyAddRequestTravelerStandard() = default;
};
class ApplyAddRequest : public Darabonba::Model {
public:
  shared_ptr<long> budget{};
  shared_ptr<long> budgetMerge{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> extendField{};
  shared_ptr<vector<ApplyAddRequestExternalTravelerList>> externalTravelerList{};
  shared_ptr<ApplyAddRequestExternalTravelerStandard> externalTravelerStandard{};
  shared_ptr<long> flightBudget{};
  shared_ptr<long> hotelBudget{};
  shared_ptr<ApplyAddRequestHotelShare> hotelShare{};
  shared_ptr<string> internationalFlightCabins{};
  shared_ptr<vector<ApplyAddRequestItineraryList>> itineraryList{};
  shared_ptr<long> itineraryRule{};
  shared_ptr<vector<ApplyAddRequestItinerarySetList>> itinerarySetList{};
  shared_ptr<long> limitTraveler{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartBusinessId{};
  shared_ptr<string> thirdpartDepartId{};
  shared_ptr<long> togetherBookRule{};
  shared_ptr<long> trainBudget{};
  shared_ptr<vector<ApplyAddRequestTravelerList>> travelerList{};
  shared_ptr<vector<ApplyAddRequestTravelerStandard>> travelerStandard{};
  shared_ptr<string> tripCause{};
  shared_ptr<long> tripDay{};
  shared_ptr<string> tripTitle{};
  shared_ptr<long> type{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> vehicleBudget{};

  ApplyAddRequest() {}

  explicit ApplyAddRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (budget) {
      res["budget"] = boost::any(*budget);
    }
    if (budgetMerge) {
      res["budget_merge"] = boost::any(*budgetMerge);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (extendField) {
      res["extend_field"] = boost::any(*extendField);
    }
    if (externalTravelerList) {
      vector<boost::any> temp1;
      for(auto item1:*externalTravelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["external_traveler_list"] = boost::any(temp1);
    }
    if (externalTravelerStandard) {
      res["external_traveler_standard"] = externalTravelerStandard ? boost::any(externalTravelerStandard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightBudget) {
      res["flight_budget"] = boost::any(*flightBudget);
    }
    if (hotelBudget) {
      res["hotel_budget"] = boost::any(*hotelBudget);
    }
    if (hotelShare) {
      res["hotel_share"] = hotelShare ? boost::any(hotelShare->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (internationalFlightCabins) {
      res["international_flight_cabins"] = boost::any(*internationalFlightCabins);
    }
    if (itineraryList) {
      vector<boost::any> temp1;
      for(auto item1:*itineraryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_list"] = boost::any(temp1);
    }
    if (itineraryRule) {
      res["itinerary_rule"] = boost::any(*itineraryRule);
    }
    if (itinerarySetList) {
      vector<boost::any> temp1;
      for(auto item1:*itinerarySetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_set_list"] = boost::any(temp1);
    }
    if (limitTraveler) {
      res["limit_traveler"] = boost::any(*limitTraveler);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    if (thirdpartDepartId) {
      res["thirdpart_depart_id"] = boost::any(*thirdpartDepartId);
    }
    if (togetherBookRule) {
      res["together_book_rule"] = boost::any(*togetherBookRule);
    }
    if (trainBudget) {
      res["train_budget"] = boost::any(*trainBudget);
    }
    if (travelerList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_list"] = boost::any(temp1);
    }
    if (travelerStandard) {
      vector<boost::any> temp1;
      for(auto item1:*travelerStandard){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_standard"] = boost::any(temp1);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripDay) {
      res["trip_day"] = boost::any(*tripDay);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (vehicleBudget) {
      res["vehicle_budget"] = boost::any(*vehicleBudget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("budget") != m.end() && !m["budget"].empty()) {
      budget = make_shared<long>(boost::any_cast<long>(m["budget"]));
    }
    if (m.find("budget_merge") != m.end() && !m["budget_merge"].empty()) {
      budgetMerge = make_shared<long>(boost::any_cast<long>(m["budget_merge"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("extend_field") != m.end() && !m["extend_field"].empty()) {
      extendField = make_shared<string>(boost::any_cast<string>(m["extend_field"]));
    }
    if (m.find("external_traveler_list") != m.end() && !m["external_traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["external_traveler_list"].type()) {
        vector<ApplyAddRequestExternalTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["external_traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestExternalTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        externalTravelerList = make_shared<vector<ApplyAddRequestExternalTravelerList>>(expect1);
      }
    }
    if (m.find("external_traveler_standard") != m.end() && !m["external_traveler_standard"].empty()) {
      if (typeid(map<string, boost::any>) == m["external_traveler_standard"].type()) {
        ApplyAddRequestExternalTravelerStandard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["external_traveler_standard"]));
        externalTravelerStandard = make_shared<ApplyAddRequestExternalTravelerStandard>(model1);
      }
    }
    if (m.find("flight_budget") != m.end() && !m["flight_budget"].empty()) {
      flightBudget = make_shared<long>(boost::any_cast<long>(m["flight_budget"]));
    }
    if (m.find("hotel_budget") != m.end() && !m["hotel_budget"].empty()) {
      hotelBudget = make_shared<long>(boost::any_cast<long>(m["hotel_budget"]));
    }
    if (m.find("hotel_share") != m.end() && !m["hotel_share"].empty()) {
      if (typeid(map<string, boost::any>) == m["hotel_share"].type()) {
        ApplyAddRequestHotelShare model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["hotel_share"]));
        hotelShare = make_shared<ApplyAddRequestHotelShare>(model1);
      }
    }
    if (m.find("international_flight_cabins") != m.end() && !m["international_flight_cabins"].empty()) {
      internationalFlightCabins = make_shared<string>(boost::any_cast<string>(m["international_flight_cabins"]));
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_list"].type()) {
        vector<ApplyAddRequestItineraryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestItineraryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itineraryList = make_shared<vector<ApplyAddRequestItineraryList>>(expect1);
      }
    }
    if (m.find("itinerary_rule") != m.end() && !m["itinerary_rule"].empty()) {
      itineraryRule = make_shared<long>(boost::any_cast<long>(m["itinerary_rule"]));
    }
    if (m.find("itinerary_set_list") != m.end() && !m["itinerary_set_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_set_list"].type()) {
        vector<ApplyAddRequestItinerarySetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_set_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestItinerarySetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itinerarySetList = make_shared<vector<ApplyAddRequestItinerarySetList>>(expect1);
      }
    }
    if (m.find("limit_traveler") != m.end() && !m["limit_traveler"].empty()) {
      limitTraveler = make_shared<long>(boost::any_cast<long>(m["limit_traveler"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
    if (m.find("thirdpart_depart_id") != m.end() && !m["thirdpart_depart_id"].empty()) {
      thirdpartDepartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_depart_id"]));
    }
    if (m.find("together_book_rule") != m.end() && !m["together_book_rule"].empty()) {
      togetherBookRule = make_shared<long>(boost::any_cast<long>(m["together_book_rule"]));
    }
    if (m.find("train_budget") != m.end() && !m["train_budget"].empty()) {
      trainBudget = make_shared<long>(boost::any_cast<long>(m["train_budget"]));
    }
    if (m.find("traveler_list") != m.end() && !m["traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_list"].type()) {
        vector<ApplyAddRequestTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerList = make_shared<vector<ApplyAddRequestTravelerList>>(expect1);
      }
    }
    if (m.find("traveler_standard") != m.end() && !m["traveler_standard"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_standard"].type()) {
        vector<ApplyAddRequestTravelerStandard> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_standard"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestTravelerStandard model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerStandard = make_shared<vector<ApplyAddRequestTravelerStandard>>(expect1);
      }
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_day") != m.end() && !m["trip_day"].empty()) {
      tripDay = make_shared<long>(boost::any_cast<long>(m["trip_day"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("vehicle_budget") != m.end() && !m["vehicle_budget"].empty()) {
      vehicleBudget = make_shared<long>(boost::any_cast<long>(m["vehicle_budget"]));
    }
  }


  virtual ~ApplyAddRequest() = default;
};
class ApplyAddShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> budget{};
  shared_ptr<long> budgetMerge{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> extendField{};
  shared_ptr<string> externalTravelerListShrink{};
  shared_ptr<string> externalTravelerStandardShrink{};
  shared_ptr<long> flightBudget{};
  shared_ptr<long> hotelBudget{};
  shared_ptr<string> hotelShareShrink{};
  shared_ptr<string> internationalFlightCabins{};
  shared_ptr<string> itineraryListShrink{};
  shared_ptr<long> itineraryRule{};
  shared_ptr<string> itinerarySetListShrink{};
  shared_ptr<long> limitTraveler{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartBusinessId{};
  shared_ptr<string> thirdpartDepartId{};
  shared_ptr<long> togetherBookRule{};
  shared_ptr<long> trainBudget{};
  shared_ptr<string> travelerListShrink{};
  shared_ptr<string> travelerStandardShrink{};
  shared_ptr<string> tripCause{};
  shared_ptr<long> tripDay{};
  shared_ptr<string> tripTitle{};
  shared_ptr<long> type{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> vehicleBudget{};

  ApplyAddShrinkRequest() {}

  explicit ApplyAddShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (budget) {
      res["budget"] = boost::any(*budget);
    }
    if (budgetMerge) {
      res["budget_merge"] = boost::any(*budgetMerge);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (extendField) {
      res["extend_field"] = boost::any(*extendField);
    }
    if (externalTravelerListShrink) {
      res["external_traveler_list"] = boost::any(*externalTravelerListShrink);
    }
    if (externalTravelerStandardShrink) {
      res["external_traveler_standard"] = boost::any(*externalTravelerStandardShrink);
    }
    if (flightBudget) {
      res["flight_budget"] = boost::any(*flightBudget);
    }
    if (hotelBudget) {
      res["hotel_budget"] = boost::any(*hotelBudget);
    }
    if (hotelShareShrink) {
      res["hotel_share"] = boost::any(*hotelShareShrink);
    }
    if (internationalFlightCabins) {
      res["international_flight_cabins"] = boost::any(*internationalFlightCabins);
    }
    if (itineraryListShrink) {
      res["itinerary_list"] = boost::any(*itineraryListShrink);
    }
    if (itineraryRule) {
      res["itinerary_rule"] = boost::any(*itineraryRule);
    }
    if (itinerarySetListShrink) {
      res["itinerary_set_list"] = boost::any(*itinerarySetListShrink);
    }
    if (limitTraveler) {
      res["limit_traveler"] = boost::any(*limitTraveler);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    if (thirdpartDepartId) {
      res["thirdpart_depart_id"] = boost::any(*thirdpartDepartId);
    }
    if (togetherBookRule) {
      res["together_book_rule"] = boost::any(*togetherBookRule);
    }
    if (trainBudget) {
      res["train_budget"] = boost::any(*trainBudget);
    }
    if (travelerListShrink) {
      res["traveler_list"] = boost::any(*travelerListShrink);
    }
    if (travelerStandardShrink) {
      res["traveler_standard"] = boost::any(*travelerStandardShrink);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripDay) {
      res["trip_day"] = boost::any(*tripDay);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (vehicleBudget) {
      res["vehicle_budget"] = boost::any(*vehicleBudget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("budget") != m.end() && !m["budget"].empty()) {
      budget = make_shared<long>(boost::any_cast<long>(m["budget"]));
    }
    if (m.find("budget_merge") != m.end() && !m["budget_merge"].empty()) {
      budgetMerge = make_shared<long>(boost::any_cast<long>(m["budget_merge"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("extend_field") != m.end() && !m["extend_field"].empty()) {
      extendField = make_shared<string>(boost::any_cast<string>(m["extend_field"]));
    }
    if (m.find("external_traveler_list") != m.end() && !m["external_traveler_list"].empty()) {
      externalTravelerListShrink = make_shared<string>(boost::any_cast<string>(m["external_traveler_list"]));
    }
    if (m.find("external_traveler_standard") != m.end() && !m["external_traveler_standard"].empty()) {
      externalTravelerStandardShrink = make_shared<string>(boost::any_cast<string>(m["external_traveler_standard"]));
    }
    if (m.find("flight_budget") != m.end() && !m["flight_budget"].empty()) {
      flightBudget = make_shared<long>(boost::any_cast<long>(m["flight_budget"]));
    }
    if (m.find("hotel_budget") != m.end() && !m["hotel_budget"].empty()) {
      hotelBudget = make_shared<long>(boost::any_cast<long>(m["hotel_budget"]));
    }
    if (m.find("hotel_share") != m.end() && !m["hotel_share"].empty()) {
      hotelShareShrink = make_shared<string>(boost::any_cast<string>(m["hotel_share"]));
    }
    if (m.find("international_flight_cabins") != m.end() && !m["international_flight_cabins"].empty()) {
      internationalFlightCabins = make_shared<string>(boost::any_cast<string>(m["international_flight_cabins"]));
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      itineraryListShrink = make_shared<string>(boost::any_cast<string>(m["itinerary_list"]));
    }
    if (m.find("itinerary_rule") != m.end() && !m["itinerary_rule"].empty()) {
      itineraryRule = make_shared<long>(boost::any_cast<long>(m["itinerary_rule"]));
    }
    if (m.find("itinerary_set_list") != m.end() && !m["itinerary_set_list"].empty()) {
      itinerarySetListShrink = make_shared<string>(boost::any_cast<string>(m["itinerary_set_list"]));
    }
    if (m.find("limit_traveler") != m.end() && !m["limit_traveler"].empty()) {
      limitTraveler = make_shared<long>(boost::any_cast<long>(m["limit_traveler"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
    if (m.find("thirdpart_depart_id") != m.end() && !m["thirdpart_depart_id"].empty()) {
      thirdpartDepartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_depart_id"]));
    }
    if (m.find("together_book_rule") != m.end() && !m["together_book_rule"].empty()) {
      togetherBookRule = make_shared<long>(boost::any_cast<long>(m["together_book_rule"]));
    }
    if (m.find("train_budget") != m.end() && !m["train_budget"].empty()) {
      trainBudget = make_shared<long>(boost::any_cast<long>(m["train_budget"]));
    }
    if (m.find("traveler_list") != m.end() && !m["traveler_list"].empty()) {
      travelerListShrink = make_shared<string>(boost::any_cast<string>(m["traveler_list"]));
    }
    if (m.find("traveler_standard") != m.end() && !m["traveler_standard"].empty()) {
      travelerStandardShrink = make_shared<string>(boost::any_cast<string>(m["traveler_standard"]));
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_day") != m.end() && !m["trip_day"].empty()) {
      tripDay = make_shared<long>(boost::any_cast<long>(m["trip_day"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("vehicle_budget") != m.end() && !m["vehicle_budget"].empty()) {
      vehicleBudget = make_shared<long>(boost::any_cast<long>(m["vehicle_budget"]));
    }
  }


  virtual ~ApplyAddShrinkRequest() = default;
};
class ApplyAddResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartBusinessId{};

  ApplyAddResponseBodyModule() {}

  explicit ApplyAddResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
  }


  virtual ~ApplyAddResponseBodyModule() = default;
};
class ApplyAddResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<ApplyAddResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ApplyAddResponseBody() {}

  explicit ApplyAddResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        ApplyAddResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<ApplyAddResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ApplyAddResponseBody() = default;
};
class ApplyAddResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyAddResponseBody> body{};

  ApplyAddResponse() {}

  explicit ApplyAddResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyAddResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyAddResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyAddResponse() = default;
};
class ApplyApproveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ApplyApproveHeaders() {}

  explicit ApplyApproveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ApplyApproveHeaders() = default;
};
class ApplyApproveRequest : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> note{};
  shared_ptr<string> operateTime{};
  shared_ptr<long> status{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyApproveRequest() {}

  explicit ApplyApproveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (note) {
      res["note"] = boost::any(*note);
    }
    if (operateTime) {
      res["operate_time"] = boost::any(*operateTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("note") != m.end() && !m["note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["note"]));
    }
    if (m.find("operate_time") != m.end() && !m["operate_time"].empty()) {
      operateTime = make_shared<string>(boost::any_cast<string>(m["operate_time"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyApproveRequest() = default;
};
class ApplyApproveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ApplyApproveResponseBody() {}

  explicit ApplyApproveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ApplyApproveResponseBody() = default;
};
class ApplyApproveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyApproveResponseBody> body{};

  ApplyApproveResponse() {}

  explicit ApplyApproveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyApproveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyApproveResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyApproveResponse() = default;
};
class ApplyInvoiceTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ApplyInvoiceTaskHeaders() {}

  explicit ApplyInvoiceTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ApplyInvoiceTaskHeaders() = default;
};
class ApplyInvoiceTaskRequestInvoiceTaskList : public Darabonba::Model {
public:
  shared_ptr<string> contact{};
  shared_ptr<string> email{};
  shared_ptr<string> flightInvoiceFee{};
  shared_ptr<string> fuPointInvoiceFee{};
  shared_ptr<string> hotelNormalInvoiceFee{};
  shared_ptr<string> hotelSpecialInvoiceFee{};
  shared_ptr<string> internationalFlightInvoiceFee{};
  shared_ptr<string> invoiceThirdPartId{};
  shared_ptr<string> mailAddress{};
  shared_ptr<string> mailCity{};
  shared_ptr<string> mailFullAddress{};
  shared_ptr<string> mailProvince{};
  shared_ptr<string> penaltyFee{};
  shared_ptr<string> remark{};
  shared_ptr<string> serviceFee{};
  shared_ptr<string> telephone{};
  shared_ptr<string> trainInvoiceFee{};
  shared_ptr<string> vehicleInvoiceFee{};

  ApplyInvoiceTaskRequestInvoiceTaskList() {}

  explicit ApplyInvoiceTaskRequestInvoiceTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contact) {
      res["contact"] = boost::any(*contact);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (flightInvoiceFee) {
      res["flight_invoice_fee"] = boost::any(*flightInvoiceFee);
    }
    if (fuPointInvoiceFee) {
      res["fu_point_invoice_fee"] = boost::any(*fuPointInvoiceFee);
    }
    if (hotelNormalInvoiceFee) {
      res["hotel_normal_invoice_fee"] = boost::any(*hotelNormalInvoiceFee);
    }
    if (hotelSpecialInvoiceFee) {
      res["hotel_special_invoice_fee"] = boost::any(*hotelSpecialInvoiceFee);
    }
    if (internationalFlightInvoiceFee) {
      res["international_flight_invoice_fee"] = boost::any(*internationalFlightInvoiceFee);
    }
    if (invoiceThirdPartId) {
      res["invoice_third_part_id"] = boost::any(*invoiceThirdPartId);
    }
    if (mailAddress) {
      res["mail_address"] = boost::any(*mailAddress);
    }
    if (mailCity) {
      res["mail_city"] = boost::any(*mailCity);
    }
    if (mailFullAddress) {
      res["mail_full_address"] = boost::any(*mailFullAddress);
    }
    if (mailProvince) {
      res["mail_province"] = boost::any(*mailProvince);
    }
    if (penaltyFee) {
      res["penalty_fee"] = boost::any(*penaltyFee);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (telephone) {
      res["telephone"] = boost::any(*telephone);
    }
    if (trainInvoiceFee) {
      res["train_invoice_fee"] = boost::any(*trainInvoiceFee);
    }
    if (vehicleInvoiceFee) {
      res["vehicle_invoice_fee"] = boost::any(*vehicleInvoiceFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact") != m.end() && !m["contact"].empty()) {
      contact = make_shared<string>(boost::any_cast<string>(m["contact"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("flight_invoice_fee") != m.end() && !m["flight_invoice_fee"].empty()) {
      flightInvoiceFee = make_shared<string>(boost::any_cast<string>(m["flight_invoice_fee"]));
    }
    if (m.find("fu_point_invoice_fee") != m.end() && !m["fu_point_invoice_fee"].empty()) {
      fuPointInvoiceFee = make_shared<string>(boost::any_cast<string>(m["fu_point_invoice_fee"]));
    }
    if (m.find("hotel_normal_invoice_fee") != m.end() && !m["hotel_normal_invoice_fee"].empty()) {
      hotelNormalInvoiceFee = make_shared<string>(boost::any_cast<string>(m["hotel_normal_invoice_fee"]));
    }
    if (m.find("hotel_special_invoice_fee") != m.end() && !m["hotel_special_invoice_fee"].empty()) {
      hotelSpecialInvoiceFee = make_shared<string>(boost::any_cast<string>(m["hotel_special_invoice_fee"]));
    }
    if (m.find("international_flight_invoice_fee") != m.end() && !m["international_flight_invoice_fee"].empty()) {
      internationalFlightInvoiceFee = make_shared<string>(boost::any_cast<string>(m["international_flight_invoice_fee"]));
    }
    if (m.find("invoice_third_part_id") != m.end() && !m["invoice_third_part_id"].empty()) {
      invoiceThirdPartId = make_shared<string>(boost::any_cast<string>(m["invoice_third_part_id"]));
    }
    if (m.find("mail_address") != m.end() && !m["mail_address"].empty()) {
      mailAddress = make_shared<string>(boost::any_cast<string>(m["mail_address"]));
    }
    if (m.find("mail_city") != m.end() && !m["mail_city"].empty()) {
      mailCity = make_shared<string>(boost::any_cast<string>(m["mail_city"]));
    }
    if (m.find("mail_full_address") != m.end() && !m["mail_full_address"].empty()) {
      mailFullAddress = make_shared<string>(boost::any_cast<string>(m["mail_full_address"]));
    }
    if (m.find("mail_province") != m.end() && !m["mail_province"].empty()) {
      mailProvince = make_shared<string>(boost::any_cast<string>(m["mail_province"]));
    }
    if (m.find("penalty_fee") != m.end() && !m["penalty_fee"].empty()) {
      penaltyFee = make_shared<string>(boost::any_cast<string>(m["penalty_fee"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<string>(boost::any_cast<string>(m["service_fee"]));
    }
    if (m.find("telephone") != m.end() && !m["telephone"].empty()) {
      telephone = make_shared<string>(boost::any_cast<string>(m["telephone"]));
    }
    if (m.find("train_invoice_fee") != m.end() && !m["train_invoice_fee"].empty()) {
      trainInvoiceFee = make_shared<string>(boost::any_cast<string>(m["train_invoice_fee"]));
    }
    if (m.find("vehicle_invoice_fee") != m.end() && !m["vehicle_invoice_fee"].empty()) {
      vehicleInvoiceFee = make_shared<string>(boost::any_cast<string>(m["vehicle_invoice_fee"]));
    }
  }


  virtual ~ApplyInvoiceTaskRequestInvoiceTaskList() = default;
};
class ApplyInvoiceTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};
  shared_ptr<vector<ApplyInvoiceTaskRequestInvoiceTaskList>> invoiceTaskList{};

  ApplyInvoiceTaskRequest() {}

  explicit ApplyInvoiceTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (invoiceTaskList) {
      vector<boost::any> temp1;
      for(auto item1:*invoiceTaskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["invoice_task_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("invoice_task_list") != m.end() && !m["invoice_task_list"].empty()) {
      if (typeid(vector<boost::any>) == m["invoice_task_list"].type()) {
        vector<ApplyInvoiceTaskRequestInvoiceTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["invoice_task_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyInvoiceTaskRequestInvoiceTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invoiceTaskList = make_shared<vector<ApplyInvoiceTaskRequestInvoiceTaskList>>(expect1);
      }
    }
  }


  virtual ~ApplyInvoiceTaskRequest() = default;
};
class ApplyInvoiceTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};
  shared_ptr<string> invoiceTaskListShrink{};

  ApplyInvoiceTaskShrinkRequest() {}

  explicit ApplyInvoiceTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (invoiceTaskListShrink) {
      res["invoice_task_list"] = boost::any(*invoiceTaskListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("invoice_task_list") != m.end() && !m["invoice_task_list"].empty()) {
      invoiceTaskListShrink = make_shared<string>(boost::any_cast<string>(m["invoice_task_list"]));
    }
  }


  virtual ~ApplyInvoiceTaskShrinkRequest() = default;
};
class ApplyInvoiceTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ApplyInvoiceTaskResponseBody() {}

  explicit ApplyInvoiceTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ApplyInvoiceTaskResponseBody() = default;
};
class ApplyInvoiceTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyInvoiceTaskResponseBody> body{};

  ApplyInvoiceTaskResponse() {}

  explicit ApplyInvoiceTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyInvoiceTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyInvoiceTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyInvoiceTaskResponse() = default;
};
class ApplyListQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ApplyListQueryHeaders() {}

  explicit ApplyListQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ApplyListQueryHeaders() = default;
};
class ApplyListQueryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allApply{};
  shared_ptr<string> departId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> gmtModified{};
  shared_ptr<bool> onlyShangLvApply{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<long> type{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};

  ApplyListQueryRequest() {}

  explicit ApplyListQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allApply) {
      res["all_apply"] = boost::any(*allApply);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (onlyShangLvApply) {
      res["only_shang_lv_apply"] = boost::any(*onlyShangLvApply);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_apply") != m.end() && !m["all_apply"].empty()) {
      allApply = make_shared<bool>(boost::any_cast<bool>(m["all_apply"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("only_shang_lv_apply") != m.end() && !m["only_shang_lv_apply"].empty()) {
      onlyShangLvApply = make_shared<bool>(boost::any_cast<bool>(m["only_shang_lv_apply"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~ApplyListQueryRequest() = default;
};
class ApplyListQueryResponseBodyModuleListApproverList : public Darabonba::Model {
public:
  shared_ptr<string> note{};
  shared_ptr<string> operateTime{};
  shared_ptr<long> order{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyListQueryResponseBodyModuleListApproverList() {}

  explicit ApplyListQueryResponseBodyModuleListApproverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (note) {
      res["note"] = boost::any(*note);
    }
    if (operateTime) {
      res["operate_time"] = boost::any(*operateTime);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["status_desc"] = boost::any(*statusDesc);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("note") != m.end() && !m["note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["note"]));
    }
    if (m.find("operate_time") != m.end() && !m["operate_time"].empty()) {
      operateTime = make_shared<string>(boost::any_cast<string>(m["operate_time"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["order"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("status_desc") != m.end() && !m["status_desc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["status_desc"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleListApproverList() = default;
};
class ApplyListQueryResponseBodyModuleListExternalTravelerList : public Darabonba::Model {
public:
  shared_ptr<string> userName{};

  ApplyListQueryResponseBodyModuleListExternalTravelerList() {}

  explicit ApplyListQueryResponseBodyModuleListExternalTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleListExternalTravelerList() = default;
};
class ApplyListQueryResponseBodyModuleListItineraryList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depDate{};
  shared_ptr<string> invoiceName{};
  shared_ptr<string> itineraryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<long> trafficType{};
  shared_ptr<long> tripWay{};

  ApplyListQueryResponseBodyModuleListItineraryList() {}

  explicit ApplyListQueryResponseBodyModuleListItineraryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceName) {
      res["invoice_name"] = boost::any(*invoiceName);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    if (tripWay) {
      res["trip_way"] = boost::any(*tripWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_name") != m.end() && !m["invoice_name"].empty()) {
      invoiceName = make_shared<string>(boost::any_cast<string>(m["invoice_name"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
    if (m.find("trip_way") != m.end() && !m["trip_way"].empty()) {
      tripWay = make_shared<long>(boost::any_cast<long>(m["trip_way"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleListItineraryList() = default;
};
class ApplyListQueryResponseBodyModuleListItinerarySetList : public Darabonba::Model {
public:
  shared_ptr<string> arrDate{};
  shared_ptr<string> cityCodeSet{};
  shared_ptr<string> citySet{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> depDate{};
  shared_ptr<string> invoiceName{};
  shared_ptr<string> itineraryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<long> trafficType{};

  ApplyListQueryResponseBodyModuleListItinerarySetList() {}

  explicit ApplyListQueryResponseBodyModuleListItinerarySetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (cityCodeSet) {
      res["city_code_set"] = boost::any(*cityCodeSet);
    }
    if (citySet) {
      res["city_set"] = boost::any(*citySet);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceName) {
      res["invoice_name"] = boost::any(*invoiceName);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("city_code_set") != m.end() && !m["city_code_set"].empty()) {
      cityCodeSet = make_shared<string>(boost::any_cast<string>(m["city_code_set"]));
    }
    if (m.find("city_set") != m.end() && !m["city_set"].empty()) {
      citySet = make_shared<string>(boost::any_cast<string>(m["city_set"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_name") != m.end() && !m["invoice_name"].empty()) {
      invoiceName = make_shared<string>(boost::any_cast<string>(m["invoice_name"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleListItinerarySetList() = default;
};
class ApplyListQueryResponseBodyModuleListTravelerList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyListQueryResponseBodyModuleListTravelerList() {}

  explicit ApplyListQueryResponseBodyModuleListTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleListTravelerList() = default;
};
class ApplyListQueryResponseBodyModuleList : public Darabonba::Model {
public:
  shared_ptr<string> applyShowId{};
  shared_ptr<vector<ApplyListQueryResponseBodyModuleListApproverList>> approverList{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<vector<ApplyListQueryResponseBodyModuleListExternalTravelerList>> externalTravelerList{};
  shared_ptr<string> flowCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<vector<ApplyListQueryResponseBodyModuleListItineraryList>> itineraryList{};
  shared_ptr<long> itineraryRule{};
  shared_ptr<vector<ApplyListQueryResponseBodyModuleListItinerarySetList>> itinerarySetList{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> thirdpartBusinessId{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<vector<ApplyListQueryResponseBodyModuleListTravelerList>> travelerList{};
  shared_ptr<string> tripCause{};
  shared_ptr<long> tripDay{};
  shared_ptr<string> tripTitle{};
  shared_ptr<long> type{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyListQueryResponseBodyModuleList() {}

  explicit ApplyListQueryResponseBodyModuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyShowId) {
      res["apply_show_id"] = boost::any(*applyShowId);
    }
    if (approverList) {
      vector<boost::any> temp1;
      for(auto item1:*approverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["approver_list"] = boost::any(temp1);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (externalTravelerList) {
      vector<boost::any> temp1;
      for(auto item1:*externalTravelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["external_traveler_list"] = boost::any(temp1);
    }
    if (flowCode) {
      res["flow_code"] = boost::any(*flowCode);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (itineraryList) {
      vector<boost::any> temp1;
      for(auto item1:*itineraryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_list"] = boost::any(temp1);
    }
    if (itineraryRule) {
      res["itinerary_rule"] = boost::any(*itineraryRule);
    }
    if (itinerarySetList) {
      vector<boost::any> temp1;
      for(auto item1:*itinerarySetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_set_list"] = boost::any(temp1);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["status_desc"] = boost::any(*statusDesc);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (travelerList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_list"] = boost::any(temp1);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripDay) {
      res["trip_day"] = boost::any(*tripDay);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_show_id") != m.end() && !m["apply_show_id"].empty()) {
      applyShowId = make_shared<string>(boost::any_cast<string>(m["apply_show_id"]));
    }
    if (m.find("approver_list") != m.end() && !m["approver_list"].empty()) {
      if (typeid(vector<boost::any>) == m["approver_list"].type()) {
        vector<ApplyListQueryResponseBodyModuleListApproverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["approver_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyListQueryResponseBodyModuleListApproverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        approverList = make_shared<vector<ApplyListQueryResponseBodyModuleListApproverList>>(expect1);
      }
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("external_traveler_list") != m.end() && !m["external_traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["external_traveler_list"].type()) {
        vector<ApplyListQueryResponseBodyModuleListExternalTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["external_traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyListQueryResponseBodyModuleListExternalTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        externalTravelerList = make_shared<vector<ApplyListQueryResponseBodyModuleListExternalTravelerList>>(expect1);
      }
    }
    if (m.find("flow_code") != m.end() && !m["flow_code"].empty()) {
      flowCode = make_shared<string>(boost::any_cast<string>(m["flow_code"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_list"].type()) {
        vector<ApplyListQueryResponseBodyModuleListItineraryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyListQueryResponseBodyModuleListItineraryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itineraryList = make_shared<vector<ApplyListQueryResponseBodyModuleListItineraryList>>(expect1);
      }
    }
    if (m.find("itinerary_rule") != m.end() && !m["itinerary_rule"].empty()) {
      itineraryRule = make_shared<long>(boost::any_cast<long>(m["itinerary_rule"]));
    }
    if (m.find("itinerary_set_list") != m.end() && !m["itinerary_set_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_set_list"].type()) {
        vector<ApplyListQueryResponseBodyModuleListItinerarySetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_set_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyListQueryResponseBodyModuleListItinerarySetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itinerarySetList = make_shared<vector<ApplyListQueryResponseBodyModuleListItinerarySetList>>(expect1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("status_desc") != m.end() && !m["status_desc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["status_desc"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("traveler_list") != m.end() && !m["traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_list"].type()) {
        vector<ApplyListQueryResponseBodyModuleListTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyListQueryResponseBodyModuleListTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerList = make_shared<vector<ApplyListQueryResponseBodyModuleListTravelerList>>(expect1);
      }
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_day") != m.end() && !m["trip_day"].empty()) {
      tripDay = make_shared<long>(boost::any_cast<long>(m["trip_day"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleList() = default;
};
class ApplyListQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<ApplyListQueryResponseBodyModuleList>> moduleList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ApplyListQueryResponseBody() {}

  explicit ApplyListQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (moduleList) {
      vector<boost::any> temp1;
      for(auto item1:*moduleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module_list"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module_list") != m.end() && !m["module_list"].empty()) {
      if (typeid(vector<boost::any>) == m["module_list"].type()) {
        vector<ApplyListQueryResponseBodyModuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyListQueryResponseBodyModuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        moduleList = make_shared<vector<ApplyListQueryResponseBodyModuleList>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ApplyListQueryResponseBody() = default;
};
class ApplyListQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyListQueryResponseBody> body{};

  ApplyListQueryResponse() {}

  explicit ApplyListQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyListQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyListQueryResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyListQueryResponse() = default;
};
class ApplyModifyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ApplyModifyHeaders() {}

  explicit ApplyModifyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ApplyModifyHeaders() = default;
};
class ApplyModifyRequestExternalTravelerList : public Darabonba::Model {
public:
  shared_ptr<string> userName{};

  ApplyModifyRequestExternalTravelerList() {}

  explicit ApplyModifyRequestExternalTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyModifyRequestExternalTravelerList() = default;
};
class ApplyModifyRequestExternalTravelerStandardHotelCitys : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> fee{};

  ApplyModifyRequestExternalTravelerStandardHotelCitys() {}

  explicit ApplyModifyRequestExternalTravelerStandardHotelCitys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
  }


  virtual ~ApplyModifyRequestExternalTravelerStandardHotelCitys() = default;
};
class ApplyModifyRequestExternalTravelerStandard : public Darabonba::Model {
public:
  shared_ptr<long> businessDiscount{};
  shared_ptr<long> economyDiscount{};
  shared_ptr<long> firstDiscount{};
  shared_ptr<string> flightCabins{};
  shared_ptr<vector<ApplyModifyRequestExternalTravelerStandardHotelCitys>> hotelCitys{};
  shared_ptr<long> premiumEconomyDiscount{};
  shared_ptr<long> reserveType{};
  shared_ptr<string> trainSeats{};

  ApplyModifyRequestExternalTravelerStandard() {}

  explicit ApplyModifyRequestExternalTravelerStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessDiscount) {
      res["business_discount"] = boost::any(*businessDiscount);
    }
    if (economyDiscount) {
      res["economy_discount"] = boost::any(*economyDiscount);
    }
    if (firstDiscount) {
      res["first_discount"] = boost::any(*firstDiscount);
    }
    if (flightCabins) {
      res["flight_cabins"] = boost::any(*flightCabins);
    }
    if (hotelCitys) {
      vector<boost::any> temp1;
      for(auto item1:*hotelCitys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_citys"] = boost::any(temp1);
    }
    if (premiumEconomyDiscount) {
      res["premium_economy_discount"] = boost::any(*premiumEconomyDiscount);
    }
    if (reserveType) {
      res["reserve_type"] = boost::any(*reserveType);
    }
    if (trainSeats) {
      res["train_seats"] = boost::any(*trainSeats);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_discount") != m.end() && !m["business_discount"].empty()) {
      businessDiscount = make_shared<long>(boost::any_cast<long>(m["business_discount"]));
    }
    if (m.find("economy_discount") != m.end() && !m["economy_discount"].empty()) {
      economyDiscount = make_shared<long>(boost::any_cast<long>(m["economy_discount"]));
    }
    if (m.find("first_discount") != m.end() && !m["first_discount"].empty()) {
      firstDiscount = make_shared<long>(boost::any_cast<long>(m["first_discount"]));
    }
    if (m.find("flight_cabins") != m.end() && !m["flight_cabins"].empty()) {
      flightCabins = make_shared<string>(boost::any_cast<string>(m["flight_cabins"]));
    }
    if (m.find("hotel_citys") != m.end() && !m["hotel_citys"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_citys"].type()) {
        vector<ApplyModifyRequestExternalTravelerStandardHotelCitys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_citys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestExternalTravelerStandardHotelCitys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelCitys = make_shared<vector<ApplyModifyRequestExternalTravelerStandardHotelCitys>>(expect1);
      }
    }
    if (m.find("premium_economy_discount") != m.end() && !m["premium_economy_discount"].empty()) {
      premiumEconomyDiscount = make_shared<long>(boost::any_cast<long>(m["premium_economy_discount"]));
    }
    if (m.find("reserve_type") != m.end() && !m["reserve_type"].empty()) {
      reserveType = make_shared<long>(boost::any_cast<long>(m["reserve_type"]));
    }
    if (m.find("train_seats") != m.end() && !m["train_seats"].empty()) {
      trainSeats = make_shared<string>(boost::any_cast<string>(m["train_seats"]));
    }
  }


  virtual ~ApplyModifyRequestExternalTravelerStandard() = default;
};
class ApplyModifyRequestHotelShare : public Darabonba::Model {
public:
  shared_ptr<string> param{};
  shared_ptr<string> type{};

  ApplyModifyRequestHotelShare() {}

  explicit ApplyModifyRequestHotelShare(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (param) {
      res["param"] = boost::any(*param);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("param") != m.end() && !m["param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["param"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ApplyModifyRequestHotelShare() = default;
};
class ApplyModifyRequestItineraryList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrDate{};
  shared_ptr<long> costCenterId{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<long> invoiceId{};
  shared_ptr<string> itineraryId{};
  shared_ptr<bool> needHotel{};
  shared_ptr<bool> needTraffic{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<long> trafficType{};
  shared_ptr<long> tripWay{};

  ApplyModifyRequestItineraryList() {}

  explicit ApplyModifyRequestItineraryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceId) {
      res["invoice_id"] = boost::any(*invoiceId);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (needHotel) {
      res["need_hotel"] = boost::any(*needHotel);
    }
    if (needTraffic) {
      res["need_traffic"] = boost::any(*needTraffic);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    if (tripWay) {
      res["trip_way"] = boost::any(*tripWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_id") != m.end() && !m["invoice_id"].empty()) {
      invoiceId = make_shared<long>(boost::any_cast<long>(m["invoice_id"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("need_hotel") != m.end() && !m["need_hotel"].empty()) {
      needHotel = make_shared<bool>(boost::any_cast<bool>(m["need_hotel"]));
    }
    if (m.find("need_traffic") != m.end() && !m["need_traffic"].empty()) {
      needTraffic = make_shared<bool>(boost::any_cast<bool>(m["need_traffic"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
    if (m.find("trip_way") != m.end() && !m["trip_way"].empty()) {
      tripWay = make_shared<long>(boost::any_cast<long>(m["trip_way"]));
    }
  }


  virtual ~ApplyModifyRequestItineraryList() = default;
};
class ApplyModifyRequestItinerarySetList : public Darabonba::Model {
public:
  shared_ptr<string> arrDate{};
  shared_ptr<string> cityCodeSet{};
  shared_ptr<string> citySet{};
  shared_ptr<long> costCenterId{};
  shared_ptr<string> depDate{};
  shared_ptr<long> invoiceId{};
  shared_ptr<string> itineraryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<long> trafficType{};

  ApplyModifyRequestItinerarySetList() {}

  explicit ApplyModifyRequestItinerarySetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (cityCodeSet) {
      res["city_code_set"] = boost::any(*cityCodeSet);
    }
    if (citySet) {
      res["city_set"] = boost::any(*citySet);
    }
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceId) {
      res["invoice_id"] = boost::any(*invoiceId);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("city_code_set") != m.end() && !m["city_code_set"].empty()) {
      cityCodeSet = make_shared<string>(boost::any_cast<string>(m["city_code_set"]));
    }
    if (m.find("city_set") != m.end() && !m["city_set"].empty()) {
      citySet = make_shared<string>(boost::any_cast<string>(m["city_set"]));
    }
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_id") != m.end() && !m["invoice_id"].empty()) {
      invoiceId = make_shared<long>(boost::any_cast<long>(m["invoice_id"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
  }


  virtual ~ApplyModifyRequestItinerarySetList() = default;
};
class ApplyModifyRequestTravelerList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyModifyRequestTravelerList() {}

  explicit ApplyModifyRequestTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyModifyRequestTravelerList() = default;
};
class ApplyModifyRequestTravelerStandardHotelCitys : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> fee{};

  ApplyModifyRequestTravelerStandardHotelCitys() {}

  explicit ApplyModifyRequestTravelerStandardHotelCitys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
  }


  virtual ~ApplyModifyRequestTravelerStandardHotelCitys() = default;
};
class ApplyModifyRequestTravelerStandard : public Darabonba::Model {
public:
  shared_ptr<long> businessDiscount{};
  shared_ptr<long> economyDiscount{};
  shared_ptr<long> firstDiscount{};
  shared_ptr<string> flightCabins{};
  shared_ptr<vector<ApplyModifyRequestTravelerStandardHotelCitys>> hotelCitys{};
  shared_ptr<long> premiumEconomyDiscount{};
  shared_ptr<long> reserveType{};
  shared_ptr<string> trainSeats{};
  shared_ptr<string> userId{};

  ApplyModifyRequestTravelerStandard() {}

  explicit ApplyModifyRequestTravelerStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessDiscount) {
      res["business_discount"] = boost::any(*businessDiscount);
    }
    if (economyDiscount) {
      res["economy_discount"] = boost::any(*economyDiscount);
    }
    if (firstDiscount) {
      res["first_discount"] = boost::any(*firstDiscount);
    }
    if (flightCabins) {
      res["flight_cabins"] = boost::any(*flightCabins);
    }
    if (hotelCitys) {
      vector<boost::any> temp1;
      for(auto item1:*hotelCitys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_citys"] = boost::any(temp1);
    }
    if (premiumEconomyDiscount) {
      res["premium_economy_discount"] = boost::any(*premiumEconomyDiscount);
    }
    if (reserveType) {
      res["reserve_type"] = boost::any(*reserveType);
    }
    if (trainSeats) {
      res["train_seats"] = boost::any(*trainSeats);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_discount") != m.end() && !m["business_discount"].empty()) {
      businessDiscount = make_shared<long>(boost::any_cast<long>(m["business_discount"]));
    }
    if (m.find("economy_discount") != m.end() && !m["economy_discount"].empty()) {
      economyDiscount = make_shared<long>(boost::any_cast<long>(m["economy_discount"]));
    }
    if (m.find("first_discount") != m.end() && !m["first_discount"].empty()) {
      firstDiscount = make_shared<long>(boost::any_cast<long>(m["first_discount"]));
    }
    if (m.find("flight_cabins") != m.end() && !m["flight_cabins"].empty()) {
      flightCabins = make_shared<string>(boost::any_cast<string>(m["flight_cabins"]));
    }
    if (m.find("hotel_citys") != m.end() && !m["hotel_citys"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_citys"].type()) {
        vector<ApplyModifyRequestTravelerStandardHotelCitys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_citys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestTravelerStandardHotelCitys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelCitys = make_shared<vector<ApplyModifyRequestTravelerStandardHotelCitys>>(expect1);
      }
    }
    if (m.find("premium_economy_discount") != m.end() && !m["premium_economy_discount"].empty()) {
      premiumEconomyDiscount = make_shared<long>(boost::any_cast<long>(m["premium_economy_discount"]));
    }
    if (m.find("reserve_type") != m.end() && !m["reserve_type"].empty()) {
      reserveType = make_shared<long>(boost::any_cast<long>(m["reserve_type"]));
    }
    if (m.find("train_seats") != m.end() && !m["train_seats"].empty()) {
      trainSeats = make_shared<string>(boost::any_cast<string>(m["train_seats"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~ApplyModifyRequestTravelerStandard() = default;
};
class ApplyModifyRequest : public Darabonba::Model {
public:
  shared_ptr<long> budget{};
  shared_ptr<long> budgetMerge{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> extendField{};
  shared_ptr<vector<ApplyModifyRequestExternalTravelerList>> externalTravelerList{};
  shared_ptr<ApplyModifyRequestExternalTravelerStandard> externalTravelerStandard{};
  shared_ptr<long> flightBudget{};
  shared_ptr<long> hotelBudget{};
  shared_ptr<ApplyModifyRequestHotelShare> hotelShare{};
  shared_ptr<vector<ApplyModifyRequestItineraryList>> itineraryList{};
  shared_ptr<long> itineraryRule{};
  shared_ptr<vector<ApplyModifyRequestItinerarySetList>> itinerarySetList{};
  shared_ptr<long> limitTraveler{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartBusinessId{};
  shared_ptr<string> thirdpartDepartId{};
  shared_ptr<long> togetherBookRule{};
  shared_ptr<long> trainBudget{};
  shared_ptr<vector<ApplyModifyRequestTravelerList>> travelerList{};
  shared_ptr<vector<ApplyModifyRequestTravelerStandard>> travelerStandard{};
  shared_ptr<string> tripCause{};
  shared_ptr<long> tripDay{};
  shared_ptr<string> tripTitle{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> vehicleBudget{};

  ApplyModifyRequest() {}

  explicit ApplyModifyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (budget) {
      res["budget"] = boost::any(*budget);
    }
    if (budgetMerge) {
      res["budget_merge"] = boost::any(*budgetMerge);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (extendField) {
      res["extend_field"] = boost::any(*extendField);
    }
    if (externalTravelerList) {
      vector<boost::any> temp1;
      for(auto item1:*externalTravelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["external_traveler_list"] = boost::any(temp1);
    }
    if (externalTravelerStandard) {
      res["external_traveler_standard"] = externalTravelerStandard ? boost::any(externalTravelerStandard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightBudget) {
      res["flight_budget"] = boost::any(*flightBudget);
    }
    if (hotelBudget) {
      res["hotel_budget"] = boost::any(*hotelBudget);
    }
    if (hotelShare) {
      res["hotel_share"] = hotelShare ? boost::any(hotelShare->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (itineraryList) {
      vector<boost::any> temp1;
      for(auto item1:*itineraryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_list"] = boost::any(temp1);
    }
    if (itineraryRule) {
      res["itinerary_rule"] = boost::any(*itineraryRule);
    }
    if (itinerarySetList) {
      vector<boost::any> temp1;
      for(auto item1:*itinerarySetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_set_list"] = boost::any(temp1);
    }
    if (limitTraveler) {
      res["limit_traveler"] = boost::any(*limitTraveler);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    if (thirdpartDepartId) {
      res["thirdpart_depart_id"] = boost::any(*thirdpartDepartId);
    }
    if (togetherBookRule) {
      res["together_book_rule"] = boost::any(*togetherBookRule);
    }
    if (trainBudget) {
      res["train_budget"] = boost::any(*trainBudget);
    }
    if (travelerList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_list"] = boost::any(temp1);
    }
    if (travelerStandard) {
      vector<boost::any> temp1;
      for(auto item1:*travelerStandard){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_standard"] = boost::any(temp1);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripDay) {
      res["trip_day"] = boost::any(*tripDay);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (vehicleBudget) {
      res["vehicle_budget"] = boost::any(*vehicleBudget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("budget") != m.end() && !m["budget"].empty()) {
      budget = make_shared<long>(boost::any_cast<long>(m["budget"]));
    }
    if (m.find("budget_merge") != m.end() && !m["budget_merge"].empty()) {
      budgetMerge = make_shared<long>(boost::any_cast<long>(m["budget_merge"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("extend_field") != m.end() && !m["extend_field"].empty()) {
      extendField = make_shared<string>(boost::any_cast<string>(m["extend_field"]));
    }
    if (m.find("external_traveler_list") != m.end() && !m["external_traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["external_traveler_list"].type()) {
        vector<ApplyModifyRequestExternalTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["external_traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestExternalTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        externalTravelerList = make_shared<vector<ApplyModifyRequestExternalTravelerList>>(expect1);
      }
    }
    if (m.find("external_traveler_standard") != m.end() && !m["external_traveler_standard"].empty()) {
      if (typeid(map<string, boost::any>) == m["external_traveler_standard"].type()) {
        ApplyModifyRequestExternalTravelerStandard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["external_traveler_standard"]));
        externalTravelerStandard = make_shared<ApplyModifyRequestExternalTravelerStandard>(model1);
      }
    }
    if (m.find("flight_budget") != m.end() && !m["flight_budget"].empty()) {
      flightBudget = make_shared<long>(boost::any_cast<long>(m["flight_budget"]));
    }
    if (m.find("hotel_budget") != m.end() && !m["hotel_budget"].empty()) {
      hotelBudget = make_shared<long>(boost::any_cast<long>(m["hotel_budget"]));
    }
    if (m.find("hotel_share") != m.end() && !m["hotel_share"].empty()) {
      if (typeid(map<string, boost::any>) == m["hotel_share"].type()) {
        ApplyModifyRequestHotelShare model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["hotel_share"]));
        hotelShare = make_shared<ApplyModifyRequestHotelShare>(model1);
      }
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_list"].type()) {
        vector<ApplyModifyRequestItineraryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestItineraryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itineraryList = make_shared<vector<ApplyModifyRequestItineraryList>>(expect1);
      }
    }
    if (m.find("itinerary_rule") != m.end() && !m["itinerary_rule"].empty()) {
      itineraryRule = make_shared<long>(boost::any_cast<long>(m["itinerary_rule"]));
    }
    if (m.find("itinerary_set_list") != m.end() && !m["itinerary_set_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_set_list"].type()) {
        vector<ApplyModifyRequestItinerarySetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_set_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestItinerarySetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itinerarySetList = make_shared<vector<ApplyModifyRequestItinerarySetList>>(expect1);
      }
    }
    if (m.find("limit_traveler") != m.end() && !m["limit_traveler"].empty()) {
      limitTraveler = make_shared<long>(boost::any_cast<long>(m["limit_traveler"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
    if (m.find("thirdpart_depart_id") != m.end() && !m["thirdpart_depart_id"].empty()) {
      thirdpartDepartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_depart_id"]));
    }
    if (m.find("together_book_rule") != m.end() && !m["together_book_rule"].empty()) {
      togetherBookRule = make_shared<long>(boost::any_cast<long>(m["together_book_rule"]));
    }
    if (m.find("train_budget") != m.end() && !m["train_budget"].empty()) {
      trainBudget = make_shared<long>(boost::any_cast<long>(m["train_budget"]));
    }
    if (m.find("traveler_list") != m.end() && !m["traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_list"].type()) {
        vector<ApplyModifyRequestTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerList = make_shared<vector<ApplyModifyRequestTravelerList>>(expect1);
      }
    }
    if (m.find("traveler_standard") != m.end() && !m["traveler_standard"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_standard"].type()) {
        vector<ApplyModifyRequestTravelerStandard> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_standard"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestTravelerStandard model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerStandard = make_shared<vector<ApplyModifyRequestTravelerStandard>>(expect1);
      }
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_day") != m.end() && !m["trip_day"].empty()) {
      tripDay = make_shared<long>(boost::any_cast<long>(m["trip_day"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("vehicle_budget") != m.end() && !m["vehicle_budget"].empty()) {
      vehicleBudget = make_shared<long>(boost::any_cast<long>(m["vehicle_budget"]));
    }
  }


  virtual ~ApplyModifyRequest() = default;
};
class ApplyModifyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> budget{};
  shared_ptr<long> budgetMerge{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> extendField{};
  shared_ptr<string> externalTravelerListShrink{};
  shared_ptr<string> externalTravelerStandardShrink{};
  shared_ptr<long> flightBudget{};
  shared_ptr<long> hotelBudget{};
  shared_ptr<string> hotelShareShrink{};
  shared_ptr<string> itineraryListShrink{};
  shared_ptr<long> itineraryRule{};
  shared_ptr<string> itinerarySetListShrink{};
  shared_ptr<long> limitTraveler{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartBusinessId{};
  shared_ptr<string> thirdpartDepartId{};
  shared_ptr<long> togetherBookRule{};
  shared_ptr<long> trainBudget{};
  shared_ptr<string> travelerListShrink{};
  shared_ptr<string> travelerStandardShrink{};
  shared_ptr<string> tripCause{};
  shared_ptr<long> tripDay{};
  shared_ptr<string> tripTitle{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> vehicleBudget{};

  ApplyModifyShrinkRequest() {}

  explicit ApplyModifyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (budget) {
      res["budget"] = boost::any(*budget);
    }
    if (budgetMerge) {
      res["budget_merge"] = boost::any(*budgetMerge);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (extendField) {
      res["extend_field"] = boost::any(*extendField);
    }
    if (externalTravelerListShrink) {
      res["external_traveler_list"] = boost::any(*externalTravelerListShrink);
    }
    if (externalTravelerStandardShrink) {
      res["external_traveler_standard"] = boost::any(*externalTravelerStandardShrink);
    }
    if (flightBudget) {
      res["flight_budget"] = boost::any(*flightBudget);
    }
    if (hotelBudget) {
      res["hotel_budget"] = boost::any(*hotelBudget);
    }
    if (hotelShareShrink) {
      res["hotel_share"] = boost::any(*hotelShareShrink);
    }
    if (itineraryListShrink) {
      res["itinerary_list"] = boost::any(*itineraryListShrink);
    }
    if (itineraryRule) {
      res["itinerary_rule"] = boost::any(*itineraryRule);
    }
    if (itinerarySetListShrink) {
      res["itinerary_set_list"] = boost::any(*itinerarySetListShrink);
    }
    if (limitTraveler) {
      res["limit_traveler"] = boost::any(*limitTraveler);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    if (thirdpartDepartId) {
      res["thirdpart_depart_id"] = boost::any(*thirdpartDepartId);
    }
    if (togetherBookRule) {
      res["together_book_rule"] = boost::any(*togetherBookRule);
    }
    if (trainBudget) {
      res["train_budget"] = boost::any(*trainBudget);
    }
    if (travelerListShrink) {
      res["traveler_list"] = boost::any(*travelerListShrink);
    }
    if (travelerStandardShrink) {
      res["traveler_standard"] = boost::any(*travelerStandardShrink);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripDay) {
      res["trip_day"] = boost::any(*tripDay);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (vehicleBudget) {
      res["vehicle_budget"] = boost::any(*vehicleBudget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("budget") != m.end() && !m["budget"].empty()) {
      budget = make_shared<long>(boost::any_cast<long>(m["budget"]));
    }
    if (m.find("budget_merge") != m.end() && !m["budget_merge"].empty()) {
      budgetMerge = make_shared<long>(boost::any_cast<long>(m["budget_merge"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("extend_field") != m.end() && !m["extend_field"].empty()) {
      extendField = make_shared<string>(boost::any_cast<string>(m["extend_field"]));
    }
    if (m.find("external_traveler_list") != m.end() && !m["external_traveler_list"].empty()) {
      externalTravelerListShrink = make_shared<string>(boost::any_cast<string>(m["external_traveler_list"]));
    }
    if (m.find("external_traveler_standard") != m.end() && !m["external_traveler_standard"].empty()) {
      externalTravelerStandardShrink = make_shared<string>(boost::any_cast<string>(m["external_traveler_standard"]));
    }
    if (m.find("flight_budget") != m.end() && !m["flight_budget"].empty()) {
      flightBudget = make_shared<long>(boost::any_cast<long>(m["flight_budget"]));
    }
    if (m.find("hotel_budget") != m.end() && !m["hotel_budget"].empty()) {
      hotelBudget = make_shared<long>(boost::any_cast<long>(m["hotel_budget"]));
    }
    if (m.find("hotel_share") != m.end() && !m["hotel_share"].empty()) {
      hotelShareShrink = make_shared<string>(boost::any_cast<string>(m["hotel_share"]));
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      itineraryListShrink = make_shared<string>(boost::any_cast<string>(m["itinerary_list"]));
    }
    if (m.find("itinerary_rule") != m.end() && !m["itinerary_rule"].empty()) {
      itineraryRule = make_shared<long>(boost::any_cast<long>(m["itinerary_rule"]));
    }
    if (m.find("itinerary_set_list") != m.end() && !m["itinerary_set_list"].empty()) {
      itinerarySetListShrink = make_shared<string>(boost::any_cast<string>(m["itinerary_set_list"]));
    }
    if (m.find("limit_traveler") != m.end() && !m["limit_traveler"].empty()) {
      limitTraveler = make_shared<long>(boost::any_cast<long>(m["limit_traveler"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
    if (m.find("thirdpart_depart_id") != m.end() && !m["thirdpart_depart_id"].empty()) {
      thirdpartDepartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_depart_id"]));
    }
    if (m.find("together_book_rule") != m.end() && !m["together_book_rule"].empty()) {
      togetherBookRule = make_shared<long>(boost::any_cast<long>(m["together_book_rule"]));
    }
    if (m.find("train_budget") != m.end() && !m["train_budget"].empty()) {
      trainBudget = make_shared<long>(boost::any_cast<long>(m["train_budget"]));
    }
    if (m.find("traveler_list") != m.end() && !m["traveler_list"].empty()) {
      travelerListShrink = make_shared<string>(boost::any_cast<string>(m["traveler_list"]));
    }
    if (m.find("traveler_standard") != m.end() && !m["traveler_standard"].empty()) {
      travelerStandardShrink = make_shared<string>(boost::any_cast<string>(m["traveler_standard"]));
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_day") != m.end() && !m["trip_day"].empty()) {
      tripDay = make_shared<long>(boost::any_cast<long>(m["trip_day"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("vehicle_budget") != m.end() && !m["vehicle_budget"].empty()) {
      vehicleBudget = make_shared<long>(boost::any_cast<long>(m["vehicle_budget"]));
    }
  }


  virtual ~ApplyModifyShrinkRequest() = default;
};
class ApplyModifyResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartBusinessId{};

  ApplyModifyResponseBodyModule() {}

  explicit ApplyModifyResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
  }


  virtual ~ApplyModifyResponseBodyModule() = default;
};
class ApplyModifyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<ApplyModifyResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ApplyModifyResponseBody() {}

  explicit ApplyModifyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        ApplyModifyResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<ApplyModifyResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ApplyModifyResponseBody() = default;
};
class ApplyModifyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyModifyResponseBody> body{};

  ApplyModifyResponse() {}

  explicit ApplyModifyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyModifyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyModifyResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyModifyResponse() = default;
};
class ApplyQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ApplyQueryHeaders() {}

  explicit ApplyQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ApplyQueryHeaders() = default;
};
class ApplyQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> applyShowId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<long> type{};

  ApplyQueryRequest() {}

  explicit ApplyQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (applyShowId) {
      res["apply_show_id"] = boost::any(*applyShowId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("apply_show_id") != m.end() && !m["apply_show_id"].empty()) {
      applyShowId = make_shared<string>(boost::any_cast<string>(m["apply_show_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~ApplyQueryRequest() = default;
};
class ApplyQueryResponseBodyModuleApproverList : public Darabonba::Model {
public:
  shared_ptr<string> note{};
  shared_ptr<string> operateTime{};
  shared_ptr<long> order{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyQueryResponseBodyModuleApproverList() {}

  explicit ApplyQueryResponseBodyModuleApproverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (note) {
      res["note"] = boost::any(*note);
    }
    if (operateTime) {
      res["operate_time"] = boost::any(*operateTime);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["status_desc"] = boost::any(*statusDesc);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("note") != m.end() && !m["note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["note"]));
    }
    if (m.find("operate_time") != m.end() && !m["operate_time"].empty()) {
      operateTime = make_shared<string>(boost::any_cast<string>(m["operate_time"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["order"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("status_desc") != m.end() && !m["status_desc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["status_desc"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleApproverList() = default;
};
class ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> fee{};

  ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys() {}

  explicit ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys() = default;
};
class ApplyQueryResponseBodyModuleExternalTravelerList : public Darabonba::Model {
public:
  shared_ptr<long> businessDiscount{};
  shared_ptr<long> economyDiscount{};
  shared_ptr<long> firstDiscount{};
  shared_ptr<string> flightCabins{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys>> hotelCitys{};
  shared_ptr<long> premiumEconomyDiscount{};
  shared_ptr<long> reserveType{};
  shared_ptr<string> trainSeats{};
  shared_ptr<string> userName{};

  ApplyQueryResponseBodyModuleExternalTravelerList() {}

  explicit ApplyQueryResponseBodyModuleExternalTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessDiscount) {
      res["business_discount"] = boost::any(*businessDiscount);
    }
    if (economyDiscount) {
      res["economy_discount"] = boost::any(*economyDiscount);
    }
    if (firstDiscount) {
      res["first_discount"] = boost::any(*firstDiscount);
    }
    if (flightCabins) {
      res["flight_cabins"] = boost::any(*flightCabins);
    }
    if (hotelCitys) {
      vector<boost::any> temp1;
      for(auto item1:*hotelCitys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_citys"] = boost::any(temp1);
    }
    if (premiumEconomyDiscount) {
      res["premium_economy_discount"] = boost::any(*premiumEconomyDiscount);
    }
    if (reserveType) {
      res["reserve_type"] = boost::any(*reserveType);
    }
    if (trainSeats) {
      res["train_seats"] = boost::any(*trainSeats);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_discount") != m.end() && !m["business_discount"].empty()) {
      businessDiscount = make_shared<long>(boost::any_cast<long>(m["business_discount"]));
    }
    if (m.find("economy_discount") != m.end() && !m["economy_discount"].empty()) {
      economyDiscount = make_shared<long>(boost::any_cast<long>(m["economy_discount"]));
    }
    if (m.find("first_discount") != m.end() && !m["first_discount"].empty()) {
      firstDiscount = make_shared<long>(boost::any_cast<long>(m["first_discount"]));
    }
    if (m.find("flight_cabins") != m.end() && !m["flight_cabins"].empty()) {
      flightCabins = make_shared<string>(boost::any_cast<string>(m["flight_cabins"]));
    }
    if (m.find("hotel_citys") != m.end() && !m["hotel_citys"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_citys"].type()) {
        vector<ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_citys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelCitys = make_shared<vector<ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys>>(expect1);
      }
    }
    if (m.find("premium_economy_discount") != m.end() && !m["premium_economy_discount"].empty()) {
      premiumEconomyDiscount = make_shared<long>(boost::any_cast<long>(m["premium_economy_discount"]));
    }
    if (m.find("reserve_type") != m.end() && !m["reserve_type"].empty()) {
      reserveType = make_shared<long>(boost::any_cast<long>(m["reserve_type"]));
    }
    if (m.find("train_seats") != m.end() && !m["train_seats"].empty()) {
      trainSeats = make_shared<string>(boost::any_cast<string>(m["train_seats"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleExternalTravelerList() = default;
};
class ApplyQueryResponseBodyModuleHotelShare : public Darabonba::Model {
public:
  shared_ptr<string> param{};
  shared_ptr<string> type{};

  ApplyQueryResponseBodyModuleHotelShare() {}

  explicit ApplyQueryResponseBodyModuleHotelShare(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (param) {
      res["param"] = boost::any(*param);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("param") != m.end() && !m["param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["param"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleHotelShare() = default;
};
class ApplyQueryResponseBodyModuleItineraryList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<string> invoiceName{};
  shared_ptr<string> itineraryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<long> trafficType{};
  shared_ptr<long> tripWay{};

  ApplyQueryResponseBodyModuleItineraryList() {}

  explicit ApplyQueryResponseBodyModuleItineraryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceName) {
      res["invoice_name"] = boost::any(*invoiceName);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    if (tripWay) {
      res["trip_way"] = boost::any(*tripWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_name") != m.end() && !m["invoice_name"].empty()) {
      invoiceName = make_shared<string>(boost::any_cast<string>(m["invoice_name"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
    if (m.find("trip_way") != m.end() && !m["trip_way"].empty()) {
      tripWay = make_shared<long>(boost::any_cast<long>(m["trip_way"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleItineraryList() = default;
};
class ApplyQueryResponseBodyModuleItinerarySetList : public Darabonba::Model {
public:
  shared_ptr<string> arrDate{};
  shared_ptr<string> cityCodeSet{};
  shared_ptr<string> citySet{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> depDate{};
  shared_ptr<string> invoiceName{};
  shared_ptr<string> itineraryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<long> trafficType{};

  ApplyQueryResponseBodyModuleItinerarySetList() {}

  explicit ApplyQueryResponseBodyModuleItinerarySetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (cityCodeSet) {
      res["city_code_set"] = boost::any(*cityCodeSet);
    }
    if (citySet) {
      res["city_set"] = boost::any(*citySet);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceName) {
      res["invoice_name"] = boost::any(*invoiceName);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("city_code_set") != m.end() && !m["city_code_set"].empty()) {
      cityCodeSet = make_shared<string>(boost::any_cast<string>(m["city_code_set"]));
    }
    if (m.find("city_set") != m.end() && !m["city_set"].empty()) {
      citySet = make_shared<string>(boost::any_cast<string>(m["city_set"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_name") != m.end() && !m["invoice_name"].empty()) {
      invoiceName = make_shared<string>(boost::any_cast<string>(m["invoice_name"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleItinerarySetList() = default;
};
class ApplyQueryResponseBodyModuleTravelerListHotelCitys : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> fee{};

  ApplyQueryResponseBodyModuleTravelerListHotelCitys() {}

  explicit ApplyQueryResponseBodyModuleTravelerListHotelCitys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleTravelerListHotelCitys() = default;
};
class ApplyQueryResponseBodyModuleTravelerList : public Darabonba::Model {
public:
  shared_ptr<long> businessDiscount{};
  shared_ptr<long> economyDiscount{};
  shared_ptr<long> firstDiscount{};
  shared_ptr<string> flightCabins{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleTravelerListHotelCitys>> hotelCitys{};
  shared_ptr<long> premiumEconomyDiscount{};
  shared_ptr<long> reserveType{};
  shared_ptr<string> trainSeats{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyQueryResponseBodyModuleTravelerList() {}

  explicit ApplyQueryResponseBodyModuleTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessDiscount) {
      res["business_discount"] = boost::any(*businessDiscount);
    }
    if (economyDiscount) {
      res["economy_discount"] = boost::any(*economyDiscount);
    }
    if (firstDiscount) {
      res["first_discount"] = boost::any(*firstDiscount);
    }
    if (flightCabins) {
      res["flight_cabins"] = boost::any(*flightCabins);
    }
    if (hotelCitys) {
      vector<boost::any> temp1;
      for(auto item1:*hotelCitys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_citys"] = boost::any(temp1);
    }
    if (premiumEconomyDiscount) {
      res["premium_economy_discount"] = boost::any(*premiumEconomyDiscount);
    }
    if (reserveType) {
      res["reserve_type"] = boost::any(*reserveType);
    }
    if (trainSeats) {
      res["train_seats"] = boost::any(*trainSeats);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_discount") != m.end() && !m["business_discount"].empty()) {
      businessDiscount = make_shared<long>(boost::any_cast<long>(m["business_discount"]));
    }
    if (m.find("economy_discount") != m.end() && !m["economy_discount"].empty()) {
      economyDiscount = make_shared<long>(boost::any_cast<long>(m["economy_discount"]));
    }
    if (m.find("first_discount") != m.end() && !m["first_discount"].empty()) {
      firstDiscount = make_shared<long>(boost::any_cast<long>(m["first_discount"]));
    }
    if (m.find("flight_cabins") != m.end() && !m["flight_cabins"].empty()) {
      flightCabins = make_shared<string>(boost::any_cast<string>(m["flight_cabins"]));
    }
    if (m.find("hotel_citys") != m.end() && !m["hotel_citys"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_citys"].type()) {
        vector<ApplyQueryResponseBodyModuleTravelerListHotelCitys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_citys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleTravelerListHotelCitys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelCitys = make_shared<vector<ApplyQueryResponseBodyModuleTravelerListHotelCitys>>(expect1);
      }
    }
    if (m.find("premium_economy_discount") != m.end() && !m["premium_economy_discount"].empty()) {
      premiumEconomyDiscount = make_shared<long>(boost::any_cast<long>(m["premium_economy_discount"]));
    }
    if (m.find("reserve_type") != m.end() && !m["reserve_type"].empty()) {
      reserveType = make_shared<long>(boost::any_cast<long>(m["reserve_type"]));
    }
    if (m.find("train_seats") != m.end() && !m["train_seats"].empty()) {
      trainSeats = make_shared<string>(boost::any_cast<string>(m["train_seats"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleTravelerList() = default;
};
class ApplyQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> applyShowId{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleApproverList>> approverList{};
  shared_ptr<long> budget{};
  shared_ptr<long> budgetMerge{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> extendField{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleExternalTravelerList>> externalTravelerList{};
  shared_ptr<long> flightBudget{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> hotelBudget{};
  shared_ptr<ApplyQueryResponseBodyModuleHotelShare> hotelShare{};
  shared_ptr<long> id{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleItineraryList>> itineraryList{};
  shared_ptr<long> itineraryRule{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleItinerarySetList>> itinerarySetList{};
  shared_ptr<long> limitTraveler{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> thirdpartBusinessId{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<long> togetherBookRule{};
  shared_ptr<long> trainBudget{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleTravelerList>> travelerList{};
  shared_ptr<string> tripCause{};
  shared_ptr<long> tripDay{};
  shared_ptr<string> tripTitle{};
  shared_ptr<long> type{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> vehicleBudget{};

  ApplyQueryResponseBodyModule() {}

  explicit ApplyQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyShowId) {
      res["apply_show_id"] = boost::any(*applyShowId);
    }
    if (approverList) {
      vector<boost::any> temp1;
      for(auto item1:*approverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["approver_list"] = boost::any(temp1);
    }
    if (budget) {
      res["budget"] = boost::any(*budget);
    }
    if (budgetMerge) {
      res["budget_merge"] = boost::any(*budgetMerge);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (extendField) {
      res["extend_field"] = boost::any(*extendField);
    }
    if (externalTravelerList) {
      vector<boost::any> temp1;
      for(auto item1:*externalTravelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["external_traveler_list"] = boost::any(temp1);
    }
    if (flightBudget) {
      res["flight_budget"] = boost::any(*flightBudget);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (hotelBudget) {
      res["hotel_budget"] = boost::any(*hotelBudget);
    }
    if (hotelShare) {
      res["hotel_share"] = hotelShare ? boost::any(hotelShare->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (itineraryList) {
      vector<boost::any> temp1;
      for(auto item1:*itineraryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_list"] = boost::any(temp1);
    }
    if (itineraryRule) {
      res["itinerary_rule"] = boost::any(*itineraryRule);
    }
    if (itinerarySetList) {
      vector<boost::any> temp1;
      for(auto item1:*itinerarySetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_set_list"] = boost::any(temp1);
    }
    if (limitTraveler) {
      res["limit_traveler"] = boost::any(*limitTraveler);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["status_desc"] = boost::any(*statusDesc);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (togetherBookRule) {
      res["together_book_rule"] = boost::any(*togetherBookRule);
    }
    if (trainBudget) {
      res["train_budget"] = boost::any(*trainBudget);
    }
    if (travelerList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_list"] = boost::any(temp1);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripDay) {
      res["trip_day"] = boost::any(*tripDay);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (vehicleBudget) {
      res["vehicle_budget"] = boost::any(*vehicleBudget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_show_id") != m.end() && !m["apply_show_id"].empty()) {
      applyShowId = make_shared<string>(boost::any_cast<string>(m["apply_show_id"]));
    }
    if (m.find("approver_list") != m.end() && !m["approver_list"].empty()) {
      if (typeid(vector<boost::any>) == m["approver_list"].type()) {
        vector<ApplyQueryResponseBodyModuleApproverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["approver_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleApproverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        approverList = make_shared<vector<ApplyQueryResponseBodyModuleApproverList>>(expect1);
      }
    }
    if (m.find("budget") != m.end() && !m["budget"].empty()) {
      budget = make_shared<long>(boost::any_cast<long>(m["budget"]));
    }
    if (m.find("budget_merge") != m.end() && !m["budget_merge"].empty()) {
      budgetMerge = make_shared<long>(boost::any_cast<long>(m["budget_merge"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("extend_field") != m.end() && !m["extend_field"].empty()) {
      extendField = make_shared<string>(boost::any_cast<string>(m["extend_field"]));
    }
    if (m.find("external_traveler_list") != m.end() && !m["external_traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["external_traveler_list"].type()) {
        vector<ApplyQueryResponseBodyModuleExternalTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["external_traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleExternalTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        externalTravelerList = make_shared<vector<ApplyQueryResponseBodyModuleExternalTravelerList>>(expect1);
      }
    }
    if (m.find("flight_budget") != m.end() && !m["flight_budget"].empty()) {
      flightBudget = make_shared<long>(boost::any_cast<long>(m["flight_budget"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("hotel_budget") != m.end() && !m["hotel_budget"].empty()) {
      hotelBudget = make_shared<long>(boost::any_cast<long>(m["hotel_budget"]));
    }
    if (m.find("hotel_share") != m.end() && !m["hotel_share"].empty()) {
      if (typeid(map<string, boost::any>) == m["hotel_share"].type()) {
        ApplyQueryResponseBodyModuleHotelShare model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["hotel_share"]));
        hotelShare = make_shared<ApplyQueryResponseBodyModuleHotelShare>(model1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_list"].type()) {
        vector<ApplyQueryResponseBodyModuleItineraryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleItineraryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itineraryList = make_shared<vector<ApplyQueryResponseBodyModuleItineraryList>>(expect1);
      }
    }
    if (m.find("itinerary_rule") != m.end() && !m["itinerary_rule"].empty()) {
      itineraryRule = make_shared<long>(boost::any_cast<long>(m["itinerary_rule"]));
    }
    if (m.find("itinerary_set_list") != m.end() && !m["itinerary_set_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_set_list"].type()) {
        vector<ApplyQueryResponseBodyModuleItinerarySetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_set_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleItinerarySetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itinerarySetList = make_shared<vector<ApplyQueryResponseBodyModuleItinerarySetList>>(expect1);
      }
    }
    if (m.find("limit_traveler") != m.end() && !m["limit_traveler"].empty()) {
      limitTraveler = make_shared<long>(boost::any_cast<long>(m["limit_traveler"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("status_desc") != m.end() && !m["status_desc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["status_desc"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("together_book_rule") != m.end() && !m["together_book_rule"].empty()) {
      togetherBookRule = make_shared<long>(boost::any_cast<long>(m["together_book_rule"]));
    }
    if (m.find("train_budget") != m.end() && !m["train_budget"].empty()) {
      trainBudget = make_shared<long>(boost::any_cast<long>(m["train_budget"]));
    }
    if (m.find("traveler_list") != m.end() && !m["traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_list"].type()) {
        vector<ApplyQueryResponseBodyModuleTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerList = make_shared<vector<ApplyQueryResponseBodyModuleTravelerList>>(expect1);
      }
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_day") != m.end() && !m["trip_day"].empty()) {
      tripDay = make_shared<long>(boost::any_cast<long>(m["trip_day"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("vehicle_budget") != m.end() && !m["vehicle_budget"].empty()) {
      vehicleBudget = make_shared<long>(boost::any_cast<long>(m["vehicle_budget"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModule() = default;
};
class ApplyQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<ApplyQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ApplyQueryResponseBody() {}

  explicit ApplyQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        ApplyQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<ApplyQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ApplyQueryResponseBody() = default;
};
class ApplyQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyQueryResponseBody> body{};

  ApplyQueryResponse() {}

  explicit ApplyQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyQueryResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyQueryResponse() = default;
};
class BtripBillInfoAdjustHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  BtripBillInfoAdjustHeaders() {}

  explicit BtripBillInfoAdjustHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~BtripBillInfoAdjustHeaders() = default;
};
class BtripBillInfoAdjustRequest : public Darabonba::Model {
public:
  shared_ptr<long> primaryId{};
  shared_ptr<string> thirdPartCostCenterId{};
  shared_ptr<string> thirdPartDepartmentId{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<string> thirdPartProjectId{};
  shared_ptr<string> userId{};

  BtripBillInfoAdjustRequest() {}

  explicit BtripBillInfoAdjustRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (primaryId) {
      res["primary_id"] = boost::any(*primaryId);
    }
    if (thirdPartCostCenterId) {
      res["third_part_cost_center_id"] = boost::any(*thirdPartCostCenterId);
    }
    if (thirdPartDepartmentId) {
      res["third_part_department_id"] = boost::any(*thirdPartDepartmentId);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (thirdPartProjectId) {
      res["third_part_project_id"] = boost::any(*thirdPartProjectId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("primary_id") != m.end() && !m["primary_id"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["primary_id"]));
    }
    if (m.find("third_part_cost_center_id") != m.end() && !m["third_part_cost_center_id"].empty()) {
      thirdPartCostCenterId = make_shared<string>(boost::any_cast<string>(m["third_part_cost_center_id"]));
    }
    if (m.find("third_part_department_id") != m.end() && !m["third_part_department_id"].empty()) {
      thirdPartDepartmentId = make_shared<string>(boost::any_cast<string>(m["third_part_department_id"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("third_part_project_id") != m.end() && !m["third_part_project_id"].empty()) {
      thirdPartProjectId = make_shared<string>(boost::any_cast<string>(m["third_part_project_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~BtripBillInfoAdjustRequest() = default;
};
class BtripBillInfoAdjustResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  BtripBillInfoAdjustResponseBody() {}

  explicit BtripBillInfoAdjustResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~BtripBillInfoAdjustResponseBody() = default;
};
class BtripBillInfoAdjustResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BtripBillInfoAdjustResponseBody> body{};

  BtripBillInfoAdjustResponse() {}

  explicit BtripBillInfoAdjustResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BtripBillInfoAdjustResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BtripBillInfoAdjustResponseBody>(model1);
      }
    }
  }


  virtual ~BtripBillInfoAdjustResponse() = default;
};
class CarApplyAddHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CarApplyAddHeaders() {}

  explicit CarApplyAddHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CarApplyAddHeaders() = default;
};
class CarApplyAddRequest : public Darabonba::Model {
public:
  shared_ptr<string> cause{};
  shared_ptr<string> city{};
  shared_ptr<string> date{};
  shared_ptr<string> finishedDate{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdPartApplyId{};
  shared_ptr<string> thirdPartCostCenterId{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<long> timesTotal{};
  shared_ptr<long> timesType{};
  shared_ptr<long> timesUsed{};
  shared_ptr<string> title{};
  shared_ptr<string> userId{};

  CarApplyAddRequest() {}

  explicit CarApplyAddRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cause) {
      res["cause"] = boost::any(*cause);
    }
    if (city) {
      res["city"] = boost::any(*city);
    }
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (finishedDate) {
      res["finished_date"] = boost::any(*finishedDate);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdPartApplyId) {
      res["third_part_apply_id"] = boost::any(*thirdPartApplyId);
    }
    if (thirdPartCostCenterId) {
      res["third_part_cost_center_id"] = boost::any(*thirdPartCostCenterId);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (timesTotal) {
      res["times_total"] = boost::any(*timesTotal);
    }
    if (timesType) {
      res["times_type"] = boost::any(*timesType);
    }
    if (timesUsed) {
      res["times_used"] = boost::any(*timesUsed);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cause") != m.end() && !m["cause"].empty()) {
      cause = make_shared<string>(boost::any_cast<string>(m["cause"]));
    }
    if (m.find("city") != m.end() && !m["city"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["city"]));
    }
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("finished_date") != m.end() && !m["finished_date"].empty()) {
      finishedDate = make_shared<string>(boost::any_cast<string>(m["finished_date"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("third_part_apply_id") != m.end() && !m["third_part_apply_id"].empty()) {
      thirdPartApplyId = make_shared<string>(boost::any_cast<string>(m["third_part_apply_id"]));
    }
    if (m.find("third_part_cost_center_id") != m.end() && !m["third_part_cost_center_id"].empty()) {
      thirdPartCostCenterId = make_shared<string>(boost::any_cast<string>(m["third_part_cost_center_id"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("times_total") != m.end() && !m["times_total"].empty()) {
      timesTotal = make_shared<long>(boost::any_cast<long>(m["times_total"]));
    }
    if (m.find("times_type") != m.end() && !m["times_type"].empty()) {
      timesType = make_shared<long>(boost::any_cast<long>(m["times_type"]));
    }
    if (m.find("times_used") != m.end() && !m["times_used"].empty()) {
      timesUsed = make_shared<long>(boost::any_cast<long>(m["times_used"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CarApplyAddRequest() = default;
};
class CarApplyAddResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<long> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CarApplyAddResponseBody() {}

  explicit CarApplyAddResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<long>(boost::any_cast<long>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CarApplyAddResponseBody() = default;
};
class CarApplyAddResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CarApplyAddResponseBody> body{};

  CarApplyAddResponse() {}

  explicit CarApplyAddResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CarApplyAddResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CarApplyAddResponseBody>(model1);
      }
    }
  }


  virtual ~CarApplyAddResponse() = default;
};
class CarApplyModifyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CarApplyModifyHeaders() {}

  explicit CarApplyModifyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CarApplyModifyHeaders() = default;
};
class CarApplyModifyRequest : public Darabonba::Model {
public:
  shared_ptr<string> operateTime{};
  shared_ptr<string> remark{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdPartApplyId{};
  shared_ptr<string> userId{};

  CarApplyModifyRequest() {}

  explicit CarApplyModifyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateTime) {
      res["operate_time"] = boost::any(*operateTime);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdPartApplyId) {
      res["third_part_apply_id"] = boost::any(*thirdPartApplyId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("operate_time") != m.end() && !m["operate_time"].empty()) {
      operateTime = make_shared<string>(boost::any_cast<string>(m["operate_time"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("third_part_apply_id") != m.end() && !m["third_part_apply_id"].empty()) {
      thirdPartApplyId = make_shared<string>(boost::any_cast<string>(m["third_part_apply_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CarApplyModifyRequest() = default;
};
class CarApplyModifyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CarApplyModifyResponseBody() {}

  explicit CarApplyModifyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<bool>(boost::any_cast<bool>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CarApplyModifyResponseBody() = default;
};
class CarApplyModifyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CarApplyModifyResponseBody> body{};

  CarApplyModifyResponse() {}

  explicit CarApplyModifyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CarApplyModifyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CarApplyModifyResponseBody>(model1);
      }
    }
  }


  virtual ~CarApplyModifyResponse() = default;
};
class CarApplyQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CarApplyQueryHeaders() {}

  explicit CarApplyQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CarApplyQueryHeaders() = default;
};
class CarApplyQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> createdEndAt{};
  shared_ptr<string> createdStartAt{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> thirdPartApplyId{};
  shared_ptr<string> userId{};

  CarApplyQueryRequest() {}

  explicit CarApplyQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdEndAt) {
      res["created_end_at"] = boost::any(*createdEndAt);
    }
    if (createdStartAt) {
      res["created_start_at"] = boost::any(*createdStartAt);
    }
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (thirdPartApplyId) {
      res["third_part_apply_id"] = boost::any(*thirdPartApplyId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("created_end_at") != m.end() && !m["created_end_at"].empty()) {
      createdEndAt = make_shared<string>(boost::any_cast<string>(m["created_end_at"]));
    }
    if (m.find("created_start_at") != m.end() && !m["created_start_at"].empty()) {
      createdStartAt = make_shared<string>(boost::any_cast<string>(m["created_start_at"]));
    }
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("third_part_apply_id") != m.end() && !m["third_part_apply_id"].empty()) {
      thirdPartApplyId = make_shared<string>(boost::any_cast<string>(m["third_part_apply_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CarApplyQueryRequest() = default;
};
class CarApplyQueryResponseBodyApplyListApproverList : public Darabonba::Model {
public:
  shared_ptr<string> note{};
  shared_ptr<string> operateTime{};
  shared_ptr<long> order{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CarApplyQueryResponseBodyApplyListApproverList() {}

  explicit CarApplyQueryResponseBodyApplyListApproverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (note) {
      res["note"] = boost::any(*note);
    }
    if (operateTime) {
      res["operate_time"] = boost::any(*operateTime);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["status_desc"] = boost::any(*statusDesc);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("note") != m.end() && !m["note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["note"]));
    }
    if (m.find("operate_time") != m.end() && !m["operate_time"].empty()) {
      operateTime = make_shared<string>(boost::any_cast<string>(m["operate_time"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["order"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("status_desc") != m.end() && !m["status_desc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["status_desc"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~CarApplyQueryResponseBodyApplyListApproverList() = default;
};
class CarApplyQueryResponseBodyApplyListItineraryList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrDate{};
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<long> invoiceId{};
  shared_ptr<string> invoiceName{};
  shared_ptr<string> itineraryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<long> trafficType{};

  CarApplyQueryResponseBodyApplyListItineraryList() {}

  explicit CarApplyQueryResponseBodyApplyListItineraryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceId) {
      res["invoice_id"] = boost::any(*invoiceId);
    }
    if (invoiceName) {
      res["invoice_name"] = boost::any(*invoiceName);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_id") != m.end() && !m["invoice_id"].empty()) {
      invoiceId = make_shared<long>(boost::any_cast<long>(m["invoice_id"]));
    }
    if (m.find("invoice_name") != m.end() && !m["invoice_name"].empty()) {
      invoiceName = make_shared<string>(boost::any_cast<string>(m["invoice_name"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
  }


  virtual ~CarApplyQueryResponseBodyApplyListItineraryList() = default;
};
class CarApplyQueryResponseBodyApplyList : public Darabonba::Model {
public:
  shared_ptr<vector<CarApplyQueryResponseBodyApplyListApproverList>> approverList{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<vector<CarApplyQueryResponseBodyApplyListItineraryList>> itineraryList{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<string> tripCause{};
  shared_ptr<string> tripTitle{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CarApplyQueryResponseBodyApplyList() {}

  explicit CarApplyQueryResponseBodyApplyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approverList) {
      vector<boost::any> temp1;
      for(auto item1:*approverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["approver_list"] = boost::any(temp1);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (itineraryList) {
      vector<boost::any> temp1;
      for(auto item1:*itineraryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_list"] = boost::any(temp1);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["status_desc"] = boost::any(*statusDesc);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("approver_list") != m.end() && !m["approver_list"].empty()) {
      if (typeid(vector<boost::any>) == m["approver_list"].type()) {
        vector<CarApplyQueryResponseBodyApplyListApproverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["approver_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarApplyQueryResponseBodyApplyListApproverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        approverList = make_shared<vector<CarApplyQueryResponseBodyApplyListApproverList>>(expect1);
      }
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_list"].type()) {
        vector<CarApplyQueryResponseBodyApplyListItineraryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarApplyQueryResponseBodyApplyListItineraryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itineraryList = make_shared<vector<CarApplyQueryResponseBodyApplyListItineraryList>>(expect1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("status_desc") != m.end() && !m["status_desc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["status_desc"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~CarApplyQueryResponseBodyApplyList() = default;
};
class CarApplyQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CarApplyQueryResponseBodyApplyList>> applyList{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};
  shared_ptr<string> traceId{};

  CarApplyQueryResponseBody() {}

  explicit CarApplyQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyList) {
      vector<boost::any> temp1;
      for(auto item1:*applyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["apply_list"] = boost::any(temp1);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_list") != m.end() && !m["apply_list"].empty()) {
      if (typeid(vector<boost::any>) == m["apply_list"].type()) {
        vector<CarApplyQueryResponseBodyApplyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["apply_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarApplyQueryResponseBodyApplyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyList = make_shared<vector<CarApplyQueryResponseBodyApplyList>>(expect1);
      }
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CarApplyQueryResponseBody() = default;
};
class CarApplyQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CarApplyQueryResponseBody> body{};

  CarApplyQueryResponse() {}

  explicit CarApplyQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CarApplyQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CarApplyQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CarApplyQueryResponse() = default;
};
class CarBillSettlementQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CarBillSettlementQueryHeaders() {}

  explicit CarBillSettlementQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CarBillSettlementQueryHeaders() = default;
};
class CarBillSettlementQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};

  CarBillSettlementQueryRequest() {}

  explicit CarBillSettlementQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
  }


  virtual ~CarBillSettlementQueryRequest() = default;
};
class CarBillSettlementQueryResponseBodyModuleDataList : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> applyId{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> arrLocation{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> billRecordTime{};
  shared_ptr<string> bookTime{};
  shared_ptr<string> bookerId{};
  shared_ptr<string> bookerJobNo{};
  shared_ptr<string> bookerName{};
  shared_ptr<string> businessCategory{};
  shared_ptr<string> capitalDirection{};
  shared_ptr<string> carLevel{};
  shared_ptr<string> cascadeDepartment{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<double> coupon{};
  shared_ptr<double> couponPrice{};
  shared_ptr<string> department{};
  shared_ptr<string> departmentId{};
  shared_ptr<string> deptCity{};
  shared_ptr<string> deptDate{};
  shared_ptr<string> deptLocation{};
  shared_ptr<string> deptTime{};
  shared_ptr<string> estimateDriveDistance{};
  shared_ptr<double> estimatePrice{};
  shared_ptr<string> feeType{};
  shared_ptr<string> index{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> memo{};
  shared_ptr<string> orderId{};
  shared_ptr<double> orderPrice{};
  shared_ptr<string> overApplyId{};
  shared_ptr<double> personSettleFee{};
  shared_ptr<long> primaryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<string> providerName{};
  shared_ptr<string> realDriveDistance{};
  shared_ptr<string> realFromAddr{};
  shared_ptr<string> realToAddr{};
  shared_ptr<string> remark{};
  shared_ptr<double> serviceFee{};
  shared_ptr<double> settlementFee{};
  shared_ptr<double> settlementGrantFee{};
  shared_ptr<string> settlementTime{};
  shared_ptr<string> settlementType{};
  shared_ptr<string> specialOrder{};
  shared_ptr<string> specialReason{};
  shared_ptr<long> status{};
  shared_ptr<string> subOrderId{};
  shared_ptr<string> travelerId{};
  shared_ptr<string> travelerJobNo{};
  shared_ptr<string> travelerName{};
  shared_ptr<string> userConfirmDesc{};
  shared_ptr<long> voucherType{};

  CarBillSettlementQueryResponseBodyModuleDataList() {}

  explicit CarBillSettlementQueryResponseBodyModuleDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (arrLocation) {
      res["arr_location"] = boost::any(*arrLocation);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (billRecordTime) {
      res["bill_record_time"] = boost::any(*billRecordTime);
    }
    if (bookTime) {
      res["book_time"] = boost::any(*bookTime);
    }
    if (bookerId) {
      res["booker_id"] = boost::any(*bookerId);
    }
    if (bookerJobNo) {
      res["booker_job_no"] = boost::any(*bookerJobNo);
    }
    if (bookerName) {
      res["booker_name"] = boost::any(*bookerName);
    }
    if (businessCategory) {
      res["business_category"] = boost::any(*businessCategory);
    }
    if (capitalDirection) {
      res["capital_direction"] = boost::any(*capitalDirection);
    }
    if (carLevel) {
      res["car_level"] = boost::any(*carLevel);
    }
    if (cascadeDepartment) {
      res["cascade_department"] = boost::any(*cascadeDepartment);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (coupon) {
      res["coupon"] = boost::any(*coupon);
    }
    if (couponPrice) {
      res["coupon_price"] = boost::any(*couponPrice);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (departmentId) {
      res["department_id"] = boost::any(*departmentId);
    }
    if (deptCity) {
      res["dept_city"] = boost::any(*deptCity);
    }
    if (deptDate) {
      res["dept_date"] = boost::any(*deptDate);
    }
    if (deptLocation) {
      res["dept_location"] = boost::any(*deptLocation);
    }
    if (deptTime) {
      res["dept_time"] = boost::any(*deptTime);
    }
    if (estimateDriveDistance) {
      res["estimate_drive_distance"] = boost::any(*estimateDriveDistance);
    }
    if (estimatePrice) {
      res["estimate_price"] = boost::any(*estimatePrice);
    }
    if (feeType) {
      res["fee_type"] = boost::any(*feeType);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderPrice) {
      res["order_price"] = boost::any(*orderPrice);
    }
    if (overApplyId) {
      res["over_apply_id"] = boost::any(*overApplyId);
    }
    if (personSettleFee) {
      res["person_settle_fee"] = boost::any(*personSettleFee);
    }
    if (primaryId) {
      res["primary_id"] = boost::any(*primaryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (providerName) {
      res["provider_name"] = boost::any(*providerName);
    }
    if (realDriveDistance) {
      res["real_drive_distance"] = boost::any(*realDriveDistance);
    }
    if (realFromAddr) {
      res["real_from_addr"] = boost::any(*realFromAddr);
    }
    if (realToAddr) {
      res["real_to_addr"] = boost::any(*realToAddr);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (settlementFee) {
      res["settlement_fee"] = boost::any(*settlementFee);
    }
    if (settlementGrantFee) {
      res["settlement_grant_fee"] = boost::any(*settlementGrantFee);
    }
    if (settlementTime) {
      res["settlement_time"] = boost::any(*settlementTime);
    }
    if (settlementType) {
      res["settlement_type"] = boost::any(*settlementType);
    }
    if (specialOrder) {
      res["special_order"] = boost::any(*specialOrder);
    }
    if (specialReason) {
      res["special_reason"] = boost::any(*specialReason);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    if (travelerId) {
      res["traveler_id"] = boost::any(*travelerId);
    }
    if (travelerJobNo) {
      res["traveler_job_no"] = boost::any(*travelerJobNo);
    }
    if (travelerName) {
      res["traveler_name"] = boost::any(*travelerName);
    }
    if (userConfirmDesc) {
      res["user_confirm_desc"] = boost::any(*userConfirmDesc);
    }
    if (voucherType) {
      res["voucher_type"] = boost::any(*voucherType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("arr_location") != m.end() && !m["arr_location"].empty()) {
      arrLocation = make_shared<string>(boost::any_cast<string>(m["arr_location"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("bill_record_time") != m.end() && !m["bill_record_time"].empty()) {
      billRecordTime = make_shared<string>(boost::any_cast<string>(m["bill_record_time"]));
    }
    if (m.find("book_time") != m.end() && !m["book_time"].empty()) {
      bookTime = make_shared<string>(boost::any_cast<string>(m["book_time"]));
    }
    if (m.find("booker_id") != m.end() && !m["booker_id"].empty()) {
      bookerId = make_shared<string>(boost::any_cast<string>(m["booker_id"]));
    }
    if (m.find("booker_job_no") != m.end() && !m["booker_job_no"].empty()) {
      bookerJobNo = make_shared<string>(boost::any_cast<string>(m["booker_job_no"]));
    }
    if (m.find("booker_name") != m.end() && !m["booker_name"].empty()) {
      bookerName = make_shared<string>(boost::any_cast<string>(m["booker_name"]));
    }
    if (m.find("business_category") != m.end() && !m["business_category"].empty()) {
      businessCategory = make_shared<string>(boost::any_cast<string>(m["business_category"]));
    }
    if (m.find("capital_direction") != m.end() && !m["capital_direction"].empty()) {
      capitalDirection = make_shared<string>(boost::any_cast<string>(m["capital_direction"]));
    }
    if (m.find("car_level") != m.end() && !m["car_level"].empty()) {
      carLevel = make_shared<string>(boost::any_cast<string>(m["car_level"]));
    }
    if (m.find("cascade_department") != m.end() && !m["cascade_department"].empty()) {
      cascadeDepartment = make_shared<string>(boost::any_cast<string>(m["cascade_department"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("coupon") != m.end() && !m["coupon"].empty()) {
      coupon = make_shared<double>(boost::any_cast<double>(m["coupon"]));
    }
    if (m.find("coupon_price") != m.end() && !m["coupon_price"].empty()) {
      couponPrice = make_shared<double>(boost::any_cast<double>(m["coupon_price"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("department_id") != m.end() && !m["department_id"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["department_id"]));
    }
    if (m.find("dept_city") != m.end() && !m["dept_city"].empty()) {
      deptCity = make_shared<string>(boost::any_cast<string>(m["dept_city"]));
    }
    if (m.find("dept_date") != m.end() && !m["dept_date"].empty()) {
      deptDate = make_shared<string>(boost::any_cast<string>(m["dept_date"]));
    }
    if (m.find("dept_location") != m.end() && !m["dept_location"].empty()) {
      deptLocation = make_shared<string>(boost::any_cast<string>(m["dept_location"]));
    }
    if (m.find("dept_time") != m.end() && !m["dept_time"].empty()) {
      deptTime = make_shared<string>(boost::any_cast<string>(m["dept_time"]));
    }
    if (m.find("estimate_drive_distance") != m.end() && !m["estimate_drive_distance"].empty()) {
      estimateDriveDistance = make_shared<string>(boost::any_cast<string>(m["estimate_drive_distance"]));
    }
    if (m.find("estimate_price") != m.end() && !m["estimate_price"].empty()) {
      estimatePrice = make_shared<double>(boost::any_cast<double>(m["estimate_price"]));
    }
    if (m.find("fee_type") != m.end() && !m["fee_type"].empty()) {
      feeType = make_shared<string>(boost::any_cast<string>(m["fee_type"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("order_price") != m.end() && !m["order_price"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["order_price"]));
    }
    if (m.find("over_apply_id") != m.end() && !m["over_apply_id"].empty()) {
      overApplyId = make_shared<string>(boost::any_cast<string>(m["over_apply_id"]));
    }
    if (m.find("person_settle_fee") != m.end() && !m["person_settle_fee"].empty()) {
      personSettleFee = make_shared<double>(boost::any_cast<double>(m["person_settle_fee"]));
    }
    if (m.find("primary_id") != m.end() && !m["primary_id"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["primary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("provider_name") != m.end() && !m["provider_name"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["provider_name"]));
    }
    if (m.find("real_drive_distance") != m.end() && !m["real_drive_distance"].empty()) {
      realDriveDistance = make_shared<string>(boost::any_cast<string>(m["real_drive_distance"]));
    }
    if (m.find("real_from_addr") != m.end() && !m["real_from_addr"].empty()) {
      realFromAddr = make_shared<string>(boost::any_cast<string>(m["real_from_addr"]));
    }
    if (m.find("real_to_addr") != m.end() && !m["real_to_addr"].empty()) {
      realToAddr = make_shared<string>(boost::any_cast<string>(m["real_to_addr"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("settlement_fee") != m.end() && !m["settlement_fee"].empty()) {
      settlementFee = make_shared<double>(boost::any_cast<double>(m["settlement_fee"]));
    }
    if (m.find("settlement_grant_fee") != m.end() && !m["settlement_grant_fee"].empty()) {
      settlementGrantFee = make_shared<double>(boost::any_cast<double>(m["settlement_grant_fee"]));
    }
    if (m.find("settlement_time") != m.end() && !m["settlement_time"].empty()) {
      settlementTime = make_shared<string>(boost::any_cast<string>(m["settlement_time"]));
    }
    if (m.find("settlement_type") != m.end() && !m["settlement_type"].empty()) {
      settlementType = make_shared<string>(boost::any_cast<string>(m["settlement_type"]));
    }
    if (m.find("special_order") != m.end() && !m["special_order"].empty()) {
      specialOrder = make_shared<string>(boost::any_cast<string>(m["special_order"]));
    }
    if (m.find("special_reason") != m.end() && !m["special_reason"].empty()) {
      specialReason = make_shared<string>(boost::any_cast<string>(m["special_reason"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<string>(boost::any_cast<string>(m["sub_order_id"]));
    }
    if (m.find("traveler_id") != m.end() && !m["traveler_id"].empty()) {
      travelerId = make_shared<string>(boost::any_cast<string>(m["traveler_id"]));
    }
    if (m.find("traveler_job_no") != m.end() && !m["traveler_job_no"].empty()) {
      travelerJobNo = make_shared<string>(boost::any_cast<string>(m["traveler_job_no"]));
    }
    if (m.find("traveler_name") != m.end() && !m["traveler_name"].empty()) {
      travelerName = make_shared<string>(boost::any_cast<string>(m["traveler_name"]));
    }
    if (m.find("user_confirm_desc") != m.end() && !m["user_confirm_desc"].empty()) {
      userConfirmDesc = make_shared<string>(boost::any_cast<string>(m["user_confirm_desc"]));
    }
    if (m.find("voucher_type") != m.end() && !m["voucher_type"].empty()) {
      voucherType = make_shared<long>(boost::any_cast<long>(m["voucher_type"]));
    }
  }


  virtual ~CarBillSettlementQueryResponseBodyModuleDataList() = default;
};
class CarBillSettlementQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> category{};
  shared_ptr<string> corpId{};
  shared_ptr<vector<CarBillSettlementQueryResponseBodyModuleDataList>> dataList{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};
  shared_ptr<long> totalNum{};

  CarBillSettlementQueryResponseBodyModule() {}

  explicit CarBillSettlementQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_list"] = boost::any(temp1);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    if (totalNum) {
      res["total_num"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["category"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("data_list") != m.end() && !m["data_list"].empty()) {
      if (typeid(vector<boost::any>) == m["data_list"].type()) {
        vector<CarBillSettlementQueryResponseBodyModuleDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarBillSettlementQueryResponseBodyModuleDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<CarBillSettlementQueryResponseBodyModuleDataList>>(expect1);
      }
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
    if (m.find("total_num") != m.end() && !m["total_num"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["total_num"]));
    }
  }


  virtual ~CarBillSettlementQueryResponseBodyModule() = default;
};
class CarBillSettlementQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CarBillSettlementQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CarBillSettlementQueryResponseBody() {}

  explicit CarBillSettlementQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CarBillSettlementQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CarBillSettlementQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CarBillSettlementQueryResponseBody() = default;
};
class CarBillSettlementQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CarBillSettlementQueryResponseBody> body{};

  CarBillSettlementQueryResponse() {}

  explicit CarBillSettlementQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CarBillSettlementQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CarBillSettlementQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CarBillSettlementQueryResponse() = default;
};
class CarOrderListQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CarOrderListQueryHeaders() {}

  explicit CarOrderListQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CarOrderListQueryHeaders() = default;
};
class CarOrderListQueryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allApply{};
  shared_ptr<long> applyId{};
  shared_ptr<string> departId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> updateEndTime{};
  shared_ptr<string> updateStartTime{};
  shared_ptr<string> userId{};

  CarOrderListQueryRequest() {}

  explicit CarOrderListQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allApply) {
      res["all_apply"] = boost::any(*allApply);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (updateEndTime) {
      res["update_end_time"] = boost::any(*updateEndTime);
    }
    if (updateStartTime) {
      res["update_start_time"] = boost::any(*updateStartTime);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_apply") != m.end() && !m["all_apply"].empty()) {
      allApply = make_shared<bool>(boost::any_cast<bool>(m["all_apply"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("update_end_time") != m.end() && !m["update_end_time"].empty()) {
      updateEndTime = make_shared<string>(boost::any_cast<string>(m["update_end_time"]));
    }
    if (m.find("update_start_time") != m.end() && !m["update_start_time"].empty()) {
      updateStartTime = make_shared<string>(boost::any_cast<string>(m["update_start_time"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CarOrderListQueryRequest() = default;
};
class CarOrderListQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<long> categoryType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> personPrice{};
  shared_ptr<double> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  CarOrderListQueryResponseBodyModulePriceInfoList() {}

  explicit CarOrderListQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (categoryType) {
      res["category_type"] = boost::any(*categoryType);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (personPrice) {
      res["person_price"] = boost::any(*personPrice);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("category_type") != m.end() && !m["category_type"].empty()) {
      categoryType = make_shared<long>(boost::any_cast<long>(m["category_type"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("person_price") != m.end() && !m["person_price"].empty()) {
      personPrice = make_shared<double>(boost::any_cast<double>(m["person_price"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~CarOrderListQueryResponseBodyModulePriceInfoList() = default;
};
class CarOrderListQueryResponseBodyModuleUserAffiliateList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CarOrderListQueryResponseBodyModuleUserAffiliateList() {}

  explicit CarOrderListQueryResponseBodyModuleUserAffiliateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~CarOrderListQueryResponseBodyModuleUserAffiliateList() = default;
};
class CarOrderListQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> applyShowId{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> businessCategory{};
  shared_ptr<string> cancelTime{};
  shared_ptr<string> carInfo{};
  shared_ptr<long> carLevel{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<long> deptId{};
  shared_ptr<string> deptName{};
  shared_ptr<string> driverConfirmTime{};
  shared_ptr<double> estimatePrice{};
  shared_ptr<string> fromAddress{};
  shared_ptr<string> fromCityName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> invoiceId{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<bool> isSpecial{};
  shared_ptr<string> memo{};
  shared_ptr<long> orderStatus{};
  shared_ptr<string> passengerName{};
  shared_ptr<string> payTime{};
  shared_ptr<vector<CarOrderListQueryResponseBodyModulePriceInfoList>> priceInfoList{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<long> provider{};
  shared_ptr<string> publishTime{};
  shared_ptr<string> realFromAddress{};
  shared_ptr<string> realFromCityName{};
  shared_ptr<string> realToAddress{};
  shared_ptr<string> realToCityName{};
  shared_ptr<long> serviceType{};
  shared_ptr<vector<string>> specialTypes{};
  shared_ptr<string> takenTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<string> toAddress{};
  shared_ptr<string> toCityName{};
  shared_ptr<double> travelDistance{};
  shared_ptr<vector<CarOrderListQueryResponseBodyModuleUserAffiliateList>> userAffiliateList{};
  shared_ptr<long> userConfirm{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CarOrderListQueryResponseBodyModule() {}

  explicit CarOrderListQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (applyShowId) {
      res["apply_show_id"] = boost::any(*applyShowId);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (businessCategory) {
      res["business_category"] = boost::any(*businessCategory);
    }
    if (cancelTime) {
      res["cancel_time"] = boost::any(*cancelTime);
    }
    if (carInfo) {
      res["car_info"] = boost::any(*carInfo);
    }
    if (carLevel) {
      res["car_level"] = boost::any(*carLevel);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (deptId) {
      res["dept_id"] = boost::any(*deptId);
    }
    if (deptName) {
      res["dept_name"] = boost::any(*deptName);
    }
    if (driverConfirmTime) {
      res["driver_confirm_time"] = boost::any(*driverConfirmTime);
    }
    if (estimatePrice) {
      res["estimate_price"] = boost::any(*estimatePrice);
    }
    if (fromAddress) {
      res["from_address"] = boost::any(*fromAddress);
    }
    if (fromCityName) {
      res["from_city_name"] = boost::any(*fromCityName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (invoiceId) {
      res["invoice_id"] = boost::any(*invoiceId);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (isSpecial) {
      res["is_special"] = boost::any(*isSpecial);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (provider) {
      res["provider"] = boost::any(*provider);
    }
    if (publishTime) {
      res["publish_time"] = boost::any(*publishTime);
    }
    if (realFromAddress) {
      res["real_from_address"] = boost::any(*realFromAddress);
    }
    if (realFromCityName) {
      res["real_from_city_name"] = boost::any(*realFromCityName);
    }
    if (realToAddress) {
      res["real_to_address"] = boost::any(*realToAddress);
    }
    if (realToCityName) {
      res["real_to_city_name"] = boost::any(*realToCityName);
    }
    if (serviceType) {
      res["service_type"] = boost::any(*serviceType);
    }
    if (specialTypes) {
      res["special_types"] = boost::any(*specialTypes);
    }
    if (takenTime) {
      res["taken_time"] = boost::any(*takenTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (toAddress) {
      res["to_address"] = boost::any(*toAddress);
    }
    if (toCityName) {
      res["to_city_name"] = boost::any(*toCityName);
    }
    if (travelDistance) {
      res["travel_distance"] = boost::any(*travelDistance);
    }
    if (userAffiliateList) {
      vector<boost::any> temp1;
      for(auto item1:*userAffiliateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["user_affiliate_list"] = boost::any(temp1);
    }
    if (userConfirm) {
      res["user_confirm"] = boost::any(*userConfirm);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("apply_show_id") != m.end() && !m["apply_show_id"].empty()) {
      applyShowId = make_shared<string>(boost::any_cast<string>(m["apply_show_id"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("business_category") != m.end() && !m["business_category"].empty()) {
      businessCategory = make_shared<string>(boost::any_cast<string>(m["business_category"]));
    }
    if (m.find("cancel_time") != m.end() && !m["cancel_time"].empty()) {
      cancelTime = make_shared<string>(boost::any_cast<string>(m["cancel_time"]));
    }
    if (m.find("car_info") != m.end() && !m["car_info"].empty()) {
      carInfo = make_shared<string>(boost::any_cast<string>(m["car_info"]));
    }
    if (m.find("car_level") != m.end() && !m["car_level"].empty()) {
      carLevel = make_shared<long>(boost::any_cast<long>(m["car_level"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("dept_id") != m.end() && !m["dept_id"].empty()) {
      deptId = make_shared<long>(boost::any_cast<long>(m["dept_id"]));
    }
    if (m.find("dept_name") != m.end() && !m["dept_name"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["dept_name"]));
    }
    if (m.find("driver_confirm_time") != m.end() && !m["driver_confirm_time"].empty()) {
      driverConfirmTime = make_shared<string>(boost::any_cast<string>(m["driver_confirm_time"]));
    }
    if (m.find("estimate_price") != m.end() && !m["estimate_price"].empty()) {
      estimatePrice = make_shared<double>(boost::any_cast<double>(m["estimate_price"]));
    }
    if (m.find("from_address") != m.end() && !m["from_address"].empty()) {
      fromAddress = make_shared<string>(boost::any_cast<string>(m["from_address"]));
    }
    if (m.find("from_city_name") != m.end() && !m["from_city_name"].empty()) {
      fromCityName = make_shared<string>(boost::any_cast<string>(m["from_city_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("invoice_id") != m.end() && !m["invoice_id"].empty()) {
      invoiceId = make_shared<long>(boost::any_cast<long>(m["invoice_id"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("is_special") != m.end() && !m["is_special"].empty()) {
      isSpecial = make_shared<bool>(boost::any_cast<bool>(m["is_special"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<string>(boost::any_cast<string>(m["pay_time"]));
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<CarOrderListQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarOrderListQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<CarOrderListQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("provider") != m.end() && !m["provider"].empty()) {
      provider = make_shared<long>(boost::any_cast<long>(m["provider"]));
    }
    if (m.find("publish_time") != m.end() && !m["publish_time"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["publish_time"]));
    }
    if (m.find("real_from_address") != m.end() && !m["real_from_address"].empty()) {
      realFromAddress = make_shared<string>(boost::any_cast<string>(m["real_from_address"]));
    }
    if (m.find("real_from_city_name") != m.end() && !m["real_from_city_name"].empty()) {
      realFromCityName = make_shared<string>(boost::any_cast<string>(m["real_from_city_name"]));
    }
    if (m.find("real_to_address") != m.end() && !m["real_to_address"].empty()) {
      realToAddress = make_shared<string>(boost::any_cast<string>(m["real_to_address"]));
    }
    if (m.find("real_to_city_name") != m.end() && !m["real_to_city_name"].empty()) {
      realToCityName = make_shared<string>(boost::any_cast<string>(m["real_to_city_name"]));
    }
    if (m.find("service_type") != m.end() && !m["service_type"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["service_type"]));
    }
    if (m.find("special_types") != m.end() && !m["special_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["special_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["special_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      specialTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("taken_time") != m.end() && !m["taken_time"].empty()) {
      takenTime = make_shared<string>(boost::any_cast<string>(m["taken_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("to_address") != m.end() && !m["to_address"].empty()) {
      toAddress = make_shared<string>(boost::any_cast<string>(m["to_address"]));
    }
    if (m.find("to_city_name") != m.end() && !m["to_city_name"].empty()) {
      toCityName = make_shared<string>(boost::any_cast<string>(m["to_city_name"]));
    }
    if (m.find("travel_distance") != m.end() && !m["travel_distance"].empty()) {
      travelDistance = make_shared<double>(boost::any_cast<double>(m["travel_distance"]));
    }
    if (m.find("user_affiliate_list") != m.end() && !m["user_affiliate_list"].empty()) {
      if (typeid(vector<boost::any>) == m["user_affiliate_list"].type()) {
        vector<CarOrderListQueryResponseBodyModuleUserAffiliateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["user_affiliate_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarOrderListQueryResponseBodyModuleUserAffiliateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userAffiliateList = make_shared<vector<CarOrderListQueryResponseBodyModuleUserAffiliateList>>(expect1);
      }
    }
    if (m.find("user_confirm") != m.end() && !m["user_confirm"].empty()) {
      userConfirm = make_shared<long>(boost::any_cast<long>(m["user_confirm"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~CarOrderListQueryResponseBodyModule() = default;
};
class CarOrderListQueryResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalNumber{};

  CarOrderListQueryResponseBodyPageInfo() {}

  explicit CarOrderListQueryResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalNumber) {
      res["total_number"] = boost::any(*totalNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_number") != m.end() && !m["total_number"].empty()) {
      totalNumber = make_shared<long>(boost::any_cast<long>(m["total_number"]));
    }
  }


  virtual ~CarOrderListQueryResponseBodyPageInfo() = default;
};
class CarOrderListQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<CarOrderListQueryResponseBodyModule>> module{};
  shared_ptr<CarOrderListQueryResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CarOrderListQueryResponseBody() {}

  explicit CarOrderListQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<CarOrderListQueryResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarOrderListQueryResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<CarOrderListQueryResponseBodyModule>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        CarOrderListQueryResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<CarOrderListQueryResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CarOrderListQueryResponseBody() = default;
};
class CarOrderListQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CarOrderListQueryResponseBody> body{};

  CarOrderListQueryResponse() {}

  explicit CarOrderListQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CarOrderListQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CarOrderListQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CarOrderListQueryResponse() = default;
};
class CarOrderQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CarOrderQueryHeaders() {}

  explicit CarOrderQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CarOrderQueryHeaders() = default;
};
class CarOrderQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> subOrderId{};

  CarOrderQueryRequest() {}

  explicit CarOrderQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<long>(boost::any_cast<long>(m["sub_order_id"]));
    }
  }


  virtual ~CarOrderQueryRequest() = default;
};
class CarOrderQueryResponseBodyModuleCarInfo : public Darabonba::Model {
public:
  shared_ptr<string> businessCategory{};
  shared_ptr<long> cancelTime{};
  shared_ptr<string> carInfo{};
  shared_ptr<long> carLevel{};
  shared_ptr<long> driverConfirmTime{};
  shared_ptr<long> estimatePrice{};
  shared_ptr<string> fromAddress{};
  shared_ptr<string> fromCityName{};
  shared_ptr<bool> isSpecial{};
  shared_ptr<string> memo{};
  shared_ptr<long> payTime{};
  shared_ptr<long> publishTime{};
  shared_ptr<string> realFromAddress{};
  shared_ptr<string> realFromCityName{};
  shared_ptr<string> realToAddress{};
  shared_ptr<string> realToCityName{};
  shared_ptr<long> serviceType{};
  shared_ptr<string> specialTypes{};
  shared_ptr<long> takenTime{};
  shared_ptr<string> toAddress{};
  shared_ptr<string> toCityName{};
  shared_ptr<string> travelDistance{};

  CarOrderQueryResponseBodyModuleCarInfo() {}

  explicit CarOrderQueryResponseBodyModuleCarInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessCategory) {
      res["business_category"] = boost::any(*businessCategory);
    }
    if (cancelTime) {
      res["cancel_time"] = boost::any(*cancelTime);
    }
    if (carInfo) {
      res["car_info"] = boost::any(*carInfo);
    }
    if (carLevel) {
      res["car_level"] = boost::any(*carLevel);
    }
    if (driverConfirmTime) {
      res["driver_confirm_time"] = boost::any(*driverConfirmTime);
    }
    if (estimatePrice) {
      res["estimate_price"] = boost::any(*estimatePrice);
    }
    if (fromAddress) {
      res["from_address"] = boost::any(*fromAddress);
    }
    if (fromCityName) {
      res["from_city_name"] = boost::any(*fromCityName);
    }
    if (isSpecial) {
      res["is_special"] = boost::any(*isSpecial);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (publishTime) {
      res["publish_time"] = boost::any(*publishTime);
    }
    if (realFromAddress) {
      res["real_from_address"] = boost::any(*realFromAddress);
    }
    if (realFromCityName) {
      res["real_from_city_name"] = boost::any(*realFromCityName);
    }
    if (realToAddress) {
      res["real_to_address"] = boost::any(*realToAddress);
    }
    if (realToCityName) {
      res["real_to_city_name"] = boost::any(*realToCityName);
    }
    if (serviceType) {
      res["service_type"] = boost::any(*serviceType);
    }
    if (specialTypes) {
      res["special_types"] = boost::any(*specialTypes);
    }
    if (takenTime) {
      res["taken_time"] = boost::any(*takenTime);
    }
    if (toAddress) {
      res["to_address"] = boost::any(*toAddress);
    }
    if (toCityName) {
      res["to_city_name"] = boost::any(*toCityName);
    }
    if (travelDistance) {
      res["travel_distance"] = boost::any(*travelDistance);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_category") != m.end() && !m["business_category"].empty()) {
      businessCategory = make_shared<string>(boost::any_cast<string>(m["business_category"]));
    }
    if (m.find("cancel_time") != m.end() && !m["cancel_time"].empty()) {
      cancelTime = make_shared<long>(boost::any_cast<long>(m["cancel_time"]));
    }
    if (m.find("car_info") != m.end() && !m["car_info"].empty()) {
      carInfo = make_shared<string>(boost::any_cast<string>(m["car_info"]));
    }
    if (m.find("car_level") != m.end() && !m["car_level"].empty()) {
      carLevel = make_shared<long>(boost::any_cast<long>(m["car_level"]));
    }
    if (m.find("driver_confirm_time") != m.end() && !m["driver_confirm_time"].empty()) {
      driverConfirmTime = make_shared<long>(boost::any_cast<long>(m["driver_confirm_time"]));
    }
    if (m.find("estimate_price") != m.end() && !m["estimate_price"].empty()) {
      estimatePrice = make_shared<long>(boost::any_cast<long>(m["estimate_price"]));
    }
    if (m.find("from_address") != m.end() && !m["from_address"].empty()) {
      fromAddress = make_shared<string>(boost::any_cast<string>(m["from_address"]));
    }
    if (m.find("from_city_name") != m.end() && !m["from_city_name"].empty()) {
      fromCityName = make_shared<string>(boost::any_cast<string>(m["from_city_name"]));
    }
    if (m.find("is_special") != m.end() && !m["is_special"].empty()) {
      isSpecial = make_shared<bool>(boost::any_cast<bool>(m["is_special"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<long>(boost::any_cast<long>(m["pay_time"]));
    }
    if (m.find("publish_time") != m.end() && !m["publish_time"].empty()) {
      publishTime = make_shared<long>(boost::any_cast<long>(m["publish_time"]));
    }
    if (m.find("real_from_address") != m.end() && !m["real_from_address"].empty()) {
      realFromAddress = make_shared<string>(boost::any_cast<string>(m["real_from_address"]));
    }
    if (m.find("real_from_city_name") != m.end() && !m["real_from_city_name"].empty()) {
      realFromCityName = make_shared<string>(boost::any_cast<string>(m["real_from_city_name"]));
    }
    if (m.find("real_to_address") != m.end() && !m["real_to_address"].empty()) {
      realToAddress = make_shared<string>(boost::any_cast<string>(m["real_to_address"]));
    }
    if (m.find("real_to_city_name") != m.end() && !m["real_to_city_name"].empty()) {
      realToCityName = make_shared<string>(boost::any_cast<string>(m["real_to_city_name"]));
    }
    if (m.find("service_type") != m.end() && !m["service_type"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["service_type"]));
    }
    if (m.find("special_types") != m.end() && !m["special_types"].empty()) {
      specialTypes = make_shared<string>(boost::any_cast<string>(m["special_types"]));
    }
    if (m.find("taken_time") != m.end() && !m["taken_time"].empty()) {
      takenTime = make_shared<long>(boost::any_cast<long>(m["taken_time"]));
    }
    if (m.find("to_address") != m.end() && !m["to_address"].empty()) {
      toAddress = make_shared<string>(boost::any_cast<string>(m["to_address"]));
    }
    if (m.find("to_city_name") != m.end() && !m["to_city_name"].empty()) {
      toCityName = make_shared<string>(boost::any_cast<string>(m["to_city_name"]));
    }
    if (m.find("travel_distance") != m.end() && !m["travel_distance"].empty()) {
      travelDistance = make_shared<string>(boost::any_cast<string>(m["travel_distance"]));
    }
  }


  virtual ~CarOrderQueryResponseBodyModuleCarInfo() = default;
};
class CarOrderQueryResponseBodyModuleInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  CarOrderQueryResponseBodyModuleInvoiceInfo() {}

  explicit CarOrderQueryResponseBodyModuleInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CarOrderQueryResponseBodyModuleInvoiceInfo() = default;
};
class CarOrderQueryResponseBodyModuleOrderBaseInfo : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> btripCause{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> orderId{};
  shared_ptr<long> orderStatus{};
  shared_ptr<long> subOrderId{};
  shared_ptr<string> thirdDepartId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CarOrderQueryResponseBodyModuleOrderBaseInfo() {}

  explicit CarOrderQueryResponseBodyModuleOrderBaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (btripCause) {
      res["btrip_cause"] = boost::any(*btripCause);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    if (thirdDepartId) {
      res["third_depart_id"] = boost::any(*thirdDepartId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("btrip_cause") != m.end() && !m["btrip_cause"].empty()) {
      btripCause = make_shared<string>(boost::any_cast<string>(m["btrip_cause"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmt_modified"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<long>(boost::any_cast<long>(m["sub_order_id"]));
    }
    if (m.find("third_depart_id") != m.end() && !m["third_depart_id"].empty()) {
      thirdDepartId = make_shared<string>(boost::any_cast<string>(m["third_depart_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~CarOrderQueryResponseBodyModuleOrderBaseInfo() = default;
};
class CarOrderQueryResponseBodyModulePassengerList : public Darabonba::Model {
public:
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<string> thirdpartProjectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> userType{};

  CarOrderQueryResponseBodyModulePassengerList() {}

  explicit CarOrderQueryResponseBodyModulePassengerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (thirdpartProjectId) {
      res["thirdpart_project_id"] = boost::any(*thirdpartProjectId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("thirdpart_project_id") != m.end() && !m["thirdpart_project_id"].empty()) {
      thirdpartProjectId = make_shared<string>(boost::any_cast<string>(m["thirdpart_project_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~CarOrderQueryResponseBodyModulePassengerList() = default;
};
class CarOrderQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> payType{};
  shared_ptr<long> personPrice{};
  shared_ptr<long> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  CarOrderQueryResponseBodyModulePriceInfoList() {}

  explicit CarOrderQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (personPrice) {
      res["person_price"] = boost::any(*personPrice);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmt_create"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("person_price") != m.end() && !m["person_price"].empty()) {
      personPrice = make_shared<long>(boost::any_cast<long>(m["person_price"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~CarOrderQueryResponseBodyModulePriceInfoList() = default;
};
class CarOrderQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<CarOrderQueryResponseBodyModuleCarInfo> carInfo{};
  shared_ptr<CarOrderQueryResponseBodyModuleInvoiceInfo> invoiceInfo{};
  shared_ptr<CarOrderQueryResponseBodyModuleOrderBaseInfo> orderBaseInfo{};
  shared_ptr<vector<CarOrderQueryResponseBodyModulePassengerList>> passengerList{};
  shared_ptr<vector<CarOrderQueryResponseBodyModulePriceInfoList>> priceInfoList{};

  CarOrderQueryResponseBodyModule() {}

  explicit CarOrderQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (carInfo) {
      res["car_info"] = carInfo ? boost::any(carInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invoiceInfo) {
      res["invoice_info"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderBaseInfo) {
      res["order_base_info"] = orderBaseInfo ? boost::any(orderBaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passengerList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_list"] = boost::any(temp1);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("car_info") != m.end() && !m["car_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["car_info"].type()) {
        CarOrderQueryResponseBodyModuleCarInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["car_info"]));
        carInfo = make_shared<CarOrderQueryResponseBodyModuleCarInfo>(model1);
      }
    }
    if (m.find("invoice_info") != m.end() && !m["invoice_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice_info"].type()) {
        CarOrderQueryResponseBodyModuleInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice_info"]));
        invoiceInfo = make_shared<CarOrderQueryResponseBodyModuleInvoiceInfo>(model1);
      }
    }
    if (m.find("order_base_info") != m.end() && !m["order_base_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["order_base_info"].type()) {
        CarOrderQueryResponseBodyModuleOrderBaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["order_base_info"]));
        orderBaseInfo = make_shared<CarOrderQueryResponseBodyModuleOrderBaseInfo>(model1);
      }
    }
    if (m.find("passenger_list") != m.end() && !m["passenger_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_list"].type()) {
        vector<CarOrderQueryResponseBodyModulePassengerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarOrderQueryResponseBodyModulePassengerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerList = make_shared<vector<CarOrderQueryResponseBodyModulePassengerList>>(expect1);
      }
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<CarOrderQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarOrderQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<CarOrderQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
  }


  virtual ~CarOrderQueryResponseBodyModule() = default;
};
class CarOrderQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CarOrderQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CarOrderQueryResponseBody() {}

  explicit CarOrderQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CarOrderQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CarOrderQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CarOrderQueryResponseBody() = default;
};
class CarOrderQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CarOrderQueryResponseBody> body{};

  CarOrderQueryResponse() {}

  explicit CarOrderQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CarOrderQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CarOrderQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CarOrderQueryResponse() = default;
};
class CitySearchHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CitySearchHeaders() {}

  explicit CitySearchHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CitySearchHeaders() = default;
};
class CitySearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};

  CitySearchRequest() {}

  explicit CitySearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["keyword"] = boost::any(*keyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("keyword") != m.end() && !m["keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["keyword"]));
    }
  }


  virtual ~CitySearchRequest() = default;
};
class CitySearchResponseBodyModuleCities : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<long> region{};

  CitySearchResponseBodyModuleCities() {}

  explicit CitySearchResponseBodyModuleCities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["region"]));
    }
  }


  virtual ~CitySearchResponseBodyModuleCities() = default;
};
class CitySearchResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<CitySearchResponseBodyModuleCities>> cities{};

  CitySearchResponseBodyModule() {}

  explicit CitySearchResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cities) {
      vector<boost::any> temp1;
      for(auto item1:*cities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cities"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cities") != m.end() && !m["cities"].empty()) {
      if (typeid(vector<boost::any>) == m["cities"].type()) {
        vector<CitySearchResponseBodyModuleCities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CitySearchResponseBodyModuleCities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cities = make_shared<vector<CitySearchResponseBodyModuleCities>>(expect1);
      }
    }
  }


  virtual ~CitySearchResponseBodyModule() = default;
};
class CitySearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CitySearchResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CitySearchResponseBody() {}

  explicit CitySearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CitySearchResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CitySearchResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CitySearchResponseBody() = default;
};
class CitySearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CitySearchResponseBody> body{};

  CitySearchResponse() {}

  explicit CitySearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CitySearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CitySearchResponseBody>(model1);
      }
    }
  }


  virtual ~CitySearchResponse() = default;
};
class CommonApplyQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CommonApplyQueryHeaders() {}

  explicit CommonApplyQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CommonApplyQueryHeaders() = default;
};
class CommonApplyQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<long> bizCategory{};
  shared_ptr<string> userId{};

  CommonApplyQueryRequest() {}

  explicit CommonApplyQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (bizCategory) {
      res["biz_category"] = boost::any(*bizCategory);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("biz_category") != m.end() && !m["biz_category"].empty()) {
      bizCategory = make_shared<long>(boost::any_cast<long>(m["biz_category"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CommonApplyQueryRequest() = default;
};
class CommonApplyQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<long> bizCategory{};
  shared_ptr<string> cause{};
  shared_ptr<string> corpId{};
  shared_ptr<string> extendValue{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdpartCorpId{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<string> tripCause{};
  shared_ptr<string> userId{};

  CommonApplyQueryResponseBodyModule() {}

  explicit CommonApplyQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (bizCategory) {
      res["biz_category"] = boost::any(*bizCategory);
    }
    if (cause) {
      res["cause"] = boost::any(*cause);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (extendValue) {
      res["extend_value"] = boost::any(*extendValue);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdpartCorpId) {
      res["thirdpart_corp_id"] = boost::any(*thirdpartCorpId);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("biz_category") != m.end() && !m["biz_category"].empty()) {
      bizCategory = make_shared<long>(boost::any_cast<long>(m["biz_category"]));
    }
    if (m.find("cause") != m.end() && !m["cause"].empty()) {
      cause = make_shared<string>(boost::any_cast<string>(m["cause"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("extend_value") != m.end() && !m["extend_value"].empty()) {
      extendValue = make_shared<string>(boost::any_cast<string>(m["extend_value"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("thirdpart_corp_id") != m.end() && !m["thirdpart_corp_id"].empty()) {
      thirdpartCorpId = make_shared<string>(boost::any_cast<string>(m["thirdpart_corp_id"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CommonApplyQueryResponseBodyModule() = default;
};
class CommonApplyQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CommonApplyQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CommonApplyQueryResponseBody() {}

  explicit CommonApplyQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CommonApplyQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CommonApplyQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CommonApplyQueryResponseBody() = default;
};
class CommonApplyQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CommonApplyQueryResponseBody> body{};

  CommonApplyQueryResponse() {}

  explicit CommonApplyQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CommonApplyQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CommonApplyQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CommonApplyQueryResponse() = default;
};
class CommonApplySyncHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CommonApplySyncHeaders() {}

  explicit CommonApplySyncHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CommonApplySyncHeaders() = default;
};
class CommonApplySyncRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<long> bizCategory{};
  shared_ptr<string> remark{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdpartyFlowId{};
  shared_ptr<string> userId{};

  CommonApplySyncRequest() {}

  explicit CommonApplySyncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (bizCategory) {
      res["biz_category"] = boost::any(*bizCategory);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdpartyFlowId) {
      res["thirdparty_flow_id"] = boost::any(*thirdpartyFlowId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("biz_category") != m.end() && !m["biz_category"].empty()) {
      bizCategory = make_shared<long>(boost::any_cast<long>(m["biz_category"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("thirdparty_flow_id") != m.end() && !m["thirdparty_flow_id"].empty()) {
      thirdpartyFlowId = make_shared<string>(boost::any_cast<string>(m["thirdparty_flow_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CommonApplySyncRequest() = default;
};
class CommonApplySyncResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CommonApplySyncResponseBody() {}

  explicit CommonApplySyncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<bool>(boost::any_cast<bool>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CommonApplySyncResponseBody() = default;
};
class CommonApplySyncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CommonApplySyncResponseBody> body{};

  CommonApplySyncResponse() {}

  explicit CommonApplySyncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CommonApplySyncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CommonApplySyncResponseBody>(model1);
      }
    }
  }


  virtual ~CommonApplySyncResponse() = default;
};
class CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps : public Darabonba::Model {
public:
  shared_ptr<string> corpName{};
  shared_ptr<string> openCorpId{};
  shared_ptr<string> trueCorpId{};

  CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps() {}

  explicit CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (openCorpId) {
      res["open_corp_id"] = boost::any(*openCorpId);
    }
    if (trueCorpId) {
      res["true_corp_id"] = boost::any(*trueCorpId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("open_corp_id") != m.end() && !m["open_corp_id"].empty()) {
      openCorpId = make_shared<string>(boost::any_cast<string>(m["open_corp_id"]));
    }
    if (m.find("true_corp_id") != m.end() && !m["true_corp_id"].empty()) {
      trueCorpId = make_shared<string>(boost::any_cast<string>(m["true_corp_id"]));
    }
  }


  virtual ~CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps() = default;
};
class CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp : public Darabonba::Model {
public:
  shared_ptr<string> corpName{};
  shared_ptr<string> openCorpId{};
  shared_ptr<string> trueCorpId{};

  CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp() {}

  explicit CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (openCorpId) {
      res["open_corp_id"] = boost::any(*openCorpId);
    }
    if (trueCorpId) {
      res["true_corp_id"] = boost::any(*trueCorpId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("open_corp_id") != m.end() && !m["open_corp_id"].empty()) {
      openCorpId = make_shared<string>(boost::any_cast<string>(m["open_corp_id"]));
    }
    if (m.find("true_corp_id") != m.end() && !m["true_corp_id"].empty()) {
      trueCorpId = make_shared<string>(boost::any_cast<string>(m["true_corp_id"]));
    }
  }


  virtual ~CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp() = default;
};
class CorpAuthLinkInfoQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps>> linkCorps{};
  shared_ptr<CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp> orgCorp{};

  CorpAuthLinkInfoQueryResponseBodyModule() {}

  explicit CorpAuthLinkInfoQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (linkCorps) {
      vector<boost::any> temp1;
      for(auto item1:*linkCorps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["link_corps"] = boost::any(temp1);
    }
    if (orgCorp) {
      res["org_corp"] = orgCorp ? boost::any(orgCorp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("link_corps") != m.end() && !m["link_corps"].empty()) {
      if (typeid(vector<boost::any>) == m["link_corps"].type()) {
        vector<CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["link_corps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        linkCorps = make_shared<vector<CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps>>(expect1);
      }
    }
    if (m.find("org_corp") != m.end() && !m["org_corp"].empty()) {
      if (typeid(map<string, boost::any>) == m["org_corp"].type()) {
        CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["org_corp"]));
        orgCorp = make_shared<CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp>(model1);
      }
    }
  }


  virtual ~CorpAuthLinkInfoQueryResponseBodyModule() = default;
};
class CorpAuthLinkInfoQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CorpAuthLinkInfoQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<string> traceId{};

  CorpAuthLinkInfoQueryResponseBody() {}

  explicit CorpAuthLinkInfoQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CorpAuthLinkInfoQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CorpAuthLinkInfoQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CorpAuthLinkInfoQueryResponseBody() = default;
};
class CorpAuthLinkInfoQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CorpAuthLinkInfoQueryResponseBody> body{};

  CorpAuthLinkInfoQueryResponse() {}

  explicit CorpAuthLinkInfoQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CorpAuthLinkInfoQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CorpAuthLinkInfoQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CorpAuthLinkInfoQueryResponse() = default;
};
class CorpTokenHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripAccessToken{};

  CorpTokenHeaders() {}

  explicit CorpTokenHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripAccessToken) {
      res["x-acs-btrip-access-token"] = boost::any(*xAcsBtripAccessToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-access-token") != m.end() && !m["x-acs-btrip-access-token"].empty()) {
      xAcsBtripAccessToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-access-token"]));
    }
  }


  virtual ~CorpTokenHeaders() = default;
};
class CorpTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appSecret{};
  shared_ptr<string> corpId{};
  shared_ptr<long> type{};

  CorpTokenRequest() {}

  explicit CorpTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appSecret) {
      res["app_secret"] = boost::any(*appSecret);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("app_secret") != m.end() && !m["app_secret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["app_secret"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~CorpTokenRequest() = default;
};
class CorpTokenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> expire{};
  shared_ptr<string> token{};

  CorpTokenResponseBodyData() {}

  explicit CorpTokenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expire) {
      res["expire"] = boost::any(*expire);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expire") != m.end() && !m["expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["expire"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~CorpTokenResponseBodyData() = default;
};
class CorpTokenResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> expire{};
  shared_ptr<long> start{};
  shared_ptr<string> token{};

  CorpTokenResponseBodyModule() {}

  explicit CorpTokenResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expire) {
      res["expire"] = boost::any(*expire);
    }
    if (start) {
      res["start"] = boost::any(*start);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expire") != m.end() && !m["expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["expire"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["start"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~CorpTokenResponseBodyModule() = default;
};
class CorpTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CorpTokenResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<CorpTokenResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<string> traceId{};

  CorpTokenResponseBody() {}

  explicit CorpTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CorpTokenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CorpTokenResponseBodyData>(model1);
      }
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CorpTokenResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CorpTokenResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CorpTokenResponseBody() = default;
};
class CorpTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CorpTokenResponseBody> body{};

  CorpTokenResponse() {}

  explicit CorpTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CorpTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CorpTokenResponseBody>(model1);
      }
    }
  }


  virtual ~CorpTokenResponse() = default;
};
class CostCenterDeleteHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CostCenterDeleteHeaders() {}

  explicit CostCenterDeleteHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CostCenterDeleteHeaders() = default;
};
class CostCenterDeleteRequest : public Darabonba::Model {
public:
  shared_ptr<string> thirdpartId{};

  CostCenterDeleteRequest() {}

  explicit CostCenterDeleteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~CostCenterDeleteRequest() = default;
};
class CostCenterDeleteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CostCenterDeleteResponseBody() {}

  explicit CostCenterDeleteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CostCenterDeleteResponseBody() = default;
};
class CostCenterDeleteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CostCenterDeleteResponseBody> body{};

  CostCenterDeleteResponse() {}

  explicit CostCenterDeleteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CostCenterDeleteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CostCenterDeleteResponseBody>(model1);
      }
    }
  }


  virtual ~CostCenterDeleteResponse() = default;
};
class CostCenterModifyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CostCenterModifyHeaders() {}

  explicit CostCenterModifyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CostCenterModifyHeaders() = default;
};
class CostCenterModifyRequest : public Darabonba::Model {
public:
  shared_ptr<string> alipayNo{};
  shared_ptr<string> number{};
  shared_ptr<long> scope{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<string> title{};

  CostCenterModifyRequest() {}

  explicit CostCenterModifyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayNo) {
      res["alipay_no"] = boost::any(*alipayNo);
    }
    if (number) {
      res["number"] = boost::any(*number);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_no") != m.end() && !m["alipay_no"].empty()) {
      alipayNo = make_shared<string>(boost::any_cast<string>(m["alipay_no"]));
    }
    if (m.find("number") != m.end() && !m["number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["number"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<long>(boost::any_cast<long>(m["scope"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CostCenterModifyRequest() = default;
};
class CostCenterModifyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CostCenterModifyResponseBody() {}

  explicit CostCenterModifyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CostCenterModifyResponseBody() = default;
};
class CostCenterModifyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CostCenterModifyResponseBody> body{};

  CostCenterModifyResponse() {}

  explicit CostCenterModifyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CostCenterModifyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CostCenterModifyResponseBody>(model1);
      }
    }
  }


  virtual ~CostCenterModifyResponse() = default;
};
class CostCenterQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CostCenterQueryHeaders() {}

  explicit CostCenterQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CostCenterQueryHeaders() = default;
};
class CostCenterQueryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> needOrgEntity{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<string> title{};
  shared_ptr<string> userId{};

  CostCenterQueryRequest() {}

  explicit CostCenterQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (needOrgEntity) {
      res["need_org_entity"] = boost::any(*needOrgEntity);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("need_org_entity") != m.end() && !m["need_org_entity"].empty()) {
      needOrgEntity = make_shared<bool>(boost::any_cast<bool>(m["need_org_entity"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CostCenterQueryRequest() = default;
};
class CostCenterQueryResponseBodyModuleEntityDOS : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> entityId{};
  shared_ptr<string> entityType{};
  shared_ptr<string> name{};
  shared_ptr<long> userNum{};

  CostCenterQueryResponseBodyModuleEntityDOS() {}

  explicit CostCenterQueryResponseBodyModuleEntityDOS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (entityId) {
      res["entity_id"] = boost::any(*entityId);
    }
    if (entityType) {
      res["entity_type"] = boost::any(*entityType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (userNum) {
      res["user_num"] = boost::any(*userNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("entity_id") != m.end() && !m["entity_id"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["entity_id"]));
    }
    if (m.find("entity_type") != m.end() && !m["entity_type"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["entity_type"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("user_num") != m.end() && !m["user_num"].empty()) {
      userNum = make_shared<long>(boost::any_cast<long>(m["user_num"]));
    }
  }


  virtual ~CostCenterQueryResponseBodyModuleEntityDOS() = default;
};
class CostCenterQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> alipayNo{};
  shared_ptr<string> corpId{};
  shared_ptr<vector<CostCenterQueryResponseBodyModuleEntityDOS>> entityDOS{};
  shared_ptr<long> id{};
  shared_ptr<string> number{};
  shared_ptr<long> ruleCode{};
  shared_ptr<long> scope{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<string> title{};

  CostCenterQueryResponseBodyModule() {}

  explicit CostCenterQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayNo) {
      res["alipay_no"] = boost::any(*alipayNo);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (entityDOS) {
      vector<boost::any> temp1;
      for(auto item1:*entityDOS){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entity_d_o_s"] = boost::any(temp1);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (number) {
      res["number"] = boost::any(*number);
    }
    if (ruleCode) {
      res["rule_code"] = boost::any(*ruleCode);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_no") != m.end() && !m["alipay_no"].empty()) {
      alipayNo = make_shared<string>(boost::any_cast<string>(m["alipay_no"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("entity_d_o_s") != m.end() && !m["entity_d_o_s"].empty()) {
      if (typeid(vector<boost::any>) == m["entity_d_o_s"].type()) {
        vector<CostCenterQueryResponseBodyModuleEntityDOS> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entity_d_o_s"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CostCenterQueryResponseBodyModuleEntityDOS model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entityDOS = make_shared<vector<CostCenterQueryResponseBodyModuleEntityDOS>>(expect1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("number") != m.end() && !m["number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["number"]));
    }
    if (m.find("rule_code") != m.end() && !m["rule_code"].empty()) {
      ruleCode = make_shared<long>(boost::any_cast<long>(m["rule_code"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<long>(boost::any_cast<long>(m["scope"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CostCenterQueryResponseBodyModule() = default;
};
class CostCenterQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<CostCenterQueryResponseBodyModule>> module{};
  shared_ptr<bool> morePage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CostCenterQueryResponseBody() {}

  explicit CostCenterQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (morePage) {
      res["more_page"] = boost::any(*morePage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<CostCenterQueryResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CostCenterQueryResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<CostCenterQueryResponseBodyModule>>(expect1);
      }
    }
    if (m.find("more_page") != m.end() && !m["more_page"].empty()) {
      morePage = make_shared<bool>(boost::any_cast<bool>(m["more_page"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CostCenterQueryResponseBody() = default;
};
class CostCenterQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CostCenterQueryResponseBody> body{};

  CostCenterQueryResponse() {}

  explicit CostCenterQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CostCenterQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CostCenterQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CostCenterQueryResponse() = default;
};
class CostCenterSaveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CostCenterSaveHeaders() {}

  explicit CostCenterSaveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CostCenterSaveHeaders() = default;
};
class CostCenterSaveRequest : public Darabonba::Model {
public:
  shared_ptr<string> alipayNo{};
  shared_ptr<string> number{};
  shared_ptr<long> scope{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<string> title{};

  CostCenterSaveRequest() {}

  explicit CostCenterSaveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayNo) {
      res["alipay_no"] = boost::any(*alipayNo);
    }
    if (number) {
      res["number"] = boost::any(*number);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_no") != m.end() && !m["alipay_no"].empty()) {
      alipayNo = make_shared<string>(boost::any_cast<string>(m["alipay_no"]));
    }
    if (m.find("number") != m.end() && !m["number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["number"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<long>(boost::any_cast<long>(m["scope"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CostCenterSaveRequest() = default;
};
class CostCenterSaveResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  CostCenterSaveResponseBodyModule() {}

  explicit CostCenterSaveResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
  }


  virtual ~CostCenterSaveResponseBodyModule() = default;
};
class CostCenterSaveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CostCenterSaveResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CostCenterSaveResponseBody() {}

  explicit CostCenterSaveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CostCenterSaveResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CostCenterSaveResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CostCenterSaveResponseBody() = default;
};
class CostCenterSaveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CostCenterSaveResponseBody> body{};

  CostCenterSaveResponse() {}

  explicit CostCenterSaveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CostCenterSaveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CostCenterSaveResponseBody>(model1);
      }
    }
  }


  virtual ~CostCenterSaveResponse() = default;
};
class DepartmentSaveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  DepartmentSaveHeaders() {}

  explicit DepartmentSaveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~DepartmentSaveHeaders() = default;
};
class DepartmentSaveRequestDepartList : public Darabonba::Model {
public:
  shared_ptr<long> departId{};
  shared_ptr<string> departName{};
  shared_ptr<long> departPid{};
  shared_ptr<string> managerIds{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdDepartId{};
  shared_ptr<string> thirdDepartPid{};

  DepartmentSaveRequestDepartList() {}

  explicit DepartmentSaveRequestDepartList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (departPid) {
      res["depart_pid"] = boost::any(*departPid);
    }
    if (managerIds) {
      res["manager_ids"] = boost::any(*managerIds);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdDepartId) {
      res["third_depart_id"] = boost::any(*thirdDepartId);
    }
    if (thirdDepartPid) {
      res["third_depart_pid"] = boost::any(*thirdDepartPid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<long>(boost::any_cast<long>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("depart_pid") != m.end() && !m["depart_pid"].empty()) {
      departPid = make_shared<long>(boost::any_cast<long>(m["depart_pid"]));
    }
    if (m.find("manager_ids") != m.end() && !m["manager_ids"].empty()) {
      managerIds = make_shared<string>(boost::any_cast<string>(m["manager_ids"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("third_depart_id") != m.end() && !m["third_depart_id"].empty()) {
      thirdDepartId = make_shared<string>(boost::any_cast<string>(m["third_depart_id"]));
    }
    if (m.find("third_depart_pid") != m.end() && !m["third_depart_pid"].empty()) {
      thirdDepartPid = make_shared<string>(boost::any_cast<string>(m["third_depart_pid"]));
    }
  }


  virtual ~DepartmentSaveRequestDepartList() = default;
};
class DepartmentSaveRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DepartmentSaveRequestDepartList>> departList{};

  DepartmentSaveRequest() {}

  explicit DepartmentSaveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departList) {
      vector<boost::any> temp1;
      for(auto item1:*departList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["depart_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("depart_list") != m.end() && !m["depart_list"].empty()) {
      if (typeid(vector<boost::any>) == m["depart_list"].type()) {
        vector<DepartmentSaveRequestDepartList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["depart_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DepartmentSaveRequestDepartList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        departList = make_shared<vector<DepartmentSaveRequestDepartList>>(expect1);
      }
    }
  }


  virtual ~DepartmentSaveRequest() = default;
};
class DepartmentSaveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> departListShrink{};

  DepartmentSaveShrinkRequest() {}

  explicit DepartmentSaveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departListShrink) {
      res["depart_list"] = boost::any(*departListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("depart_list") != m.end() && !m["depart_list"].empty()) {
      departListShrink = make_shared<string>(boost::any_cast<string>(m["depart_list"]));
    }
  }


  virtual ~DepartmentSaveShrinkRequest() = default;
};
class DepartmentSaveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DepartmentSaveResponseBody() {}

  explicit DepartmentSaveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~DepartmentSaveResponseBody() = default;
};
class DepartmentSaveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DepartmentSaveResponseBody> body{};

  DepartmentSaveResponse() {}

  explicit DepartmentSaveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DepartmentSaveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DepartmentSaveResponseBody>(model1);
      }
    }
  }


  virtual ~DepartmentSaveResponse() = default;
};
class EntityAddHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  EntityAddHeaders() {}

  explicit EntityAddHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~EntityAddHeaders() = default;
};
class EntityAddRequestEntityDOList : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> entityType{};

  EntityAddRequestEntityDOList() {}

  explicit EntityAddRequestEntityDOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["entity_id"] = boost::any(*entityId);
    }
    if (entityType) {
      res["entity_type"] = boost::any(*entityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_id") != m.end() && !m["entity_id"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["entity_id"]));
    }
    if (m.find("entity_type") != m.end() && !m["entity_type"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["entity_type"]));
    }
  }


  virtual ~EntityAddRequestEntityDOList() = default;
};
class EntityAddRequest : public Darabonba::Model {
public:
  shared_ptr<vector<EntityAddRequestEntityDOList>> entityDOList{};
  shared_ptr<string> thirdpartId{};

  EntityAddRequest() {}

  explicit EntityAddRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityDOList) {
      vector<boost::any> temp1;
      for(auto item1:*entityDOList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entity_d_o_list"] = boost::any(temp1);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_d_o_list") != m.end() && !m["entity_d_o_list"].empty()) {
      if (typeid(vector<boost::any>) == m["entity_d_o_list"].type()) {
        vector<EntityAddRequestEntityDOList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entity_d_o_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EntityAddRequestEntityDOList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entityDOList = make_shared<vector<EntityAddRequestEntityDOList>>(expect1);
      }
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~EntityAddRequest() = default;
};
class EntityAddShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> entityDOListShrink{};
  shared_ptr<string> thirdpartId{};

  EntityAddShrinkRequest() {}

  explicit EntityAddShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityDOListShrink) {
      res["entity_d_o_list"] = boost::any(*entityDOListShrink);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_d_o_list") != m.end() && !m["entity_d_o_list"].empty()) {
      entityDOListShrink = make_shared<string>(boost::any_cast<string>(m["entity_d_o_list"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~EntityAddShrinkRequest() = default;
};
class EntityAddResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> addNum{};
  shared_ptr<long> selectedUserNum{};

  EntityAddResponseBodyModule() {}

  explicit EntityAddResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addNum) {
      res["add_num"] = boost::any(*addNum);
    }
    if (selectedUserNum) {
      res["selected_user_num"] = boost::any(*selectedUserNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("add_num") != m.end() && !m["add_num"].empty()) {
      addNum = make_shared<long>(boost::any_cast<long>(m["add_num"]));
    }
    if (m.find("selected_user_num") != m.end() && !m["selected_user_num"].empty()) {
      selectedUserNum = make_shared<long>(boost::any_cast<long>(m["selected_user_num"]));
    }
  }


  virtual ~EntityAddResponseBodyModule() = default;
};
class EntityAddResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<EntityAddResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  EntityAddResponseBody() {}

  explicit EntityAddResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        EntityAddResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<EntityAddResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~EntityAddResponseBody() = default;
};
class EntityAddResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EntityAddResponseBody> body{};

  EntityAddResponse() {}

  explicit EntityAddResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EntityAddResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EntityAddResponseBody>(model1);
      }
    }
  }


  virtual ~EntityAddResponse() = default;
};
class EntityDeleteHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  EntityDeleteHeaders() {}

  explicit EntityDeleteHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~EntityDeleteHeaders() = default;
};
class EntityDeleteRequestEntityDOList : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> entityType{};

  EntityDeleteRequestEntityDOList() {}

  explicit EntityDeleteRequestEntityDOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["entity_id"] = boost::any(*entityId);
    }
    if (entityType) {
      res["entity_type"] = boost::any(*entityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_id") != m.end() && !m["entity_id"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["entity_id"]));
    }
    if (m.find("entity_type") != m.end() && !m["entity_type"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["entity_type"]));
    }
  }


  virtual ~EntityDeleteRequestEntityDOList() = default;
};
class EntityDeleteRequest : public Darabonba::Model {
public:
  shared_ptr<bool> delAll{};
  shared_ptr<vector<EntityDeleteRequestEntityDOList>> entityDOList{};
  shared_ptr<string> thirdpartId{};

  EntityDeleteRequest() {}

  explicit EntityDeleteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delAll) {
      res["del_all"] = boost::any(*delAll);
    }
    if (entityDOList) {
      vector<boost::any> temp1;
      for(auto item1:*entityDOList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entity_d_o_list"] = boost::any(temp1);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("del_all") != m.end() && !m["del_all"].empty()) {
      delAll = make_shared<bool>(boost::any_cast<bool>(m["del_all"]));
    }
    if (m.find("entity_d_o_list") != m.end() && !m["entity_d_o_list"].empty()) {
      if (typeid(vector<boost::any>) == m["entity_d_o_list"].type()) {
        vector<EntityDeleteRequestEntityDOList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entity_d_o_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EntityDeleteRequestEntityDOList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entityDOList = make_shared<vector<EntityDeleteRequestEntityDOList>>(expect1);
      }
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~EntityDeleteRequest() = default;
};
class EntityDeleteShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> delAll{};
  shared_ptr<string> entityDOListShrink{};
  shared_ptr<string> thirdpartId{};

  EntityDeleteShrinkRequest() {}

  explicit EntityDeleteShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delAll) {
      res["del_all"] = boost::any(*delAll);
    }
    if (entityDOListShrink) {
      res["entity_d_o_list"] = boost::any(*entityDOListShrink);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("del_all") != m.end() && !m["del_all"].empty()) {
      delAll = make_shared<bool>(boost::any_cast<bool>(m["del_all"]));
    }
    if (m.find("entity_d_o_list") != m.end() && !m["entity_d_o_list"].empty()) {
      entityDOListShrink = make_shared<string>(boost::any_cast<string>(m["entity_d_o_list"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~EntityDeleteShrinkRequest() = default;
};
class EntityDeleteResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> removeNum{};
  shared_ptr<long> selectedUserNum{};

  EntityDeleteResponseBodyModule() {}

  explicit EntityDeleteResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (removeNum) {
      res["remove_num"] = boost::any(*removeNum);
    }
    if (selectedUserNum) {
      res["selected_user_num"] = boost::any(*selectedUserNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("remove_num") != m.end() && !m["remove_num"].empty()) {
      removeNum = make_shared<long>(boost::any_cast<long>(m["remove_num"]));
    }
    if (m.find("selected_user_num") != m.end() && !m["selected_user_num"].empty()) {
      selectedUserNum = make_shared<long>(boost::any_cast<long>(m["selected_user_num"]));
    }
  }


  virtual ~EntityDeleteResponseBodyModule() = default;
};
class EntityDeleteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<EntityDeleteResponseBodyModule> module{};
  shared_ptr<bool> morePage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  EntityDeleteResponseBody() {}

  explicit EntityDeleteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (morePage) {
      res["more_page"] = boost::any(*morePage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        EntityDeleteResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<EntityDeleteResponseBodyModule>(model1);
      }
    }
    if (m.find("more_page") != m.end() && !m["more_page"].empty()) {
      morePage = make_shared<bool>(boost::any_cast<bool>(m["more_page"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~EntityDeleteResponseBody() = default;
};
class EntityDeleteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EntityDeleteResponseBody> body{};

  EntityDeleteResponse() {}

  explicit EntityDeleteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EntityDeleteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EntityDeleteResponseBody>(model1);
      }
    }
  }


  virtual ~EntityDeleteResponse() = default;
};
class EntitySetHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  EntitySetHeaders() {}

  explicit EntitySetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~EntitySetHeaders() = default;
};
class EntitySetRequestEntityDOList : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> entityType{};

  EntitySetRequestEntityDOList() {}

  explicit EntitySetRequestEntityDOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["entity_id"] = boost::any(*entityId);
    }
    if (entityType) {
      res["entity_type"] = boost::any(*entityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_id") != m.end() && !m["entity_id"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["entity_id"]));
    }
    if (m.find("entity_type") != m.end() && !m["entity_type"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["entity_type"]));
    }
  }


  virtual ~EntitySetRequestEntityDOList() = default;
};
class EntitySetRequest : public Darabonba::Model {
public:
  shared_ptr<vector<EntitySetRequestEntityDOList>> entityDOList{};
  shared_ptr<string> thirdpartId{};

  EntitySetRequest() {}

  explicit EntitySetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityDOList) {
      vector<boost::any> temp1;
      for(auto item1:*entityDOList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entity_d_o_list"] = boost::any(temp1);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_d_o_list") != m.end() && !m["entity_d_o_list"].empty()) {
      if (typeid(vector<boost::any>) == m["entity_d_o_list"].type()) {
        vector<EntitySetRequestEntityDOList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entity_d_o_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EntitySetRequestEntityDOList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entityDOList = make_shared<vector<EntitySetRequestEntityDOList>>(expect1);
      }
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~EntitySetRequest() = default;
};
class EntitySetShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> entityDOListShrink{};
  shared_ptr<string> thirdpartId{};

  EntitySetShrinkRequest() {}

  explicit EntitySetShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityDOListShrink) {
      res["entity_d_o_list"] = boost::any(*entityDOListShrink);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_d_o_list") != m.end() && !m["entity_d_o_list"].empty()) {
      entityDOListShrink = make_shared<string>(boost::any_cast<string>(m["entity_d_o_list"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~EntitySetShrinkRequest() = default;
};
class EntitySetResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> addNum{};
  shared_ptr<long> removeNum{};
  shared_ptr<long> selectedUserNum{};

  EntitySetResponseBodyModule() {}

  explicit EntitySetResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addNum) {
      res["add_num"] = boost::any(*addNum);
    }
    if (removeNum) {
      res["remove_num"] = boost::any(*removeNum);
    }
    if (selectedUserNum) {
      res["selected_user_num"] = boost::any(*selectedUserNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("add_num") != m.end() && !m["add_num"].empty()) {
      addNum = make_shared<long>(boost::any_cast<long>(m["add_num"]));
    }
    if (m.find("remove_num") != m.end() && !m["remove_num"].empty()) {
      removeNum = make_shared<long>(boost::any_cast<long>(m["remove_num"]));
    }
    if (m.find("selected_user_num") != m.end() && !m["selected_user_num"].empty()) {
      selectedUserNum = make_shared<long>(boost::any_cast<long>(m["selected_user_num"]));
    }
  }


  virtual ~EntitySetResponseBodyModule() = default;
};
class EntitySetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<EntitySetResponseBodyModule> module{};
  shared_ptr<bool> morePage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  EntitySetResponseBody() {}

  explicit EntitySetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (morePage) {
      res["more_page"] = boost::any(*morePage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        EntitySetResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<EntitySetResponseBodyModule>(model1);
      }
    }
    if (m.find("more_page") != m.end() && !m["more_page"].empty()) {
      morePage = make_shared<bool>(boost::any_cast<bool>(m["more_page"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~EntitySetResponseBody() = default;
};
class EntitySetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EntitySetResponseBody> body{};

  EntitySetResponse() {}

  explicit EntitySetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EntitySetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EntitySetResponseBody>(model1);
      }
    }
  }


  virtual ~EntitySetResponse() = default;
};
class EstimatedPriceQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  EstimatedPriceQueryHeaders() {}

  explicit EstimatedPriceQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~EstimatedPriceQueryHeaders() = default;
};
class EstimatedPriceQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> category{};
  shared_ptr<string> depCity{};
  shared_ptr<long> endTime{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> subCorpId{};
  shared_ptr<string> userId{};

  EstimatedPriceQueryRequest() {}

  explicit EstimatedPriceQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["end_time"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["start_time"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~EstimatedPriceQueryRequest() = default;
};
class EstimatedPriceQueryResponseBodyModuleHotelFeeDetail : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<long> criterion{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> total{};
  shared_ptr<long> tripDays{};

  EstimatedPriceQueryResponseBodyModuleHotelFeeDetail() {}

  explicit EstimatedPriceQueryResponseBodyModuleHotelFeeDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["city"] = boost::any(*city);
    }
    if (criterion) {
      res["criterion"] = boost::any(*criterion);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    if (tripDays) {
      res["trip_days"] = boost::any(*tripDays);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city") != m.end() && !m["city"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["city"]));
    }
    if (m.find("criterion") != m.end() && !m["criterion"].empty()) {
      criterion = make_shared<long>(boost::any_cast<long>(m["criterion"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
    if (m.find("trip_days") != m.end() && !m["trip_days"].empty()) {
      tripDays = make_shared<long>(boost::any_cast<long>(m["trip_days"]));
    }
  }


  virtual ~EstimatedPriceQueryResponseBodyModuleHotelFeeDetail() = default;
};
class EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest : public Darabonba::Model {
public:
  shared_ptr<string> arrTime{};
  shared_ptr<string> depTime{};
  shared_ptr<long> fee{};
  shared_ptr<string> seatGrade{};
  shared_ptr<string> vehicleNo{};

  EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest() {}

  explicit EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    if (seatGrade) {
      res["seat_grade"] = boost::any(*seatGrade);
    }
    if (vehicleNo) {
      res["vehicle_no"] = boost::any(*vehicleNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
    if (m.find("seat_grade") != m.end() && !m["seat_grade"].empty()) {
      seatGrade = make_shared<string>(boost::any_cast<string>(m["seat_grade"]));
    }
    if (m.find("vehicle_no") != m.end() && !m["vehicle_no"].empty()) {
      vehicleNo = make_shared<string>(boost::any_cast<string>(m["vehicle_no"]));
    }
  }


  virtual ~EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest() = default;
};
class EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive : public Darabonba::Model {
public:
  shared_ptr<string> arrTime{};
  shared_ptr<string> depTime{};
  shared_ptr<long> fee{};
  shared_ptr<string> seatGrade{};
  shared_ptr<string> vehicleNo{};

  EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive() {}

  explicit EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    if (seatGrade) {
      res["seat_grade"] = boost::any(*seatGrade);
    }
    if (vehicleNo) {
      res["vehicle_no"] = boost::any(*vehicleNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
    if (m.find("seat_grade") != m.end() && !m["seat_grade"].empty()) {
      seatGrade = make_shared<string>(boost::any_cast<string>(m["seat_grade"]));
    }
    if (m.find("vehicle_no") != m.end() && !m["vehicle_no"].empty()) {
      vehicleNo = make_shared<string>(boost::any_cast<string>(m["vehicle_no"]));
    }
  }


  virtual ~EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive() = default;
};
class EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<long> arrDate{};
  shared_ptr<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest> cheapest{};
  shared_ptr<string> depCity{};
  shared_ptr<long> depDate{};
  shared_ptr<string> errMsg{};
  shared_ptr<string> itineraryId{};
  shared_ptr<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive> mostExpensive{};
  shared_ptr<bool> success{};

  EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes() {}

  explicit EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (cheapest) {
      res["cheapest"] = cheapest ? boost::any(cheapest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (errMsg) {
      res["err_msg"] = boost::any(*errMsg);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (mostExpensive) {
      res["most_expensive"] = mostExpensive ? boost::any(mostExpensive->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<long>(boost::any_cast<long>(m["arr_date"]));
    }
    if (m.find("cheapest") != m.end() && !m["cheapest"].empty()) {
      if (typeid(map<string, boost::any>) == m["cheapest"].type()) {
        EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cheapest"]));
        cheapest = make_shared<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest>(model1);
      }
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<long>(boost::any_cast<long>(m["dep_date"]));
    }
    if (m.find("err_msg") != m.end() && !m["err_msg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["err_msg"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("most_expensive") != m.end() && !m["most_expensive"].empty()) {
      if (typeid(map<string, boost::any>) == m["most_expensive"].type()) {
        EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["most_expensive"]));
        mostExpensive = make_shared<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes() = default;
};
class EstimatedPriceQueryResponseBodyModuleTrafficFee : public Darabonba::Model {
public:
  shared_ptr<vector<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes>> btripRoutes{};
  shared_ptr<string> errMsg{};
  shared_ptr<long> maxFee{};
  shared_ptr<long> minFee{};
  shared_ptr<bool> success{};

  EstimatedPriceQueryResponseBodyModuleTrafficFee() {}

  explicit EstimatedPriceQueryResponseBodyModuleTrafficFee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripRoutes) {
      vector<boost::any> temp1;
      for(auto item1:*btripRoutes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["btrip_routes"] = boost::any(temp1);
    }
    if (errMsg) {
      res["err_msg"] = boost::any(*errMsg);
    }
    if (maxFee) {
      res["max_fee"] = boost::any(*maxFee);
    }
    if (minFee) {
      res["min_fee"] = boost::any(*minFee);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_routes") != m.end() && !m["btrip_routes"].empty()) {
      if (typeid(vector<boost::any>) == m["btrip_routes"].type()) {
        vector<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["btrip_routes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        btripRoutes = make_shared<vector<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes>>(expect1);
      }
    }
    if (m.find("err_msg") != m.end() && !m["err_msg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["err_msg"]));
    }
    if (m.find("max_fee") != m.end() && !m["max_fee"].empty()) {
      maxFee = make_shared<long>(boost::any_cast<long>(m["max_fee"]));
    }
    if (m.find("min_fee") != m.end() && !m["min_fee"].empty()) {
      minFee = make_shared<long>(boost::any_cast<long>(m["min_fee"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~EstimatedPriceQueryResponseBodyModuleTrafficFee() = default;
};
class EstimatedPriceQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<EstimatedPriceQueryResponseBodyModuleHotelFeeDetail>> hotelFeeDetail{};
  shared_ptr<long> totalHotelFee{};
  shared_ptr<EstimatedPriceQueryResponseBodyModuleTrafficFee> trafficFee{};

  EstimatedPriceQueryResponseBodyModule() {}

  explicit EstimatedPriceQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelFeeDetail) {
      vector<boost::any> temp1;
      for(auto item1:*hotelFeeDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_fee_detail"] = boost::any(temp1);
    }
    if (totalHotelFee) {
      res["total_hotel_fee"] = boost::any(*totalHotelFee);
    }
    if (trafficFee) {
      res["traffic_fee"] = trafficFee ? boost::any(trafficFee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_fee_detail") != m.end() && !m["hotel_fee_detail"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_fee_detail"].type()) {
        vector<EstimatedPriceQueryResponseBodyModuleHotelFeeDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_fee_detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EstimatedPriceQueryResponseBodyModuleHotelFeeDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelFeeDetail = make_shared<vector<EstimatedPriceQueryResponseBodyModuleHotelFeeDetail>>(expect1);
      }
    }
    if (m.find("total_hotel_fee") != m.end() && !m["total_hotel_fee"].empty()) {
      totalHotelFee = make_shared<long>(boost::any_cast<long>(m["total_hotel_fee"]));
    }
    if (m.find("traffic_fee") != m.end() && !m["traffic_fee"].empty()) {
      if (typeid(map<string, boost::any>) == m["traffic_fee"].type()) {
        EstimatedPriceQueryResponseBodyModuleTrafficFee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["traffic_fee"]));
        trafficFee = make_shared<EstimatedPriceQueryResponseBodyModuleTrafficFee>(model1);
      }
    }
  }


  virtual ~EstimatedPriceQueryResponseBodyModule() = default;
};
class EstimatedPriceQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<EstimatedPriceQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  EstimatedPriceQueryResponseBody() {}

  explicit EstimatedPriceQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        EstimatedPriceQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<EstimatedPriceQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~EstimatedPriceQueryResponseBody() = default;
};
class EstimatedPriceQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EstimatedPriceQueryResponseBody> body{};

  EstimatedPriceQueryResponse() {}

  explicit EstimatedPriceQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EstimatedPriceQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EstimatedPriceQueryResponseBody>(model1);
      }
    }
  }


  virtual ~EstimatedPriceQueryResponse() = default;
};
class ExceedApplySyncHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ExceedApplySyncHeaders() {}

  explicit ExceedApplySyncHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ExceedApplySyncHeaders() = default;
};
class ExceedApplySyncRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<long> bizCategory{};
  shared_ptr<string> remark{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdpartyFlowId{};
  shared_ptr<string> userId{};

  ExceedApplySyncRequest() {}

  explicit ExceedApplySyncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (bizCategory) {
      res["biz_category"] = boost::any(*bizCategory);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdpartyFlowId) {
      res["thirdparty_flow_id"] = boost::any(*thirdpartyFlowId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("biz_category") != m.end() && !m["biz_category"].empty()) {
      bizCategory = make_shared<long>(boost::any_cast<long>(m["biz_category"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("thirdparty_flow_id") != m.end() && !m["thirdparty_flow_id"].empty()) {
      thirdpartyFlowId = make_shared<string>(boost::any_cast<string>(m["thirdparty_flow_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~ExceedApplySyncRequest() = default;
};
class ExceedApplySyncResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ExceedApplySyncResponseBody() {}

  explicit ExceedApplySyncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<bool>(boost::any_cast<bool>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ExceedApplySyncResponseBody() = default;
};
class ExceedApplySyncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExceedApplySyncResponseBody> body{};

  ExceedApplySyncResponse() {}

  explicit ExceedApplySyncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExceedApplySyncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExceedApplySyncResponseBody>(model1);
      }
    }
  }


  virtual ~ExceedApplySyncResponse() = default;
};
class FlightBillSettlementQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  FlightBillSettlementQueryHeaders() {}

  explicit FlightBillSettlementQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~FlightBillSettlementQueryHeaders() = default;
};
class FlightBillSettlementQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};

  FlightBillSettlementQueryRequest() {}

  explicit FlightBillSettlementQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
  }


  virtual ~FlightBillSettlementQueryRequest() = default;
};
class FlightBillSettlementQueryResponseBodyModuleDataList : public Darabonba::Model {
public:
  shared_ptr<long> advanceDay{};
  shared_ptr<string> airlineCorpCode{};
  shared_ptr<string> airlineCorpName{};
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> applyId{};
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> arrStation{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> billRecordTime{};
  shared_ptr<string> bookTime{};
  shared_ptr<string> bookerId{};
  shared_ptr<string> bookerJobNo{};
  shared_ptr<string> bookerName{};
  shared_ptr<double> btripCouponFee{};
  shared_ptr<double> buildFee{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> capitalDirection{};
  shared_ptr<string> cascadeDepartment{};
  shared_ptr<double> changeFee{};
  shared_ptr<double> corpPayOrderFee{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<double> coupon{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> department{};
  shared_ptr<string> departmentId{};
  shared_ptr<string> deptCity{};
  shared_ptr<string> deptDate{};
  shared_ptr<string> deptStation{};
  shared_ptr<string> deptTime{};
  shared_ptr<string> discount{};
  shared_ptr<string> feeType{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> index{};
  shared_ptr<double> insuranceFee{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> itineraryNum{};
  shared_ptr<double> itineraryPrice{};
  shared_ptr<string> mostDifferenceDeptTime{};
  shared_ptr<string> mostDifferenceDiscount{};
  shared_ptr<string> mostDifferenceFlightNo{};
  shared_ptr<double> mostDifferencePrice{};
  shared_ptr<string> mostDifferenceReason{};
  shared_ptr<double> mostPrice{};
  shared_ptr<double> negotiationCouponFee{};
  shared_ptr<double> oilFee{};
  shared_ptr<string> orderId{};
  shared_ptr<string> overApplyId{};
  shared_ptr<long> primaryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<double> refundFee{};
  shared_ptr<double> refundUpgradeCost{};
  shared_ptr<string> remark{};
  shared_ptr<string> repeatRefund{};
  shared_ptr<double> sealPrice{};
  shared_ptr<double> serviceFee{};
  shared_ptr<double> settlementFee{};
  shared_ptr<double> settlementGrantFee{};
  shared_ptr<string> settlementTime{};
  shared_ptr<string> settlementType{};
  shared_ptr<long> status{};
  shared_ptr<string> ticketId{};
  shared_ptr<string> travelerId{};
  shared_ptr<string> travelerJobNo{};
  shared_ptr<string> travelerName{};
  shared_ptr<double> upgradeCost{};
  shared_ptr<long> voucherType{};

  FlightBillSettlementQueryResponseBodyModuleDataList() {}

  explicit FlightBillSettlementQueryResponseBodyModuleDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advanceDay) {
      res["advance_day"] = boost::any(*advanceDay);
    }
    if (airlineCorpCode) {
      res["airline_corp_code"] = boost::any(*airlineCorpCode);
    }
    if (airlineCorpName) {
      res["airline_corp_name"] = boost::any(*airlineCorpName);
    }
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (arrStation) {
      res["arr_station"] = boost::any(*arrStation);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (billRecordTime) {
      res["bill_record_time"] = boost::any(*billRecordTime);
    }
    if (bookTime) {
      res["book_time"] = boost::any(*bookTime);
    }
    if (bookerId) {
      res["booker_id"] = boost::any(*bookerId);
    }
    if (bookerJobNo) {
      res["booker_job_no"] = boost::any(*bookerJobNo);
    }
    if (bookerName) {
      res["booker_name"] = boost::any(*bookerName);
    }
    if (btripCouponFee) {
      res["btrip_coupon_fee"] = boost::any(*btripCouponFee);
    }
    if (buildFee) {
      res["build_fee"] = boost::any(*buildFee);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (capitalDirection) {
      res["capital_direction"] = boost::any(*capitalDirection);
    }
    if (cascadeDepartment) {
      res["cascade_department"] = boost::any(*cascadeDepartment);
    }
    if (changeFee) {
      res["change_fee"] = boost::any(*changeFee);
    }
    if (corpPayOrderFee) {
      res["corp_pay_order_fee"] = boost::any(*corpPayOrderFee);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (coupon) {
      res["coupon"] = boost::any(*coupon);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (departmentId) {
      res["department_id"] = boost::any(*departmentId);
    }
    if (deptCity) {
      res["dept_city"] = boost::any(*deptCity);
    }
    if (deptDate) {
      res["dept_date"] = boost::any(*deptDate);
    }
    if (deptStation) {
      res["dept_station"] = boost::any(*deptStation);
    }
    if (deptTime) {
      res["dept_time"] = boost::any(*deptTime);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (feeType) {
      res["fee_type"] = boost::any(*feeType);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (insuranceFee) {
      res["insurance_fee"] = boost::any(*insuranceFee);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (itineraryNum) {
      res["itinerary_num"] = boost::any(*itineraryNum);
    }
    if (itineraryPrice) {
      res["itinerary_price"] = boost::any(*itineraryPrice);
    }
    if (mostDifferenceDeptTime) {
      res["most_difference_dept_time"] = boost::any(*mostDifferenceDeptTime);
    }
    if (mostDifferenceDiscount) {
      res["most_difference_discount"] = boost::any(*mostDifferenceDiscount);
    }
    if (mostDifferenceFlightNo) {
      res["most_difference_flight_no"] = boost::any(*mostDifferenceFlightNo);
    }
    if (mostDifferencePrice) {
      res["most_difference_price"] = boost::any(*mostDifferencePrice);
    }
    if (mostDifferenceReason) {
      res["most_difference_reason"] = boost::any(*mostDifferenceReason);
    }
    if (mostPrice) {
      res["most_price"] = boost::any(*mostPrice);
    }
    if (negotiationCouponFee) {
      res["negotiation_coupon_fee"] = boost::any(*negotiationCouponFee);
    }
    if (oilFee) {
      res["oil_fee"] = boost::any(*oilFee);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (overApplyId) {
      res["over_apply_id"] = boost::any(*overApplyId);
    }
    if (primaryId) {
      res["primary_id"] = boost::any(*primaryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundUpgradeCost) {
      res["refund_upgrade_cost"] = boost::any(*refundUpgradeCost);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (repeatRefund) {
      res["repeat_refund"] = boost::any(*repeatRefund);
    }
    if (sealPrice) {
      res["seal_price"] = boost::any(*sealPrice);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (settlementFee) {
      res["settlement_fee"] = boost::any(*settlementFee);
    }
    if (settlementGrantFee) {
      res["settlement_grant_fee"] = boost::any(*settlementGrantFee);
    }
    if (settlementTime) {
      res["settlement_time"] = boost::any(*settlementTime);
    }
    if (settlementType) {
      res["settlement_type"] = boost::any(*settlementType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (ticketId) {
      res["ticket_id"] = boost::any(*ticketId);
    }
    if (travelerId) {
      res["traveler_id"] = boost::any(*travelerId);
    }
    if (travelerJobNo) {
      res["traveler_job_no"] = boost::any(*travelerJobNo);
    }
    if (travelerName) {
      res["traveler_name"] = boost::any(*travelerName);
    }
    if (upgradeCost) {
      res["upgrade_cost"] = boost::any(*upgradeCost);
    }
    if (voucherType) {
      res["voucher_type"] = boost::any(*voucherType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("advance_day") != m.end() && !m["advance_day"].empty()) {
      advanceDay = make_shared<long>(boost::any_cast<long>(m["advance_day"]));
    }
    if (m.find("airline_corp_code") != m.end() && !m["airline_corp_code"].empty()) {
      airlineCorpCode = make_shared<string>(boost::any_cast<string>(m["airline_corp_code"]));
    }
    if (m.find("airline_corp_name") != m.end() && !m["airline_corp_name"].empty()) {
      airlineCorpName = make_shared<string>(boost::any_cast<string>(m["airline_corp_name"]));
    }
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("arr_station") != m.end() && !m["arr_station"].empty()) {
      arrStation = make_shared<string>(boost::any_cast<string>(m["arr_station"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("bill_record_time") != m.end() && !m["bill_record_time"].empty()) {
      billRecordTime = make_shared<string>(boost::any_cast<string>(m["bill_record_time"]));
    }
    if (m.find("book_time") != m.end() && !m["book_time"].empty()) {
      bookTime = make_shared<string>(boost::any_cast<string>(m["book_time"]));
    }
    if (m.find("booker_id") != m.end() && !m["booker_id"].empty()) {
      bookerId = make_shared<string>(boost::any_cast<string>(m["booker_id"]));
    }
    if (m.find("booker_job_no") != m.end() && !m["booker_job_no"].empty()) {
      bookerJobNo = make_shared<string>(boost::any_cast<string>(m["booker_job_no"]));
    }
    if (m.find("booker_name") != m.end() && !m["booker_name"].empty()) {
      bookerName = make_shared<string>(boost::any_cast<string>(m["booker_name"]));
    }
    if (m.find("btrip_coupon_fee") != m.end() && !m["btrip_coupon_fee"].empty()) {
      btripCouponFee = make_shared<double>(boost::any_cast<double>(m["btrip_coupon_fee"]));
    }
    if (m.find("build_fee") != m.end() && !m["build_fee"].empty()) {
      buildFee = make_shared<double>(boost::any_cast<double>(m["build_fee"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("capital_direction") != m.end() && !m["capital_direction"].empty()) {
      capitalDirection = make_shared<string>(boost::any_cast<string>(m["capital_direction"]));
    }
    if (m.find("cascade_department") != m.end() && !m["cascade_department"].empty()) {
      cascadeDepartment = make_shared<string>(boost::any_cast<string>(m["cascade_department"]));
    }
    if (m.find("change_fee") != m.end() && !m["change_fee"].empty()) {
      changeFee = make_shared<double>(boost::any_cast<double>(m["change_fee"]));
    }
    if (m.find("corp_pay_order_fee") != m.end() && !m["corp_pay_order_fee"].empty()) {
      corpPayOrderFee = make_shared<double>(boost::any_cast<double>(m["corp_pay_order_fee"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("coupon") != m.end() && !m["coupon"].empty()) {
      coupon = make_shared<double>(boost::any_cast<double>(m["coupon"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("department_id") != m.end() && !m["department_id"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["department_id"]));
    }
    if (m.find("dept_city") != m.end() && !m["dept_city"].empty()) {
      deptCity = make_shared<string>(boost::any_cast<string>(m["dept_city"]));
    }
    if (m.find("dept_date") != m.end() && !m["dept_date"].empty()) {
      deptDate = make_shared<string>(boost::any_cast<string>(m["dept_date"]));
    }
    if (m.find("dept_station") != m.end() && !m["dept_station"].empty()) {
      deptStation = make_shared<string>(boost::any_cast<string>(m["dept_station"]));
    }
    if (m.find("dept_time") != m.end() && !m["dept_time"].empty()) {
      deptTime = make_shared<string>(boost::any_cast<string>(m["dept_time"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("fee_type") != m.end() && !m["fee_type"].empty()) {
      feeType = make_shared<string>(boost::any_cast<string>(m["fee_type"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("insurance_fee") != m.end() && !m["insurance_fee"].empty()) {
      insuranceFee = make_shared<double>(boost::any_cast<double>(m["insurance_fee"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("itinerary_num") != m.end() && !m["itinerary_num"].empty()) {
      itineraryNum = make_shared<string>(boost::any_cast<string>(m["itinerary_num"]));
    }
    if (m.find("itinerary_price") != m.end() && !m["itinerary_price"].empty()) {
      itineraryPrice = make_shared<double>(boost::any_cast<double>(m["itinerary_price"]));
    }
    if (m.find("most_difference_dept_time") != m.end() && !m["most_difference_dept_time"].empty()) {
      mostDifferenceDeptTime = make_shared<string>(boost::any_cast<string>(m["most_difference_dept_time"]));
    }
    if (m.find("most_difference_discount") != m.end() && !m["most_difference_discount"].empty()) {
      mostDifferenceDiscount = make_shared<string>(boost::any_cast<string>(m["most_difference_discount"]));
    }
    if (m.find("most_difference_flight_no") != m.end() && !m["most_difference_flight_no"].empty()) {
      mostDifferenceFlightNo = make_shared<string>(boost::any_cast<string>(m["most_difference_flight_no"]));
    }
    if (m.find("most_difference_price") != m.end() && !m["most_difference_price"].empty()) {
      mostDifferencePrice = make_shared<double>(boost::any_cast<double>(m["most_difference_price"]));
    }
    if (m.find("most_difference_reason") != m.end() && !m["most_difference_reason"].empty()) {
      mostDifferenceReason = make_shared<string>(boost::any_cast<string>(m["most_difference_reason"]));
    }
    if (m.find("most_price") != m.end() && !m["most_price"].empty()) {
      mostPrice = make_shared<double>(boost::any_cast<double>(m["most_price"]));
    }
    if (m.find("negotiation_coupon_fee") != m.end() && !m["negotiation_coupon_fee"].empty()) {
      negotiationCouponFee = make_shared<double>(boost::any_cast<double>(m["negotiation_coupon_fee"]));
    }
    if (m.find("oil_fee") != m.end() && !m["oil_fee"].empty()) {
      oilFee = make_shared<double>(boost::any_cast<double>(m["oil_fee"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("over_apply_id") != m.end() && !m["over_apply_id"].empty()) {
      overApplyId = make_shared<string>(boost::any_cast<string>(m["over_apply_id"]));
    }
    if (m.find("primary_id") != m.end() && !m["primary_id"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["primary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<double>(boost::any_cast<double>(m["refund_fee"]));
    }
    if (m.find("refund_upgrade_cost") != m.end() && !m["refund_upgrade_cost"].empty()) {
      refundUpgradeCost = make_shared<double>(boost::any_cast<double>(m["refund_upgrade_cost"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("repeat_refund") != m.end() && !m["repeat_refund"].empty()) {
      repeatRefund = make_shared<string>(boost::any_cast<string>(m["repeat_refund"]));
    }
    if (m.find("seal_price") != m.end() && !m["seal_price"].empty()) {
      sealPrice = make_shared<double>(boost::any_cast<double>(m["seal_price"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("settlement_fee") != m.end() && !m["settlement_fee"].empty()) {
      settlementFee = make_shared<double>(boost::any_cast<double>(m["settlement_fee"]));
    }
    if (m.find("settlement_grant_fee") != m.end() && !m["settlement_grant_fee"].empty()) {
      settlementGrantFee = make_shared<double>(boost::any_cast<double>(m["settlement_grant_fee"]));
    }
    if (m.find("settlement_time") != m.end() && !m["settlement_time"].empty()) {
      settlementTime = make_shared<string>(boost::any_cast<string>(m["settlement_time"]));
    }
    if (m.find("settlement_type") != m.end() && !m["settlement_type"].empty()) {
      settlementType = make_shared<string>(boost::any_cast<string>(m["settlement_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("ticket_id") != m.end() && !m["ticket_id"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["ticket_id"]));
    }
    if (m.find("traveler_id") != m.end() && !m["traveler_id"].empty()) {
      travelerId = make_shared<string>(boost::any_cast<string>(m["traveler_id"]));
    }
    if (m.find("traveler_job_no") != m.end() && !m["traveler_job_no"].empty()) {
      travelerJobNo = make_shared<string>(boost::any_cast<string>(m["traveler_job_no"]));
    }
    if (m.find("traveler_name") != m.end() && !m["traveler_name"].empty()) {
      travelerName = make_shared<string>(boost::any_cast<string>(m["traveler_name"]));
    }
    if (m.find("upgrade_cost") != m.end() && !m["upgrade_cost"].empty()) {
      upgradeCost = make_shared<double>(boost::any_cast<double>(m["upgrade_cost"]));
    }
    if (m.find("voucher_type") != m.end() && !m["voucher_type"].empty()) {
      voucherType = make_shared<long>(boost::any_cast<long>(m["voucher_type"]));
    }
  }


  virtual ~FlightBillSettlementQueryResponseBodyModuleDataList() = default;
};
class FlightBillSettlementQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> category{};
  shared_ptr<string> corpId{};
  shared_ptr<vector<FlightBillSettlementQueryResponseBodyModuleDataList>> dataList{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};
  shared_ptr<long> totalNum{};

  FlightBillSettlementQueryResponseBodyModule() {}

  explicit FlightBillSettlementQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_list"] = boost::any(temp1);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    if (totalNum) {
      res["total_num"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["category"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("data_list") != m.end() && !m["data_list"].empty()) {
      if (typeid(vector<boost::any>) == m["data_list"].type()) {
        vector<FlightBillSettlementQueryResponseBodyModuleDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightBillSettlementQueryResponseBodyModuleDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<FlightBillSettlementQueryResponseBodyModuleDataList>>(expect1);
      }
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
    if (m.find("total_num") != m.end() && !m["total_num"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["total_num"]));
    }
  }


  virtual ~FlightBillSettlementQueryResponseBodyModule() = default;
};
class FlightBillSettlementQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightBillSettlementQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightBillSettlementQueryResponseBody() {}

  explicit FlightBillSettlementQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightBillSettlementQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightBillSettlementQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightBillSettlementQueryResponseBody() = default;
};
class FlightBillSettlementQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightBillSettlementQueryResponseBody> body{};

  FlightBillSettlementQueryResponse() {}

  explicit FlightBillSettlementQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightBillSettlementQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightBillSettlementQueryResponseBody>(model1);
      }
    }
  }


  virtual ~FlightBillSettlementQueryResponse() = default;
};
class FlightCancelOrderHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightCancelOrderHeaders() {}

  explicit FlightCancelOrderHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightCancelOrderHeaders() = default;
};
class FlightCancelOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};

  FlightCancelOrderRequest() {}

  explicit FlightCancelOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
  }


  virtual ~FlightCancelOrderRequest() = default;
};
class FlightCancelOrderResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> cancelTime{};
  shared_ptr<string> failCode{};
  shared_ptr<string> failReason{};
  shared_ptr<string> orderStatus{};

  FlightCancelOrderResponseBodyModule() {}

  explicit FlightCancelOrderResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelTime) {
      res["cancel_time"] = boost::any(*cancelTime);
    }
    if (failCode) {
      res["fail_code"] = boost::any(*failCode);
    }
    if (failReason) {
      res["fail_reason"] = boost::any(*failReason);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cancel_time") != m.end() && !m["cancel_time"].empty()) {
      cancelTime = make_shared<string>(boost::any_cast<string>(m["cancel_time"]));
    }
    if (m.find("fail_code") != m.end() && !m["fail_code"].empty()) {
      failCode = make_shared<string>(boost::any_cast<string>(m["fail_code"]));
    }
    if (m.find("fail_reason") != m.end() && !m["fail_reason"].empty()) {
      failReason = make_shared<string>(boost::any_cast<string>(m["fail_reason"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<string>(boost::any_cast<string>(m["order_status"]));
    }
  }


  virtual ~FlightCancelOrderResponseBodyModule() = default;
};
class FlightCancelOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightCancelOrderResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightCancelOrderResponseBody() {}

  explicit FlightCancelOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightCancelOrderResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightCancelOrderResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightCancelOrderResponseBody() = default;
};
class FlightCancelOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightCancelOrderResponseBody> body{};

  FlightCancelOrderResponse() {}

  explicit FlightCancelOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightCancelOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightCancelOrderResponseBody>(model1);
      }
    }
  }


  virtual ~FlightCancelOrderResponse() = default;
};
class FlightCreateOrderHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightCreateOrderHeaders() {}

  explicit FlightCreateOrderHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightCreateOrderHeaders() = default;
};
class FlightCreateOrderRequestContactInfo : public Darabonba::Model {
public:
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhone{};

  FlightCreateOrderRequestContactInfo() {}

  explicit FlightCreateOrderRequestContactInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactEmail) {
      res["contact_email"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (contactPhone) {
      res["contact_phone"] = boost::any(*contactPhone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact_email") != m.end() && !m["contact_email"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["contact_email"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("contact_phone") != m.end() && !m["contact_phone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["contact_phone"]));
    }
  }


  virtual ~FlightCreateOrderRequestContactInfo() = default;
};
class FlightCreateOrderRequestTravelerInfoList : public Darabonba::Model {
public:
  shared_ptr<string> birthday{};
  shared_ptr<string> certNation{};
  shared_ptr<string> certNo{};
  shared_ptr<string> certType{};
  shared_ptr<string> certValidDate{};
  shared_ptr<string> name{};
  shared_ptr<string> nationality{};
  shared_ptr<string> nationalityCode{};
  shared_ptr<string> outUserId{};
  shared_ptr<string> phone{};
  shared_ptr<long> sex{};
  shared_ptr<string> type{};

  FlightCreateOrderRequestTravelerInfoList() {}

  explicit FlightCreateOrderRequestTravelerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthday) {
      res["birthday"] = boost::any(*birthday);
    }
    if (certNation) {
      res["cert_nation"] = boost::any(*certNation);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (certValidDate) {
      res["cert_valid_date"] = boost::any(*certValidDate);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nationality) {
      res["nationality"] = boost::any(*nationality);
    }
    if (nationalityCode) {
      res["nationality_code"] = boost::any(*nationalityCode);
    }
    if (outUserId) {
      res["out_user_id"] = boost::any(*outUserId);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (sex) {
      res["sex"] = boost::any(*sex);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birthday") != m.end() && !m["birthday"].empty()) {
      birthday = make_shared<string>(boost::any_cast<string>(m["birthday"]));
    }
    if (m.find("cert_nation") != m.end() && !m["cert_nation"].empty()) {
      certNation = make_shared<string>(boost::any_cast<string>(m["cert_nation"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["cert_type"]));
    }
    if (m.find("cert_valid_date") != m.end() && !m["cert_valid_date"].empty()) {
      certValidDate = make_shared<string>(boost::any_cast<string>(m["cert_valid_date"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nationality") != m.end() && !m["nationality"].empty()) {
      nationality = make_shared<string>(boost::any_cast<string>(m["nationality"]));
    }
    if (m.find("nationality_code") != m.end() && !m["nationality_code"].empty()) {
      nationalityCode = make_shared<string>(boost::any_cast<string>(m["nationality_code"]));
    }
    if (m.find("out_user_id") != m.end() && !m["out_user_id"].empty()) {
      outUserId = make_shared<string>(boost::any_cast<string>(m["out_user_id"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("sex") != m.end() && !m["sex"].empty()) {
      sex = make_shared<long>(boost::any_cast<long>(m["sex"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~FlightCreateOrderRequestTravelerInfoList() = default;
};
class FlightCreateOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<long> autoPay{};
  shared_ptr<string> buyerName{};
  shared_ptr<string> buyerUniqueKey{};
  shared_ptr<FlightCreateOrderRequestContactInfo> contactInfo{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<string> disOrderId{};
  shared_ptr<map<string, boost::any>> orderAttr{};
  shared_ptr<string> orderParams{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<string> receiptAddress{};
  shared_ptr<long> receiptTarget{};
  shared_ptr<string> receiptTitle{};
  shared_ptr<vector<FlightCreateOrderRequestTravelerInfoList>> travelerInfoList{};
  shared_ptr<long> tripType{};

  FlightCreateOrderRequest() {}

  explicit FlightCreateOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (autoPay) {
      res["auto_pay"] = boost::any(*autoPay);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (buyerUniqueKey) {
      res["buyer_unique_key"] = boost::any(*buyerUniqueKey);
    }
    if (contactInfo) {
      res["contact_info"] = contactInfo ? boost::any(contactInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (orderAttr) {
      res["order_attr"] = boost::any(*orderAttr);
    }
    if (orderParams) {
      res["order_params"] = boost::any(*orderParams);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (receiptAddress) {
      res["receipt_address"] = boost::any(*receiptAddress);
    }
    if (receiptTarget) {
      res["receipt_target"] = boost::any(*receiptTarget);
    }
    if (receiptTitle) {
      res["receipt_title"] = boost::any(*receiptTitle);
    }
    if (travelerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_info_list"] = boost::any(temp1);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("auto_pay") != m.end() && !m["auto_pay"].empty()) {
      autoPay = make_shared<long>(boost::any_cast<long>(m["auto_pay"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("buyer_unique_key") != m.end() && !m["buyer_unique_key"].empty()) {
      buyerUniqueKey = make_shared<string>(boost::any_cast<string>(m["buyer_unique_key"]));
    }
    if (m.find("contact_info") != m.end() && !m["contact_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["contact_info"].type()) {
        FlightCreateOrderRequestContactInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["contact_info"]));
        contactInfo = make_shared<FlightCreateOrderRequestContactInfo>(model1);
      }
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("order_attr") != m.end() && !m["order_attr"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["order_attr"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      orderAttr = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("order_params") != m.end() && !m["order_params"].empty()) {
      orderParams = make_shared<string>(boost::any_cast<string>(m["order_params"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("receipt_address") != m.end() && !m["receipt_address"].empty()) {
      receiptAddress = make_shared<string>(boost::any_cast<string>(m["receipt_address"]));
    }
    if (m.find("receipt_target") != m.end() && !m["receipt_target"].empty()) {
      receiptTarget = make_shared<long>(boost::any_cast<long>(m["receipt_target"]));
    }
    if (m.find("receipt_title") != m.end() && !m["receipt_title"].empty()) {
      receiptTitle = make_shared<string>(boost::any_cast<string>(m["receipt_title"]));
    }
    if (m.find("traveler_info_list") != m.end() && !m["traveler_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_info_list"].type()) {
        vector<FlightCreateOrderRequestTravelerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightCreateOrderRequestTravelerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerInfoList = make_shared<vector<FlightCreateOrderRequestTravelerInfoList>>(expect1);
      }
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightCreateOrderRequest() = default;
};
class FlightCreateOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<long> autoPay{};
  shared_ptr<string> buyerName{};
  shared_ptr<string> buyerUniqueKey{};
  shared_ptr<string> contactInfoShrink{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> orderAttrShrink{};
  shared_ptr<string> orderParams{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<string> receiptAddress{};
  shared_ptr<long> receiptTarget{};
  shared_ptr<string> receiptTitle{};
  shared_ptr<string> travelerInfoListShrink{};
  shared_ptr<long> tripType{};

  FlightCreateOrderShrinkRequest() {}

  explicit FlightCreateOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (autoPay) {
      res["auto_pay"] = boost::any(*autoPay);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (buyerUniqueKey) {
      res["buyer_unique_key"] = boost::any(*buyerUniqueKey);
    }
    if (contactInfoShrink) {
      res["contact_info"] = boost::any(*contactInfoShrink);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (orderAttrShrink) {
      res["order_attr"] = boost::any(*orderAttrShrink);
    }
    if (orderParams) {
      res["order_params"] = boost::any(*orderParams);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (receiptAddress) {
      res["receipt_address"] = boost::any(*receiptAddress);
    }
    if (receiptTarget) {
      res["receipt_target"] = boost::any(*receiptTarget);
    }
    if (receiptTitle) {
      res["receipt_title"] = boost::any(*receiptTitle);
    }
    if (travelerInfoListShrink) {
      res["traveler_info_list"] = boost::any(*travelerInfoListShrink);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("auto_pay") != m.end() && !m["auto_pay"].empty()) {
      autoPay = make_shared<long>(boost::any_cast<long>(m["auto_pay"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("buyer_unique_key") != m.end() && !m["buyer_unique_key"].empty()) {
      buyerUniqueKey = make_shared<string>(boost::any_cast<string>(m["buyer_unique_key"]));
    }
    if (m.find("contact_info") != m.end() && !m["contact_info"].empty()) {
      contactInfoShrink = make_shared<string>(boost::any_cast<string>(m["contact_info"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("order_attr") != m.end() && !m["order_attr"].empty()) {
      orderAttrShrink = make_shared<string>(boost::any_cast<string>(m["order_attr"]));
    }
    if (m.find("order_params") != m.end() && !m["order_params"].empty()) {
      orderParams = make_shared<string>(boost::any_cast<string>(m["order_params"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("receipt_address") != m.end() && !m["receipt_address"].empty()) {
      receiptAddress = make_shared<string>(boost::any_cast<string>(m["receipt_address"]));
    }
    if (m.find("receipt_target") != m.end() && !m["receipt_target"].empty()) {
      receiptTarget = make_shared<long>(boost::any_cast<long>(m["receipt_target"]));
    }
    if (m.find("receipt_title") != m.end() && !m["receipt_title"].empty()) {
      receiptTitle = make_shared<string>(boost::any_cast<string>(m["receipt_title"]));
    }
    if (m.find("traveler_info_list") != m.end() && !m["traveler_info_list"].empty()) {
      travelerInfoListShrink = make_shared<string>(boost::any_cast<string>(m["traveler_info_list"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightCreateOrderShrinkRequest() = default;
};
class FlightCreateOrderResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<long> btripOrderId{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> lastPayTime{};
  shared_ptr<long> orderStatus{};
  shared_ptr<long> payStatus{};
  shared_ptr<long> paymentPrice{};
  shared_ptr<long> totalPrice{};

  FlightCreateOrderResponseBodyModule() {}

  explicit FlightCreateOrderResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (lastPayTime) {
      res["last_pay_time"] = boost::any(*lastPayTime);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (payStatus) {
      res["pay_status"] = boost::any(*payStatus);
    }
    if (paymentPrice) {
      res["payment_price"] = boost::any(*paymentPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_order_id"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("last_pay_time") != m.end() && !m["last_pay_time"].empty()) {
      lastPayTime = make_shared<string>(boost::any_cast<string>(m["last_pay_time"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("pay_status") != m.end() && !m["pay_status"].empty()) {
      payStatus = make_shared<long>(boost::any_cast<long>(m["pay_status"]));
    }
    if (m.find("payment_price") != m.end() && !m["payment_price"].empty()) {
      paymentPrice = make_shared<long>(boost::any_cast<long>(m["payment_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
  }


  virtual ~FlightCreateOrderResponseBodyModule() = default;
};
class FlightCreateOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightCreateOrderResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightCreateOrderResponseBody() {}

  explicit FlightCreateOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightCreateOrderResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightCreateOrderResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightCreateOrderResponseBody() = default;
};
class FlightCreateOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightCreateOrderResponseBody> body{};

  FlightCreateOrderResponse() {}

  explicit FlightCreateOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightCreateOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightCreateOrderResponseBody>(model1);
      }
    }
  }


  virtual ~FlightCreateOrderResponse() = default;
};
class FlightExceedApplyQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  FlightExceedApplyQueryHeaders() {}

  explicit FlightExceedApplyQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~FlightExceedApplyQueryHeaders() = default;
};
class FlightExceedApplyQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};

  FlightExceedApplyQueryRequest() {}

  explicit FlightExceedApplyQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
  }


  virtual ~FlightExceedApplyQueryRequest() = default;
};
class FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> cabin{};
  shared_ptr<long> cabinClass{};
  shared_ptr<string> cabinClassStr{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depTime{};
  shared_ptr<string> discount{};
  shared_ptr<string> flightNo{};
  shared_ptr<long> price{};
  shared_ptr<long> type{};

  FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo() {}

  explicit FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassStr) {
      res["cabin_class_str"] = boost::any(*cabinClassStr);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<long>(boost::any_cast<long>(m["cabin_class"]));
    }
    if (m.find("cabin_class_str") != m.end() && !m["cabin_class_str"].empty()) {
      cabinClassStr = make_shared<string>(boost::any_cast<string>(m["cabin_class_str"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo() = default;
};
class FlightExceedApplyQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo> applyIntentionInfoDo{};
  shared_ptr<string> btripCause{};
  shared_ptr<string> corpId{};
  shared_ptr<string> exceedReason{};
  shared_ptr<long> exceedType{};
  shared_ptr<string> originStandard{};
  shared_ptr<long> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartCorpId{};
  shared_ptr<string> userId{};

  FlightExceedApplyQueryResponseBodyModule() {}

  explicit FlightExceedApplyQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (applyIntentionInfoDo) {
      res["apply_intention_info_do"] = applyIntentionInfoDo ? boost::any(applyIntentionInfoDo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (btripCause) {
      res["btrip_cause"] = boost::any(*btripCause);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (exceedReason) {
      res["exceed_reason"] = boost::any(*exceedReason);
    }
    if (exceedType) {
      res["exceed_type"] = boost::any(*exceedType);
    }
    if (originStandard) {
      res["origin_standard"] = boost::any(*originStandard);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (submitTime) {
      res["submit_time"] = boost::any(*submitTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartCorpId) {
      res["thirdpart_corp_id"] = boost::any(*thirdpartCorpId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("apply_intention_info_do") != m.end() && !m["apply_intention_info_do"].empty()) {
      if (typeid(map<string, boost::any>) == m["apply_intention_info_do"].type()) {
        FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["apply_intention_info_do"]));
        applyIntentionInfoDo = make_shared<FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo>(model1);
      }
    }
    if (m.find("btrip_cause") != m.end() && !m["btrip_cause"].empty()) {
      btripCause = make_shared<string>(boost::any_cast<string>(m["btrip_cause"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("exceed_reason") != m.end() && !m["exceed_reason"].empty()) {
      exceedReason = make_shared<string>(boost::any_cast<string>(m["exceed_reason"]));
    }
    if (m.find("exceed_type") != m.end() && !m["exceed_type"].empty()) {
      exceedType = make_shared<long>(boost::any_cast<long>(m["exceed_type"]));
    }
    if (m.find("origin_standard") != m.end() && !m["origin_standard"].empty()) {
      originStandard = make_shared<string>(boost::any_cast<string>(m["origin_standard"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("submit_time") != m.end() && !m["submit_time"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["submit_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_corp_id") != m.end() && !m["thirdpart_corp_id"].empty()) {
      thirdpartCorpId = make_shared<string>(boost::any_cast<string>(m["thirdpart_corp_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightExceedApplyQueryResponseBodyModule() = default;
};
class FlightExceedApplyQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightExceedApplyQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightExceedApplyQueryResponseBody() {}

  explicit FlightExceedApplyQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightExceedApplyQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightExceedApplyQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightExceedApplyQueryResponseBody() = default;
};
class FlightExceedApplyQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightExceedApplyQueryResponseBody> body{};

  FlightExceedApplyQueryResponse() {}

  explicit FlightExceedApplyQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightExceedApplyQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightExceedApplyQueryResponseBody>(model1);
      }
    }
  }


  virtual ~FlightExceedApplyQueryResponse() = default;
};
class FlightItineraryScanQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  FlightItineraryScanQueryHeaders() {}

  explicit FlightItineraryScanQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~FlightItineraryScanQueryHeaders() = default;
};
class FlightItineraryScanQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};
  shared_ptr<long> billId{};
  shared_ptr<long> invoiceSubTaskId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  FlightItineraryScanQueryRequest() {}

  explicit FlightItineraryScanQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (billId) {
      res["bill_id"] = boost::any(*billId);
    }
    if (invoiceSubTaskId) {
      res["invoice_sub_task_id"] = boost::any(*invoiceSubTaskId);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("bill_id") != m.end() && !m["bill_id"].empty()) {
      billId = make_shared<long>(boost::any_cast<long>(m["bill_id"]));
    }
    if (m.find("invoice_sub_task_id") != m.end() && !m["invoice_sub_task_id"].empty()) {
      invoiceSubTaskId = make_shared<long>(boost::any_cast<long>(m["invoice_sub_task_id"]));
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
  }


  virtual ~FlightItineraryScanQueryRequest() = default;
};
class FlightItineraryScanQueryResponseBodyModuleItems : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};
  shared_ptr<string> build{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> department{};
  shared_ptr<string> fuelSurcharge{};
  shared_ptr<string> insurance{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> itineraryNum{};
  shared_ptr<long> orderId{};
  shared_ptr<string> ossUrl{};
  shared_ptr<string> passengerName{};
  shared_ptr<string> project{};
  shared_ptr<string> taxAmount{};
  shared_ptr<string> taxRate{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> ticketPrice{};
  shared_ptr<string> totalPrice{};

  FlightItineraryScanQueryResponseBodyModuleItems() {}

  explicit FlightItineraryScanQueryResponseBodyModuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (build) {
      res["build"] = boost::any(*build);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (fuelSurcharge) {
      res["fuel_surcharge"] = boost::any(*fuelSurcharge);
    }
    if (insurance) {
      res["insurance"] = boost::any(*insurance);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (itineraryNum) {
      res["itinerary_num"] = boost::any(*itineraryNum);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (ossUrl) {
      res["oss_url"] = boost::any(*ossUrl);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (project) {
      res["project"] = boost::any(*project);
    }
    if (taxAmount) {
      res["tax_amount"] = boost::any(*taxAmount);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("build") != m.end() && !m["build"].empty()) {
      build = make_shared<string>(boost::any_cast<string>(m["build"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("fuel_surcharge") != m.end() && !m["fuel_surcharge"].empty()) {
      fuelSurcharge = make_shared<string>(boost::any_cast<string>(m["fuel_surcharge"]));
    }
    if (m.find("insurance") != m.end() && !m["insurance"].empty()) {
      insurance = make_shared<string>(boost::any_cast<string>(m["insurance"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("itinerary_num") != m.end() && !m["itinerary_num"].empty()) {
      itineraryNum = make_shared<string>(boost::any_cast<string>(m["itinerary_num"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("oss_url") != m.end() && !m["oss_url"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["oss_url"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("project") != m.end() && !m["project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["project"]));
    }
    if (m.find("tax_amount") != m.end() && !m["tax_amount"].empty()) {
      taxAmount = make_shared<string>(boost::any_cast<string>(m["tax_amount"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<string>(boost::any_cast<string>(m["ticket_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<string>(boost::any_cast<string>(m["total_price"]));
    }
  }


  virtual ~FlightItineraryScanQueryResponseBodyModuleItems() = default;
};
class FlightItineraryScanQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightItineraryScanQueryResponseBodyModuleItems>> items{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalPage{};
  shared_ptr<long> totalSize{};

  FlightItineraryScanQueryResponseBodyModule() {}

  explicit FlightItineraryScanQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalPage) {
      res["total_page"] = boost::any(*totalPage);
    }
    if (totalSize) {
      res["total_size"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<FlightItineraryScanQueryResponseBodyModuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightItineraryScanQueryResponseBodyModuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FlightItineraryScanQueryResponseBodyModuleItems>>(expect1);
      }
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_page") != m.end() && !m["total_page"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["total_page"]));
    }
    if (m.find("total_size") != m.end() && !m["total_size"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["total_size"]));
    }
  }


  virtual ~FlightItineraryScanQueryResponseBodyModule() = default;
};
class FlightItineraryScanQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightItineraryScanQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightItineraryScanQueryResponseBody() {}

  explicit FlightItineraryScanQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightItineraryScanQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightItineraryScanQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightItineraryScanQueryResponseBody() = default;
};
class FlightItineraryScanQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightItineraryScanQueryResponseBody> body{};

  FlightItineraryScanQueryResponse() {}

  explicit FlightItineraryScanQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightItineraryScanQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightItineraryScanQueryResponseBody>(model1);
      }
    }
  }


  virtual ~FlightItineraryScanQueryResponse() = default;
};
class FlightListingSearchHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightListingSearchHeaders() {}

  explicit FlightListingSearchHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightListingSearchHeaders() = default;
};
class FlightListingSearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};

  FlightListingSearchRequest() {}

  explicit FlightListingSearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
  }


  virtual ~FlightListingSearchRequest() = default;
};
class FlightListingSearchResponseBodyModuleFlightListAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};

  FlightListingSearchResponseBodyModuleFlightListAirlineInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListAirlineInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightListingSearchResponseBodyModuleFlightListArrAirportInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListArrAirportInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightListingSearchResponseBodyModuleFlightListDepAirportInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListDepAirportInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["image_d_o"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("image_d_o") != m.end() && !m["image_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["image_d_o"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["image_d_o"]));
        imageDO = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<boost::any>> extraContentVisualizes{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (extraContentVisualizes) {
      res["extra_content_visualizes"] = boost::any(*extraContentVisualizes);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("extra_content_visualizes") != m.end() && !m["extra_content_visualizes"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["extra_content_visualizes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_content_visualizes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      extraContentVisualizes = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo>> info{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo>> info{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo>> info{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo>> info{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleList : public Darabonba::Model {
public:
  shared_ptr<string> baggageInfo{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem> baggageItem{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule> changeRule{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem> changeRuleItem{};
  shared_ptr<string> extra{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule> refundRule{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem> refundRuleItem{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule> signRule{};
  shared_ptr<string> tuigaiqianInfo{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule> upgradeRule{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleList() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageInfo) {
      res["baggage_info"] = boost::any(*baggageInfo);
    }
    if (baggageItem) {
      res["baggage_item"] = baggageItem ? boost::any(baggageItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRule) {
      res["change_rule"] = changeRule ? boost::any(changeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRuleItem) {
      res["change_rule_item"] = changeRuleItem ? boost::any(changeRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (refundRule) {
      res["refund_rule"] = refundRule ? boost::any(refundRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundRuleItem) {
      res["refund_rule_item"] = refundRuleItem ? boost::any(refundRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signRule) {
      res["sign_rule"] = signRule ? boost::any(signRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    if (upgradeRule) {
      res["upgrade_rule"] = upgradeRule ? boost::any(upgradeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_info") != m.end() && !m["baggage_info"].empty()) {
      baggageInfo = make_shared<string>(boost::any_cast<string>(m["baggage_info"]));
    }
    if (m.find("baggage_item") != m.end() && !m["baggage_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["baggage_item"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["baggage_item"]));
        baggageItem = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem>(model1);
      }
    }
    if (m.find("change_rule") != m.end() && !m["change_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule"]));
        changeRule = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule>(model1);
      }
    }
    if (m.find("change_rule_item") != m.end() && !m["change_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule_item"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule_item"]));
        changeRuleItem = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem>(model1);
      }
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("refund_rule") != m.end() && !m["refund_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule"]));
        refundRule = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule>(model1);
      }
    }
    if (m.find("refund_rule_item") != m.end() && !m["refund_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule_item"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule_item"]));
        refundRuleItem = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem>(model1);
      }
    }
    if (m.find("sign_rule") != m.end() && !m["sign_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["sign_rule"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sign_rule"]));
        signRule = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule>(model1);
      }
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
    if (m.find("upgrade_rule") != m.end() && !m["upgrade_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_rule"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_rule"]));
        upgradeRule = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule>(model1);
      }
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleList() = default;
};
class FlightListingSearchResponseBodyModuleFlightList : public Darabonba::Model {
public:
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListAirlineInfo> airlineInfo{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListArrAirportInfo> arrAirportInfo{};
  shared_ptr<string> arrDate{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> carrierAirline{};
  shared_ptr<string> carrierNo{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListDepAirportInfo> depAirportInfo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<long> discount{};
  shared_ptr<string> flightNo{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleList>> flightRuleList{};
  shared_ptr<string> flightRuleListStr{};
  shared_ptr<string> flightSize{};
  shared_ptr<string> flightType{};
  shared_ptr<long> invoiceType{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<bool> isShare{};
  shared_ptr<bool> isStop{};
  shared_ptr<bool> isTransfer{};
  shared_ptr<string> mealDesc{};
  shared_ptr<long> oilPrice{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<long> productType{};
  shared_ptr<string> productTypeDesc{};
  shared_ptr<string> promotionPrice{};
  shared_ptr<string> remainedSeatCount{};
  shared_ptr<string> secretParams{};
  shared_ptr<string> segmentNumber{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<string> totalPrice{};
  shared_ptr<long> tripType{};

  FlightListingSearchResponseBodyModuleFlightList() {}

  explicit FlightListingSearchResponseBodyModuleFlightList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (carrierAirline) {
      res["carrier_airline"] = boost::any(*carrierAirline);
    }
    if (carrierNo) {
      res["carrier_no"] = boost::any(*carrierNo);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*flightRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_rule_list"] = boost::any(temp1);
    }
    if (flightRuleListStr) {
      res["flight_rule_list_str"] = boost::any(*flightRuleListStr);
    }
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (isShare) {
      res["is_share"] = boost::any(*isShare);
    }
    if (isStop) {
      res["is_stop"] = boost::any(*isStop);
    }
    if (isTransfer) {
      res["is_transfer"] = boost::any(*isTransfer);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (productType) {
      res["product_type"] = boost::any(*productType);
    }
    if (productTypeDesc) {
      res["product_type_desc"] = boost::any(*productTypeDesc);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (remainedSeatCount) {
      res["remained_seat_count"] = boost::any(*remainedSeatCount);
    }
    if (secretParams) {
      res["secret_params"] = boost::any(*secretParams);
    }
    if (segmentNumber) {
      res["segment_number"] = boost::any(*segmentNumber);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        FlightListingSearchResponseBodyModuleFlightListAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<FlightListingSearchResponseBodyModuleFlightListAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        FlightListingSearchResponseBodyModuleFlightListArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<FlightListingSearchResponseBodyModuleFlightListArrAirportInfo>(model1);
      }
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("carrier_airline") != m.end() && !m["carrier_airline"].empty()) {
      carrierAirline = make_shared<string>(boost::any_cast<string>(m["carrier_airline"]));
    }
    if (m.find("carrier_no") != m.end() && !m["carrier_no"].empty()) {
      carrierNo = make_shared<string>(boost::any_cast<string>(m["carrier_no"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        FlightListingSearchResponseBodyModuleFlightListDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<FlightListingSearchResponseBodyModuleFlightListDepAirportInfo>(model1);
      }
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<long>(boost::any_cast<long>(m["discount"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_rule_list") != m.end() && !m["flight_rule_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_rule_list"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_rule_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightRuleList = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleList>>(expect1);
      }
    }
    if (m.find("flight_rule_list_str") != m.end() && !m["flight_rule_list_str"].empty()) {
      flightRuleListStr = make_shared<string>(boost::any_cast<string>(m["flight_rule_list_str"]));
    }
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("is_share") != m.end() && !m["is_share"].empty()) {
      isShare = make_shared<bool>(boost::any_cast<bool>(m["is_share"]));
    }
    if (m.find("is_stop") != m.end() && !m["is_stop"].empty()) {
      isStop = make_shared<bool>(boost::any_cast<bool>(m["is_stop"]));
    }
    if (m.find("is_transfer") != m.end() && !m["is_transfer"].empty()) {
      isTransfer = make_shared<bool>(boost::any_cast<bool>(m["is_transfer"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("product_type") != m.end() && !m["product_type"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["product_type"]));
    }
    if (m.find("product_type_desc") != m.end() && !m["product_type_desc"].empty()) {
      productTypeDesc = make_shared<string>(boost::any_cast<string>(m["product_type_desc"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<string>(boost::any_cast<string>(m["promotion_price"]));
    }
    if (m.find("remained_seat_count") != m.end() && !m["remained_seat_count"].empty()) {
      remainedSeatCount = make_shared<string>(boost::any_cast<string>(m["remained_seat_count"]));
    }
    if (m.find("secret_params") != m.end() && !m["secret_params"].empty()) {
      secretParams = make_shared<string>(boost::any_cast<string>(m["secret_params"]));
    }
    if (m.find("segment_number") != m.end() && !m["segment_number"].empty()) {
      segmentNumber = make_shared<string>(boost::any_cast<string>(m["segment_number"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<string>(boost::any_cast<string>(m["total_price"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightList() = default;
};
class FlightListingSearchResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightList>> flightList{};

  FlightListingSearchResponseBodyModule() {}

  explicit FlightListingSearchResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightList) {
      vector<boost::any> temp1;
      for(auto item1:*flightList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_list") != m.end() && !m["flight_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_list"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightList = make_shared<vector<FlightListingSearchResponseBodyModuleFlightList>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchResponseBodyModule() = default;
};
class FlightListingSearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightListingSearchResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightListingSearchResponseBody() {}

  explicit FlightListingSearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightListingSearchResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightListingSearchResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightListingSearchResponseBody() = default;
};
class FlightListingSearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightListingSearchResponseBody> body{};

  FlightListingSearchResponse() {}

  explicit FlightListingSearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightListingSearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightListingSearchResponseBody>(model1);
      }
    }
  }


  virtual ~FlightListingSearchResponse() = default;
};
class FlightOrderDetailInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightOrderDetailInfoHeaders() {}

  explicit FlightOrderDetailInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightOrderDetailInfoHeaders() = default;
};
class FlightOrderDetailInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};

  FlightOrderDetailInfoRequest() {}

  explicit FlightOrderDetailInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
  }


  virtual ~FlightOrderDetailInfoRequest() = default;
};
class FlightOrderDetailInfoResponseBodyModuleFlightInfoList : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};
  shared_ptr<string> arrAirport{};
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrAirportCodeName{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrTerminal{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> baggage{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> carrier{};
  shared_ptr<string> depAirport{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depAirportCodeName{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depTerminal{};
  shared_ptr<string> depTime{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> lastCabin{};
  shared_ptr<string> lastFlightNo{};
  shared_ptr<string> meal{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> segmentType{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<string> tuigaiqianInfo{};

  FlightOrderDetailInfoResponseBodyModuleFlightInfoList() {}

  explicit FlightOrderDetailInfoResponseBodyModuleFlightInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    if (arrAirport) {
      res["arr_airport"] = boost::any(*arrAirport);
    }
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrAirportCodeName) {
      res["arr_airport_code_name"] = boost::any(*arrAirportCodeName);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrTerminal) {
      res["arr_terminal"] = boost::any(*arrTerminal);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (baggage) {
      res["baggage"] = boost::any(*baggage);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (carrier) {
      res["carrier"] = boost::any(*carrier);
    }
    if (depAirport) {
      res["dep_airport"] = boost::any(*depAirport);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depAirportCodeName) {
      res["dep_airport_code_name"] = boost::any(*depAirportCodeName);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depTerminal) {
      res["dep_terminal"] = boost::any(*depTerminal);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (lastCabin) {
      res["last_cabin"] = boost::any(*lastCabin);
    }
    if (lastFlightNo) {
      res["last_flight_no"] = boost::any(*lastFlightNo);
    }
    if (meal) {
      res["meal"] = boost::any(*meal);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (segmentType) {
      res["segment_type"] = boost::any(*segmentType);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
    if (m.find("arr_airport") != m.end() && !m["arr_airport"].empty()) {
      arrAirport = make_shared<string>(boost::any_cast<string>(m["arr_airport"]));
    }
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_airport_code_name") != m.end() && !m["arr_airport_code_name"].empty()) {
      arrAirportCodeName = make_shared<string>(boost::any_cast<string>(m["arr_airport_code_name"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_terminal") != m.end() && !m["arr_terminal"].empty()) {
      arrTerminal = make_shared<string>(boost::any_cast<string>(m["arr_terminal"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("baggage") != m.end() && !m["baggage"].empty()) {
      baggage = make_shared<string>(boost::any_cast<string>(m["baggage"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("carrier") != m.end() && !m["carrier"].empty()) {
      carrier = make_shared<string>(boost::any_cast<string>(m["carrier"]));
    }
    if (m.find("dep_airport") != m.end() && !m["dep_airport"].empty()) {
      depAirport = make_shared<string>(boost::any_cast<string>(m["dep_airport"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_airport_code_name") != m.end() && !m["dep_airport_code_name"].empty()) {
      depAirportCodeName = make_shared<string>(boost::any_cast<string>(m["dep_airport_code_name"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_terminal") != m.end() && !m["dep_terminal"].empty()) {
      depTerminal = make_shared<string>(boost::any_cast<string>(m["dep_terminal"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("last_cabin") != m.end() && !m["last_cabin"].empty()) {
      lastCabin = make_shared<string>(boost::any_cast<string>(m["last_cabin"]));
    }
    if (m.find("last_flight_no") != m.end() && !m["last_flight_no"].empty()) {
      lastFlightNo = make_shared<string>(boost::any_cast<string>(m["last_flight_no"]));
    }
    if (m.find("meal") != m.end() && !m["meal"].empty()) {
      meal = make_shared<string>(boost::any_cast<string>(m["meal"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("segment_type") != m.end() && !m["segment_type"].empty()) {
      segmentType = make_shared<long>(boost::any_cast<long>(m["segment_type"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
  }


  virtual ~FlightOrderDetailInfoResponseBodyModuleFlightInfoList() = default;
};
class FlightOrderDetailInfoResponseBodyModuleTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> openTicketStatus{};
  shared_ptr<string> pnrCode{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> ticketStatus{};

  FlightOrderDetailInfoResponseBodyModuleTicketInfoList() {}

  explicit FlightOrderDetailInfoResponseBodyModuleTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openTicketStatus) {
      res["open_ticket_status"] = boost::any(*openTicketStatus);
    }
    if (pnrCode) {
      res["pnr_code"] = boost::any(*pnrCode);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (ticketStatus) {
      res["ticket_status"] = boost::any(*ticketStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("open_ticket_status") != m.end() && !m["open_ticket_status"].empty()) {
      openTicketStatus = make_shared<string>(boost::any_cast<string>(m["open_ticket_status"]));
    }
    if (m.find("pnr_code") != m.end() && !m["pnr_code"].empty()) {
      pnrCode = make_shared<string>(boost::any_cast<string>(m["pnr_code"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("ticket_status") != m.end() && !m["ticket_status"].empty()) {
      ticketStatus = make_shared<string>(boost::any_cast<string>(m["ticket_status"]));
    }
  }


  virtual ~FlightOrderDetailInfoResponseBodyModuleTicketInfoList() = default;
};
class FlightOrderDetailInfoResponseBodyModuleTravelerInfoList : public Darabonba::Model {
public:
  shared_ptr<string> birthDate{};
  shared_ptr<string> certNo{};
  shared_ptr<string> certType{};
  shared_ptr<long> openTicketStatus{};
  shared_ptr<string> passengerName{};
  shared_ptr<string> passengerType{};
  shared_ptr<string> phone{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> userId{};

  FlightOrderDetailInfoResponseBodyModuleTravelerInfoList() {}

  explicit FlightOrderDetailInfoResponseBodyModuleTravelerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthDate) {
      res["birth_date"] = boost::any(*birthDate);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (openTicketStatus) {
      res["open_ticket_status"] = boost::any(*openTicketStatus);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birth_date") != m.end() && !m["birth_date"].empty()) {
      birthDate = make_shared<string>(boost::any_cast<string>(m["birth_date"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["cert_type"]));
    }
    if (m.find("open_ticket_status") != m.end() && !m["open_ticket_status"].empty()) {
      openTicketStatus = make_shared<long>(boost::any_cast<long>(m["open_ticket_status"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<string>(boost::any_cast<string>(m["passenger_type"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightOrderDetailInfoResponseBodyModuleTravelerInfoList() = default;
};
class FlightOrderDetailInfoResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> bookUserId{};
  shared_ptr<long> btripOrderId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhone{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> extra{};
  shared_ptr<vector<FlightOrderDetailInfoResponseBodyModuleFlightInfoList>> flightInfoList{};
  shared_ptr<string> lastPayTime{};
  shared_ptr<long> payStatus{};
  shared_ptr<string> payTime{};
  shared_ptr<long> promotionPrice{};
  shared_ptr<long> settleAmount{};
  shared_ptr<long> settleType{};
  shared_ptr<long> status{};
  shared_ptr<vector<FlightOrderDetailInfoResponseBodyModuleTicketInfoList>> ticketInfoList{};
  shared_ptr<long> totalBuildPrice{};
  shared_ptr<long> totalOilPrice{};
  shared_ptr<long> totalOrderPrice{};
  shared_ptr<vector<FlightOrderDetailInfoResponseBodyModuleTravelerInfoList>> travelerInfoList{};

  FlightOrderDetailInfoResponseBodyModule() {}

  explicit FlightOrderDetailInfoResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (bookUserId) {
      res["book_user_id"] = boost::any(*bookUserId);
    }
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (contactPhone) {
      res["contact_phone"] = boost::any(*contactPhone);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (flightInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_info_list"] = boost::any(temp1);
    }
    if (lastPayTime) {
      res["last_pay_time"] = boost::any(*lastPayTime);
    }
    if (payStatus) {
      res["pay_status"] = boost::any(*payStatus);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (settleAmount) {
      res["settle_amount"] = boost::any(*settleAmount);
    }
    if (settleType) {
      res["settle_type"] = boost::any(*settleType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (ticketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*ticketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ticket_info_list"] = boost::any(temp1);
    }
    if (totalBuildPrice) {
      res["total_build_price"] = boost::any(*totalBuildPrice);
    }
    if (totalOilPrice) {
      res["total_oil_price"] = boost::any(*totalOilPrice);
    }
    if (totalOrderPrice) {
      res["total_order_price"] = boost::any(*totalOrderPrice);
    }
    if (travelerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("book_user_id") != m.end() && !m["book_user_id"].empty()) {
      bookUserId = make_shared<string>(boost::any_cast<string>(m["book_user_id"]));
    }
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_order_id"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("contact_phone") != m.end() && !m["contact_phone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["contact_phone"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("flight_info_list") != m.end() && !m["flight_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_info_list"].type()) {
        vector<FlightOrderDetailInfoResponseBodyModuleFlightInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderDetailInfoResponseBodyModuleFlightInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightInfoList = make_shared<vector<FlightOrderDetailInfoResponseBodyModuleFlightInfoList>>(expect1);
      }
    }
    if (m.find("last_pay_time") != m.end() && !m["last_pay_time"].empty()) {
      lastPayTime = make_shared<string>(boost::any_cast<string>(m["last_pay_time"]));
    }
    if (m.find("pay_status") != m.end() && !m["pay_status"].empty()) {
      payStatus = make_shared<long>(boost::any_cast<long>(m["pay_status"]));
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<string>(boost::any_cast<string>(m["pay_time"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<long>(boost::any_cast<long>(m["promotion_price"]));
    }
    if (m.find("settle_amount") != m.end() && !m["settle_amount"].empty()) {
      settleAmount = make_shared<long>(boost::any_cast<long>(m["settle_amount"]));
    }
    if (m.find("settle_type") != m.end() && !m["settle_type"].empty()) {
      settleType = make_shared<long>(boost::any_cast<long>(m["settle_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("ticket_info_list") != m.end() && !m["ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["ticket_info_list"].type()) {
        vector<FlightOrderDetailInfoResponseBodyModuleTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderDetailInfoResponseBodyModuleTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ticketInfoList = make_shared<vector<FlightOrderDetailInfoResponseBodyModuleTicketInfoList>>(expect1);
      }
    }
    if (m.find("total_build_price") != m.end() && !m["total_build_price"].empty()) {
      totalBuildPrice = make_shared<long>(boost::any_cast<long>(m["total_build_price"]));
    }
    if (m.find("total_oil_price") != m.end() && !m["total_oil_price"].empty()) {
      totalOilPrice = make_shared<long>(boost::any_cast<long>(m["total_oil_price"]));
    }
    if (m.find("total_order_price") != m.end() && !m["total_order_price"].empty()) {
      totalOrderPrice = make_shared<long>(boost::any_cast<long>(m["total_order_price"]));
    }
    if (m.find("traveler_info_list") != m.end() && !m["traveler_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_info_list"].type()) {
        vector<FlightOrderDetailInfoResponseBodyModuleTravelerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderDetailInfoResponseBodyModuleTravelerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerInfoList = make_shared<vector<FlightOrderDetailInfoResponseBodyModuleTravelerInfoList>>(expect1);
      }
    }
  }


  virtual ~FlightOrderDetailInfoResponseBodyModule() = default;
};
class FlightOrderDetailInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightOrderDetailInfoResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightOrderDetailInfoResponseBody() {}

  explicit FlightOrderDetailInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightOrderDetailInfoResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightOrderDetailInfoResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightOrderDetailInfoResponseBody() = default;
};
class FlightOrderDetailInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightOrderDetailInfoResponseBody> body{};

  FlightOrderDetailInfoResponse() {}

  explicit FlightOrderDetailInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightOrderDetailInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightOrderDetailInfoResponseBody>(model1);
      }
    }
  }


  virtual ~FlightOrderDetailInfoResponse() = default;
};
class FlightOrderListQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  FlightOrderListQueryHeaders() {}

  explicit FlightOrderListQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~FlightOrderListQueryHeaders() = default;
};
class FlightOrderListQueryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allApply{};
  shared_ptr<long> applyId{};
  shared_ptr<string> departId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> updateEndTime{};
  shared_ptr<string> updateStartTime{};
  shared_ptr<string> userId{};

  FlightOrderListQueryRequest() {}

  explicit FlightOrderListQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allApply) {
      res["all_apply"] = boost::any(*allApply);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (updateEndTime) {
      res["update_end_time"] = boost::any(*updateEndTime);
    }
    if (updateStartTime) {
      res["update_start_time"] = boost::any(*updateStartTime);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_apply") != m.end() && !m["all_apply"].empty()) {
      allApply = make_shared<bool>(boost::any_cast<bool>(m["all_apply"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("update_end_time") != m.end() && !m["update_end_time"].empty()) {
      updateEndTime = make_shared<string>(boost::any_cast<string>(m["update_end_time"]));
    }
    if (m.find("update_start_time") != m.end() && !m["update_start_time"].empty()) {
      updateStartTime = make_shared<string>(boost::any_cast<string>(m["update_start_time"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightOrderListQueryRequest() = default;
};
class FlightOrderListQueryResponseBodyModuleCostCenter : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> number{};

  FlightOrderListQueryResponseBodyModuleCostCenter() {}

  explicit FlightOrderListQueryResponseBodyModuleCostCenter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (number) {
      res["number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("number") != m.end() && !m["number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["number"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyModuleCostCenter() = default;
};
class FlightOrderListQueryResponseBodyModuleInsureInfoList : public Darabonba::Model {
public:
  shared_ptr<string> insureNo{};
  shared_ptr<string> name{};
  shared_ptr<long> status{};

  FlightOrderListQueryResponseBodyModuleInsureInfoList() {}

  explicit FlightOrderListQueryResponseBodyModuleInsureInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (insureNo) {
      res["insure_no"] = boost::any(*insureNo);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("insure_no") != m.end() && !m["insure_no"].empty()) {
      insureNo = make_shared<string>(boost::any_cast<string>(m["insure_no"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyModuleInsureInfoList() = default;
};
class FlightOrderListQueryResponseBodyModuleInvoice : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  FlightOrderListQueryResponseBodyModuleInvoice() {}

  explicit FlightOrderListQueryResponseBodyModuleInvoice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyModuleInvoice() = default;
};
class FlightOrderListQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<long> categoryType{};
  shared_ptr<string> changeFlightNo{};
  shared_ptr<string> discount{};
  shared_ptr<string> endTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> originalTicketNo{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> startTime{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  FlightOrderListQueryResponseBodyModulePriceInfoList() {}

  explicit FlightOrderListQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (categoryType) {
      res["category_type"] = boost::any(*categoryType);
    }
    if (changeFlightNo) {
      res["change_flight_no"] = boost::any(*changeFlightNo);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (originalTicketNo) {
      res["original_ticket_no"] = boost::any(*originalTicketNo);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("category_type") != m.end() && !m["category_type"].empty()) {
      categoryType = make_shared<long>(boost::any_cast<long>(m["category_type"]));
    }
    if (m.find("change_flight_no") != m.end() && !m["change_flight_no"].empty()) {
      changeFlightNo = make_shared<string>(boost::any_cast<string>(m["change_flight_no"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("original_ticket_no") != m.end() && !m["original_ticket_no"].empty()) {
      originalTicketNo = make_shared<string>(boost::any_cast<string>(m["original_ticket_no"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyModulePriceInfoList() = default;
};
class FlightOrderListQueryResponseBodyModuleUserAffiliateList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  FlightOrderListQueryResponseBodyModuleUserAffiliateList() {}

  explicit FlightOrderListQueryResponseBodyModuleUserAffiliateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyModuleUserAffiliateList() = default;
};
class FlightOrderListQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> arrAirport{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> contactName{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<FlightOrderListQueryResponseBodyModuleCostCenter> costCenter{};
  shared_ptr<string> depAirport{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depDate{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> discount{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<vector<FlightOrderListQueryResponseBodyModuleInsureInfoList>> insureInfoList{};
  shared_ptr<FlightOrderListQueryResponseBodyModuleInvoice> invoice{};
  shared_ptr<long> passengerCount{};
  shared_ptr<string> passengerName{};
  shared_ptr<vector<FlightOrderListQueryResponseBodyModulePriceInfoList>> priceInfoList{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> retDate{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdPartProjectId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> tripType{};
  shared_ptr<vector<FlightOrderListQueryResponseBodyModuleUserAffiliateList>> userAffiliateList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  FlightOrderListQueryResponseBodyModule() {}

  explicit FlightOrderListQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (arrAirport) {
      res["arr_airport"] = boost::any(*arrAirport);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (costCenter) {
      res["cost_center"] = costCenter ? boost::any(costCenter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depAirport) {
      res["dep_airport"] = boost::any(*depAirport);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (insureInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*insureInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["insure_info_list"] = boost::any(temp1);
    }
    if (invoice) {
      res["invoice"] = invoice ? boost::any(invoice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passengerCount) {
      res["passenger_count"] = boost::any(*passengerCount);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (retDate) {
      res["ret_date"] = boost::any(*retDate);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdPartProjectId) {
      res["third_part_project_id"] = boost::any(*thirdPartProjectId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    if (userAffiliateList) {
      vector<boost::any> temp1;
      for(auto item1:*userAffiliateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["user_affiliate_list"] = boost::any(temp1);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("arr_airport") != m.end() && !m["arr_airport"].empty()) {
      arrAirport = make_shared<string>(boost::any_cast<string>(m["arr_airport"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      if (typeid(map<string, boost::any>) == m["cost_center"].type()) {
        FlightOrderListQueryResponseBodyModuleCostCenter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cost_center"]));
        costCenter = make_shared<FlightOrderListQueryResponseBodyModuleCostCenter>(model1);
      }
    }
    if (m.find("dep_airport") != m.end() && !m["dep_airport"].empty()) {
      depAirport = make_shared<string>(boost::any_cast<string>(m["dep_airport"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("insure_info_list") != m.end() && !m["insure_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["insure_info_list"].type()) {
        vector<FlightOrderListQueryResponseBodyModuleInsureInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["insure_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderListQueryResponseBodyModuleInsureInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        insureInfoList = make_shared<vector<FlightOrderListQueryResponseBodyModuleInsureInfoList>>(expect1);
      }
    }
    if (m.find("invoice") != m.end() && !m["invoice"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice"].type()) {
        FlightOrderListQueryResponseBodyModuleInvoice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice"]));
        invoice = make_shared<FlightOrderListQueryResponseBodyModuleInvoice>(model1);
      }
    }
    if (m.find("passenger_count") != m.end() && !m["passenger_count"].empty()) {
      passengerCount = make_shared<long>(boost::any_cast<long>(m["passenger_count"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<FlightOrderListQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderListQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<FlightOrderListQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("ret_date") != m.end() && !m["ret_date"].empty()) {
      retDate = make_shared<string>(boost::any_cast<string>(m["ret_date"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("third_part_project_id") != m.end() && !m["third_part_project_id"].empty()) {
      thirdPartProjectId = make_shared<string>(boost::any_cast<string>(m["third_part_project_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
    if (m.find("user_affiliate_list") != m.end() && !m["user_affiliate_list"].empty()) {
      if (typeid(vector<boost::any>) == m["user_affiliate_list"].type()) {
        vector<FlightOrderListQueryResponseBodyModuleUserAffiliateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["user_affiliate_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderListQueryResponseBodyModuleUserAffiliateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userAffiliateList = make_shared<vector<FlightOrderListQueryResponseBodyModuleUserAffiliateList>>(expect1);
      }
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyModule() = default;
};
class FlightOrderListQueryResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalNumber{};

  FlightOrderListQueryResponseBodyPageInfo() {}

  explicit FlightOrderListQueryResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalNumber) {
      res["total_number"] = boost::any(*totalNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_number") != m.end() && !m["total_number"].empty()) {
      totalNumber = make_shared<long>(boost::any_cast<long>(m["total_number"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyPageInfo() = default;
};
class FlightOrderListQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<FlightOrderListQueryResponseBodyModule>> module{};
  shared_ptr<FlightOrderListQueryResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightOrderListQueryResponseBody() {}

  explicit FlightOrderListQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<FlightOrderListQueryResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderListQueryResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<FlightOrderListQueryResponseBodyModule>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        FlightOrderListQueryResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<FlightOrderListQueryResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBody() = default;
};
class FlightOrderListQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightOrderListQueryResponseBody> body{};

  FlightOrderListQueryResponse() {}

  explicit FlightOrderListQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightOrderListQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightOrderListQueryResponseBody>(model1);
      }
    }
  }


  virtual ~FlightOrderListQueryResponse() = default;
};
class FlightOrderQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  FlightOrderQueryHeaders() {}

  explicit FlightOrderQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~FlightOrderQueryHeaders() = default;
};
class FlightOrderQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<string> userId{};

  FlightOrderQueryRequest() {}

  explicit FlightOrderQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightOrderQueryRequest() = default;
};
class FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> arrTime{};
  shared_ptr<string> changeCabin{};
  shared_ptr<string> changeCabinLevel{};
  shared_ptr<double> changeFee{};
  shared_ptr<string> changeFlightNo{};
  shared_ptr<long> changeOrderId{};
  shared_ptr<string> changeReason{};
  shared_ptr<long> changeType{};
  shared_ptr<string> depTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> originTicketNo{};
  shared_ptr<string> ticketNo{};
  shared_ptr<double> upgradeFee{};

  FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList() {}

  explicit FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (changeCabin) {
      res["change_cabin"] = boost::any(*changeCabin);
    }
    if (changeCabinLevel) {
      res["change_cabin_level"] = boost::any(*changeCabinLevel);
    }
    if (changeFee) {
      res["change_fee"] = boost::any(*changeFee);
    }
    if (changeFlightNo) {
      res["change_flight_no"] = boost::any(*changeFlightNo);
    }
    if (changeOrderId) {
      res["change_order_id"] = boost::any(*changeOrderId);
    }
    if (changeReason) {
      res["change_reason"] = boost::any(*changeReason);
    }
    if (changeType) {
      res["change_type"] = boost::any(*changeType);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (originTicketNo) {
      res["origin_ticket_no"] = boost::any(*originTicketNo);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (upgradeFee) {
      res["upgrade_fee"] = boost::any(*upgradeFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("change_cabin") != m.end() && !m["change_cabin"].empty()) {
      changeCabin = make_shared<string>(boost::any_cast<string>(m["change_cabin"]));
    }
    if (m.find("change_cabin_level") != m.end() && !m["change_cabin_level"].empty()) {
      changeCabinLevel = make_shared<string>(boost::any_cast<string>(m["change_cabin_level"]));
    }
    if (m.find("change_fee") != m.end() && !m["change_fee"].empty()) {
      changeFee = make_shared<double>(boost::any_cast<double>(m["change_fee"]));
    }
    if (m.find("change_flight_no") != m.end() && !m["change_flight_no"].empty()) {
      changeFlightNo = make_shared<string>(boost::any_cast<string>(m["change_flight_no"]));
    }
    if (m.find("change_order_id") != m.end() && !m["change_order_id"].empty()) {
      changeOrderId = make_shared<long>(boost::any_cast<long>(m["change_order_id"]));
    }
    if (m.find("change_reason") != m.end() && !m["change_reason"].empty()) {
      changeReason = make_shared<string>(boost::any_cast<string>(m["change_reason"]));
    }
    if (m.find("change_type") != m.end() && !m["change_type"].empty()) {
      changeType = make_shared<long>(boost::any_cast<long>(m["change_type"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("origin_ticket_no") != m.end() && !m["origin_ticket_no"].empty()) {
      originTicketNo = make_shared<string>(boost::any_cast<string>(m["origin_ticket_no"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("upgrade_fee") != m.end() && !m["upgrade_fee"].empty()) {
      upgradeFee = make_shared<double>(boost::any_cast<double>(m["upgrade_fee"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList() = default;
};
class FlightOrderQueryResponseBodyModuleFlightInfoList : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrAirportName{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinLevel{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depAirportName{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depTime{};
  shared_ptr<long> flightMile{};
  shared_ptr<string> flightNo{};

  FlightOrderQueryResponseBodyModuleFlightInfoList() {}

  explicit FlightOrderQueryResponseBodyModuleFlightInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrAirportName) {
      res["arr_airport_name"] = boost::any(*arrAirportName);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinLevel) {
      res["cabin_level"] = boost::any(*cabinLevel);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depAirportName) {
      res["dep_airport_name"] = boost::any(*depAirportName);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (flightMile) {
      res["flight_mile"] = boost::any(*flightMile);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_airport_name") != m.end() && !m["arr_airport_name"].empty()) {
      arrAirportName = make_shared<string>(boost::any_cast<string>(m["arr_airport_name"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_level") != m.end() && !m["cabin_level"].empty()) {
      cabinLevel = make_shared<string>(boost::any_cast<string>(m["cabin_level"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_airport_name") != m.end() && !m["dep_airport_name"].empty()) {
      depAirportName = make_shared<string>(boost::any_cast<string>(m["dep_airport_name"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("flight_mile") != m.end() && !m["flight_mile"].empty()) {
      flightMile = make_shared<long>(boost::any_cast<long>(m["flight_mile"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleFlightInfoList() = default;
};
class FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<long> refundOrderId{};
  shared_ptr<string> refundReason{};
  shared_ptr<double> refundTicketFee{};
  shared_ptr<long> refundType{};
  shared_ptr<string> ticketNo{};

  FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList() {}

  explicit FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (refundOrderId) {
      res["refund_order_id"] = boost::any(*refundOrderId);
    }
    if (refundReason) {
      res["refund_reason"] = boost::any(*refundReason);
    }
    if (refundTicketFee) {
      res["refund_ticket_fee"] = boost::any(*refundTicketFee);
    }
    if (refundType) {
      res["refund_type"] = boost::any(*refundType);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("refund_order_id") != m.end() && !m["refund_order_id"].empty()) {
      refundOrderId = make_shared<long>(boost::any_cast<long>(m["refund_order_id"]));
    }
    if (m.find("refund_reason") != m.end() && !m["refund_reason"].empty()) {
      refundReason = make_shared<string>(boost::any_cast<string>(m["refund_reason"]));
    }
    if (m.find("refund_ticket_fee") != m.end() && !m["refund_ticket_fee"].empty()) {
      refundTicketFee = make_shared<double>(boost::any_cast<double>(m["refund_ticket_fee"]));
    }
    if (m.find("refund_type") != m.end() && !m["refund_type"].empty()) {
      refundType = make_shared<long>(boost::any_cast<long>(m["refund_type"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList() = default;
};
class FlightOrderQueryResponseBodyModuleFlightTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<double> buildPrice{};
  shared_ptr<bool> changed{};
  shared_ptr<long> discount{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<double> oilPrice{};
  shared_ptr<long> payType{};
  shared_ptr<double> settlePrice{};
  shared_ptr<string> ticketNo{};
  shared_ptr<double> ticketPrice{};
  shared_ptr<string> ticketStatus{};
  shared_ptr<long> ticketStatusCode{};
  shared_ptr<string> userId{};

  FlightOrderQueryResponseBodyModuleFlightTicketInfoList() {}

  explicit FlightOrderQueryResponseBodyModuleFlightTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (changed) {
      res["changed"] = boost::any(*changed);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (settlePrice) {
      res["settle_price"] = boost::any(*settlePrice);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (ticketStatus) {
      res["ticket_status"] = boost::any(*ticketStatus);
    }
    if (ticketStatusCode) {
      res["ticket_status_code"] = boost::any(*ticketStatusCode);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<double>(boost::any_cast<double>(m["build_price"]));
    }
    if (m.find("changed") != m.end() && !m["changed"].empty()) {
      changed = make_shared<bool>(boost::any_cast<bool>(m["changed"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<long>(boost::any_cast<long>(m["discount"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<double>(boost::any_cast<double>(m["oil_price"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("settle_price") != m.end() && !m["settle_price"].empty()) {
      settlePrice = make_shared<double>(boost::any_cast<double>(m["settle_price"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<double>(boost::any_cast<double>(m["ticket_price"]));
    }
    if (m.find("ticket_status") != m.end() && !m["ticket_status"].empty()) {
      ticketStatus = make_shared<string>(boost::any_cast<string>(m["ticket_status"]));
    }
    if (m.find("ticket_status_code") != m.end() && !m["ticket_status_code"].empty()) {
      ticketStatusCode = make_shared<long>(boost::any_cast<long>(m["ticket_status_code"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleFlightTicketInfoList() = default;
};
class FlightOrderQueryResponseBodyModuleInsuranceInfoList : public Darabonba::Model {
public:
  shared_ptr<double> amount{};
  shared_ptr<string> insuranceNo{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  FlightOrderQueryResponseBodyModuleInsuranceInfoList() {}

  explicit FlightOrderQueryResponseBodyModuleInsuranceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (insuranceNo) {
      res["insurance_no"] = boost::any(*insuranceNo);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<double>(boost::any_cast<double>(m["amount"]));
    }
    if (m.find("insurance_no") != m.end() && !m["insurance_no"].empty()) {
      insuranceNo = make_shared<string>(boost::any_cast<string>(m["insurance_no"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleInsuranceInfoList() = default;
};
class FlightOrderQueryResponseBodyModuleInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  FlightOrderQueryResponseBodyModuleInvoiceInfo() {}

  explicit FlightOrderQueryResponseBodyModuleInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleInvoiceInfo() = default;
};
class FlightOrderQueryResponseBodyModuleOrderBaseInfo : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> contactName{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> orderId{};
  shared_ptr<long> orderStatus{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartCorpId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> tripType{};
  shared_ptr<string> userId{};

  FlightOrderQueryResponseBodyModuleOrderBaseInfo() {}

  explicit FlightOrderQueryResponseBodyModuleOrderBaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartCorpId) {
      res["thirdpart_corp_id"] = boost::any(*thirdpartCorpId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_corp_id") != m.end() && !m["thirdpart_corp_id"].empty()) {
      thirdpartCorpId = make_shared<string>(boost::any_cast<string>(m["thirdpart_corp_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleOrderBaseInfo() = default;
};
class FlightOrderQueryResponseBodyModulePassengerInfoList : public Darabonba::Model {
public:
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartProjectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> userType{};

  FlightOrderQueryResponseBodyModulePassengerInfoList() {}

  explicit FlightOrderQueryResponseBodyModulePassengerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartProjectId) {
      res["thirdpart_project_id"] = boost::any(*thirdpartProjectId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_project_id") != m.end() && !m["thirdpart_project_id"].empty()) {
      thirdpartProjectId = make_shared<string>(boost::any_cast<string>(m["thirdpart_project_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModulePassengerInfoList() = default;
};
class FlightOrderQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  FlightOrderQueryResponseBodyModulePriceInfoList() {}

  explicit FlightOrderQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModulePriceInfoList() = default;
};
class FlightOrderQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList>> flightChangeTicketInfoList{};
  shared_ptr<vector<FlightOrderQueryResponseBodyModuleFlightInfoList>> flightInfoList{};
  shared_ptr<vector<FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList>> flightRefundTicketInfoList{};
  shared_ptr<vector<FlightOrderQueryResponseBodyModuleFlightTicketInfoList>> flightTicketInfoList{};
  shared_ptr<vector<FlightOrderQueryResponseBodyModuleInsuranceInfoList>> insuranceInfoList{};
  shared_ptr<FlightOrderQueryResponseBodyModuleInvoiceInfo> invoiceInfo{};
  shared_ptr<FlightOrderQueryResponseBodyModuleOrderBaseInfo> orderBaseInfo{};
  shared_ptr<vector<FlightOrderQueryResponseBodyModulePassengerInfoList>> passengerInfoList{};
  shared_ptr<vector<FlightOrderQueryResponseBodyModulePriceInfoList>> priceInfoList{};

  FlightOrderQueryResponseBodyModule() {}

  explicit FlightOrderQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightChangeTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightChangeTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_change_ticket_info_list"] = boost::any(temp1);
    }
    if (flightInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_info_list"] = boost::any(temp1);
    }
    if (flightRefundTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightRefundTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_refund_ticket_info_list"] = boost::any(temp1);
    }
    if (flightTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_ticket_info_list"] = boost::any(temp1);
    }
    if (insuranceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*insuranceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["insurance_info_list"] = boost::any(temp1);
    }
    if (invoiceInfo) {
      res["invoice_info"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderBaseInfo) {
      res["order_base_info"] = orderBaseInfo ? boost::any(orderBaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passengerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_info_list"] = boost::any(temp1);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_change_ticket_info_list") != m.end() && !m["flight_change_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_change_ticket_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_change_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightChangeTicketInfoList = make_shared<vector<FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList>>(expect1);
      }
    }
    if (m.find("flight_info_list") != m.end() && !m["flight_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModuleFlightInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModuleFlightInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightInfoList = make_shared<vector<FlightOrderQueryResponseBodyModuleFlightInfoList>>(expect1);
      }
    }
    if (m.find("flight_refund_ticket_info_list") != m.end() && !m["flight_refund_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_refund_ticket_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_refund_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightRefundTicketInfoList = make_shared<vector<FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList>>(expect1);
      }
    }
    if (m.find("flight_ticket_info_list") != m.end() && !m["flight_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_ticket_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModuleFlightTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModuleFlightTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightTicketInfoList = make_shared<vector<FlightOrderQueryResponseBodyModuleFlightTicketInfoList>>(expect1);
      }
    }
    if (m.find("insurance_info_list") != m.end() && !m["insurance_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["insurance_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModuleInsuranceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["insurance_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModuleInsuranceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        insuranceInfoList = make_shared<vector<FlightOrderQueryResponseBodyModuleInsuranceInfoList>>(expect1);
      }
    }
    if (m.find("invoice_info") != m.end() && !m["invoice_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice_info"].type()) {
        FlightOrderQueryResponseBodyModuleInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice_info"]));
        invoiceInfo = make_shared<FlightOrderQueryResponseBodyModuleInvoiceInfo>(model1);
      }
    }
    if (m.find("order_base_info") != m.end() && !m["order_base_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["order_base_info"].type()) {
        FlightOrderQueryResponseBodyModuleOrderBaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["order_base_info"]));
        orderBaseInfo = make_shared<FlightOrderQueryResponseBodyModuleOrderBaseInfo>(model1);
      }
    }
    if (m.find("passenger_info_list") != m.end() && !m["passenger_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModulePassengerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModulePassengerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerInfoList = make_shared<vector<FlightOrderQueryResponseBodyModulePassengerInfoList>>(expect1);
      }
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<FlightOrderQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
  }


  virtual ~FlightOrderQueryResponseBodyModule() = default;
};
class FlightOrderQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightOrderQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightOrderQueryResponseBody() {}

  explicit FlightOrderQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightOrderQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightOrderQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightOrderQueryResponseBody() = default;
};
class FlightOrderQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightOrderQueryResponseBody> body{};

  FlightOrderQueryResponse() {}

  explicit FlightOrderQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightOrderQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightOrderQueryResponseBody>(model1);
      }
    }
  }


  virtual ~FlightOrderQueryResponse() = default;
};
class FlightOtaSearchHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightOtaSearchHeaders() {}

  explicit FlightOtaSearchHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightOtaSearchHeaders() = default;
};
class FlightOtaSearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> carrierFlightNo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<string> flightNo{};

  FlightOtaSearchRequest() {}

  explicit FlightOtaSearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (carrierFlightNo) {
      res["carrier_flight_no"] = boost::any(*carrierFlightNo);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("carrier_flight_no") != m.end() && !m["carrier_flight_no"].empty()) {
      carrierFlightNo = make_shared<string>(boost::any_cast<string>(m["carrier_flight_no"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
  }


  virtual ~FlightOtaSearchRequest() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};

  FlightOtaSearchResponseBodyModuleFlightListAirlineInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListAirlineInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["image_d_o"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("image_d_o") != m.end() && !m["image_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["image_d_o"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["image_d_o"]));
        imageDO = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<boost::any>> extraContentVisualizes{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (extraContentVisualizes) {
      res["extra_content_visualizes"] = boost::any(*extraContentVisualizes);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("extra_content_visualizes") != m.end() && !m["extra_content_visualizes"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["extra_content_visualizes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_content_visualizes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      extraContentVisualizes = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList : public Darabonba::Model {
public:
  shared_ptr<string> baggageInfo{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem> baggageItem{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule> changeRule{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem> changeRuleItem{};
  shared_ptr<string> extra{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule> refundRule{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem> refundRuleItem{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule> signRule{};
  shared_ptr<string> tuigaiqianInfo{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule> upgradeRule{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageInfo) {
      res["baggage_info"] = boost::any(*baggageInfo);
    }
    if (baggageItem) {
      res["baggage_item"] = baggageItem ? boost::any(baggageItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRule) {
      res["change_rule"] = changeRule ? boost::any(changeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRuleItem) {
      res["change_rule_item"] = changeRuleItem ? boost::any(changeRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (refundRule) {
      res["refund_rule"] = refundRule ? boost::any(refundRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundRuleItem) {
      res["refund_rule_item"] = refundRuleItem ? boost::any(refundRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signRule) {
      res["sign_rule"] = signRule ? boost::any(signRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    if (upgradeRule) {
      res["upgrade_rule"] = upgradeRule ? boost::any(upgradeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_info") != m.end() && !m["baggage_info"].empty()) {
      baggageInfo = make_shared<string>(boost::any_cast<string>(m["baggage_info"]));
    }
    if (m.find("baggage_item") != m.end() && !m["baggage_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["baggage_item"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["baggage_item"]));
        baggageItem = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem>(model1);
      }
    }
    if (m.find("change_rule") != m.end() && !m["change_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule"]));
        changeRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule>(model1);
      }
    }
    if (m.find("change_rule_item") != m.end() && !m["change_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule_item"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule_item"]));
        changeRuleItem = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem>(model1);
      }
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("refund_rule") != m.end() && !m["refund_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule"]));
        refundRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule>(model1);
      }
    }
    if (m.find("refund_rule_item") != m.end() && !m["refund_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule_item"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule_item"]));
        refundRuleItem = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem>(model1);
      }
    }
    if (m.find("sign_rule") != m.end() && !m["sign_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["sign_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sign_rule"]));
        signRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule>(model1);
      }
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
    if (m.find("upgrade_rule") != m.end() && !m["upgrade_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_rule"]));
        upgradeRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule>(model1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoList : public Darabonba::Model {
public:
  shared_ptr<long> agentId{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<string> childCabin{};
  shared_ptr<string> className{};
  shared_ptr<string> classRule{};
  shared_ptr<string> discount{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList>> flightRuleList{};
  shared_ptr<string> flightRuleListStr{};
  shared_ptr<long> invoiceType{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<long> oilPrice{};
  shared_ptr<string> orderParams{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<long> productType{};
  shared_ptr<string> productTypeDesc{};
  shared_ptr<string> promotionPrice{};
  shared_ptr<string> remainedSeatCount{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> totalPrice{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoList() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["agent_id"] = boost::any(*agentId);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabin_class_name"] = boost::any(*cabinClassName);
    }
    if (childCabin) {
      res["child_cabin"] = boost::any(*childCabin);
    }
    if (className) {
      res["class_name"] = boost::any(*className);
    }
    if (classRule) {
      res["class_rule"] = boost::any(*classRule);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*flightRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_rule_list"] = boost::any(temp1);
    }
    if (flightRuleListStr) {
      res["flight_rule_list_str"] = boost::any(*flightRuleListStr);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (orderParams) {
      res["order_params"] = boost::any(*orderParams);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (productType) {
      res["product_type"] = boost::any(*productType);
    }
    if (productTypeDesc) {
      res["product_type_desc"] = boost::any(*productTypeDesc);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (remainedSeatCount) {
      res["remained_seat_count"] = boost::any(*remainedSeatCount);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("agent_id") != m.end() && !m["agent_id"].empty()) {
      agentId = make_shared<long>(boost::any_cast<long>(m["agent_id"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_class_name") != m.end() && !m["cabin_class_name"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabin_class_name"]));
    }
    if (m.find("child_cabin") != m.end() && !m["child_cabin"].empty()) {
      childCabin = make_shared<string>(boost::any_cast<string>(m["child_cabin"]));
    }
    if (m.find("class_name") != m.end() && !m["class_name"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["class_name"]));
    }
    if (m.find("class_rule") != m.end() && !m["class_rule"].empty()) {
      classRule = make_shared<string>(boost::any_cast<string>(m["class_rule"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("flight_rule_list") != m.end() && !m["flight_rule_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_rule_list"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_rule_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightRuleList = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList>>(expect1);
      }
    }
    if (m.find("flight_rule_list_str") != m.end() && !m["flight_rule_list_str"].empty()) {
      flightRuleListStr = make_shared<string>(boost::any_cast<string>(m["flight_rule_list_str"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("order_params") != m.end() && !m["order_params"].empty()) {
      orderParams = make_shared<string>(boost::any_cast<string>(m["order_params"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("product_type") != m.end() && !m["product_type"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["product_type"]));
    }
    if (m.find("product_type_desc") != m.end() && !m["product_type_desc"].empty()) {
      productTypeDesc = make_shared<string>(boost::any_cast<string>(m["product_type_desc"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<string>(boost::any_cast<string>(m["promotion_price"]));
    }
    if (m.find("remained_seat_count") != m.end() && !m["remained_seat_count"].empty()) {
      remainedSeatCount = make_shared<string>(boost::any_cast<string>(m["remained_seat_count"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoList() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["image_d_o"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("image_d_o") != m.end() && !m["image_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["image_d_o"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["image_d_o"]));
        imageDO = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<boost::any>> extraContentVisualizes{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (extraContentVisualizes) {
      res["extra_content_visualizes"] = boost::any(*extraContentVisualizes);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("extra_content_visualizes") != m.end() && !m["extra_content_visualizes"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["extra_content_visualizes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_content_visualizes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      extraContentVisualizes = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleList : public Darabonba::Model {
public:
  shared_ptr<string> baggageInfo{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem> baggageItem{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule> changeRule{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem> changeRuleItem{};
  shared_ptr<string> extra{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule> refundRule{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem> refundRuleItem{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule> signRule{};
  shared_ptr<string> tuigaiqianInfo{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule> upgradeRule{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleList() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageInfo) {
      res["baggage_info"] = boost::any(*baggageInfo);
    }
    if (baggageItem) {
      res["baggage_item"] = baggageItem ? boost::any(baggageItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRule) {
      res["change_rule"] = changeRule ? boost::any(changeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRuleItem) {
      res["change_rule_item"] = changeRuleItem ? boost::any(changeRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (refundRule) {
      res["refund_rule"] = refundRule ? boost::any(refundRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundRuleItem) {
      res["refund_rule_item"] = refundRuleItem ? boost::any(refundRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signRule) {
      res["sign_rule"] = signRule ? boost::any(signRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    if (upgradeRule) {
      res["upgrade_rule"] = upgradeRule ? boost::any(upgradeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_info") != m.end() && !m["baggage_info"].empty()) {
      baggageInfo = make_shared<string>(boost::any_cast<string>(m["baggage_info"]));
    }
    if (m.find("baggage_item") != m.end() && !m["baggage_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["baggage_item"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["baggage_item"]));
        baggageItem = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem>(model1);
      }
    }
    if (m.find("change_rule") != m.end() && !m["change_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule"]));
        changeRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule>(model1);
      }
    }
    if (m.find("change_rule_item") != m.end() && !m["change_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule_item"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule_item"]));
        changeRuleItem = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem>(model1);
      }
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("refund_rule") != m.end() && !m["refund_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule"]));
        refundRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule>(model1);
      }
    }
    if (m.find("refund_rule_item") != m.end() && !m["refund_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule_item"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule_item"]));
        refundRuleItem = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem>(model1);
      }
    }
    if (m.find("sign_rule") != m.end() && !m["sign_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["sign_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sign_rule"]));
        signRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule>(model1);
      }
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
    if (m.find("upgrade_rule") != m.end() && !m["upgrade_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_rule"]));
        upgradeRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule>(model1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleList() = default;
};
class FlightOtaSearchResponseBodyModuleFlightList : public Darabonba::Model {
public:
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListAirlineInfo> airlineInfo{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo> arrAirportInfo{};
  shared_ptr<string> arrDate{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoList>> cabinInfoList{};
  shared_ptr<string> carrierAirline{};
  shared_ptr<string> carrierNo{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo> depAirportInfo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<long> discount{};
  shared_ptr<string> flightNo{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleList>> flightRuleList{};
  shared_ptr<string> flightRuleListStr{};
  shared_ptr<string> flightSize{};
  shared_ptr<string> flightType{};
  shared_ptr<long> invoiceType{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<bool> isShare{};
  shared_ptr<bool> isStop{};
  shared_ptr<bool> isTransfer{};
  shared_ptr<string> mealDesc{};
  shared_ptr<long> oilPrice{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<long> productType{};
  shared_ptr<string> productTypeDesc{};
  shared_ptr<string> promotionPrice{};
  shared_ptr<string> remainedSeatCount{};
  shared_ptr<string> secretParams{};
  shared_ptr<string> segmentNumber{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<string> totalPrice{};
  shared_ptr<long> tripType{};

  FlightOtaSearchResponseBodyModuleFlightList() {}

  explicit FlightOtaSearchResponseBodyModuleFlightList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*cabinInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cabin_info_list"] = boost::any(temp1);
    }
    if (carrierAirline) {
      res["carrier_airline"] = boost::any(*carrierAirline);
    }
    if (carrierNo) {
      res["carrier_no"] = boost::any(*carrierNo);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*flightRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_rule_list"] = boost::any(temp1);
    }
    if (flightRuleListStr) {
      res["flight_rule_list_str"] = boost::any(*flightRuleListStr);
    }
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (isShare) {
      res["is_share"] = boost::any(*isShare);
    }
    if (isStop) {
      res["is_stop"] = boost::any(*isStop);
    }
    if (isTransfer) {
      res["is_transfer"] = boost::any(*isTransfer);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (productType) {
      res["product_type"] = boost::any(*productType);
    }
    if (productTypeDesc) {
      res["product_type_desc"] = boost::any(*productTypeDesc);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (remainedSeatCount) {
      res["remained_seat_count"] = boost::any(*remainedSeatCount);
    }
    if (secretParams) {
      res["secret_params"] = boost::any(*secretParams);
    }
    if (segmentNumber) {
      res["segment_number"] = boost::any(*segmentNumber);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<FlightOtaSearchResponseBodyModuleFlightListAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo>(model1);
      }
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_info_list") != m.end() && !m["cabin_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["cabin_info_list"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cabin_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cabinInfoList = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoList>>(expect1);
      }
    }
    if (m.find("carrier_airline") != m.end() && !m["carrier_airline"].empty()) {
      carrierAirline = make_shared<string>(boost::any_cast<string>(m["carrier_airline"]));
    }
    if (m.find("carrier_no") != m.end() && !m["carrier_no"].empty()) {
      carrierNo = make_shared<string>(boost::any_cast<string>(m["carrier_no"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo>(model1);
      }
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<long>(boost::any_cast<long>(m["discount"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_rule_list") != m.end() && !m["flight_rule_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_rule_list"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_rule_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightRuleList = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleList>>(expect1);
      }
    }
    if (m.find("flight_rule_list_str") != m.end() && !m["flight_rule_list_str"].empty()) {
      flightRuleListStr = make_shared<string>(boost::any_cast<string>(m["flight_rule_list_str"]));
    }
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("is_share") != m.end() && !m["is_share"].empty()) {
      isShare = make_shared<bool>(boost::any_cast<bool>(m["is_share"]));
    }
    if (m.find("is_stop") != m.end() && !m["is_stop"].empty()) {
      isStop = make_shared<bool>(boost::any_cast<bool>(m["is_stop"]));
    }
    if (m.find("is_transfer") != m.end() && !m["is_transfer"].empty()) {
      isTransfer = make_shared<bool>(boost::any_cast<bool>(m["is_transfer"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("product_type") != m.end() && !m["product_type"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["product_type"]));
    }
    if (m.find("product_type_desc") != m.end() && !m["product_type_desc"].empty()) {
      productTypeDesc = make_shared<string>(boost::any_cast<string>(m["product_type_desc"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<string>(boost::any_cast<string>(m["promotion_price"]));
    }
    if (m.find("remained_seat_count") != m.end() && !m["remained_seat_count"].empty()) {
      remainedSeatCount = make_shared<string>(boost::any_cast<string>(m["remained_seat_count"]));
    }
    if (m.find("secret_params") != m.end() && !m["secret_params"].empty()) {
      secretParams = make_shared<string>(boost::any_cast<string>(m["secret_params"]));
    }
    if (m.find("segment_number") != m.end() && !m["segment_number"].empty()) {
      segmentNumber = make_shared<string>(boost::any_cast<string>(m["segment_number"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<string>(boost::any_cast<string>(m["total_price"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightList() = default;
};
class FlightOtaSearchResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightList>> flightList{};

  FlightOtaSearchResponseBodyModule() {}

  explicit FlightOtaSearchResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightList) {
      vector<boost::any> temp1;
      for(auto item1:*flightList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_list") != m.end() && !m["flight_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_list"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightList = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightList>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModule() = default;
};
class FlightOtaSearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightOtaSearchResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightOtaSearchResponseBody() {}

  explicit FlightOtaSearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightOtaSearchResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightOtaSearchResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightOtaSearchResponseBody() = default;
};
class FlightOtaSearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightOtaSearchResponseBody> body{};

  FlightOtaSearchResponse() {}

  explicit FlightOtaSearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightOtaSearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightOtaSearchResponseBody>(model1);
      }
    }
  }


  virtual ~FlightOtaSearchResponse() = default;
};
class FlightPayOrderHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightPayOrderHeaders() {}

  explicit FlightPayOrderHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightPayOrderHeaders() = default;
};
class FlightPayOrderRequest : public Darabonba::Model {
public:
  shared_ptr<long> corpPayPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<map<string, string>> extra{};
  shared_ptr<long> personalPayPrice{};
  shared_ptr<long> totalPayPrice{};

  FlightPayOrderRequest() {}

  explicit FlightPayOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpPayPrice) {
      res["corp_pay_price"] = boost::any(*corpPayPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (personalPayPrice) {
      res["personal_pay_price"] = boost::any(*personalPayPrice);
    }
    if (totalPayPrice) {
      res["total_pay_price"] = boost::any(*totalPayPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_pay_price") != m.end() && !m["corp_pay_price"].empty()) {
      corpPayPrice = make_shared<long>(boost::any_cast<long>(m["corp_pay_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["extra"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extra = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("personal_pay_price") != m.end() && !m["personal_pay_price"].empty()) {
      personalPayPrice = make_shared<long>(boost::any_cast<long>(m["personal_pay_price"]));
    }
    if (m.find("total_pay_price") != m.end() && !m["total_pay_price"].empty()) {
      totalPayPrice = make_shared<long>(boost::any_cast<long>(m["total_pay_price"]));
    }
  }


  virtual ~FlightPayOrderRequest() = default;
};
class FlightPayOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> corpPayPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> extraShrink{};
  shared_ptr<long> personalPayPrice{};
  shared_ptr<long> totalPayPrice{};

  FlightPayOrderShrinkRequest() {}

  explicit FlightPayOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpPayPrice) {
      res["corp_pay_price"] = boost::any(*corpPayPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (extraShrink) {
      res["extra"] = boost::any(*extraShrink);
    }
    if (personalPayPrice) {
      res["personal_pay_price"] = boost::any(*personalPayPrice);
    }
    if (totalPayPrice) {
      res["total_pay_price"] = boost::any(*totalPayPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_pay_price") != m.end() && !m["corp_pay_price"].empty()) {
      corpPayPrice = make_shared<long>(boost::any_cast<long>(m["corp_pay_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extraShrink = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("personal_pay_price") != m.end() && !m["personal_pay_price"].empty()) {
      personalPayPrice = make_shared<long>(boost::any_cast<long>(m["personal_pay_price"]));
    }
    if (m.find("total_pay_price") != m.end() && !m["total_pay_price"].empty()) {
      totalPayPrice = make_shared<long>(boost::any_cast<long>(m["total_pay_price"]));
    }
  }


  virtual ~FlightPayOrderShrinkRequest() = default;
};
class FlightPayOrderResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> actualPayPrice{};
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> lastPayTime{};
  shared_ptr<long> payStatus{};

  FlightPayOrderResponseBodyModule() {}

  explicit FlightPayOrderResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualPayPrice) {
      res["actual_pay_price"] = boost::any(*actualPayPrice);
    }
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (lastPayTime) {
      res["last_pay_time"] = boost::any(*lastPayTime);
    }
    if (payStatus) {
      res["pay_status"] = boost::any(*payStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actual_pay_price") != m.end() && !m["actual_pay_price"].empty()) {
      actualPayPrice = make_shared<long>(boost::any_cast<long>(m["actual_pay_price"]));
    }
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("last_pay_time") != m.end() && !m["last_pay_time"].empty()) {
      lastPayTime = make_shared<string>(boost::any_cast<string>(m["last_pay_time"]));
    }
    if (m.find("pay_status") != m.end() && !m["pay_status"].empty()) {
      payStatus = make_shared<long>(boost::any_cast<long>(m["pay_status"]));
    }
  }


  virtual ~FlightPayOrderResponseBodyModule() = default;
};
class FlightPayOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightPayOrderResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightPayOrderResponseBody() {}

  explicit FlightPayOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightPayOrderResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightPayOrderResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightPayOrderResponseBody() = default;
};
class FlightPayOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightPayOrderResponseBody> body{};

  FlightPayOrderResponse() {}

  explicit FlightPayOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightPayOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightPayOrderResponseBody>(model1);
      }
    }
  }


  virtual ~FlightPayOrderResponse() = default;
};
class FlightRefundApplyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightRefundApplyHeaders() {}

  explicit FlightRefundApplyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightRefundApplyHeaders() = default;
};
class FlightRefundApplyRequestPassengerSegmentInfoList : public Darabonba::Model {
public:
  shared_ptr<string> flightNo{};
  shared_ptr<string> passengerName{};
  shared_ptr<string> userId{};

  FlightRefundApplyRequestPassengerSegmentInfoList() {}

  explicit FlightRefundApplyRequestPassengerSegmentInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightRefundApplyRequestPassengerSegmentInfoList() = default;
};
class FlightRefundApplyRequest : public Darabonba::Model {
public:
  shared_ptr<long> corpRefundPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<string> displayRefundMoney{};
  shared_ptr<map<string, string>> extra{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<string> itemUnitIds{};
  shared_ptr<vector<FlightRefundApplyRequestPassengerSegmentInfoList>> passengerSegmentInfoList{};
  shared_ptr<long> personalRefundPrice{};
  shared_ptr<string> reasonDetail{};
  shared_ptr<long> reasonType{};
  shared_ptr<vector<string>> refundVoucherInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<long> totalRefundPrice{};

  FlightRefundApplyRequest() {}

  explicit FlightRefundApplyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpRefundPrice) {
      res["corp_refund_price"] = boost::any(*corpRefundPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (displayRefundMoney) {
      res["display_refund_money"] = boost::any(*displayRefundMoney);
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (itemUnitIds) {
      res["item_unit_ids"] = boost::any(*itemUnitIds);
    }
    if (passengerSegmentInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerSegmentInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_segment_info_list"] = boost::any(temp1);
    }
    if (personalRefundPrice) {
      res["personal_refund_price"] = boost::any(*personalRefundPrice);
    }
    if (reasonDetail) {
      res["reason_detail"] = boost::any(*reasonDetail);
    }
    if (reasonType) {
      res["reason_type"] = boost::any(*reasonType);
    }
    if (refundVoucherInfo) {
      res["refund_voucher_info"] = boost::any(*refundVoucherInfo);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (totalRefundPrice) {
      res["total_refund_price"] = boost::any(*totalRefundPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_refund_price") != m.end() && !m["corp_refund_price"].empty()) {
      corpRefundPrice = make_shared<long>(boost::any_cast<long>(m["corp_refund_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("display_refund_money") != m.end() && !m["display_refund_money"].empty()) {
      displayRefundMoney = make_shared<string>(boost::any_cast<string>(m["display_refund_money"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["extra"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extra = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("item_unit_ids") != m.end() && !m["item_unit_ids"].empty()) {
      itemUnitIds = make_shared<string>(boost::any_cast<string>(m["item_unit_ids"]));
    }
    if (m.find("passenger_segment_info_list") != m.end() && !m["passenger_segment_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_segment_info_list"].type()) {
        vector<FlightRefundApplyRequestPassengerSegmentInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_segment_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundApplyRequestPassengerSegmentInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerSegmentInfoList = make_shared<vector<FlightRefundApplyRequestPassengerSegmentInfoList>>(expect1);
      }
    }
    if (m.find("personal_refund_price") != m.end() && !m["personal_refund_price"].empty()) {
      personalRefundPrice = make_shared<long>(boost::any_cast<long>(m["personal_refund_price"]));
    }
    if (m.find("reason_detail") != m.end() && !m["reason_detail"].empty()) {
      reasonDetail = make_shared<string>(boost::any_cast<string>(m["reason_detail"]));
    }
    if (m.find("reason_type") != m.end() && !m["reason_type"].empty()) {
      reasonType = make_shared<long>(boost::any_cast<long>(m["reason_type"]));
    }
    if (m.find("refund_voucher_info") != m.end() && !m["refund_voucher_info"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["refund_voucher_info"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["refund_voucher_info"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      refundVoucherInfo = make_shared<vector<string>>(toVec1);
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("total_refund_price") != m.end() && !m["total_refund_price"].empty()) {
      totalRefundPrice = make_shared<long>(boost::any_cast<long>(m["total_refund_price"]));
    }
  }


  virtual ~FlightRefundApplyRequest() = default;
};
class FlightRefundApplyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> corpRefundPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<string> displayRefundMoney{};
  shared_ptr<string> extraShrink{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<string> itemUnitIds{};
  shared_ptr<string> passengerSegmentInfoListShrink{};
  shared_ptr<long> personalRefundPrice{};
  shared_ptr<string> reasonDetail{};
  shared_ptr<long> reasonType{};
  shared_ptr<string> refundVoucherInfoShrink{};
  shared_ptr<string> sessionId{};
  shared_ptr<long> totalRefundPrice{};

  FlightRefundApplyShrinkRequest() {}

  explicit FlightRefundApplyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpRefundPrice) {
      res["corp_refund_price"] = boost::any(*corpRefundPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (displayRefundMoney) {
      res["display_refund_money"] = boost::any(*displayRefundMoney);
    }
    if (extraShrink) {
      res["extra"] = boost::any(*extraShrink);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (itemUnitIds) {
      res["item_unit_ids"] = boost::any(*itemUnitIds);
    }
    if (passengerSegmentInfoListShrink) {
      res["passenger_segment_info_list"] = boost::any(*passengerSegmentInfoListShrink);
    }
    if (personalRefundPrice) {
      res["personal_refund_price"] = boost::any(*personalRefundPrice);
    }
    if (reasonDetail) {
      res["reason_detail"] = boost::any(*reasonDetail);
    }
    if (reasonType) {
      res["reason_type"] = boost::any(*reasonType);
    }
    if (refundVoucherInfoShrink) {
      res["refund_voucher_info"] = boost::any(*refundVoucherInfoShrink);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (totalRefundPrice) {
      res["total_refund_price"] = boost::any(*totalRefundPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_refund_price") != m.end() && !m["corp_refund_price"].empty()) {
      corpRefundPrice = make_shared<long>(boost::any_cast<long>(m["corp_refund_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("display_refund_money") != m.end() && !m["display_refund_money"].empty()) {
      displayRefundMoney = make_shared<string>(boost::any_cast<string>(m["display_refund_money"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extraShrink = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("item_unit_ids") != m.end() && !m["item_unit_ids"].empty()) {
      itemUnitIds = make_shared<string>(boost::any_cast<string>(m["item_unit_ids"]));
    }
    if (m.find("passenger_segment_info_list") != m.end() && !m["passenger_segment_info_list"].empty()) {
      passengerSegmentInfoListShrink = make_shared<string>(boost::any_cast<string>(m["passenger_segment_info_list"]));
    }
    if (m.find("personal_refund_price") != m.end() && !m["personal_refund_price"].empty()) {
      personalRefundPrice = make_shared<long>(boost::any_cast<long>(m["personal_refund_price"]));
    }
    if (m.find("reason_detail") != m.end() && !m["reason_detail"].empty()) {
      reasonDetail = make_shared<string>(boost::any_cast<string>(m["reason_detail"]));
    }
    if (m.find("reason_type") != m.end() && !m["reason_type"].empty()) {
      reasonType = make_shared<long>(boost::any_cast<long>(m["reason_type"]));
    }
    if (m.find("refund_voucher_info") != m.end() && !m["refund_voucher_info"].empty()) {
      refundVoucherInfoShrink = make_shared<string>(boost::any_cast<string>(m["refund_voucher_info"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("total_refund_price") != m.end() && !m["total_refund_price"].empty()) {
      totalRefundPrice = make_shared<long>(boost::any_cast<long>(m["total_refund_price"]));
    }
  }


  virtual ~FlightRefundApplyShrinkRequest() = default;
};
class FlightRefundApplyResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<long> refundApplyId{};
  shared_ptr<long> refundFee{};
  shared_ptr<long> refundMoney{};

  FlightRefundApplyResponseBodyModule() {}

  explicit FlightRefundApplyResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (refundApplyId) {
      res["refund_apply_id"] = boost::any(*refundApplyId);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundMoney) {
      res["refund_money"] = boost::any(*refundMoney);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("refund_apply_id") != m.end() && !m["refund_apply_id"].empty()) {
      refundApplyId = make_shared<long>(boost::any_cast<long>(m["refund_apply_id"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["refund_fee"]));
    }
    if (m.find("refund_money") != m.end() && !m["refund_money"].empty()) {
      refundMoney = make_shared<long>(boost::any_cast<long>(m["refund_money"]));
    }
  }


  virtual ~FlightRefundApplyResponseBodyModule() = default;
};
class FlightRefundApplyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightRefundApplyResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightRefundApplyResponseBody() {}

  explicit FlightRefundApplyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightRefundApplyResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightRefundApplyResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightRefundApplyResponseBody() = default;
};
class FlightRefundApplyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightRefundApplyResponseBody> body{};

  FlightRefundApplyResponse() {}

  explicit FlightRefundApplyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightRefundApplyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightRefundApplyResponseBody>(model1);
      }
    }
  }


  virtual ~FlightRefundApplyResponse() = default;
};
class FlightRefundDetailHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightRefundDetailHeaders() {}

  explicit FlightRefundDetailHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightRefundDetailHeaders() = default;
};
class FlightRefundDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};

  FlightRefundDetailRequest() {}

  explicit FlightRefundDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
  }


  virtual ~FlightRefundDetailRequest() = default;
};
class FlightRefundDetailResponseBodyModuleRefundFeeList : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<long> refundFee{};
  shared_ptr<long> refundPrice{};
  shared_ptr<string> status{};

  FlightRefundDetailResponseBodyModuleRefundFeeList() {}

  explicit FlightRefundDetailResponseBodyModuleRefundFeeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundPrice) {
      res["refund_price"] = boost::any(*refundPrice);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["refund_fee"]));
    }
    if (m.find("refund_price") != m.end() && !m["refund_price"].empty()) {
      refundPrice = make_shared<long>(boost::any_cast<long>(m["refund_price"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~FlightRefundDetailResponseBodyModuleRefundFeeList() = default;
};
class FlightRefundDetailResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> btripOrderId{};
  shared_ptr<long> btripSubOrderId{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<string> reason{};
  shared_ptr<long> refundFee{};
  shared_ptr<vector<FlightRefundDetailResponseBodyModuleRefundFeeList>> refundFeeList{};
  shared_ptr<long> refundPrice{};
  shared_ptr<string> status{};

  FlightRefundDetailResponseBodyModule() {}

  explicit FlightRefundDetailResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (btripSubOrderId) {
      res["btrip_sub_order_id"] = boost::any(*btripSubOrderId);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundFeeList) {
      vector<boost::any> temp1;
      for(auto item1:*refundFeeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_fee_list"] = boost::any(temp1);
    }
    if (refundPrice) {
      res["refund_price"] = boost::any(*refundPrice);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_order_id"]));
    }
    if (m.find("btrip_sub_order_id") != m.end() && !m["btrip_sub_order_id"].empty()) {
      btripSubOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_sub_order_id"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["refund_fee"]));
    }
    if (m.find("refund_fee_list") != m.end() && !m["refund_fee_list"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_fee_list"].type()) {
        vector<FlightRefundDetailResponseBodyModuleRefundFeeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_fee_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundDetailResponseBodyModuleRefundFeeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundFeeList = make_shared<vector<FlightRefundDetailResponseBodyModuleRefundFeeList>>(expect1);
      }
    }
    if (m.find("refund_price") != m.end() && !m["refund_price"].empty()) {
      refundPrice = make_shared<long>(boost::any_cast<long>(m["refund_price"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~FlightRefundDetailResponseBodyModule() = default;
};
class FlightRefundDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightRefundDetailResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightRefundDetailResponseBody() {}

  explicit FlightRefundDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightRefundDetailResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightRefundDetailResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightRefundDetailResponseBody() = default;
};
class FlightRefundDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightRefundDetailResponseBody> body{};

  FlightRefundDetailResponse() {}

  explicit FlightRefundDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightRefundDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightRefundDetailResponseBody>(model1);
      }
    }
  }


  virtual ~FlightRefundDetailResponse() = default;
};
class FlightRefundPreCalHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightRefundPreCalHeaders() {}

  explicit FlightRefundPreCalHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightRefundPreCalHeaders() = default;
};
class FlightRefundPreCalRequestPassengerSegmentInfoList : public Darabonba::Model {
public:
  shared_ptr<string> flightNo{};
  shared_ptr<string> passengerName{};
  shared_ptr<string> userId{};

  FlightRefundPreCalRequestPassengerSegmentInfoList() {}

  explicit FlightRefundPreCalRequestPassengerSegmentInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightRefundPreCalRequestPassengerSegmentInfoList() = default;
};
class FlightRefundPreCalRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> isVoluntary{};
  shared_ptr<vector<FlightRefundPreCalRequestPassengerSegmentInfoList>> passengerSegmentInfoList{};

  FlightRefundPreCalRequest() {}

  explicit FlightRefundPreCalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (passengerSegmentInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerSegmentInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_segment_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<string>(boost::any_cast<string>(m["is_voluntary"]));
    }
    if (m.find("passenger_segment_info_list") != m.end() && !m["passenger_segment_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_segment_info_list"].type()) {
        vector<FlightRefundPreCalRequestPassengerSegmentInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_segment_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundPreCalRequestPassengerSegmentInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerSegmentInfoList = make_shared<vector<FlightRefundPreCalRequestPassengerSegmentInfoList>>(expect1);
      }
    }
  }


  virtual ~FlightRefundPreCalRequest() = default;
};
class FlightRefundPreCalShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> isVoluntary{};
  shared_ptr<string> passengerSegmentInfoListShrink{};

  FlightRefundPreCalShrinkRequest() {}

  explicit FlightRefundPreCalShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (passengerSegmentInfoListShrink) {
      res["passenger_segment_info_list"] = boost::any(*passengerSegmentInfoListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<string>(boost::any_cast<string>(m["is_voluntary"]));
    }
    if (m.find("passenger_segment_info_list") != m.end() && !m["passenger_segment_info_list"].empty()) {
      passengerSegmentInfoListShrink = make_shared<string>(boost::any_cast<string>(m["passenger_segment_info_list"]));
    }
  }


  virtual ~FlightRefundPreCalShrinkRequest() = default;
};
class FlightRefundPreCalResponseBodyModuleMultiRefundCalList : public Darabonba::Model {
public:
  shared_ptr<bool> canApplyRefund{};
  shared_ptr<string> name{};
  shared_ptr<long> preRefundMoney{};
  shared_ptr<long> refundFee{};
  shared_ptr<string> userId{};

  FlightRefundPreCalResponseBodyModuleMultiRefundCalList() {}

  explicit FlightRefundPreCalResponseBodyModuleMultiRefundCalList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canApplyRefund) {
      res["can_apply_refund"] = boost::any(*canApplyRefund);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (preRefundMoney) {
      res["pre_refund_money"] = boost::any(*preRefundMoney);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("can_apply_refund") != m.end() && !m["can_apply_refund"].empty()) {
      canApplyRefund = make_shared<bool>(boost::any_cast<bool>(m["can_apply_refund"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("pre_refund_money") != m.end() && !m["pre_refund_money"].empty()) {
      preRefundMoney = make_shared<long>(boost::any_cast<long>(m["pre_refund_money"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["refund_fee"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightRefundPreCalResponseBodyModuleMultiRefundCalList() = default;
};
class FlightRefundPreCalResponseBodyModuleReturnReason : public Darabonba::Model {
public:
  shared_ptr<string> extendDesc{};
  shared_ptr<long> person{};
  shared_ptr<long> reasonCode{};
  shared_ptr<string> reasonShow{};
  shared_ptr<long> reasonType{};
  shared_ptr<long> volunteer{};

  FlightRefundPreCalResponseBodyModuleReturnReason() {}

  explicit FlightRefundPreCalResponseBodyModuleReturnReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extendDesc) {
      res["extend_desc"] = boost::any(*extendDesc);
    }
    if (person) {
      res["person"] = boost::any(*person);
    }
    if (reasonCode) {
      res["reason_code"] = boost::any(*reasonCode);
    }
    if (reasonShow) {
      res["reason_show"] = boost::any(*reasonShow);
    }
    if (reasonType) {
      res["reason_type"] = boost::any(*reasonType);
    }
    if (volunteer) {
      res["volunteer"] = boost::any(*volunteer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extend_desc") != m.end() && !m["extend_desc"].empty()) {
      extendDesc = make_shared<string>(boost::any_cast<string>(m["extend_desc"]));
    }
    if (m.find("person") != m.end() && !m["person"].empty()) {
      person = make_shared<long>(boost::any_cast<long>(m["person"]));
    }
    if (m.find("reason_code") != m.end() && !m["reason_code"].empty()) {
      reasonCode = make_shared<long>(boost::any_cast<long>(m["reason_code"]));
    }
    if (m.find("reason_show") != m.end() && !m["reason_show"].empty()) {
      reasonShow = make_shared<string>(boost::any_cast<string>(m["reason_show"]));
    }
    if (m.find("reason_type") != m.end() && !m["reason_type"].empty()) {
      reasonType = make_shared<long>(boost::any_cast<long>(m["reason_type"]));
    }
    if (m.find("volunteer") != m.end() && !m["volunteer"].empty()) {
      volunteer = make_shared<long>(boost::any_cast<long>(m["volunteer"]));
    }
  }


  virtual ~FlightRefundPreCalResponseBodyModuleReturnReason() = default;
};
class FlightRefundPreCalResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<bool> flightChange{};
  shared_ptr<string> itemUnitId{};
  shared_ptr<vector<FlightRefundPreCalResponseBodyModuleMultiRefundCalList>> multiRefundCalList{};
  shared_ptr<long> preRefundMoney{};
  shared_ptr<long> refundFee{};
  shared_ptr<vector<FlightRefundPreCalResponseBodyModuleReturnReason>> returnReason{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> tips{};

  FlightRefundPreCalResponseBodyModule() {}

  explicit FlightRefundPreCalResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightChange) {
      res["flight_change"] = boost::any(*flightChange);
    }
    if (itemUnitId) {
      res["item_unit_id"] = boost::any(*itemUnitId);
    }
    if (multiRefundCalList) {
      vector<boost::any> temp1;
      for(auto item1:*multiRefundCalList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["multi_refund_cal_list"] = boost::any(temp1);
    }
    if (preRefundMoney) {
      res["pre_refund_money"] = boost::any(*preRefundMoney);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (returnReason) {
      vector<boost::any> temp1;
      for(auto item1:*returnReason){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["return_reason"] = boost::any(temp1);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (tips) {
      res["tips"] = boost::any(*tips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_change") != m.end() && !m["flight_change"].empty()) {
      flightChange = make_shared<bool>(boost::any_cast<bool>(m["flight_change"]));
    }
    if (m.find("item_unit_id") != m.end() && !m["item_unit_id"].empty()) {
      itemUnitId = make_shared<string>(boost::any_cast<string>(m["item_unit_id"]));
    }
    if (m.find("multi_refund_cal_list") != m.end() && !m["multi_refund_cal_list"].empty()) {
      if (typeid(vector<boost::any>) == m["multi_refund_cal_list"].type()) {
        vector<FlightRefundPreCalResponseBodyModuleMultiRefundCalList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["multi_refund_cal_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundPreCalResponseBodyModuleMultiRefundCalList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multiRefundCalList = make_shared<vector<FlightRefundPreCalResponseBodyModuleMultiRefundCalList>>(expect1);
      }
    }
    if (m.find("pre_refund_money") != m.end() && !m["pre_refund_money"].empty()) {
      preRefundMoney = make_shared<long>(boost::any_cast<long>(m["pre_refund_money"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["refund_fee"]));
    }
    if (m.find("return_reason") != m.end() && !m["return_reason"].empty()) {
      if (typeid(vector<boost::any>) == m["return_reason"].type()) {
        vector<FlightRefundPreCalResponseBodyModuleReturnReason> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["return_reason"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundPreCalResponseBodyModuleReturnReason model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        returnReason = make_shared<vector<FlightRefundPreCalResponseBodyModuleReturnReason>>(expect1);
      }
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      tips = make_shared<string>(boost::any_cast<string>(m["tips"]));
    }
  }


  virtual ~FlightRefundPreCalResponseBodyModule() = default;
};
class FlightRefundPreCalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightRefundPreCalResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightRefundPreCalResponseBody() {}

  explicit FlightRefundPreCalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightRefundPreCalResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightRefundPreCalResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightRefundPreCalResponseBody() = default;
};
class FlightRefundPreCalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightRefundPreCalResponseBody> body{};

  FlightRefundPreCalResponse() {}

  explicit FlightRefundPreCalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightRefundPreCalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightRefundPreCalResponseBody>(model1);
      }
    }
  }


  virtual ~FlightRefundPreCalResponse() = default;
};
class FlightSearchListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightSearchListHeaders() {}

  explicit FlightSearchListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightSearchListHeaders() = default;
};
class FlightSearchListRequest : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depDate{};
  shared_ptr<string> flightNo{};
  shared_ptr<bool> needMultiClassPrice{};
  shared_ptr<string> transferCityCode{};
  shared_ptr<string> transferFlightNo{};
  shared_ptr<string> transferLeaveDate{};
  shared_ptr<string> tripType{};

  FlightSearchListRequest() {}

  explicit FlightSearchListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (needMultiClassPrice) {
      res["need_multi_class_price"] = boost::any(*needMultiClassPrice);
    }
    if (transferCityCode) {
      res["transfer_city_code"] = boost::any(*transferCityCode);
    }
    if (transferFlightNo) {
      res["transfer_flight_no"] = boost::any(*transferFlightNo);
    }
    if (transferLeaveDate) {
      res["transfer_leave_date"] = boost::any(*transferLeaveDate);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("need_multi_class_price") != m.end() && !m["need_multi_class_price"].empty()) {
      needMultiClassPrice = make_shared<bool>(boost::any_cast<bool>(m["need_multi_class_price"]));
    }
    if (m.find("transfer_city_code") != m.end() && !m["transfer_city_code"].empty()) {
      transferCityCode = make_shared<string>(boost::any_cast<string>(m["transfer_city_code"]));
    }
    if (m.find("transfer_flight_no") != m.end() && !m["transfer_flight_no"].empty()) {
      transferFlightNo = make_shared<string>(boost::any_cast<string>(m["transfer_flight_no"]));
    }
    if (m.find("transfer_leave_date") != m.end() && !m["transfer_leave_date"].empty()) {
      transferLeaveDate = make_shared<string>(boost::any_cast<string>(m["transfer_leave_date"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<string>(boost::any_cast<string>(m["trip_type"]));
    }
  }


  virtual ~FlightSearchListRequest() = default;
};
class FlightSearchListResponseBodyModuleFlightListAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};

  FlightSearchListResponseBodyModuleFlightListAirlineInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListAirlineInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightSearchListResponseBodyModuleFlightListArrAirportInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListArrAirportInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["image_d_o"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("image_d_o") != m.end() && !m["image_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["image_d_o"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["image_d_o"]));
        imageDO = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<boost::any>> extraContentVisualizes{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (extraContentVisualizes) {
      res["extra_content_visualizes"] = boost::any(*extraContentVisualizes);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("extra_content_visualizes") != m.end() && !m["extra_content_visualizes"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["extra_content_visualizes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_content_visualizes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      extraContentVisualizes = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList : public Darabonba::Model {
public:
  shared_ptr<string> baggageInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem> baggageItem{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule> changeRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem> changeRuleItem{};
  shared_ptr<string> extra{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule> refundRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem> refundRuleItem{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule> signRule{};
  shared_ptr<string> tuigaiqianInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule> upgradeRule{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageInfo) {
      res["baggage_info"] = boost::any(*baggageInfo);
    }
    if (baggageItem) {
      res["baggage_item"] = baggageItem ? boost::any(baggageItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRule) {
      res["change_rule"] = changeRule ? boost::any(changeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRuleItem) {
      res["change_rule_item"] = changeRuleItem ? boost::any(changeRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (refundRule) {
      res["refund_rule"] = refundRule ? boost::any(refundRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundRuleItem) {
      res["refund_rule_item"] = refundRuleItem ? boost::any(refundRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signRule) {
      res["sign_rule"] = signRule ? boost::any(signRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    if (upgradeRule) {
      res["upgrade_rule"] = upgradeRule ? boost::any(upgradeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_info") != m.end() && !m["baggage_info"].empty()) {
      baggageInfo = make_shared<string>(boost::any_cast<string>(m["baggage_info"]));
    }
    if (m.find("baggage_item") != m.end() && !m["baggage_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["baggage_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["baggage_item"]));
        baggageItem = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem>(model1);
      }
    }
    if (m.find("change_rule") != m.end() && !m["change_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule"]));
        changeRule = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule>(model1);
      }
    }
    if (m.find("change_rule_item") != m.end() && !m["change_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule_item"]));
        changeRuleItem = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem>(model1);
      }
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("refund_rule") != m.end() && !m["refund_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule"]));
        refundRule = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule>(model1);
      }
    }
    if (m.find("refund_rule_item") != m.end() && !m["refund_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule_item"]));
        refundRuleItem = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem>(model1);
      }
    }
    if (m.find("sign_rule") != m.end() && !m["sign_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["sign_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sign_rule"]));
        signRule = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule>(model1);
      }
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
    if (m.find("upgrade_rule") != m.end() && !m["upgrade_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_rule"]));
        upgradeRule = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule>(model1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoList : public Darabonba::Model {
public:
  shared_ptr<long> agentId{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<string> childCabin{};
  shared_ptr<string> className{};
  shared_ptr<string> classRule{};
  shared_ptr<string> discount{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList>> flightRuleList{};
  shared_ptr<string> flightRuleListStr{};
  shared_ptr<long> invoiceType{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<string> memo{};
  shared_ptr<long> oilPrice{};
  shared_ptr<string> orderParams{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<long> productType{};
  shared_ptr<string> productTypeDesc{};
  shared_ptr<string> promotionPrice{};
  shared_ptr<string> remainedSeatCount{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> totalPrice{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoList() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["agent_id"] = boost::any(*agentId);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabin_class_name"] = boost::any(*cabinClassName);
    }
    if (childCabin) {
      res["child_cabin"] = boost::any(*childCabin);
    }
    if (className) {
      res["class_name"] = boost::any(*className);
    }
    if (classRule) {
      res["class_rule"] = boost::any(*classRule);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*flightRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_rule_list"] = boost::any(temp1);
    }
    if (flightRuleListStr) {
      res["flight_rule_list_str"] = boost::any(*flightRuleListStr);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (orderParams) {
      res["order_params"] = boost::any(*orderParams);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (productType) {
      res["product_type"] = boost::any(*productType);
    }
    if (productTypeDesc) {
      res["product_type_desc"] = boost::any(*productTypeDesc);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (remainedSeatCount) {
      res["remained_seat_count"] = boost::any(*remainedSeatCount);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("agent_id") != m.end() && !m["agent_id"].empty()) {
      agentId = make_shared<long>(boost::any_cast<long>(m["agent_id"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_class_name") != m.end() && !m["cabin_class_name"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabin_class_name"]));
    }
    if (m.find("child_cabin") != m.end() && !m["child_cabin"].empty()) {
      childCabin = make_shared<string>(boost::any_cast<string>(m["child_cabin"]));
    }
    if (m.find("class_name") != m.end() && !m["class_name"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["class_name"]));
    }
    if (m.find("class_rule") != m.end() && !m["class_rule"].empty()) {
      classRule = make_shared<string>(boost::any_cast<string>(m["class_rule"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("flight_rule_list") != m.end() && !m["flight_rule_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_rule_list"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_rule_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightRuleList = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList>>(expect1);
      }
    }
    if (m.find("flight_rule_list_str") != m.end() && !m["flight_rule_list_str"].empty()) {
      flightRuleListStr = make_shared<string>(boost::any_cast<string>(m["flight_rule_list_str"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("order_params") != m.end() && !m["order_params"].empty()) {
      orderParams = make_shared<string>(boost::any_cast<string>(m["order_params"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("product_type") != m.end() && !m["product_type"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["product_type"]));
    }
    if (m.find("product_type_desc") != m.end() && !m["product_type_desc"].empty()) {
      productTypeDesc = make_shared<string>(boost::any_cast<string>(m["product_type_desc"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<string>(boost::any_cast<string>(m["promotion_price"]));
    }
    if (m.find("remained_seat_count") != m.end() && !m["remained_seat_count"].empty()) {
      remainedSeatCount = make_shared<string>(boost::any_cast<string>(m["remained_seat_count"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoList() = default;
};
class FlightSearchListResponseBodyModuleFlightListDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightSearchListResponseBodyModuleFlightListDepAirportInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListDepAirportInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["image_d_o"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("image_d_o") != m.end() && !m["image_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["image_d_o"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["image_d_o"]));
        imageDO = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<boost::any>> extraContentVisualizes{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (extraContentVisualizes) {
      res["extra_content_visualizes"] = boost::any(*extraContentVisualizes);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("extra_content_visualizes") != m.end() && !m["extra_content_visualizes"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["extra_content_visualizes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_content_visualizes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      extraContentVisualizes = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleList : public Darabonba::Model {
public:
  shared_ptr<string> baggageInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem> baggageItem{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule> changeRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem> changeRuleItem{};
  shared_ptr<string> extra{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule> refundRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem> refundRuleItem{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule> signRule{};
  shared_ptr<string> tuigaiqianInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule> upgradeRule{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleList() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageInfo) {
      res["baggage_info"] = boost::any(*baggageInfo);
    }
    if (baggageItem) {
      res["baggage_item"] = baggageItem ? boost::any(baggageItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRule) {
      res["change_rule"] = changeRule ? boost::any(changeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRuleItem) {
      res["change_rule_item"] = changeRuleItem ? boost::any(changeRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (refundRule) {
      res["refund_rule"] = refundRule ? boost::any(refundRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundRuleItem) {
      res["refund_rule_item"] = refundRuleItem ? boost::any(refundRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signRule) {
      res["sign_rule"] = signRule ? boost::any(signRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    if (upgradeRule) {
      res["upgrade_rule"] = upgradeRule ? boost::any(upgradeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_info") != m.end() && !m["baggage_info"].empty()) {
      baggageInfo = make_shared<string>(boost::any_cast<string>(m["baggage_info"]));
    }
    if (m.find("baggage_item") != m.end() && !m["baggage_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["baggage_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["baggage_item"]));
        baggageItem = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem>(model1);
      }
    }
    if (m.find("change_rule") != m.end() && !m["change_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule"]));
        changeRule = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule>(model1);
      }
    }
    if (m.find("change_rule_item") != m.end() && !m["change_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule_item"]));
        changeRuleItem = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem>(model1);
      }
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("refund_rule") != m.end() && !m["refund_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule"]));
        refundRule = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule>(model1);
      }
    }
    if (m.find("refund_rule_item") != m.end() && !m["refund_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule_item"]));
        refundRuleItem = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem>(model1);
      }
    }
    if (m.find("sign_rule") != m.end() && !m["sign_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["sign_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sign_rule"]));
        signRule = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule>(model1);
      }
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
    if (m.find("upgrade_rule") != m.end() && !m["upgrade_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_rule"]));
        upgradeRule = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule>(model1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleList() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["image_d_o"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("image_d_o") != m.end() && !m["image_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["image_d_o"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["image_d_o"]));
        imageDO = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<boost::any>> extraContentVisualizes{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (extraContentVisualizes) {
      res["extra_content_visualizes"] = boost::any(*extraContentVisualizes);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("extra_content_visualizes") != m.end() && !m["extra_content_visualizes"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["extra_content_visualizes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_content_visualizes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      extraContentVisualizes = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList : public Darabonba::Model {
public:
  shared_ptr<string> baggageInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem> baggageItem{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule> changeRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem> changeRuleItem{};
  shared_ptr<string> extra{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule> refundRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem> refundRuleItem{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule> signRule{};
  shared_ptr<string> tuigaiqianInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule> upgradeRule{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageInfo) {
      res["baggage_info"] = boost::any(*baggageInfo);
    }
    if (baggageItem) {
      res["baggage_item"] = baggageItem ? boost::any(baggageItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRule) {
      res["change_rule"] = changeRule ? boost::any(changeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRuleItem) {
      res["change_rule_item"] = changeRuleItem ? boost::any(changeRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (refundRule) {
      res["refund_rule"] = refundRule ? boost::any(refundRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundRuleItem) {
      res["refund_rule_item"] = refundRuleItem ? boost::any(refundRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signRule) {
      res["sign_rule"] = signRule ? boost::any(signRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    if (upgradeRule) {
      res["upgrade_rule"] = upgradeRule ? boost::any(upgradeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_info") != m.end() && !m["baggage_info"].empty()) {
      baggageInfo = make_shared<string>(boost::any_cast<string>(m["baggage_info"]));
    }
    if (m.find("baggage_item") != m.end() && !m["baggage_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["baggage_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["baggage_item"]));
        baggageItem = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem>(model1);
      }
    }
    if (m.find("change_rule") != m.end() && !m["change_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule"]));
        changeRule = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule>(model1);
      }
    }
    if (m.find("change_rule_item") != m.end() && !m["change_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule_item"]));
        changeRuleItem = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem>(model1);
      }
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("refund_rule") != m.end() && !m["refund_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule"]));
        refundRule = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule>(model1);
      }
    }
    if (m.find("refund_rule_item") != m.end() && !m["refund_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule_item"]));
        refundRuleItem = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem>(model1);
      }
    }
    if (m.find("sign_rule") != m.end() && !m["sign_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["sign_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sign_rule"]));
        signRule = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule>(model1);
      }
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
    if (m.find("upgrade_rule") != m.end() && !m["upgrade_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_rule"]));
        upgradeRule = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule>(model1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfo : public Darabonba::Model {
public:
  shared_ptr<string> flightSize{};
  shared_ptr<string> flightType{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo> transferAirlineInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo> transferArrAirportInfo{};
  shared_ptr<string> transferArrDate{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo> transferDepAirportInfo{};
  shared_ptr<string> transferDepDate{};
  shared_ptr<string> transferFlightNo{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList>> transferFlightRuleList{};

  FlightSearchListResponseBodyModuleFlightListTransferInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (transferAirlineInfo) {
      res["transfer_airline_info"] = transferAirlineInfo ? boost::any(transferAirlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transferArrAirportInfo) {
      res["transfer_arr_airport_info"] = transferArrAirportInfo ? boost::any(transferArrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transferArrDate) {
      res["transfer_arr_date"] = boost::any(*transferArrDate);
    }
    if (transferDepAirportInfo) {
      res["transfer_dep_airport_info"] = transferDepAirportInfo ? boost::any(transferDepAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transferDepDate) {
      res["transfer_dep_date"] = boost::any(*transferDepDate);
    }
    if (transferFlightNo) {
      res["transfer_flight_no"] = boost::any(*transferFlightNo);
    }
    if (transferFlightRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*transferFlightRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["transfer_flight_rule_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("transfer_airline_info") != m.end() && !m["transfer_airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["transfer_airline_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["transfer_airline_info"]));
        transferAirlineInfo = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo>(model1);
      }
    }
    if (m.find("transfer_arr_airport_info") != m.end() && !m["transfer_arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["transfer_arr_airport_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["transfer_arr_airport_info"]));
        transferArrAirportInfo = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo>(model1);
      }
    }
    if (m.find("transfer_arr_date") != m.end() && !m["transfer_arr_date"].empty()) {
      transferArrDate = make_shared<string>(boost::any_cast<string>(m["transfer_arr_date"]));
    }
    if (m.find("transfer_dep_airport_info") != m.end() && !m["transfer_dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["transfer_dep_airport_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["transfer_dep_airport_info"]));
        transferDepAirportInfo = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo>(model1);
      }
    }
    if (m.find("transfer_dep_date") != m.end() && !m["transfer_dep_date"].empty()) {
      transferDepDate = make_shared<string>(boost::any_cast<string>(m["transfer_dep_date"]));
    }
    if (m.find("transfer_flight_no") != m.end() && !m["transfer_flight_no"].empty()) {
      transferFlightNo = make_shared<string>(boost::any_cast<string>(m["transfer_flight_no"]));
    }
    if (m.find("transfer_flight_rule_list") != m.end() && !m["transfer_flight_rule_list"].empty()) {
      if (typeid(vector<boost::any>) == m["transfer_flight_rule_list"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["transfer_flight_rule_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transferFlightRuleList = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightList : public Darabonba::Model {
public:
  shared_ptr<FlightSearchListResponseBodyModuleFlightListAirlineInfo> airlineInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListArrAirportInfo> arrAirportInfo{};
  shared_ptr<string> arrDate{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoList>> cabinInfoList{};
  shared_ptr<string> carrierAirline{};
  shared_ptr<string> carrierNo{};
  shared_ptr<string> classRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListDepAirportInfo> depAirportInfo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<long> discount{};
  shared_ptr<string> flightNo{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleList>> flightRuleList{};
  shared_ptr<string> flightRuleListStr{};
  shared_ptr<string> flightSize{};
  shared_ptr<string> flightType{};
  shared_ptr<long> invoiceType{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<bool> isShare{};
  shared_ptr<bool> isStop{};
  shared_ptr<bool> isTransfer{};
  shared_ptr<string> mealDesc{};
  shared_ptr<string> memo{};
  shared_ptr<long> oilPrice{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<long> productType{};
  shared_ptr<string> productTypeDesc{};
  shared_ptr<string> promotionPrice{};
  shared_ptr<string> remainedSeatCount{};
  shared_ptr<string> secretParams{};
  shared_ptr<string> segmentNumber{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<string> totalPrice{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfo> transferInfo{};
  shared_ptr<long> tripType{};

  FlightSearchListResponseBodyModuleFlightList() {}

  explicit FlightSearchListResponseBodyModuleFlightList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*cabinInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cabin_info_list"] = boost::any(temp1);
    }
    if (carrierAirline) {
      res["carrier_airline"] = boost::any(*carrierAirline);
    }
    if (carrierNo) {
      res["carrier_no"] = boost::any(*carrierNo);
    }
    if (classRule) {
      res["class_rule"] = boost::any(*classRule);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*flightRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_rule_list"] = boost::any(temp1);
    }
    if (flightRuleListStr) {
      res["flight_rule_list_str"] = boost::any(*flightRuleListStr);
    }
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (isShare) {
      res["is_share"] = boost::any(*isShare);
    }
    if (isStop) {
      res["is_stop"] = boost::any(*isStop);
    }
    if (isTransfer) {
      res["is_transfer"] = boost::any(*isTransfer);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (productType) {
      res["product_type"] = boost::any(*productType);
    }
    if (productTypeDesc) {
      res["product_type_desc"] = boost::any(*productTypeDesc);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (remainedSeatCount) {
      res["remained_seat_count"] = boost::any(*remainedSeatCount);
    }
    if (secretParams) {
      res["secret_params"] = boost::any(*secretParams);
    }
    if (segmentNumber) {
      res["segment_number"] = boost::any(*segmentNumber);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    if (transferInfo) {
      res["transfer_info"] = transferInfo ? boost::any(transferInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<FlightSearchListResponseBodyModuleFlightListAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<FlightSearchListResponseBodyModuleFlightListArrAirportInfo>(model1);
      }
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_info_list") != m.end() && !m["cabin_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["cabin_info_list"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cabin_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cabinInfoList = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoList>>(expect1);
      }
    }
    if (m.find("carrier_airline") != m.end() && !m["carrier_airline"].empty()) {
      carrierAirline = make_shared<string>(boost::any_cast<string>(m["carrier_airline"]));
    }
    if (m.find("carrier_no") != m.end() && !m["carrier_no"].empty()) {
      carrierNo = make_shared<string>(boost::any_cast<string>(m["carrier_no"]));
    }
    if (m.find("class_rule") != m.end() && !m["class_rule"].empty()) {
      classRule = make_shared<string>(boost::any_cast<string>(m["class_rule"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<FlightSearchListResponseBodyModuleFlightListDepAirportInfo>(model1);
      }
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<long>(boost::any_cast<long>(m["discount"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_rule_list") != m.end() && !m["flight_rule_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_rule_list"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_rule_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightRuleList = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleList>>(expect1);
      }
    }
    if (m.find("flight_rule_list_str") != m.end() && !m["flight_rule_list_str"].empty()) {
      flightRuleListStr = make_shared<string>(boost::any_cast<string>(m["flight_rule_list_str"]));
    }
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("is_share") != m.end() && !m["is_share"].empty()) {
      isShare = make_shared<bool>(boost::any_cast<bool>(m["is_share"]));
    }
    if (m.find("is_stop") != m.end() && !m["is_stop"].empty()) {
      isStop = make_shared<bool>(boost::any_cast<bool>(m["is_stop"]));
    }
    if (m.find("is_transfer") != m.end() && !m["is_transfer"].empty()) {
      isTransfer = make_shared<bool>(boost::any_cast<bool>(m["is_transfer"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("product_type") != m.end() && !m["product_type"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["product_type"]));
    }
    if (m.find("product_type_desc") != m.end() && !m["product_type_desc"].empty()) {
      productTypeDesc = make_shared<string>(boost::any_cast<string>(m["product_type_desc"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<string>(boost::any_cast<string>(m["promotion_price"]));
    }
    if (m.find("remained_seat_count") != m.end() && !m["remained_seat_count"].empty()) {
      remainedSeatCount = make_shared<string>(boost::any_cast<string>(m["remained_seat_count"]));
    }
    if (m.find("secret_params") != m.end() && !m["secret_params"].empty()) {
      secretParams = make_shared<string>(boost::any_cast<string>(m["secret_params"]));
    }
    if (m.find("segment_number") != m.end() && !m["segment_number"].empty()) {
      segmentNumber = make_shared<string>(boost::any_cast<string>(m["segment_number"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<string>(boost::any_cast<string>(m["total_price"]));
    }
    if (m.find("transfer_info") != m.end() && !m["transfer_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["transfer_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["transfer_info"]));
        transferInfo = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfo>(model1);
      }
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightList() = default;
};
class FlightSearchListResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightList>> flightList{};
  shared_ptr<bool> isReplacePnr{};

  FlightSearchListResponseBodyModule() {}

  explicit FlightSearchListResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightList) {
      vector<boost::any> temp1;
      for(auto item1:*flightList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_list"] = boost::any(temp1);
    }
    if (isReplacePnr) {
      res["is_replace_pnr"] = boost::any(*isReplacePnr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_list") != m.end() && !m["flight_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_list"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightList = make_shared<vector<FlightSearchListResponseBodyModuleFlightList>>(expect1);
      }
    }
    if (m.find("is_replace_pnr") != m.end() && !m["is_replace_pnr"].empty()) {
      isReplacePnr = make_shared<bool>(boost::any_cast<bool>(m["is_replace_pnr"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModule() = default;
};
class FlightSearchListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightSearchListResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightSearchListResponseBody() {}

  explicit FlightSearchListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightSearchListResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightSearchListResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightSearchListResponseBody() = default;
};
class FlightSearchListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightSearchListResponseBody> body{};

  FlightSearchListResponse() {}

  explicit FlightSearchListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightSearchListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightSearchListResponseBody>(model1);
      }
    }
  }


  virtual ~FlightSearchListResponse() = default;
};
class HotelBillSettlementQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  HotelBillSettlementQueryHeaders() {}

  explicit HotelBillSettlementQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~HotelBillSettlementQueryHeaders() = default;
};
class HotelBillSettlementQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};

  HotelBillSettlementQueryRequest() {}

  explicit HotelBillSettlementQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
  }


  virtual ~HotelBillSettlementQueryRequest() = default;
};
class HotelBillSettlementQueryResponseBodyModuleDataList : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> applyId{};
  shared_ptr<string> billRecordTime{};
  shared_ptr<string> bookTime{};
  shared_ptr<string> bookerId{};
  shared_ptr<string> bookerJobNo{};
  shared_ptr<string> bookerName{};
  shared_ptr<string> capitalDirection{};
  shared_ptr<string> cascadeDepartment{};
  shared_ptr<string> checkInDate{};
  shared_ptr<string> checkoutDate{};
  shared_ptr<string> city{};
  shared_ptr<string> cityCode{};
  shared_ptr<double> corpRefundFee{};
  shared_ptr<double> corpTotalFee{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<string> department{};
  shared_ptr<string> departmentId{};
  shared_ptr<string> feeType{};
  shared_ptr<double> fees{};
  shared_ptr<double> fuPointFee{};
  shared_ptr<string> hotelName{};
  shared_ptr<string> index{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> isNegotiation{};
  shared_ptr<string> isShareStr{};
  shared_ptr<long> nights{};
  shared_ptr<string> orderId{};
  shared_ptr<double> orderPrice{};
  shared_ptr<string> orderType{};
  shared_ptr<string> overApplyId{};
  shared_ptr<double> personRefundFee{};
  shared_ptr<double> personSettlePrice{};
  shared_ptr<long> primaryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<double> promotionFee{};
  shared_ptr<string> remark{};
  shared_ptr<long> roomNumber{};
  shared_ptr<double> roomPrice{};
  shared_ptr<string> roomType{};
  shared_ptr<double> serviceFee{};
  shared_ptr<double> settlementFee{};
  shared_ptr<double> settlementGrantFee{};
  shared_ptr<string> settlementTime{};
  shared_ptr<string> settlementType{};
  shared_ptr<long> status{};
  shared_ptr<long> totalNights{};
  shared_ptr<string> travelerId{};
  shared_ptr<string> travelerJobNo{};
  shared_ptr<string> travelerName{};
  shared_ptr<long> voucherType{};

  HotelBillSettlementQueryResponseBodyModuleDataList() {}

  explicit HotelBillSettlementQueryResponseBodyModuleDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (billRecordTime) {
      res["bill_record_time"] = boost::any(*billRecordTime);
    }
    if (bookTime) {
      res["book_time"] = boost::any(*bookTime);
    }
    if (bookerId) {
      res["booker_id"] = boost::any(*bookerId);
    }
    if (bookerJobNo) {
      res["booker_job_no"] = boost::any(*bookerJobNo);
    }
    if (bookerName) {
      res["booker_name"] = boost::any(*bookerName);
    }
    if (capitalDirection) {
      res["capital_direction"] = boost::any(*capitalDirection);
    }
    if (cascadeDepartment) {
      res["cascade_department"] = boost::any(*cascadeDepartment);
    }
    if (checkInDate) {
      res["check_in_date"] = boost::any(*checkInDate);
    }
    if (checkoutDate) {
      res["checkout_date"] = boost::any(*checkoutDate);
    }
    if (city) {
      res["city"] = boost::any(*city);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (corpRefundFee) {
      res["corp_refund_fee"] = boost::any(*corpRefundFee);
    }
    if (corpTotalFee) {
      res["corp_total_fee"] = boost::any(*corpTotalFee);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (departmentId) {
      res["department_id"] = boost::any(*departmentId);
    }
    if (feeType) {
      res["fee_type"] = boost::any(*feeType);
    }
    if (fees) {
      res["fees"] = boost::any(*fees);
    }
    if (fuPointFee) {
      res["fu_point_fee"] = boost::any(*fuPointFee);
    }
    if (hotelName) {
      res["hotel_name"] = boost::any(*hotelName);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (isNegotiation) {
      res["is_negotiation"] = boost::any(*isNegotiation);
    }
    if (isShareStr) {
      res["is_share_str"] = boost::any(*isShareStr);
    }
    if (nights) {
      res["nights"] = boost::any(*nights);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderPrice) {
      res["order_price"] = boost::any(*orderPrice);
    }
    if (orderType) {
      res["order_type"] = boost::any(*orderType);
    }
    if (overApplyId) {
      res["over_apply_id"] = boost::any(*overApplyId);
    }
    if (personRefundFee) {
      res["person_refund_fee"] = boost::any(*personRefundFee);
    }
    if (personSettlePrice) {
      res["person_settle_price"] = boost::any(*personSettlePrice);
    }
    if (primaryId) {
      res["primary_id"] = boost::any(*primaryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (promotionFee) {
      res["promotion_fee"] = boost::any(*promotionFee);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (roomNumber) {
      res["room_number"] = boost::any(*roomNumber);
    }
    if (roomPrice) {
      res["room_price"] = boost::any(*roomPrice);
    }
    if (roomType) {
      res["room_type"] = boost::any(*roomType);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (settlementFee) {
      res["settlement_fee"] = boost::any(*settlementFee);
    }
    if (settlementGrantFee) {
      res["settlement_grant_fee"] = boost::any(*settlementGrantFee);
    }
    if (settlementTime) {
      res["settlement_time"] = boost::any(*settlementTime);
    }
    if (settlementType) {
      res["settlement_type"] = boost::any(*settlementType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (totalNights) {
      res["total_nights"] = boost::any(*totalNights);
    }
    if (travelerId) {
      res["traveler_id"] = boost::any(*travelerId);
    }
    if (travelerJobNo) {
      res["traveler_job_no"] = boost::any(*travelerJobNo);
    }
    if (travelerName) {
      res["traveler_name"] = boost::any(*travelerName);
    }
    if (voucherType) {
      res["voucher_type"] = boost::any(*voucherType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("bill_record_time") != m.end() && !m["bill_record_time"].empty()) {
      billRecordTime = make_shared<string>(boost::any_cast<string>(m["bill_record_time"]));
    }
    if (m.find("book_time") != m.end() && !m["book_time"].empty()) {
      bookTime = make_shared<string>(boost::any_cast<string>(m["book_time"]));
    }
    if (m.find("booker_id") != m.end() && !m["booker_id"].empty()) {
      bookerId = make_shared<string>(boost::any_cast<string>(m["booker_id"]));
    }
    if (m.find("booker_job_no") != m.end() && !m["booker_job_no"].empty()) {
      bookerJobNo = make_shared<string>(boost::any_cast<string>(m["booker_job_no"]));
    }
    if (m.find("booker_name") != m.end() && !m["booker_name"].empty()) {
      bookerName = make_shared<string>(boost::any_cast<string>(m["booker_name"]));
    }
    if (m.find("capital_direction") != m.end() && !m["capital_direction"].empty()) {
      capitalDirection = make_shared<string>(boost::any_cast<string>(m["capital_direction"]));
    }
    if (m.find("cascade_department") != m.end() && !m["cascade_department"].empty()) {
      cascadeDepartment = make_shared<string>(boost::any_cast<string>(m["cascade_department"]));
    }
    if (m.find("check_in_date") != m.end() && !m["check_in_date"].empty()) {
      checkInDate = make_shared<string>(boost::any_cast<string>(m["check_in_date"]));
    }
    if (m.find("checkout_date") != m.end() && !m["checkout_date"].empty()) {
      checkoutDate = make_shared<string>(boost::any_cast<string>(m["checkout_date"]));
    }
    if (m.find("city") != m.end() && !m["city"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["city"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("corp_refund_fee") != m.end() && !m["corp_refund_fee"].empty()) {
      corpRefundFee = make_shared<double>(boost::any_cast<double>(m["corp_refund_fee"]));
    }
    if (m.find("corp_total_fee") != m.end() && !m["corp_total_fee"].empty()) {
      corpTotalFee = make_shared<double>(boost::any_cast<double>(m["corp_total_fee"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("department_id") != m.end() && !m["department_id"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["department_id"]));
    }
    if (m.find("fee_type") != m.end() && !m["fee_type"].empty()) {
      feeType = make_shared<string>(boost::any_cast<string>(m["fee_type"]));
    }
    if (m.find("fees") != m.end() && !m["fees"].empty()) {
      fees = make_shared<double>(boost::any_cast<double>(m["fees"]));
    }
    if (m.find("fu_point_fee") != m.end() && !m["fu_point_fee"].empty()) {
      fuPointFee = make_shared<double>(boost::any_cast<double>(m["fu_point_fee"]));
    }
    if (m.find("hotel_name") != m.end() && !m["hotel_name"].empty()) {
      hotelName = make_shared<string>(boost::any_cast<string>(m["hotel_name"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("is_negotiation") != m.end() && !m["is_negotiation"].empty()) {
      isNegotiation = make_shared<string>(boost::any_cast<string>(m["is_negotiation"]));
    }
    if (m.find("is_share_str") != m.end() && !m["is_share_str"].empty()) {
      isShareStr = make_shared<string>(boost::any_cast<string>(m["is_share_str"]));
    }
    if (m.find("nights") != m.end() && !m["nights"].empty()) {
      nights = make_shared<long>(boost::any_cast<long>(m["nights"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("order_price") != m.end() && !m["order_price"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["order_price"]));
    }
    if (m.find("order_type") != m.end() && !m["order_type"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["order_type"]));
    }
    if (m.find("over_apply_id") != m.end() && !m["over_apply_id"].empty()) {
      overApplyId = make_shared<string>(boost::any_cast<string>(m["over_apply_id"]));
    }
    if (m.find("person_refund_fee") != m.end() && !m["person_refund_fee"].empty()) {
      personRefundFee = make_shared<double>(boost::any_cast<double>(m["person_refund_fee"]));
    }
    if (m.find("person_settle_price") != m.end() && !m["person_settle_price"].empty()) {
      personSettlePrice = make_shared<double>(boost::any_cast<double>(m["person_settle_price"]));
    }
    if (m.find("primary_id") != m.end() && !m["primary_id"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["primary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("promotion_fee") != m.end() && !m["promotion_fee"].empty()) {
      promotionFee = make_shared<double>(boost::any_cast<double>(m["promotion_fee"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("room_number") != m.end() && !m["room_number"].empty()) {
      roomNumber = make_shared<long>(boost::any_cast<long>(m["room_number"]));
    }
    if (m.find("room_price") != m.end() && !m["room_price"].empty()) {
      roomPrice = make_shared<double>(boost::any_cast<double>(m["room_price"]));
    }
    if (m.find("room_type") != m.end() && !m["room_type"].empty()) {
      roomType = make_shared<string>(boost::any_cast<string>(m["room_type"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("settlement_fee") != m.end() && !m["settlement_fee"].empty()) {
      settlementFee = make_shared<double>(boost::any_cast<double>(m["settlement_fee"]));
    }
    if (m.find("settlement_grant_fee") != m.end() && !m["settlement_grant_fee"].empty()) {
      settlementGrantFee = make_shared<double>(boost::any_cast<double>(m["settlement_grant_fee"]));
    }
    if (m.find("settlement_time") != m.end() && !m["settlement_time"].empty()) {
      settlementTime = make_shared<string>(boost::any_cast<string>(m["settlement_time"]));
    }
    if (m.find("settlement_type") != m.end() && !m["settlement_type"].empty()) {
      settlementType = make_shared<string>(boost::any_cast<string>(m["settlement_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("total_nights") != m.end() && !m["total_nights"].empty()) {
      totalNights = make_shared<long>(boost::any_cast<long>(m["total_nights"]));
    }
    if (m.find("traveler_id") != m.end() && !m["traveler_id"].empty()) {
      travelerId = make_shared<string>(boost::any_cast<string>(m["traveler_id"]));
    }
    if (m.find("traveler_job_no") != m.end() && !m["traveler_job_no"].empty()) {
      travelerJobNo = make_shared<string>(boost::any_cast<string>(m["traveler_job_no"]));
    }
    if (m.find("traveler_name") != m.end() && !m["traveler_name"].empty()) {
      travelerName = make_shared<string>(boost::any_cast<string>(m["traveler_name"]));
    }
    if (m.find("voucher_type") != m.end() && !m["voucher_type"].empty()) {
      voucherType = make_shared<long>(boost::any_cast<long>(m["voucher_type"]));
    }
  }


  virtual ~HotelBillSettlementQueryResponseBodyModuleDataList() = default;
};
class HotelBillSettlementQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> category{};
  shared_ptr<string> corpId{};
  shared_ptr<vector<HotelBillSettlementQueryResponseBodyModuleDataList>> dataList{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};
  shared_ptr<long> totalNum{};

  HotelBillSettlementQueryResponseBodyModule() {}

  explicit HotelBillSettlementQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_list"] = boost::any(temp1);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    if (totalNum) {
      res["total_num"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["category"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("data_list") != m.end() && !m["data_list"].empty()) {
      if (typeid(vector<boost::any>) == m["data_list"].type()) {
        vector<HotelBillSettlementQueryResponseBodyModuleDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelBillSettlementQueryResponseBodyModuleDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<HotelBillSettlementQueryResponseBodyModuleDataList>>(expect1);
      }
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
    if (m.find("total_num") != m.end() && !m["total_num"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["total_num"]));
    }
  }


  virtual ~HotelBillSettlementQueryResponseBodyModule() = default;
};
class HotelBillSettlementQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelBillSettlementQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelBillSettlementQueryResponseBody() {}

  explicit HotelBillSettlementQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelBillSettlementQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelBillSettlementQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelBillSettlementQueryResponseBody() = default;
};
class HotelBillSettlementQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelBillSettlementQueryResponseBody> body{};

  HotelBillSettlementQueryResponse() {}

  explicit HotelBillSettlementQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelBillSettlementQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelBillSettlementQueryResponseBody>(model1);
      }
    }
  }


  virtual ~HotelBillSettlementQueryResponse() = default;
};
class HotelExceedApplyQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  HotelExceedApplyQueryHeaders() {}

  explicit HotelExceedApplyQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~HotelExceedApplyQueryHeaders() = default;
};
class HotelExceedApplyQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};

  HotelExceedApplyQueryRequest() {}

  explicit HotelExceedApplyQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
  }


  virtual ~HotelExceedApplyQueryRequest() = default;
};
class HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo : public Darabonba::Model {
public:
  shared_ptr<string> checkIn{};
  shared_ptr<string> checkOut{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> price{};
  shared_ptr<bool> together{};
  shared_ptr<long> type{};

  HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo() {}

  explicit HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (together) {
      res["together"] = boost::any(*together);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<string>(boost::any_cast<string>(m["check_out"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("together") != m.end() && !m["together"].empty()) {
      together = make_shared<bool>(boost::any_cast<bool>(m["together"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo() = default;
};
class HotelExceedApplyQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo> applyIntentionInfoDo{};
  shared_ptr<string> btripCause{};
  shared_ptr<string> corpId{};
  shared_ptr<string> exceedReason{};
  shared_ptr<long> exceedType{};
  shared_ptr<string> originStandard{};
  shared_ptr<long> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartCorpId{};
  shared_ptr<string> userId{};

  HotelExceedApplyQueryResponseBodyModule() {}

  explicit HotelExceedApplyQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (applyIntentionInfoDo) {
      res["apply_intention_info_do"] = applyIntentionInfoDo ? boost::any(applyIntentionInfoDo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (btripCause) {
      res["btrip_cause"] = boost::any(*btripCause);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (exceedReason) {
      res["exceed_reason"] = boost::any(*exceedReason);
    }
    if (exceedType) {
      res["exceed_type"] = boost::any(*exceedType);
    }
    if (originStandard) {
      res["origin_standard"] = boost::any(*originStandard);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (submitTime) {
      res["submit_time"] = boost::any(*submitTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartCorpId) {
      res["thirdpart_corp_id"] = boost::any(*thirdpartCorpId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("apply_intention_info_do") != m.end() && !m["apply_intention_info_do"].empty()) {
      if (typeid(map<string, boost::any>) == m["apply_intention_info_do"].type()) {
        HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["apply_intention_info_do"]));
        applyIntentionInfoDo = make_shared<HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo>(model1);
      }
    }
    if (m.find("btrip_cause") != m.end() && !m["btrip_cause"].empty()) {
      btripCause = make_shared<string>(boost::any_cast<string>(m["btrip_cause"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("exceed_reason") != m.end() && !m["exceed_reason"].empty()) {
      exceedReason = make_shared<string>(boost::any_cast<string>(m["exceed_reason"]));
    }
    if (m.find("exceed_type") != m.end() && !m["exceed_type"].empty()) {
      exceedType = make_shared<long>(boost::any_cast<long>(m["exceed_type"]));
    }
    if (m.find("origin_standard") != m.end() && !m["origin_standard"].empty()) {
      originStandard = make_shared<string>(boost::any_cast<string>(m["origin_standard"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("submit_time") != m.end() && !m["submit_time"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["submit_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_corp_id") != m.end() && !m["thirdpart_corp_id"].empty()) {
      thirdpartCorpId = make_shared<string>(boost::any_cast<string>(m["thirdpart_corp_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~HotelExceedApplyQueryResponseBodyModule() = default;
};
class HotelExceedApplyQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelExceedApplyQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelExceedApplyQueryResponseBody() {}

  explicit HotelExceedApplyQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelExceedApplyQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelExceedApplyQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelExceedApplyQueryResponseBody() = default;
};
class HotelExceedApplyQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelExceedApplyQueryResponseBody> body{};

  HotelExceedApplyQueryResponse() {}

  explicit HotelExceedApplyQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelExceedApplyQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelExceedApplyQueryResponseBody>(model1);
      }
    }
  }


  virtual ~HotelExceedApplyQueryResponse() = default;
};
class HotelOrderListQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  HotelOrderListQueryHeaders() {}

  explicit HotelOrderListQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~HotelOrderListQueryHeaders() = default;
};
class HotelOrderListQueryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allApply{};
  shared_ptr<long> applyId{};
  shared_ptr<string> departId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> updateEndTime{};
  shared_ptr<string> updateStartTime{};
  shared_ptr<string> userId{};

  HotelOrderListQueryRequest() {}

  explicit HotelOrderListQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allApply) {
      res["all_apply"] = boost::any(*allApply);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (updateEndTime) {
      res["update_end_time"] = boost::any(*updateEndTime);
    }
    if (updateStartTime) {
      res["update_start_time"] = boost::any(*updateStartTime);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_apply") != m.end() && !m["all_apply"].empty()) {
      allApply = make_shared<bool>(boost::any_cast<bool>(m["all_apply"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("update_end_time") != m.end() && !m["update_end_time"].empty()) {
      updateEndTime = make_shared<string>(boost::any_cast<string>(m["update_end_time"]));
    }
    if (m.find("update_start_time") != m.end() && !m["update_start_time"].empty()) {
      updateStartTime = make_shared<string>(boost::any_cast<string>(m["update_start_time"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~HotelOrderListQueryRequest() = default;
};
class HotelOrderListQueryResponseBodyModuleCostCenter : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> number{};

  HotelOrderListQueryResponseBodyModuleCostCenter() {}

  explicit HotelOrderListQueryResponseBodyModuleCostCenter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (number) {
      res["number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("number") != m.end() && !m["number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["number"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBodyModuleCostCenter() = default;
};
class HotelOrderListQueryResponseBodyModuleInvoice : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> invoiceType{};
  shared_ptr<string> title{};

  HotelOrderListQueryResponseBodyModuleInvoice() {}

  explicit HotelOrderListQueryResponseBodyModuleInvoice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBodyModuleInvoice() = default;
};
class HotelOrderListQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<long> categoryType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  HotelOrderListQueryResponseBodyModulePriceInfoList() {}

  explicit HotelOrderListQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (categoryType) {
      res["category_type"] = boost::any(*categoryType);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("category_type") != m.end() && !m["category_type"].empty()) {
      categoryType = make_shared<long>(boost::any_cast<long>(m["category_type"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBodyModulePriceInfoList() = default;
};
class HotelOrderListQueryResponseBodyModuleUserAffiliateList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  HotelOrderListQueryResponseBodyModuleUserAffiliateList() {}

  explicit HotelOrderListQueryResponseBodyModuleUserAffiliateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBodyModuleUserAffiliateList() = default;
};
class HotelOrderListQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> checkIn{};
  shared_ptr<string> checkOut{};
  shared_ptr<string> city{};
  shared_ptr<string> contactName{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<HotelOrderListQueryResponseBodyModuleCostCenter> costCenter{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> guest{};
  shared_ptr<string> hotelName{};
  shared_ptr<long> hotelSupportVatInvoiceType{};
  shared_ptr<long> id{};
  shared_ptr<HotelOrderListQueryResponseBodyModuleInvoice> invoice{};
  shared_ptr<long> night{};
  shared_ptr<long> orderStatus{};
  shared_ptr<string> orderStatusDesc{};
  shared_ptr<long> orderType{};
  shared_ptr<string> orderTypeDesc{};
  shared_ptr<vector<HotelOrderListQueryResponseBodyModulePriceInfoList>> priceInfoList{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<long> roomNum{};
  shared_ptr<string> roomType{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<string> thirdpartProjectId{};
  shared_ptr<vector<HotelOrderListQueryResponseBodyModuleUserAffiliateList>> userAffiliateList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  HotelOrderListQueryResponseBodyModule() {}

  explicit HotelOrderListQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (city) {
      res["city"] = boost::any(*city);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (costCenter) {
      res["cost_center"] = costCenter ? boost::any(costCenter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (guest) {
      res["guest"] = boost::any(*guest);
    }
    if (hotelName) {
      res["hotel_name"] = boost::any(*hotelName);
    }
    if (hotelSupportVatInvoiceType) {
      res["hotel_support_vat_invoice_type"] = boost::any(*hotelSupportVatInvoiceType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (invoice) {
      res["invoice"] = invoice ? boost::any(invoice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (night) {
      res["night"] = boost::any(*night);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (orderStatusDesc) {
      res["order_status_desc"] = boost::any(*orderStatusDesc);
    }
    if (orderType) {
      res["order_type"] = boost::any(*orderType);
    }
    if (orderTypeDesc) {
      res["order_type_desc"] = boost::any(*orderTypeDesc);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (roomNum) {
      res["room_num"] = boost::any(*roomNum);
    }
    if (roomType) {
      res["room_type"] = boost::any(*roomType);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (thirdpartProjectId) {
      res["thirdpart_project_id"] = boost::any(*thirdpartProjectId);
    }
    if (userAffiliateList) {
      vector<boost::any> temp1;
      for(auto item1:*userAffiliateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["user_affiliate_list"] = boost::any(temp1);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<string>(boost::any_cast<string>(m["check_out"]));
    }
    if (m.find("city") != m.end() && !m["city"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["city"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      if (typeid(map<string, boost::any>) == m["cost_center"].type()) {
        HotelOrderListQueryResponseBodyModuleCostCenter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cost_center"]));
        costCenter = make_shared<HotelOrderListQueryResponseBodyModuleCostCenter>(model1);
      }
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("guest") != m.end() && !m["guest"].empty()) {
      guest = make_shared<string>(boost::any_cast<string>(m["guest"]));
    }
    if (m.find("hotel_name") != m.end() && !m["hotel_name"].empty()) {
      hotelName = make_shared<string>(boost::any_cast<string>(m["hotel_name"]));
    }
    if (m.find("hotel_support_vat_invoice_type") != m.end() && !m["hotel_support_vat_invoice_type"].empty()) {
      hotelSupportVatInvoiceType = make_shared<long>(boost::any_cast<long>(m["hotel_support_vat_invoice_type"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("invoice") != m.end() && !m["invoice"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice"].type()) {
        HotelOrderListQueryResponseBodyModuleInvoice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice"]));
        invoice = make_shared<HotelOrderListQueryResponseBodyModuleInvoice>(model1);
      }
    }
    if (m.find("night") != m.end() && !m["night"].empty()) {
      night = make_shared<long>(boost::any_cast<long>(m["night"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("order_status_desc") != m.end() && !m["order_status_desc"].empty()) {
      orderStatusDesc = make_shared<string>(boost::any_cast<string>(m["order_status_desc"]));
    }
    if (m.find("order_type") != m.end() && !m["order_type"].empty()) {
      orderType = make_shared<long>(boost::any_cast<long>(m["order_type"]));
    }
    if (m.find("order_type_desc") != m.end() && !m["order_type_desc"].empty()) {
      orderTypeDesc = make_shared<string>(boost::any_cast<string>(m["order_type_desc"]));
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<HotelOrderListQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderListQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<HotelOrderListQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("room_num") != m.end() && !m["room_num"].empty()) {
      roomNum = make_shared<long>(boost::any_cast<long>(m["room_num"]));
    }
    if (m.find("room_type") != m.end() && !m["room_type"].empty()) {
      roomType = make_shared<string>(boost::any_cast<string>(m["room_type"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("thirdpart_project_id") != m.end() && !m["thirdpart_project_id"].empty()) {
      thirdpartProjectId = make_shared<string>(boost::any_cast<string>(m["thirdpart_project_id"]));
    }
    if (m.find("user_affiliate_list") != m.end() && !m["user_affiliate_list"].empty()) {
      if (typeid(vector<boost::any>) == m["user_affiliate_list"].type()) {
        vector<HotelOrderListQueryResponseBodyModuleUserAffiliateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["user_affiliate_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderListQueryResponseBodyModuleUserAffiliateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userAffiliateList = make_shared<vector<HotelOrderListQueryResponseBodyModuleUserAffiliateList>>(expect1);
      }
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBodyModule() = default;
};
class HotelOrderListQueryResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalNumber{};

  HotelOrderListQueryResponseBodyPageInfo() {}

  explicit HotelOrderListQueryResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalNumber) {
      res["total_number"] = boost::any(*totalNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_number") != m.end() && !m["total_number"].empty()) {
      totalNumber = make_shared<long>(boost::any_cast<long>(m["total_number"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBodyPageInfo() = default;
};
class HotelOrderListQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<HotelOrderListQueryResponseBodyModule>> module{};
  shared_ptr<HotelOrderListQueryResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelOrderListQueryResponseBody() {}

  explicit HotelOrderListQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<HotelOrderListQueryResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderListQueryResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<HotelOrderListQueryResponseBodyModule>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        HotelOrderListQueryResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<HotelOrderListQueryResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBody() = default;
};
class HotelOrderListQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelOrderListQueryResponseBody> body{};

  HotelOrderListQueryResponse() {}

  explicit HotelOrderListQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelOrderListQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelOrderListQueryResponseBody>(model1);
      }
    }
  }


  virtual ~HotelOrderListQueryResponse() = default;
};
class HotelOrderQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  HotelOrderQueryHeaders() {}

  explicit HotelOrderQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~HotelOrderQueryHeaders() = default;
};
class HotelOrderQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};

  HotelOrderQueryRequest() {}

  explicit HotelOrderQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
  }


  virtual ~HotelOrderQueryRequest() = default;
};
class HotelOrderQueryResponseBodyModuleHotelInfo : public Darabonba::Model {
public:
  shared_ptr<long> checkIn{};
  shared_ptr<long> checkOut{};
  shared_ptr<string> city{};
  shared_ptr<string> hotelName{};
  shared_ptr<long> hotelSupportVatInvoiceType{};
  shared_ptr<long> night{};
  shared_ptr<long> roomNum{};
  shared_ptr<string> roomType{};

  HotelOrderQueryResponseBodyModuleHotelInfo() {}

  explicit HotelOrderQueryResponseBodyModuleHotelInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (city) {
      res["city"] = boost::any(*city);
    }
    if (hotelName) {
      res["hotel_name"] = boost::any(*hotelName);
    }
    if (hotelSupportVatInvoiceType) {
      res["hotel_support_vat_invoice_type"] = boost::any(*hotelSupportVatInvoiceType);
    }
    if (night) {
      res["night"] = boost::any(*night);
    }
    if (roomNum) {
      res["room_num"] = boost::any(*roomNum);
    }
    if (roomType) {
      res["room_type"] = boost::any(*roomType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<long>(boost::any_cast<long>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<long>(boost::any_cast<long>(m["check_out"]));
    }
    if (m.find("city") != m.end() && !m["city"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["city"]));
    }
    if (m.find("hotel_name") != m.end() && !m["hotel_name"].empty()) {
      hotelName = make_shared<string>(boost::any_cast<string>(m["hotel_name"]));
    }
    if (m.find("hotel_support_vat_invoice_type") != m.end() && !m["hotel_support_vat_invoice_type"].empty()) {
      hotelSupportVatInvoiceType = make_shared<long>(boost::any_cast<long>(m["hotel_support_vat_invoice_type"]));
    }
    if (m.find("night") != m.end() && !m["night"].empty()) {
      night = make_shared<long>(boost::any_cast<long>(m["night"]));
    }
    if (m.find("room_num") != m.end() && !m["room_num"].empty()) {
      roomNum = make_shared<long>(boost::any_cast<long>(m["room_num"]));
    }
    if (m.find("room_type") != m.end() && !m["room_type"].empty()) {
      roomType = make_shared<string>(boost::any_cast<string>(m["room_type"]));
    }
  }


  virtual ~HotelOrderQueryResponseBodyModuleHotelInfo() = default;
};
class HotelOrderQueryResponseBodyModuleInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  HotelOrderQueryResponseBodyModuleInvoiceInfo() {}

  explicit HotelOrderQueryResponseBodyModuleInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~HotelOrderQueryResponseBodyModuleInvoiceInfo() = default;
};
class HotelOrderQueryResponseBodyModuleOrderBaseInfo : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> orderStatus{};
  shared_ptr<long> orderType{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartDepartId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  HotelOrderQueryResponseBodyModuleOrderBaseInfo() {}

  explicit HotelOrderQueryResponseBodyModuleOrderBaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (orderType) {
      res["order_type"] = boost::any(*orderType);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartDepartId) {
      res["thirdpart_depart_id"] = boost::any(*thirdpartDepartId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmt_modified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("order_type") != m.end() && !m["order_type"].empty()) {
      orderType = make_shared<long>(boost::any_cast<long>(m["order_type"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_depart_id") != m.end() && !m["thirdpart_depart_id"].empty()) {
      thirdpartDepartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_depart_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~HotelOrderQueryResponseBodyModuleOrderBaseInfo() = default;
};
class HotelOrderQueryResponseBodyModulePassengerList : public Darabonba::Model {
public:
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<string> thirdpartProjectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> userType{};

  HotelOrderQueryResponseBodyModulePassengerList() {}

  explicit HotelOrderQueryResponseBodyModulePassengerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (thirdpartProjectId) {
      res["thirdpart_project_id"] = boost::any(*thirdpartProjectId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("thirdpart_project_id") != m.end() && !m["thirdpart_project_id"].empty()) {
      thirdpartProjectId = make_shared<string>(boost::any_cast<string>(m["thirdpart_project_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~HotelOrderQueryResponseBodyModulePassengerList() = default;
};
class HotelOrderQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  HotelOrderQueryResponseBodyModulePriceInfoList() {}

  explicit HotelOrderQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmt_create"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~HotelOrderQueryResponseBodyModulePriceInfoList() = default;
};
class HotelOrderQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<HotelOrderQueryResponseBodyModuleHotelInfo> hotelInfo{};
  shared_ptr<HotelOrderQueryResponseBodyModuleInvoiceInfo> invoiceInfo{};
  shared_ptr<HotelOrderQueryResponseBodyModuleOrderBaseInfo> orderBaseInfo{};
  shared_ptr<vector<HotelOrderQueryResponseBodyModulePassengerList>> passengerList{};
  shared_ptr<vector<HotelOrderQueryResponseBodyModulePriceInfoList>> priceInfoList{};

  HotelOrderQueryResponseBodyModule() {}

  explicit HotelOrderQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelInfo) {
      res["hotel_info"] = hotelInfo ? boost::any(hotelInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invoiceInfo) {
      res["invoice_info"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderBaseInfo) {
      res["order_base_info"] = orderBaseInfo ? boost::any(orderBaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passengerList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_list"] = boost::any(temp1);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_info") != m.end() && !m["hotel_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["hotel_info"].type()) {
        HotelOrderQueryResponseBodyModuleHotelInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["hotel_info"]));
        hotelInfo = make_shared<HotelOrderQueryResponseBodyModuleHotelInfo>(model1);
      }
    }
    if (m.find("invoice_info") != m.end() && !m["invoice_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice_info"].type()) {
        HotelOrderQueryResponseBodyModuleInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice_info"]));
        invoiceInfo = make_shared<HotelOrderQueryResponseBodyModuleInvoiceInfo>(model1);
      }
    }
    if (m.find("order_base_info") != m.end() && !m["order_base_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["order_base_info"].type()) {
        HotelOrderQueryResponseBodyModuleOrderBaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["order_base_info"]));
        orderBaseInfo = make_shared<HotelOrderQueryResponseBodyModuleOrderBaseInfo>(model1);
      }
    }
    if (m.find("passenger_list") != m.end() && !m["passenger_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_list"].type()) {
        vector<HotelOrderQueryResponseBodyModulePassengerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderQueryResponseBodyModulePassengerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerList = make_shared<vector<HotelOrderQueryResponseBodyModulePassengerList>>(expect1);
      }
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<HotelOrderQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<HotelOrderQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
  }


  virtual ~HotelOrderQueryResponseBodyModule() = default;
};
class HotelOrderQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelOrderQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelOrderQueryResponseBody() {}

  explicit HotelOrderQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelOrderQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelOrderQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelOrderQueryResponseBody() = default;
};
class HotelOrderQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelOrderQueryResponseBody> body{};

  HotelOrderQueryResponse() {}

  explicit HotelOrderQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelOrderQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelOrderQueryResponseBody>(model1);
      }
    }
  }


  virtual ~HotelOrderQueryResponse() = default;
};
class IeFlightBillSettlementQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  IeFlightBillSettlementQueryHeaders() {}

  explicit IeFlightBillSettlementQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~IeFlightBillSettlementQueryHeaders() = default;
};
class IeFlightBillSettlementQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};

  IeFlightBillSettlementQueryRequest() {}

  explicit IeFlightBillSettlementQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
  }


  virtual ~IeFlightBillSettlementQueryRequest() = default;
};
class IeFlightBillSettlementQueryResponseBodyModuleDataList : public Darabonba::Model {
public:
  shared_ptr<long> advanceDay{};
  shared_ptr<string> airlineCorpCode{};
  shared_ptr<string> airlineCorpName{};
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> applyId{};
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> arrStation{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> billRecordTime{};
  shared_ptr<string> bookMode{};
  shared_ptr<string> bookTime{};
  shared_ptr<string> bookerId{};
  shared_ptr<string> bookerJobNo{};
  shared_ptr<string> bookerName{};
  shared_ptr<double> btripCouponFee{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> capitalDirection{};
  shared_ptr<string> cascadeDepartment{};
  shared_ptr<double> changeFee{};
  shared_ptr<double> corpPayOrderFee{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<double> coupon{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> department{};
  shared_ptr<string> departmentId{};
  shared_ptr<string> deptCity{};
  shared_ptr<string> deptDate{};
  shared_ptr<string> deptStation{};
  shared_ptr<string> deptTime{};
  shared_ptr<string> discount{};
  shared_ptr<string> feeType{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> index{};
  shared_ptr<double> insuranceFee{};
  shared_ptr<string> insuranceNumber{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> mostDifferenceDeptTime{};
  shared_ptr<string> mostDifferenceDiscount{};
  shared_ptr<string> mostDifferenceFlightNo{};
  shared_ptr<double> mostDifferencePrice{};
  shared_ptr<string> mostDifferenceReason{};
  shared_ptr<double> mostPrice{};
  shared_ptr<double> negotiationCouponFee{};
  shared_ptr<string> orderId{};
  shared_ptr<string> orderStatusDesc{};
  shared_ptr<string> overApplyId{};
  shared_ptr<long> primaryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<double> refundFee{};
  shared_ptr<string> remark{};
  shared_ptr<string> repeatRefund{};
  shared_ptr<double> sealPrice{};
  shared_ptr<string> segmentType{};
  shared_ptr<double> serviceFee{};
  shared_ptr<double> settlementFee{};
  shared_ptr<double> settlementGrantFee{};
  shared_ptr<string> settlementTime{};
  shared_ptr<string> settlementType{};
  shared_ptr<long> status{};
  shared_ptr<string> subOrderId{};
  shared_ptr<double> taxFee{};
  shared_ptr<string> ticketId{};
  shared_ptr<string> trade{};
  shared_ptr<string> travelerId{};
  shared_ptr<string> travelerJobNo{};
  shared_ptr<string> travelerName{};
  shared_ptr<long> voucherType{};

  IeFlightBillSettlementQueryResponseBodyModuleDataList() {}

  explicit IeFlightBillSettlementQueryResponseBodyModuleDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advanceDay) {
      res["advance_day"] = boost::any(*advanceDay);
    }
    if (airlineCorpCode) {
      res["airline_corp_code"] = boost::any(*airlineCorpCode);
    }
    if (airlineCorpName) {
      res["airline_corp_name"] = boost::any(*airlineCorpName);
    }
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (arrStation) {
      res["arr_station"] = boost::any(*arrStation);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (billRecordTime) {
      res["bill_record_time"] = boost::any(*billRecordTime);
    }
    if (bookMode) {
      res["book_mode"] = boost::any(*bookMode);
    }
    if (bookTime) {
      res["book_time"] = boost::any(*bookTime);
    }
    if (bookerId) {
      res["booker_id"] = boost::any(*bookerId);
    }
    if (bookerJobNo) {
      res["booker_job_no"] = boost::any(*bookerJobNo);
    }
    if (bookerName) {
      res["booker_name"] = boost::any(*bookerName);
    }
    if (btripCouponFee) {
      res["btrip_coupon_fee"] = boost::any(*btripCouponFee);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (capitalDirection) {
      res["capital_direction"] = boost::any(*capitalDirection);
    }
    if (cascadeDepartment) {
      res["cascade_department"] = boost::any(*cascadeDepartment);
    }
    if (changeFee) {
      res["change_fee"] = boost::any(*changeFee);
    }
    if (corpPayOrderFee) {
      res["corp_pay_order_fee"] = boost::any(*corpPayOrderFee);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (coupon) {
      res["coupon"] = boost::any(*coupon);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (departmentId) {
      res["department_id"] = boost::any(*departmentId);
    }
    if (deptCity) {
      res["dept_city"] = boost::any(*deptCity);
    }
    if (deptDate) {
      res["dept_date"] = boost::any(*deptDate);
    }
    if (deptStation) {
      res["dept_station"] = boost::any(*deptStation);
    }
    if (deptTime) {
      res["dept_time"] = boost::any(*deptTime);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (feeType) {
      res["fee_type"] = boost::any(*feeType);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (insuranceFee) {
      res["insurance_fee"] = boost::any(*insuranceFee);
    }
    if (insuranceNumber) {
      res["insurance_number"] = boost::any(*insuranceNumber);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (mostDifferenceDeptTime) {
      res["most_difference_dept_time"] = boost::any(*mostDifferenceDeptTime);
    }
    if (mostDifferenceDiscount) {
      res["most_difference_discount"] = boost::any(*mostDifferenceDiscount);
    }
    if (mostDifferenceFlightNo) {
      res["most_difference_flight_no"] = boost::any(*mostDifferenceFlightNo);
    }
    if (mostDifferencePrice) {
      res["most_difference_price"] = boost::any(*mostDifferencePrice);
    }
    if (mostDifferenceReason) {
      res["most_difference_reason"] = boost::any(*mostDifferenceReason);
    }
    if (mostPrice) {
      res["most_price"] = boost::any(*mostPrice);
    }
    if (negotiationCouponFee) {
      res["negotiation_coupon_fee"] = boost::any(*negotiationCouponFee);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderStatusDesc) {
      res["order_status_desc"] = boost::any(*orderStatusDesc);
    }
    if (overApplyId) {
      res["over_apply_id"] = boost::any(*overApplyId);
    }
    if (primaryId) {
      res["primary_id"] = boost::any(*primaryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (repeatRefund) {
      res["repeat_refund"] = boost::any(*repeatRefund);
    }
    if (sealPrice) {
      res["seal_price"] = boost::any(*sealPrice);
    }
    if (segmentType) {
      res["segment_type"] = boost::any(*segmentType);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (settlementFee) {
      res["settlement_fee"] = boost::any(*settlementFee);
    }
    if (settlementGrantFee) {
      res["settlement_grant_fee"] = boost::any(*settlementGrantFee);
    }
    if (settlementTime) {
      res["settlement_time"] = boost::any(*settlementTime);
    }
    if (settlementType) {
      res["settlement_type"] = boost::any(*settlementType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    if (taxFee) {
      res["tax_fee"] = boost::any(*taxFee);
    }
    if (ticketId) {
      res["ticket_id"] = boost::any(*ticketId);
    }
    if (trade) {
      res["trade"] = boost::any(*trade);
    }
    if (travelerId) {
      res["traveler_id"] = boost::any(*travelerId);
    }
    if (travelerJobNo) {
      res["traveler_job_no"] = boost::any(*travelerJobNo);
    }
    if (travelerName) {
      res["traveler_name"] = boost::any(*travelerName);
    }
    if (voucherType) {
      res["voucher_type"] = boost::any(*voucherType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("advance_day") != m.end() && !m["advance_day"].empty()) {
      advanceDay = make_shared<long>(boost::any_cast<long>(m["advance_day"]));
    }
    if (m.find("airline_corp_code") != m.end() && !m["airline_corp_code"].empty()) {
      airlineCorpCode = make_shared<string>(boost::any_cast<string>(m["airline_corp_code"]));
    }
    if (m.find("airline_corp_name") != m.end() && !m["airline_corp_name"].empty()) {
      airlineCorpName = make_shared<string>(boost::any_cast<string>(m["airline_corp_name"]));
    }
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("arr_station") != m.end() && !m["arr_station"].empty()) {
      arrStation = make_shared<string>(boost::any_cast<string>(m["arr_station"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("bill_record_time") != m.end() && !m["bill_record_time"].empty()) {
      billRecordTime = make_shared<string>(boost::any_cast<string>(m["bill_record_time"]));
    }
    if (m.find("book_mode") != m.end() && !m["book_mode"].empty()) {
      bookMode = make_shared<string>(boost::any_cast<string>(m["book_mode"]));
    }
    if (m.find("book_time") != m.end() && !m["book_time"].empty()) {
      bookTime = make_shared<string>(boost::any_cast<string>(m["book_time"]));
    }
    if (m.find("booker_id") != m.end() && !m["booker_id"].empty()) {
      bookerId = make_shared<string>(boost::any_cast<string>(m["booker_id"]));
    }
    if (m.find("booker_job_no") != m.end() && !m["booker_job_no"].empty()) {
      bookerJobNo = make_shared<string>(boost::any_cast<string>(m["booker_job_no"]));
    }
    if (m.find("booker_name") != m.end() && !m["booker_name"].empty()) {
      bookerName = make_shared<string>(boost::any_cast<string>(m["booker_name"]));
    }
    if (m.find("btrip_coupon_fee") != m.end() && !m["btrip_coupon_fee"].empty()) {
      btripCouponFee = make_shared<double>(boost::any_cast<double>(m["btrip_coupon_fee"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("capital_direction") != m.end() && !m["capital_direction"].empty()) {
      capitalDirection = make_shared<string>(boost::any_cast<string>(m["capital_direction"]));
    }
    if (m.find("cascade_department") != m.end() && !m["cascade_department"].empty()) {
      cascadeDepartment = make_shared<string>(boost::any_cast<string>(m["cascade_department"]));
    }
    if (m.find("change_fee") != m.end() && !m["change_fee"].empty()) {
      changeFee = make_shared<double>(boost::any_cast<double>(m["change_fee"]));
    }
    if (m.find("corp_pay_order_fee") != m.end() && !m["corp_pay_order_fee"].empty()) {
      corpPayOrderFee = make_shared<double>(boost::any_cast<double>(m["corp_pay_order_fee"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("coupon") != m.end() && !m["coupon"].empty()) {
      coupon = make_shared<double>(boost::any_cast<double>(m["coupon"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("department_id") != m.end() && !m["department_id"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["department_id"]));
    }
    if (m.find("dept_city") != m.end() && !m["dept_city"].empty()) {
      deptCity = make_shared<string>(boost::any_cast<string>(m["dept_city"]));
    }
    if (m.find("dept_date") != m.end() && !m["dept_date"].empty()) {
      deptDate = make_shared<string>(boost::any_cast<string>(m["dept_date"]));
    }
    if (m.find("dept_station") != m.end() && !m["dept_station"].empty()) {
      deptStation = make_shared<string>(boost::any_cast<string>(m["dept_station"]));
    }
    if (m.find("dept_time") != m.end() && !m["dept_time"].empty()) {
      deptTime = make_shared<string>(boost::any_cast<string>(m["dept_time"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("fee_type") != m.end() && !m["fee_type"].empty()) {
      feeType = make_shared<string>(boost::any_cast<string>(m["fee_type"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("insurance_fee") != m.end() && !m["insurance_fee"].empty()) {
      insuranceFee = make_shared<double>(boost::any_cast<double>(m["insurance_fee"]));
    }
    if (m.find("insurance_number") != m.end() && !m["insurance_number"].empty()) {
      insuranceNumber = make_shared<string>(boost::any_cast<string>(m["insurance_number"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("most_difference_dept_time") != m.end() && !m["most_difference_dept_time"].empty()) {
      mostDifferenceDeptTime = make_shared<string>(boost::any_cast<string>(m["most_difference_dept_time"]));
    }
    if (m.find("most_difference_discount") != m.end() && !m["most_difference_discount"].empty()) {
      mostDifferenceDiscount = make_shared<string>(boost::any_cast<string>(m["most_difference_discount"]));
    }
    if (m.find("most_difference_flight_no") != m.end() && !m["most_difference_flight_no"].empty()) {
      mostDifferenceFlightNo = make_shared<string>(boost::any_cast<string>(m["most_difference_flight_no"]));
    }
    if (m.find("most_difference_price") != m.end() && !m["most_difference_price"].empty()) {
      mostDifferencePrice = make_shared<double>(boost::any_cast<double>(m["most_difference_price"]));
    }
    if (m.find("most_difference_reason") != m.end() && !m["most_difference_reason"].empty()) {
      mostDifferenceReason = make_shared<string>(boost::any_cast<string>(m["most_difference_reason"]));
    }
    if (m.find("most_price") != m.end() && !m["most_price"].empty()) {
      mostPrice = make_shared<double>(boost::any_cast<double>(m["most_price"]));
    }
    if (m.find("negotiation_coupon_fee") != m.end() && !m["negotiation_coupon_fee"].empty()) {
      negotiationCouponFee = make_shared<double>(boost::any_cast<double>(m["negotiation_coupon_fee"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("order_status_desc") != m.end() && !m["order_status_desc"].empty()) {
      orderStatusDesc = make_shared<string>(boost::any_cast<string>(m["order_status_desc"]));
    }
    if (m.find("over_apply_id") != m.end() && !m["over_apply_id"].empty()) {
      overApplyId = make_shared<string>(boost::any_cast<string>(m["over_apply_id"]));
    }
    if (m.find("primary_id") != m.end() && !m["primary_id"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["primary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<double>(boost::any_cast<double>(m["refund_fee"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("repeat_refund") != m.end() && !m["repeat_refund"].empty()) {
      repeatRefund = make_shared<string>(boost::any_cast<string>(m["repeat_refund"]));
    }
    if (m.find("seal_price") != m.end() && !m["seal_price"].empty()) {
      sealPrice = make_shared<double>(boost::any_cast<double>(m["seal_price"]));
    }
    if (m.find("segment_type") != m.end() && !m["segment_type"].empty()) {
      segmentType = make_shared<string>(boost::any_cast<string>(m["segment_type"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("settlement_fee") != m.end() && !m["settlement_fee"].empty()) {
      settlementFee = make_shared<double>(boost::any_cast<double>(m["settlement_fee"]));
    }
    if (m.find("settlement_grant_fee") != m.end() && !m["settlement_grant_fee"].empty()) {
      settlementGrantFee = make_shared<double>(boost::any_cast<double>(m["settlement_grant_fee"]));
    }
    if (m.find("settlement_time") != m.end() && !m["settlement_time"].empty()) {
      settlementTime = make_shared<string>(boost::any_cast<string>(m["settlement_time"]));
    }
    if (m.find("settlement_type") != m.end() && !m["settlement_type"].empty()) {
      settlementType = make_shared<string>(boost::any_cast<string>(m["settlement_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<string>(boost::any_cast<string>(m["sub_order_id"]));
    }
    if (m.find("tax_fee") != m.end() && !m["tax_fee"].empty()) {
      taxFee = make_shared<double>(boost::any_cast<double>(m["tax_fee"]));
    }
    if (m.find("ticket_id") != m.end() && !m["ticket_id"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["ticket_id"]));
    }
    if (m.find("trade") != m.end() && !m["trade"].empty()) {
      trade = make_shared<string>(boost::any_cast<string>(m["trade"]));
    }
    if (m.find("traveler_id") != m.end() && !m["traveler_id"].empty()) {
      travelerId = make_shared<string>(boost::any_cast<string>(m["traveler_id"]));
    }
    if (m.find("traveler_job_no") != m.end() && !m["traveler_job_no"].empty()) {
      travelerJobNo = make_shared<string>(boost::any_cast<string>(m["traveler_job_no"]));
    }
    if (m.find("traveler_name") != m.end() && !m["traveler_name"].empty()) {
      travelerName = make_shared<string>(boost::any_cast<string>(m["traveler_name"]));
    }
    if (m.find("voucher_type") != m.end() && !m["voucher_type"].empty()) {
      voucherType = make_shared<long>(boost::any_cast<long>(m["voucher_type"]));
    }
  }


  virtual ~IeFlightBillSettlementQueryResponseBodyModuleDataList() = default;
};
class IeFlightBillSettlementQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> category{};
  shared_ptr<string> corpId{};
  shared_ptr<vector<IeFlightBillSettlementQueryResponseBodyModuleDataList>> dataList{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};
  shared_ptr<long> totalNum{};

  IeFlightBillSettlementQueryResponseBodyModule() {}

  explicit IeFlightBillSettlementQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_list"] = boost::any(temp1);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    if (totalNum) {
      res["total_num"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["category"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("data_list") != m.end() && !m["data_list"].empty()) {
      if (typeid(vector<boost::any>) == m["data_list"].type()) {
        vector<IeFlightBillSettlementQueryResponseBodyModuleDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IeFlightBillSettlementQueryResponseBodyModuleDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<IeFlightBillSettlementQueryResponseBodyModuleDataList>>(expect1);
      }
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
    if (m.find("total_num") != m.end() && !m["total_num"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["total_num"]));
    }
  }


  virtual ~IeFlightBillSettlementQueryResponseBodyModule() = default;
};
class IeFlightBillSettlementQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<IeFlightBillSettlementQueryResponseBodyModule> module{};
  shared_ptr<bool> morePage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  IeFlightBillSettlementQueryResponseBody() {}

  explicit IeFlightBillSettlementQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (morePage) {
      res["more_page"] = boost::any(*morePage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        IeFlightBillSettlementQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<IeFlightBillSettlementQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("more_page") != m.end() && !m["more_page"].empty()) {
      morePage = make_shared<bool>(boost::any_cast<bool>(m["more_page"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~IeFlightBillSettlementQueryResponseBody() = default;
};
class IeFlightBillSettlementQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<IeFlightBillSettlementQueryResponseBody> body{};

  IeFlightBillSettlementQueryResponse() {}

  explicit IeFlightBillSettlementQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        IeFlightBillSettlementQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<IeFlightBillSettlementQueryResponseBody>(model1);
      }
    }
  }


  virtual ~IeFlightBillSettlementQueryResponse() = default;
};
class InvoiceAddHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  InvoiceAddHeaders() {}

  explicit InvoiceAddHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~InvoiceAddHeaders() = default;
};
class InvoiceAddRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> bankName{};
  shared_ptr<string> bankNo{};
  shared_ptr<string> taxNo{};
  shared_ptr<string> tel{};
  shared_ptr<string> thirdPartId{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  InvoiceAddRequest() {}

  explicit InvoiceAddRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["address"] = boost::any(*address);
    }
    if (bankName) {
      res["bank_name"] = boost::any(*bankName);
    }
    if (bankNo) {
      res["bank_no"] = boost::any(*bankNo);
    }
    if (taxNo) {
      res["tax_no"] = boost::any(*taxNo);
    }
    if (tel) {
      res["tel"] = boost::any(*tel);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("address") != m.end() && !m["address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["address"]));
    }
    if (m.find("bank_name") != m.end() && !m["bank_name"].empty()) {
      bankName = make_shared<string>(boost::any_cast<string>(m["bank_name"]));
    }
    if (m.find("bank_no") != m.end() && !m["bank_no"].empty()) {
      bankNo = make_shared<string>(boost::any_cast<string>(m["bank_no"]));
    }
    if (m.find("tax_no") != m.end() && !m["tax_no"].empty()) {
      taxNo = make_shared<string>(boost::any_cast<string>(m["tax_no"]));
    }
    if (m.find("tel") != m.end() && !m["tel"].empty()) {
      tel = make_shared<string>(boost::any_cast<string>(m["tel"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~InvoiceAddRequest() = default;
};
class InvoiceAddResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InvoiceAddResponseBody() {}

  explicit InvoiceAddResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InvoiceAddResponseBody() = default;
};
class InvoiceAddResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvoiceAddResponseBody> body{};

  InvoiceAddResponse() {}

  explicit InvoiceAddResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvoiceAddResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvoiceAddResponseBody>(model1);
      }
    }
  }


  virtual ~InvoiceAddResponse() = default;
};
class InvoiceDeleteHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  InvoiceDeleteHeaders() {}

  explicit InvoiceDeleteHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~InvoiceDeleteHeaders() = default;
};
class InvoiceDeleteRequest : public Darabonba::Model {
public:
  shared_ptr<string> thirdPartId{};

  InvoiceDeleteRequest() {}

  explicit InvoiceDeleteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~InvoiceDeleteRequest() = default;
};
class InvoiceDeleteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InvoiceDeleteResponseBody() {}

  explicit InvoiceDeleteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InvoiceDeleteResponseBody() = default;
};
class InvoiceDeleteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvoiceDeleteResponseBody> body{};

  InvoiceDeleteResponse() {}

  explicit InvoiceDeleteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvoiceDeleteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvoiceDeleteResponseBody>(model1);
      }
    }
  }


  virtual ~InvoiceDeleteResponse() = default;
};
class InvoiceModifyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  InvoiceModifyHeaders() {}

  explicit InvoiceModifyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~InvoiceModifyHeaders() = default;
};
class InvoiceModifyRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> bankName{};
  shared_ptr<string> bankNo{};
  shared_ptr<string> taxNo{};
  shared_ptr<string> tel{};
  shared_ptr<string> thirdPartId{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  InvoiceModifyRequest() {}

  explicit InvoiceModifyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["address"] = boost::any(*address);
    }
    if (bankName) {
      res["bank_name"] = boost::any(*bankName);
    }
    if (bankNo) {
      res["bank_no"] = boost::any(*bankNo);
    }
    if (taxNo) {
      res["tax_no"] = boost::any(*taxNo);
    }
    if (tel) {
      res["tel"] = boost::any(*tel);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("address") != m.end() && !m["address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["address"]));
    }
    if (m.find("bank_name") != m.end() && !m["bank_name"].empty()) {
      bankName = make_shared<string>(boost::any_cast<string>(m["bank_name"]));
    }
    if (m.find("bank_no") != m.end() && !m["bank_no"].empty()) {
      bankNo = make_shared<string>(boost::any_cast<string>(m["bank_no"]));
    }
    if (m.find("tax_no") != m.end() && !m["tax_no"].empty()) {
      taxNo = make_shared<string>(boost::any_cast<string>(m["tax_no"]));
    }
    if (m.find("tel") != m.end() && !m["tel"].empty()) {
      tel = make_shared<string>(boost::any_cast<string>(m["tel"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~InvoiceModifyRequest() = default;
};
class InvoiceModifyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InvoiceModifyResponseBody() {}

  explicit InvoiceModifyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InvoiceModifyResponseBody() = default;
};
class InvoiceModifyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvoiceModifyResponseBody> body{};

  InvoiceModifyResponse() {}

  explicit InvoiceModifyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvoiceModifyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvoiceModifyResponseBody>(model1);
      }
    }
  }


  virtual ~InvoiceModifyResponse() = default;
};
class InvoiceRuleSaveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  InvoiceRuleSaveHeaders() {}

  explicit InvoiceRuleSaveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~InvoiceRuleSaveHeaders() = default;
};
class InvoiceRuleSaveRequestEntities : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> type{};

  InvoiceRuleSaveRequestEntities() {}

  explicit InvoiceRuleSaveRequestEntities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~InvoiceRuleSaveRequestEntities() = default;
};
class InvoiceRuleSaveRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allEmploye{};
  shared_ptr<vector<InvoiceRuleSaveRequestEntities>> entities{};
  shared_ptr<string> thirdPartId{};

  InvoiceRuleSaveRequest() {}

  explicit InvoiceRuleSaveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allEmploye) {
      res["all_employe"] = boost::any(*allEmploye);
    }
    if (entities) {
      vector<boost::any> temp1;
      for(auto item1:*entities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entities"] = boost::any(temp1);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_employe") != m.end() && !m["all_employe"].empty()) {
      allEmploye = make_shared<bool>(boost::any_cast<bool>(m["all_employe"]));
    }
    if (m.find("entities") != m.end() && !m["entities"].empty()) {
      if (typeid(vector<boost::any>) == m["entities"].type()) {
        vector<InvoiceRuleSaveRequestEntities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvoiceRuleSaveRequestEntities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entities = make_shared<vector<InvoiceRuleSaveRequestEntities>>(expect1);
      }
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~InvoiceRuleSaveRequest() = default;
};
class InvoiceRuleSaveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allEmploye{};
  shared_ptr<string> entitiesShrink{};
  shared_ptr<string> thirdPartId{};

  InvoiceRuleSaveShrinkRequest() {}

  explicit InvoiceRuleSaveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allEmploye) {
      res["all_employe"] = boost::any(*allEmploye);
    }
    if (entitiesShrink) {
      res["entities"] = boost::any(*entitiesShrink);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_employe") != m.end() && !m["all_employe"].empty()) {
      allEmploye = make_shared<bool>(boost::any_cast<bool>(m["all_employe"]));
    }
    if (m.find("entities") != m.end() && !m["entities"].empty()) {
      entitiesShrink = make_shared<string>(boost::any_cast<string>(m["entities"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~InvoiceRuleSaveShrinkRequest() = default;
};
class InvoiceRuleSaveResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> addNum{};
  shared_ptr<long> removeNum{};

  InvoiceRuleSaveResponseBodyModule() {}

  explicit InvoiceRuleSaveResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addNum) {
      res["add_num"] = boost::any(*addNum);
    }
    if (removeNum) {
      res["remove_num"] = boost::any(*removeNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("add_num") != m.end() && !m["add_num"].empty()) {
      addNum = make_shared<long>(boost::any_cast<long>(m["add_num"]));
    }
    if (m.find("remove_num") != m.end() && !m["remove_num"].empty()) {
      removeNum = make_shared<long>(boost::any_cast<long>(m["remove_num"]));
    }
  }


  virtual ~InvoiceRuleSaveResponseBodyModule() = default;
};
class InvoiceRuleSaveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<InvoiceRuleSaveResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InvoiceRuleSaveResponseBody() {}

  explicit InvoiceRuleSaveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        InvoiceRuleSaveResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<InvoiceRuleSaveResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InvoiceRuleSaveResponseBody() = default;
};
class InvoiceRuleSaveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvoiceRuleSaveResponseBody> body{};

  InvoiceRuleSaveResponse() {}

  explicit InvoiceRuleSaveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvoiceRuleSaveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvoiceRuleSaveResponseBody>(model1);
      }
    }
  }


  virtual ~InvoiceRuleSaveResponse() = default;
};
class InvoiceSearchHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  InvoiceSearchHeaders() {}

  explicit InvoiceSearchHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~InvoiceSearchHeaders() = default;
};
class InvoiceSearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> title{};
  shared_ptr<string> userId{};

  InvoiceSearchRequest() {}

  explicit InvoiceSearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~InvoiceSearchRequest() = default;
};
class InvoiceSearchResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<string> title{};

  InvoiceSearchResponseBodyModule() {}

  explicit InvoiceSearchResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~InvoiceSearchResponseBodyModule() = default;
};
class InvoiceSearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<InvoiceSearchResponseBodyModule>> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InvoiceSearchResponseBody() {}

  explicit InvoiceSearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<InvoiceSearchResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvoiceSearchResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<InvoiceSearchResponseBodyModule>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InvoiceSearchResponseBody() = default;
};
class InvoiceSearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvoiceSearchResponseBody> body{};

  InvoiceSearchResponse() {}

  explicit InvoiceSearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvoiceSearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvoiceSearchResponseBody>(model1);
      }
    }
  }


  virtual ~InvoiceSearchResponse() = default;
};
class IsvRuleSaveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  IsvRuleSaveHeaders() {}

  explicit IsvRuleSaveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~IsvRuleSaveHeaders() = default;
};
class IsvRuleSaveRequest : public Darabonba::Model {
public:
  shared_ptr<string> bookType{};
  shared_ptr<long> status{};
  shared_ptr<string> userId{};

  IsvRuleSaveRequest() {}

  explicit IsvRuleSaveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bookType) {
      res["book_type"] = boost::any(*bookType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("book_type") != m.end() && !m["book_type"].empty()) {
      bookType = make_shared<string>(boost::any_cast<string>(m["book_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~IsvRuleSaveRequest() = default;
};
class IsvRuleSaveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  IsvRuleSaveResponseBody() {}

  explicit IsvRuleSaveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~IsvRuleSaveResponseBody() = default;
};
class IsvRuleSaveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<IsvRuleSaveResponseBody> body{};

  IsvRuleSaveResponse() {}

  explicit IsvRuleSaveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        IsvRuleSaveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<IsvRuleSaveResponseBody>(model1);
      }
    }
  }


  virtual ~IsvRuleSaveResponse() = default;
};
class IsvUserSaveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  IsvUserSaveHeaders() {}

  explicit IsvUserSaveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~IsvUserSaveHeaders() = default;
};
class IsvUserSaveRequestUserList : public Darabonba::Model {
public:
  shared_ptr<long> departId{};
  shared_ptr<string> email{};
  shared_ptr<string> jobNo{};
  shared_ptr<long> leaveStatus{};
  shared_ptr<string> managerUserId{};
  shared_ptr<string> phone{};
  shared_ptr<string> position{};
  shared_ptr<string> positionLevel{};
  shared_ptr<string> realNameEn{};
  shared_ptr<string> thirdDepartId{};
  shared_ptr<vector<string>> thirdDepartIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  IsvUserSaveRequestUserList() {}

  explicit IsvUserSaveRequestUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (jobNo) {
      res["job_no"] = boost::any(*jobNo);
    }
    if (leaveStatus) {
      res["leave_status"] = boost::any(*leaveStatus);
    }
    if (managerUserId) {
      res["manager_user_id"] = boost::any(*managerUserId);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (position) {
      res["position"] = boost::any(*position);
    }
    if (positionLevel) {
      res["position_level"] = boost::any(*positionLevel);
    }
    if (realNameEn) {
      res["real_name_en"] = boost::any(*realNameEn);
    }
    if (thirdDepartId) {
      res["third_depart_id"] = boost::any(*thirdDepartId);
    }
    if (thirdDepartIdList) {
      res["third_depart_id_list"] = boost::any(*thirdDepartIdList);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<long>(boost::any_cast<long>(m["depart_id"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("job_no") != m.end() && !m["job_no"].empty()) {
      jobNo = make_shared<string>(boost::any_cast<string>(m["job_no"]));
    }
    if (m.find("leave_status") != m.end() && !m["leave_status"].empty()) {
      leaveStatus = make_shared<long>(boost::any_cast<long>(m["leave_status"]));
    }
    if (m.find("manager_user_id") != m.end() && !m["manager_user_id"].empty()) {
      managerUserId = make_shared<string>(boost::any_cast<string>(m["manager_user_id"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("position") != m.end() && !m["position"].empty()) {
      position = make_shared<string>(boost::any_cast<string>(m["position"]));
    }
    if (m.find("position_level") != m.end() && !m["position_level"].empty()) {
      positionLevel = make_shared<string>(boost::any_cast<string>(m["position_level"]));
    }
    if (m.find("real_name_en") != m.end() && !m["real_name_en"].empty()) {
      realNameEn = make_shared<string>(boost::any_cast<string>(m["real_name_en"]));
    }
    if (m.find("third_depart_id") != m.end() && !m["third_depart_id"].empty()) {
      thirdDepartId = make_shared<string>(boost::any_cast<string>(m["third_depart_id"]));
    }
    if (m.find("third_depart_id_list") != m.end() && !m["third_depart_id_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["third_depart_id_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["third_depart_id_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      thirdDepartIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~IsvUserSaveRequestUserList() = default;
};
class IsvUserSaveRequest : public Darabonba::Model {
public:
  shared_ptr<vector<IsvUserSaveRequestUserList>> userList{};

  IsvUserSaveRequest() {}

  explicit IsvUserSaveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["user_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_list") != m.end() && !m["user_list"].empty()) {
      if (typeid(vector<boost::any>) == m["user_list"].type()) {
        vector<IsvUserSaveRequestUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["user_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IsvUserSaveRequestUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<IsvUserSaveRequestUserList>>(expect1);
      }
    }
  }


  virtual ~IsvUserSaveRequest() = default;
};
class IsvUserSaveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> userListShrink{};

  IsvUserSaveShrinkRequest() {}

  explicit IsvUserSaveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userListShrink) {
      res["user_list"] = boost::any(*userListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_list") != m.end() && !m["user_list"].empty()) {
      userListShrink = make_shared<string>(boost::any_cast<string>(m["user_list"]));
    }
  }


  virtual ~IsvUserSaveShrinkRequest() = default;
};
class IsvUserSaveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  IsvUserSaveResponseBody() {}

  explicit IsvUserSaveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~IsvUserSaveResponseBody() = default;
};
class IsvUserSaveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<IsvUserSaveResponseBody> body{};

  IsvUserSaveResponse() {}

  explicit IsvUserSaveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        IsvUserSaveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<IsvUserSaveResponseBody>(model1);
      }
    }
  }


  virtual ~IsvUserSaveResponse() = default;
};
class MonthBillConfirmHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  MonthBillConfirmHeaders() {}

  explicit MonthBillConfirmHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~MonthBillConfirmHeaders() = default;
};
class MonthBillConfirmRequest : public Darabonba::Model {
public:
  shared_ptr<long> mailBillDate{};
  shared_ptr<string> userId{};

  MonthBillConfirmRequest() {}

  explicit MonthBillConfirmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mailBillDate) {
      res["mail_bill_date"] = boost::any(*mailBillDate);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("mail_bill_date") != m.end() && !m["mail_bill_date"].empty()) {
      mailBillDate = make_shared<long>(boost::any_cast<long>(m["mail_bill_date"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~MonthBillConfirmRequest() = default;
};
class MonthBillConfirmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  MonthBillConfirmResponseBody() {}

  explicit MonthBillConfirmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~MonthBillConfirmResponseBody() = default;
};
class MonthBillConfirmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MonthBillConfirmResponseBody> body{};

  MonthBillConfirmResponse() {}

  explicit MonthBillConfirmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MonthBillConfirmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MonthBillConfirmResponseBody>(model1);
      }
    }
  }


  virtual ~MonthBillConfirmResponse() = default;
};
class MonthBillGetHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  MonthBillGetHeaders() {}

  explicit MonthBillGetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~MonthBillGetHeaders() = default;
};
class MonthBillGetRequest : public Darabonba::Model {
public:
  shared_ptr<string> billMonth{};

  MonthBillGetRequest() {}

  explicit MonthBillGetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billMonth) {
      res["bill_month"] = boost::any(*billMonth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_month") != m.end() && !m["bill_month"].empty()) {
      billMonth = make_shared<string>(boost::any_cast<string>(m["bill_month"]));
    }
  }


  virtual ~MonthBillGetRequest() = default;
};
class MonthBillGetResponseBodyModuleMonthAccountBillDetail : public Darabonba::Model {
public:
  shared_ptr<double> carAmount{};
  shared_ptr<double> damageAmount{};
  shared_ptr<double> flightAmount{};
  shared_ptr<double> fuPoint{};
  shared_ptr<double> hotelAmount{};
  shared_ptr<double> ieFlightAmount{};
  shared_ptr<long> mailBillDate{};
  shared_ptr<double> serviceAmount{};
  shared_ptr<double> trainAmount{};

  MonthBillGetResponseBodyModuleMonthAccountBillDetail() {}

  explicit MonthBillGetResponseBodyModuleMonthAccountBillDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (carAmount) {
      res["carAmount"] = boost::any(*carAmount);
    }
    if (damageAmount) {
      res["damageAmount"] = boost::any(*damageAmount);
    }
    if (flightAmount) {
      res["flightAmount"] = boost::any(*flightAmount);
    }
    if (fuPoint) {
      res["fuPoint"] = boost::any(*fuPoint);
    }
    if (hotelAmount) {
      res["hotelAmount"] = boost::any(*hotelAmount);
    }
    if (ieFlightAmount) {
      res["ieFlightAmount"] = boost::any(*ieFlightAmount);
    }
    if (mailBillDate) {
      res["mailBillDate"] = boost::any(*mailBillDate);
    }
    if (serviceAmount) {
      res["serviceAmount"] = boost::any(*serviceAmount);
    }
    if (trainAmount) {
      res["trainAmount"] = boost::any(*trainAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("carAmount") != m.end() && !m["carAmount"].empty()) {
      carAmount = make_shared<double>(boost::any_cast<double>(m["carAmount"]));
    }
    if (m.find("damageAmount") != m.end() && !m["damageAmount"].empty()) {
      damageAmount = make_shared<double>(boost::any_cast<double>(m["damageAmount"]));
    }
    if (m.find("flightAmount") != m.end() && !m["flightAmount"].empty()) {
      flightAmount = make_shared<double>(boost::any_cast<double>(m["flightAmount"]));
    }
    if (m.find("fuPoint") != m.end() && !m["fuPoint"].empty()) {
      fuPoint = make_shared<double>(boost::any_cast<double>(m["fuPoint"]));
    }
    if (m.find("hotelAmount") != m.end() && !m["hotelAmount"].empty()) {
      hotelAmount = make_shared<double>(boost::any_cast<double>(m["hotelAmount"]));
    }
    if (m.find("ieFlightAmount") != m.end() && !m["ieFlightAmount"].empty()) {
      ieFlightAmount = make_shared<double>(boost::any_cast<double>(m["ieFlightAmount"]));
    }
    if (m.find("mailBillDate") != m.end() && !m["mailBillDate"].empty()) {
      mailBillDate = make_shared<long>(boost::any_cast<long>(m["mailBillDate"]));
    }
    if (m.find("serviceAmount") != m.end() && !m["serviceAmount"].empty()) {
      serviceAmount = make_shared<double>(boost::any_cast<double>(m["serviceAmount"]));
    }
    if (m.find("trainAmount") != m.end() && !m["trainAmount"].empty()) {
      trainAmount = make_shared<double>(boost::any_cast<double>(m["trainAmount"]));
    }
  }


  virtual ~MonthBillGetResponseBodyModuleMonthAccountBillDetail() = default;
};
class MonthBillGetResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<MonthBillGetResponseBodyModuleMonthAccountBillDetail> monthAccountBillDetail{};
  shared_ptr<string> startDate{};
  shared_ptr<string> url{};

  MonthBillGetResponseBodyModule() {}

  explicit MonthBillGetResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["end_date"] = boost::any(*endDate);
    }
    if (monthAccountBillDetail) {
      res["monthAccountBillDetail"] = monthAccountBillDetail ? boost::any(monthAccountBillDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startDate) {
      res["start_date"] = boost::any(*startDate);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("end_date") != m.end() && !m["end_date"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["end_date"]));
    }
    if (m.find("monthAccountBillDetail") != m.end() && !m["monthAccountBillDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["monthAccountBillDetail"].type()) {
        MonthBillGetResponseBodyModuleMonthAccountBillDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["monthAccountBillDetail"]));
        monthAccountBillDetail = make_shared<MonthBillGetResponseBodyModuleMonthAccountBillDetail>(model1);
      }
    }
    if (m.find("start_date") != m.end() && !m["start_date"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["start_date"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~MonthBillGetResponseBodyModule() = default;
};
class MonthBillGetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<MonthBillGetResponseBodyModule>> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  MonthBillGetResponseBody() {}

  explicit MonthBillGetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<MonthBillGetResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MonthBillGetResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<MonthBillGetResponseBodyModule>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~MonthBillGetResponseBody() = default;
};
class MonthBillGetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MonthBillGetResponseBody> body{};

  MonthBillGetResponse() {}

  explicit MonthBillGetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MonthBillGetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MonthBillGetResponseBody>(model1);
      }
    }
  }


  virtual ~MonthBillGetResponse() = default;
};
class ProjectAddHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ProjectAddHeaders() {}

  explicit ProjectAddHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ProjectAddHeaders() = default;
};
class ProjectAddRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> projectName{};
  shared_ptr<string> thirdPartCostCenterId{};
  shared_ptr<string> thirdPartId{};
  shared_ptr<string> thirdPartInvoiceId{};

  ProjectAddRequest() {}

  explicit ProjectAddRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (thirdPartCostCenterId) {
      res["third_part_cost_center_id"] = boost::any(*thirdPartCostCenterId);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("third_part_cost_center_id") != m.end() && !m["third_part_cost_center_id"].empty()) {
      thirdPartCostCenterId = make_shared<string>(boost::any_cast<string>(m["third_part_cost_center_id"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
  }


  virtual ~ProjectAddRequest() = default;
};
class ProjectAddResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<long> module{};
  shared_ptr<bool> morePage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ProjectAddResponseBody() {}

  explicit ProjectAddResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (morePage) {
      res["more_page"] = boost::any(*morePage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<long>(boost::any_cast<long>(m["module"]));
    }
    if (m.find("more_page") != m.end() && !m["more_page"].empty()) {
      morePage = make_shared<bool>(boost::any_cast<bool>(m["more_page"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ProjectAddResponseBody() = default;
};
class ProjectAddResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ProjectAddResponseBody> body{};

  ProjectAddResponse() {}

  explicit ProjectAddResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ProjectAddResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ProjectAddResponseBody>(model1);
      }
    }
  }


  virtual ~ProjectAddResponse() = default;
};
class ProjectDeleteHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ProjectDeleteHeaders() {}

  explicit ProjectDeleteHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ProjectDeleteHeaders() = default;
};
class ProjectDeleteRequest : public Darabonba::Model {
public:
  shared_ptr<string> thirdPartId{};

  ProjectDeleteRequest() {}

  explicit ProjectDeleteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~ProjectDeleteRequest() = default;
};
class ProjectDeleteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ProjectDeleteResponseBody() {}

  explicit ProjectDeleteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<bool>(boost::any_cast<bool>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ProjectDeleteResponseBody() = default;
};
class ProjectDeleteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ProjectDeleteResponseBody> body{};

  ProjectDeleteResponse() {}

  explicit ProjectDeleteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ProjectDeleteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ProjectDeleteResponseBody>(model1);
      }
    }
  }


  virtual ~ProjectDeleteResponse() = default;
};
class ProjectModifyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ProjectModifyHeaders() {}

  explicit ProjectModifyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ProjectModifyHeaders() = default;
};
class ProjectModifyRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> projectName{};
  shared_ptr<string> thirdPartCostCenterId{};
  shared_ptr<string> thirdPartId{};
  shared_ptr<string> thirdPartInvoiceId{};

  ProjectModifyRequest() {}

  explicit ProjectModifyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (thirdPartCostCenterId) {
      res["third_part_cost_center_id"] = boost::any(*thirdPartCostCenterId);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("third_part_cost_center_id") != m.end() && !m["third_part_cost_center_id"].empty()) {
      thirdPartCostCenterId = make_shared<string>(boost::any_cast<string>(m["third_part_cost_center_id"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
  }


  virtual ~ProjectModifyRequest() = default;
};
class ProjectModifyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ProjectModifyResponseBody() {}

  explicit ProjectModifyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<bool>(boost::any_cast<bool>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ProjectModifyResponseBody() = default;
};
class ProjectModifyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ProjectModifyResponseBody> body{};

  ProjectModifyResponse() {}

  explicit ProjectModifyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ProjectModifyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ProjectModifyResponseBody>(model1);
      }
    }
  }


  virtual ~ProjectModifyResponse() = default;
};
class QueryReimbursementOrderHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  QueryReimbursementOrderHeaders() {}

  explicit QueryReimbursementOrderHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~QueryReimbursementOrderHeaders() = default;
};
class QueryReimbursementOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> reimbOrderNo{};
  shared_ptr<string> subCorpId{};

  QueryReimbursementOrderRequest() {}

  explicit QueryReimbursementOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reimbOrderNo) {
      res["reimb_order_no"] = boost::any(*reimbOrderNo);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("reimb_order_no") != m.end() && !m["reimb_order_no"].empty()) {
      reimbOrderNo = make_shared<string>(boost::any_cast<string>(m["reimb_order_no"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
  }


  virtual ~QueryReimbursementOrderRequest() = default;
};
class QueryReimbursementOrderResponseBodyModuleExpenses : public Darabonba::Model {
public:
  shared_ptr<string> amount{};
  shared_ptr<string> currency{};
  shared_ptr<string> expenseCity{};
  shared_ptr<string> expenseTime{};
  shared_ptr<string> expenseType{};
  shared_ptr<string> expenseTypeCode{};
  shared_ptr<long> reimbExpenseId{};
  shared_ptr<string> remark{};
  shared_ptr<string> settlementType{};

  QueryReimbursementOrderResponseBodyModuleExpenses() {}

  explicit QueryReimbursementOrderResponseBodyModuleExpenses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (currency) {
      res["currency"] = boost::any(*currency);
    }
    if (expenseCity) {
      res["expense_city"] = boost::any(*expenseCity);
    }
    if (expenseTime) {
      res["expense_time"] = boost::any(*expenseTime);
    }
    if (expenseType) {
      res["expense_type"] = boost::any(*expenseType);
    }
    if (expenseTypeCode) {
      res["expense_type_code"] = boost::any(*expenseTypeCode);
    }
    if (reimbExpenseId) {
      res["reimb_expense_id"] = boost::any(*reimbExpenseId);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (settlementType) {
      res["settlement_type"] = boost::any(*settlementType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<string>(boost::any_cast<string>(m["amount"]));
    }
    if (m.find("currency") != m.end() && !m["currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["currency"]));
    }
    if (m.find("expense_city") != m.end() && !m["expense_city"].empty()) {
      expenseCity = make_shared<string>(boost::any_cast<string>(m["expense_city"]));
    }
    if (m.find("expense_time") != m.end() && !m["expense_time"].empty()) {
      expenseTime = make_shared<string>(boost::any_cast<string>(m["expense_time"]));
    }
    if (m.find("expense_type") != m.end() && !m["expense_type"].empty()) {
      expenseType = make_shared<string>(boost::any_cast<string>(m["expense_type"]));
    }
    if (m.find("expense_type_code") != m.end() && !m["expense_type_code"].empty()) {
      expenseTypeCode = make_shared<string>(boost::any_cast<string>(m["expense_type_code"]));
    }
    if (m.find("reimb_expense_id") != m.end() && !m["reimb_expense_id"].empty()) {
      reimbExpenseId = make_shared<long>(boost::any_cast<long>(m["reimb_expense_id"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("settlement_type") != m.end() && !m["settlement_type"].empty()) {
      settlementType = make_shared<string>(boost::any_cast<string>(m["settlement_type"]));
    }
  }


  virtual ~QueryReimbursementOrderResponseBodyModuleExpenses() = default;
};
class QueryReimbursementOrderResponseBodyModuleItineraries : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depDate{};
  shared_ptr<string> trafficWay{};
  shared_ptr<string> tripWay{};

  QueryReimbursementOrderResponseBodyModuleItineraries() {}

  explicit QueryReimbursementOrderResponseBodyModuleItineraries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (trafficWay) {
      res["traffic_way"] = boost::any(*trafficWay);
    }
    if (tripWay) {
      res["trip_way"] = boost::any(*tripWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("traffic_way") != m.end() && !m["traffic_way"].empty()) {
      trafficWay = make_shared<string>(boost::any_cast<string>(m["traffic_way"]));
    }
    if (m.find("trip_way") != m.end() && !m["trip_way"].empty()) {
      tripWay = make_shared<string>(boost::any_cast<string>(m["trip_way"]));
    }
  }


  virtual ~QueryReimbursementOrderResponseBodyModuleItineraries() = default;
};
class QueryReimbursementOrderResponseBodyModulePaymentInfos : public Darabonba::Model {
public:
  shared_ptr<string> amount{};
  shared_ptr<string> payeeUserId{};

  QueryReimbursementOrderResponseBodyModulePaymentInfos() {}

  explicit QueryReimbursementOrderResponseBodyModulePaymentInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (payeeUserId) {
      res["payee_user_id"] = boost::any(*payeeUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<string>(boost::any_cast<string>(m["amount"]));
    }
    if (m.find("payee_user_id") != m.end() && !m["payee_user_id"].empty()) {
      payeeUserId = make_shared<string>(boost::any_cast<string>(m["payee_user_id"]));
    }
  }


  virtual ~QueryReimbursementOrderResponseBodyModulePaymentInfos() = default;
};
class QueryReimbursementOrderResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> companyAmount{};
  shared_ptr<string> companyPayAmount{};
  shared_ptr<string> corpId{};
  shared_ptr<vector<QueryReimbursementOrderResponseBodyModuleExpenses>> expenses{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<vector<QueryReimbursementOrderResponseBodyModuleItineraries>> itineraries{};
  shared_ptr<vector<QueryReimbursementOrderResponseBodyModulePaymentInfos>> paymentInfos{};
  shared_ptr<string> personalAmount{};
  shared_ptr<string> reason{};
  shared_ptr<string> reimbursementNo{};
  shared_ptr<string> remark{};
  shared_ptr<string> status{};
  shared_ptr<string> travelThirdApplyId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  QueryReimbursementOrderResponseBodyModule() {}

  explicit QueryReimbursementOrderResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (companyAmount) {
      res["company_amount"] = boost::any(*companyAmount);
    }
    if (companyPayAmount) {
      res["company_pay_amount"] = boost::any(*companyPayAmount);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (expenses) {
      vector<boost::any> temp1;
      for(auto item1:*expenses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["expenses"] = boost::any(temp1);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (itineraries) {
      vector<boost::any> temp1;
      for(auto item1:*itineraries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itineraries"] = boost::any(temp1);
    }
    if (paymentInfos) {
      vector<boost::any> temp1;
      for(auto item1:*paymentInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["payment_infos"] = boost::any(temp1);
    }
    if (personalAmount) {
      res["personal_amount"] = boost::any(*personalAmount);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (reimbursementNo) {
      res["reimbursement_no"] = boost::any(*reimbursementNo);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (travelThirdApplyId) {
      res["travel_third_apply_id"] = boost::any(*travelThirdApplyId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("company_amount") != m.end() && !m["company_amount"].empty()) {
      companyAmount = make_shared<string>(boost::any_cast<string>(m["company_amount"]));
    }
    if (m.find("company_pay_amount") != m.end() && !m["company_pay_amount"].empty()) {
      companyPayAmount = make_shared<string>(boost::any_cast<string>(m["company_pay_amount"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("expenses") != m.end() && !m["expenses"].empty()) {
      if (typeid(vector<boost::any>) == m["expenses"].type()) {
        vector<QueryReimbursementOrderResponseBodyModuleExpenses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["expenses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryReimbursementOrderResponseBodyModuleExpenses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expenses = make_shared<vector<QueryReimbursementOrderResponseBodyModuleExpenses>>(expect1);
      }
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("itineraries") != m.end() && !m["itineraries"].empty()) {
      if (typeid(vector<boost::any>) == m["itineraries"].type()) {
        vector<QueryReimbursementOrderResponseBodyModuleItineraries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itineraries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryReimbursementOrderResponseBodyModuleItineraries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itineraries = make_shared<vector<QueryReimbursementOrderResponseBodyModuleItineraries>>(expect1);
      }
    }
    if (m.find("payment_infos") != m.end() && !m["payment_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["payment_infos"].type()) {
        vector<QueryReimbursementOrderResponseBodyModulePaymentInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["payment_infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryReimbursementOrderResponseBodyModulePaymentInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paymentInfos = make_shared<vector<QueryReimbursementOrderResponseBodyModulePaymentInfos>>(expect1);
      }
    }
    if (m.find("personal_amount") != m.end() && !m["personal_amount"].empty()) {
      personalAmount = make_shared<string>(boost::any_cast<string>(m["personal_amount"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("reimbursement_no") != m.end() && !m["reimbursement_no"].empty()) {
      reimbursementNo = make_shared<string>(boost::any_cast<string>(m["reimbursement_no"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("travel_third_apply_id") != m.end() && !m["travel_third_apply_id"].empty()) {
      travelThirdApplyId = make_shared<string>(boost::any_cast<string>(m["travel_third_apply_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~QueryReimbursementOrderResponseBodyModule() = default;
};
class QueryReimbursementOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryReimbursementOrderResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  QueryReimbursementOrderResponseBody() {}

  explicit QueryReimbursementOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        QueryReimbursementOrderResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<QueryReimbursementOrderResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~QueryReimbursementOrderResponseBody() = default;
};
class QueryReimbursementOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryReimbursementOrderResponseBody> body{};

  QueryReimbursementOrderResponse() {}

  explicit QueryReimbursementOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryReimbursementOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryReimbursementOrderResponseBody>(model1);
      }
    }
  }


  virtual ~QueryReimbursementOrderResponse() = default;
};
class SyncSingleUserHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  SyncSingleUserHeaders() {}

  explicit SyncSingleUserHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~SyncSingleUserHeaders() = default;
};
class SyncSingleUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> email{};
  shared_ptr<string> jobNo{};
  shared_ptr<long> leaveStatus{};
  shared_ptr<string> managerUserId{};
  shared_ptr<string> phone{};
  shared_ptr<string> position{};
  shared_ptr<string> positionLevel{};
  shared_ptr<string> realNameEn{};
  shared_ptr<vector<string>> thirdDepartIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  SyncSingleUserRequest() {}

  explicit SyncSingleUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (jobNo) {
      res["job_no"] = boost::any(*jobNo);
    }
    if (leaveStatus) {
      res["leave_status"] = boost::any(*leaveStatus);
    }
    if (managerUserId) {
      res["manager_user_id"] = boost::any(*managerUserId);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (position) {
      res["position"] = boost::any(*position);
    }
    if (positionLevel) {
      res["position_level"] = boost::any(*positionLevel);
    }
    if (realNameEn) {
      res["real_name_en"] = boost::any(*realNameEn);
    }
    if (thirdDepartIdList) {
      res["third_depart_id_list"] = boost::any(*thirdDepartIdList);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("job_no") != m.end() && !m["job_no"].empty()) {
      jobNo = make_shared<string>(boost::any_cast<string>(m["job_no"]));
    }
    if (m.find("leave_status") != m.end() && !m["leave_status"].empty()) {
      leaveStatus = make_shared<long>(boost::any_cast<long>(m["leave_status"]));
    }
    if (m.find("manager_user_id") != m.end() && !m["manager_user_id"].empty()) {
      managerUserId = make_shared<string>(boost::any_cast<string>(m["manager_user_id"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("position") != m.end() && !m["position"].empty()) {
      position = make_shared<string>(boost::any_cast<string>(m["position"]));
    }
    if (m.find("position_level") != m.end() && !m["position_level"].empty()) {
      positionLevel = make_shared<string>(boost::any_cast<string>(m["position_level"]));
    }
    if (m.find("real_name_en") != m.end() && !m["real_name_en"].empty()) {
      realNameEn = make_shared<string>(boost::any_cast<string>(m["real_name_en"]));
    }
    if (m.find("third_depart_id_list") != m.end() && !m["third_depart_id_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["third_depart_id_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["third_depart_id_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      thirdDepartIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~SyncSingleUserRequest() = default;
};
class SyncSingleUserShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> email{};
  shared_ptr<string> jobNo{};
  shared_ptr<long> leaveStatus{};
  shared_ptr<string> managerUserId{};
  shared_ptr<string> phone{};
  shared_ptr<string> position{};
  shared_ptr<string> positionLevel{};
  shared_ptr<string> realNameEn{};
  shared_ptr<string> thirdDepartIdListShrink{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  SyncSingleUserShrinkRequest() {}

  explicit SyncSingleUserShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (jobNo) {
      res["job_no"] = boost::any(*jobNo);
    }
    if (leaveStatus) {
      res["leave_status"] = boost::any(*leaveStatus);
    }
    if (managerUserId) {
      res["manager_user_id"] = boost::any(*managerUserId);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (position) {
      res["position"] = boost::any(*position);
    }
    if (positionLevel) {
      res["position_level"] = boost::any(*positionLevel);
    }
    if (realNameEn) {
      res["real_name_en"] = boost::any(*realNameEn);
    }
    if (thirdDepartIdListShrink) {
      res["third_depart_id_list"] = boost::any(*thirdDepartIdListShrink);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("job_no") != m.end() && !m["job_no"].empty()) {
      jobNo = make_shared<string>(boost::any_cast<string>(m["job_no"]));
    }
    if (m.find("leave_status") != m.end() && !m["leave_status"].empty()) {
      leaveStatus = make_shared<long>(boost::any_cast<long>(m["leave_status"]));
    }
    if (m.find("manager_user_id") != m.end() && !m["manager_user_id"].empty()) {
      managerUserId = make_shared<string>(boost::any_cast<string>(m["manager_user_id"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("position") != m.end() && !m["position"].empty()) {
      position = make_shared<string>(boost::any_cast<string>(m["position"]));
    }
    if (m.find("position_level") != m.end() && !m["position_level"].empty()) {
      positionLevel = make_shared<string>(boost::any_cast<string>(m["position_level"]));
    }
    if (m.find("real_name_en") != m.end() && !m["real_name_en"].empty()) {
      realNameEn = make_shared<string>(boost::any_cast<string>(m["real_name_en"]));
    }
    if (m.find("third_depart_id_list") != m.end() && !m["third_depart_id_list"].empty()) {
      thirdDepartIdListShrink = make_shared<string>(boost::any_cast<string>(m["third_depart_id_list"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~SyncSingleUserShrinkRequest() = default;
};
class SyncSingleUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  SyncSingleUserResponseBody() {}

  explicit SyncSingleUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~SyncSingleUserResponseBody() = default;
};
class SyncSingleUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncSingleUserResponseBody> body{};

  SyncSingleUserResponse() {}

  explicit SyncSingleUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncSingleUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncSingleUserResponseBody>(model1);
      }
    }
  }


  virtual ~SyncSingleUserResponse() = default;
};
class TicketChangingApplyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TicketChangingApplyHeaders() {}

  explicit TicketChangingApplyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TicketChangingApplyHeaders() = default;
};
class TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList : public Darabonba::Model {
public:
  shared_ptr<string> originFlightNo{};
  shared_ptr<string> outUserId{};
  shared_ptr<string> passengerName{};

  TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList() {}

  explicit TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originFlightNo) {
      res["origin_flight_no"] = boost::any(*originFlightNo);
    }
    if (outUserId) {
      res["out_user_id"] = boost::any(*outUserId);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("origin_flight_no") != m.end() && !m["origin_flight_no"].empty()) {
      originFlightNo = make_shared<string>(boost::any_cast<string>(m["origin_flight_no"]));
    }
    if (m.find("out_user_id") != m.end() && !m["out_user_id"].empty()) {
      outUserId = make_shared<string>(boost::any_cast<string>(m["out_user_id"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
  }


  virtual ~TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList() = default;
};
class TicketChangingApplyRequestModifyFlightInfoList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> cabin{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depDate{};
  shared_ptr<string> flightNo{};
  shared_ptr<vector<TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList>> passengerInfoList{};

  TicketChangingApplyRequestModifyFlightInfoList() {}

  explicit TicketChangingApplyRequestModifyFlightInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (passengerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("passenger_info_list") != m.end() && !m["passenger_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_info_list"].type()) {
        vector<TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerInfoList = make_shared<vector<TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList>>(expect1);
      }
    }
  }


  virtual ~TicketChangingApplyRequestModifyFlightInfoList() = default;
};
class TicketChangingApplyRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<vector<TicketChangingApplyRequestModifyFlightInfoList>> modifyFlightInfoList{};
  shared_ptr<string> otaItemId{};
  shared_ptr<string> reason{};
  shared_ptr<string> sessionId{};
  shared_ptr<bool> whetherRetry{};

  TicketChangingApplyRequest() {}

  explicit TicketChangingApplyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (modifyFlightInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*modifyFlightInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["modify_flight_info_list"] = boost::any(temp1);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (whetherRetry) {
      res["whether_retry"] = boost::any(*whetherRetry);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("modify_flight_info_list") != m.end() && !m["modify_flight_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["modify_flight_info_list"].type()) {
        vector<TicketChangingApplyRequestModifyFlightInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["modify_flight_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingApplyRequestModifyFlightInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modifyFlightInfoList = make_shared<vector<TicketChangingApplyRequestModifyFlightInfoList>>(expect1);
      }
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("whether_retry") != m.end() && !m["whether_retry"].empty()) {
      whetherRetry = make_shared<bool>(boost::any_cast<bool>(m["whether_retry"]));
    }
  }


  virtual ~TicketChangingApplyRequest() = default;
};
class TicketChangingApplyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<string> modifyFlightInfoListShrink{};
  shared_ptr<string> otaItemId{};
  shared_ptr<string> reason{};
  shared_ptr<string> sessionId{};
  shared_ptr<bool> whetherRetry{};

  TicketChangingApplyShrinkRequest() {}

  explicit TicketChangingApplyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (modifyFlightInfoListShrink) {
      res["modify_flight_info_list"] = boost::any(*modifyFlightInfoListShrink);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (whetherRetry) {
      res["whether_retry"] = boost::any(*whetherRetry);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("modify_flight_info_list") != m.end() && !m["modify_flight_info_list"].empty()) {
      modifyFlightInfoListShrink = make_shared<string>(boost::any_cast<string>(m["modify_flight_info_list"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("whether_retry") != m.end() && !m["whether_retry"].empty()) {
      whetherRetry = make_shared<bool>(boost::any_cast<bool>(m["whether_retry"]));
    }
  }


  virtual ~TicketChangingApplyShrinkRequest() = default;
};
class TicketChangingApplyResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> bookingChangedTotalFee{};
  shared_ptr<long> bookingOriginTotalFee{};
  shared_ptr<bool> bookingPriceChanged{};
  shared_ptr<long> btripOrderId{};
  shared_ptr<long> btripSubOrderId{};
  shared_ptr<bool> canPay{};
  shared_ptr<long> changeFee{};
  shared_ptr<string> deadlineTime{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<long> maxRetryTimes{};
  shared_ptr<long> nextRetryInterval{};
  shared_ptr<bool> retry{};
  shared_ptr<string> retryClientTips{};
  shared_ptr<long> status{};
  shared_ptr<long> upgradeFee{};

  TicketChangingApplyResponseBodyModule() {}

  explicit TicketChangingApplyResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bookingChangedTotalFee) {
      res["booking_changed_total_fee"] = boost::any(*bookingChangedTotalFee);
    }
    if (bookingOriginTotalFee) {
      res["booking_origin_total_fee"] = boost::any(*bookingOriginTotalFee);
    }
    if (bookingPriceChanged) {
      res["booking_price_changed"] = boost::any(*bookingPriceChanged);
    }
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (btripSubOrderId) {
      res["btrip_sub_order_id"] = boost::any(*btripSubOrderId);
    }
    if (canPay) {
      res["can_pay"] = boost::any(*canPay);
    }
    if (changeFee) {
      res["change_fee"] = boost::any(*changeFee);
    }
    if (deadlineTime) {
      res["deadline_time"] = boost::any(*deadlineTime);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (maxRetryTimes) {
      res["max_retry_times"] = boost::any(*maxRetryTimes);
    }
    if (nextRetryInterval) {
      res["next_retry_interval"] = boost::any(*nextRetryInterval);
    }
    if (retry) {
      res["retry"] = boost::any(*retry);
    }
    if (retryClientTips) {
      res["retry_client_tips"] = boost::any(*retryClientTips);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (upgradeFee) {
      res["upgrade_fee"] = boost::any(*upgradeFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("booking_changed_total_fee") != m.end() && !m["booking_changed_total_fee"].empty()) {
      bookingChangedTotalFee = make_shared<long>(boost::any_cast<long>(m["booking_changed_total_fee"]));
    }
    if (m.find("booking_origin_total_fee") != m.end() && !m["booking_origin_total_fee"].empty()) {
      bookingOriginTotalFee = make_shared<long>(boost::any_cast<long>(m["booking_origin_total_fee"]));
    }
    if (m.find("booking_price_changed") != m.end() && !m["booking_price_changed"].empty()) {
      bookingPriceChanged = make_shared<bool>(boost::any_cast<bool>(m["booking_price_changed"]));
    }
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_order_id"]));
    }
    if (m.find("btrip_sub_order_id") != m.end() && !m["btrip_sub_order_id"].empty()) {
      btripSubOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_sub_order_id"]));
    }
    if (m.find("can_pay") != m.end() && !m["can_pay"].empty()) {
      canPay = make_shared<bool>(boost::any_cast<bool>(m["can_pay"]));
    }
    if (m.find("change_fee") != m.end() && !m["change_fee"].empty()) {
      changeFee = make_shared<long>(boost::any_cast<long>(m["change_fee"]));
    }
    if (m.find("deadline_time") != m.end() && !m["deadline_time"].empty()) {
      deadlineTime = make_shared<string>(boost::any_cast<string>(m["deadline_time"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("max_retry_times") != m.end() && !m["max_retry_times"].empty()) {
      maxRetryTimes = make_shared<long>(boost::any_cast<long>(m["max_retry_times"]));
    }
    if (m.find("next_retry_interval") != m.end() && !m["next_retry_interval"].empty()) {
      nextRetryInterval = make_shared<long>(boost::any_cast<long>(m["next_retry_interval"]));
    }
    if (m.find("retry") != m.end() && !m["retry"].empty()) {
      retry = make_shared<bool>(boost::any_cast<bool>(m["retry"]));
    }
    if (m.find("retry_client_tips") != m.end() && !m["retry_client_tips"].empty()) {
      retryClientTips = make_shared<string>(boost::any_cast<string>(m["retry_client_tips"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("upgrade_fee") != m.end() && !m["upgrade_fee"].empty()) {
      upgradeFee = make_shared<long>(boost::any_cast<long>(m["upgrade_fee"]));
    }
  }


  virtual ~TicketChangingApplyResponseBodyModule() = default;
};
class TicketChangingApplyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TicketChangingApplyResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TicketChangingApplyResponseBody() {}

  explicit TicketChangingApplyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TicketChangingApplyResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TicketChangingApplyResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TicketChangingApplyResponseBody() = default;
};
class TicketChangingApplyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TicketChangingApplyResponseBody> body{};

  TicketChangingApplyResponse() {}

  explicit TicketChangingApplyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TicketChangingApplyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TicketChangingApplyResponseBody>(model1);
      }
    }
  }


  virtual ~TicketChangingApplyResponse() = default;
};
class TicketChangingCancelHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TicketChangingCancelHeaders() {}

  explicit TicketChangingCancelHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TicketChangingCancelHeaders() = default;
};
class TicketChangingCancelRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};

  TicketChangingCancelRequest() {}

  explicit TicketChangingCancelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
  }


  virtual ~TicketChangingCancelRequest() = default;
};
class TicketChangingCancelResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> cancelTime{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<string> status{};

  TicketChangingCancelResponseBodyModule() {}

  explicit TicketChangingCancelResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelTime) {
      res["cancel_time"] = boost::any(*cancelTime);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cancel_time") != m.end() && !m["cancel_time"].empty()) {
      cancelTime = make_shared<string>(boost::any_cast<string>(m["cancel_time"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~TicketChangingCancelResponseBodyModule() = default;
};
class TicketChangingCancelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TicketChangingCancelResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TicketChangingCancelResponseBody() {}

  explicit TicketChangingCancelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TicketChangingCancelResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TicketChangingCancelResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TicketChangingCancelResponseBody() = default;
};
class TicketChangingCancelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TicketChangingCancelResponseBody> body{};

  TicketChangingCancelResponse() {}

  explicit TicketChangingCancelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TicketChangingCancelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TicketChangingCancelResponseBody>(model1);
      }
    }
  }


  virtual ~TicketChangingCancelResponse() = default;
};
class TicketChangingDetailHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TicketChangingDetailHeaders() {}

  explicit TicketChangingDetailHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TicketChangingDetailHeaders() = default;
};
class TicketChangingDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};

  TicketChangingDetailRequest() {}

  explicit TicketChangingDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
  }


  virtual ~TicketChangingDetailRequest() = default;
};
class TicketChangingDetailResponseBodyModuleFlightInfoList : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};
  shared_ptr<string> arrAirport{};
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrAirportCodeName{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrTerminal{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> baggage{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> carrier{};
  shared_ptr<string> depAirport{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depAirportCodeName{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depTerminal{};
  shared_ptr<string> depTime{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> lastCabin{};
  shared_ptr<string> lastFlightNo{};
  shared_ptr<string> meal{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> segmentType{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<string> tuigaiqianInfo{};

  TicketChangingDetailResponseBodyModuleFlightInfoList() {}

  explicit TicketChangingDetailResponseBodyModuleFlightInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    if (arrAirport) {
      res["arr_airport"] = boost::any(*arrAirport);
    }
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrAirportCodeName) {
      res["arr_airport_code_name"] = boost::any(*arrAirportCodeName);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrTerminal) {
      res["arr_terminal"] = boost::any(*arrTerminal);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (baggage) {
      res["baggage"] = boost::any(*baggage);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (carrier) {
      res["carrier"] = boost::any(*carrier);
    }
    if (depAirport) {
      res["dep_airport"] = boost::any(*depAirport);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depAirportCodeName) {
      res["dep_airport_code_name"] = boost::any(*depAirportCodeName);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depTerminal) {
      res["dep_terminal"] = boost::any(*depTerminal);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (lastCabin) {
      res["last_cabin"] = boost::any(*lastCabin);
    }
    if (lastFlightNo) {
      res["last_flight_no"] = boost::any(*lastFlightNo);
    }
    if (meal) {
      res["meal"] = boost::any(*meal);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (segmentType) {
      res["segment_type"] = boost::any(*segmentType);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
    if (m.find("arr_airport") != m.end() && !m["arr_airport"].empty()) {
      arrAirport = make_shared<string>(boost::any_cast<string>(m["arr_airport"]));
    }
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_airport_code_name") != m.end() && !m["arr_airport_code_name"].empty()) {
      arrAirportCodeName = make_shared<string>(boost::any_cast<string>(m["arr_airport_code_name"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_terminal") != m.end() && !m["arr_terminal"].empty()) {
      arrTerminal = make_shared<string>(boost::any_cast<string>(m["arr_terminal"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("baggage") != m.end() && !m["baggage"].empty()) {
      baggage = make_shared<string>(boost::any_cast<string>(m["baggage"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("carrier") != m.end() && !m["carrier"].empty()) {
      carrier = make_shared<string>(boost::any_cast<string>(m["carrier"]));
    }
    if (m.find("dep_airport") != m.end() && !m["dep_airport"].empty()) {
      depAirport = make_shared<string>(boost::any_cast<string>(m["dep_airport"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_airport_code_name") != m.end() && !m["dep_airport_code_name"].empty()) {
      depAirportCodeName = make_shared<string>(boost::any_cast<string>(m["dep_airport_code_name"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_terminal") != m.end() && !m["dep_terminal"].empty()) {
      depTerminal = make_shared<string>(boost::any_cast<string>(m["dep_terminal"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("last_cabin") != m.end() && !m["last_cabin"].empty()) {
      lastCabin = make_shared<string>(boost::any_cast<string>(m["last_cabin"]));
    }
    if (m.find("last_flight_no") != m.end() && !m["last_flight_no"].empty()) {
      lastFlightNo = make_shared<string>(boost::any_cast<string>(m["last_flight_no"]));
    }
    if (m.find("meal") != m.end() && !m["meal"].empty()) {
      meal = make_shared<string>(boost::any_cast<string>(m["meal"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("segment_type") != m.end() && !m["segment_type"].empty()) {
      segmentType = make_shared<long>(boost::any_cast<long>(m["segment_type"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
  }


  virtual ~TicketChangingDetailResponseBodyModuleFlightInfoList() = default;
};
class TicketChangingDetailResponseBodyModuleTravelerInfoList : public Darabonba::Model {
public:
  shared_ptr<string> birthDate{};
  shared_ptr<string> certNo{};
  shared_ptr<string> certType{};
  shared_ptr<long> openTicketStatus{};
  shared_ptr<string> passengerName{};
  shared_ptr<string> passengerType{};
  shared_ptr<string> phone{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> userId{};

  TicketChangingDetailResponseBodyModuleTravelerInfoList() {}

  explicit TicketChangingDetailResponseBodyModuleTravelerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthDate) {
      res["birth_date"] = boost::any(*birthDate);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (openTicketStatus) {
      res["open_ticket_status"] = boost::any(*openTicketStatus);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birth_date") != m.end() && !m["birth_date"].empty()) {
      birthDate = make_shared<string>(boost::any_cast<string>(m["birth_date"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["cert_type"]));
    }
    if (m.find("open_ticket_status") != m.end() && !m["open_ticket_status"].empty()) {
      openTicketStatus = make_shared<long>(boost::any_cast<long>(m["open_ticket_status"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<string>(boost::any_cast<string>(m["passenger_type"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TicketChangingDetailResponseBodyModuleTravelerInfoList() = default;
};
class TicketChangingDetailResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<long> btripOrderId{};
  shared_ptr<long> btripSubOrderId{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<string> extra{};
  shared_ptr<vector<TicketChangingDetailResponseBodyModuleFlightInfoList>> flightInfoList{};
  shared_ptr<string> lastPayTime{};
  shared_ptr<long> payStatus{};
  shared_ptr<string> payTime{};
  shared_ptr<long> settlePrice{};
  shared_ptr<long> settleType{};
  shared_ptr<long> status{};
  shared_ptr<long> totalChangePrice{};
  shared_ptr<long> totalPrice{};
  shared_ptr<long> totalUpgradePrice{};
  shared_ptr<vector<TicketChangingDetailResponseBodyModuleTravelerInfoList>> travelerInfoList{};

  TicketChangingDetailResponseBodyModule() {}

  explicit TicketChangingDetailResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (btripSubOrderId) {
      res["btrip_sub_order_id"] = boost::any(*btripSubOrderId);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (flightInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_info_list"] = boost::any(temp1);
    }
    if (lastPayTime) {
      res["last_pay_time"] = boost::any(*lastPayTime);
    }
    if (payStatus) {
      res["pay_status"] = boost::any(*payStatus);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (settlePrice) {
      res["settle_price"] = boost::any(*settlePrice);
    }
    if (settleType) {
      res["settle_type"] = boost::any(*settleType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (totalChangePrice) {
      res["total_change_price"] = boost::any(*totalChangePrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    if (totalUpgradePrice) {
      res["total_upgrade_price"] = boost::any(*totalUpgradePrice);
    }
    if (travelerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_order_id"]));
    }
    if (m.find("btrip_sub_order_id") != m.end() && !m["btrip_sub_order_id"].empty()) {
      btripSubOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_sub_order_id"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("flight_info_list") != m.end() && !m["flight_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_info_list"].type()) {
        vector<TicketChangingDetailResponseBodyModuleFlightInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingDetailResponseBodyModuleFlightInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightInfoList = make_shared<vector<TicketChangingDetailResponseBodyModuleFlightInfoList>>(expect1);
      }
    }
    if (m.find("last_pay_time") != m.end() && !m["last_pay_time"].empty()) {
      lastPayTime = make_shared<string>(boost::any_cast<string>(m["last_pay_time"]));
    }
    if (m.find("pay_status") != m.end() && !m["pay_status"].empty()) {
      payStatus = make_shared<long>(boost::any_cast<long>(m["pay_status"]));
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<string>(boost::any_cast<string>(m["pay_time"]));
    }
    if (m.find("settle_price") != m.end() && !m["settle_price"].empty()) {
      settlePrice = make_shared<long>(boost::any_cast<long>(m["settle_price"]));
    }
    if (m.find("settle_type") != m.end() && !m["settle_type"].empty()) {
      settleType = make_shared<long>(boost::any_cast<long>(m["settle_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("total_change_price") != m.end() && !m["total_change_price"].empty()) {
      totalChangePrice = make_shared<long>(boost::any_cast<long>(m["total_change_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
    if (m.find("total_upgrade_price") != m.end() && !m["total_upgrade_price"].empty()) {
      totalUpgradePrice = make_shared<long>(boost::any_cast<long>(m["total_upgrade_price"]));
    }
    if (m.find("traveler_info_list") != m.end() && !m["traveler_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_info_list"].type()) {
        vector<TicketChangingDetailResponseBodyModuleTravelerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingDetailResponseBodyModuleTravelerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerInfoList = make_shared<vector<TicketChangingDetailResponseBodyModuleTravelerInfoList>>(expect1);
      }
    }
  }


  virtual ~TicketChangingDetailResponseBodyModule() = default;
};
class TicketChangingDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TicketChangingDetailResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TicketChangingDetailResponseBody() {}

  explicit TicketChangingDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TicketChangingDetailResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TicketChangingDetailResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TicketChangingDetailResponseBody() = default;
};
class TicketChangingDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TicketChangingDetailResponseBody> body{};

  TicketChangingDetailResponse() {}

  explicit TicketChangingDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TicketChangingDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TicketChangingDetailResponseBody>(model1);
      }
    }
  }


  virtual ~TicketChangingDetailResponse() = default;
};
class TicketChangingEnquiryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TicketChangingEnquiryHeaders() {}

  explicit TicketChangingEnquiryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TicketChangingEnquiryHeaders() = default;
};
class TicketChangingEnquiryRequest : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> depCity{};
  shared_ptr<string> disOrderId{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<string> modifyDepartDate{};
  shared_ptr<string> modifyFlightNo{};
  shared_ptr<string> sessionId{};

  TicketChangingEnquiryRequest() {}

  explicit TicketChangingEnquiryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (modifyDepartDate) {
      res["modify_depart_date"] = boost::any(*modifyDepartDate);
    }
    if (modifyFlightNo) {
      res["modify_flight_no"] = boost::any(*modifyFlightNo);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("modify_depart_date") != m.end() && !m["modify_depart_date"].empty()) {
      modifyDepartDate = make_shared<string>(boost::any_cast<string>(m["modify_depart_date"]));
    }
    if (m.find("modify_flight_no") != m.end() && !m["modify_flight_no"].empty()) {
      modifyFlightNo = make_shared<string>(boost::any_cast<string>(m["modify_flight_no"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
  }


  virtual ~TicketChangingEnquiryRequest() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["imageDO"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["subTitle"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("imageDO") != m.end() && !m["imageDO"].empty()) {
      if (typeid(map<string, boost::any>) == m["imageDO"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["imageDO"]));
        imageDO = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("subTitle") != m.end() && !m["subTitle"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["subTitle"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents : public Darabonba::Model {
public:
  shared_ptr<string> baggageDesc{};
  shared_ptr<string> icon{};
  shared_ptr<long> style{};
  shared_ptr<string> subTitle{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      baggageDesc = make_shared<string>(boost::any_cast<string>(m["baggage_desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> attributes{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents>> baggageSubContents{};
  shared_ptr<string> content{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributes) {
      res["attributes"] = boost::any(*attributes);
    }
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (baggageSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_contents"] = boost::any(temp1);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("attributes") != m.end() && !m["attributes"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["attributes"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      attributes = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("baggage_sub_contents") != m.end() && !m["baggage_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_contents"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContents = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents>>(expect1);
      }
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails : public Darabonba::Model {
public:
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> icon{};
  shared_ptr<string> title{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<string> style{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<string>(boost::any_cast<string>(m["style"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails : public Darabonba::Model {
public:
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems>> refundSubItems{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems>>(expect1);
      }
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> icon{};
  shared_ptr<string> title{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<string> style{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<string>(boost::any_cast<string>(m["style"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails : public Darabonba::Model {
public:
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems>> refundSubItems{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems>>(expect1);
      }
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq : public Darabonba::Model {
public:
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails>> baggageDetails{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails>> changeDetails{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails>> refundDetails{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDetails) {
      vector<boost::any> temp1;
      for(auto item1:*baggageDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_details"] = boost::any(temp1);
    }
    if (changeDetails) {
      vector<boost::any> temp1;
      for(auto item1:*changeDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["change_details"] = boost::any(temp1);
    }
    if (refundDetails) {
      vector<boost::any> temp1;
      for(auto item1:*refundDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_details"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_details") != m.end() && !m["baggage_details"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_details"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageDetails = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails>>(expect1);
      }
    }
    if (m.find("change_details") != m.end() && !m["change_details"].empty()) {
      if (typeid(vector<boost::any>) == m["change_details"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["change_details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeDetails = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails>>(expect1);
      }
    }
    if (m.find("refund_details") != m.end() && !m["refund_details"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_details"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundDetails = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails>>(expect1);
      }
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList : public Darabonba::Model {
public:
  shared_ptr<long> passengerType{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> upgradeFee{};
  shared_ptr<long> upgradePrice{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (upgradeFee) {
      res["upgrade_fee"] = boost::any(*upgradeFee);
    }
    if (upgradePrice) {
      res["upgrade_price"] = boost::any(*upgradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<long>(boost::any_cast<long>(m["passenger_type"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("upgrade_fee") != m.end() && !m["upgrade_fee"].empty()) {
      upgradeFee = make_shared<long>(boost::any_cast<long>(m["upgrade_fee"]));
    }
    if (m.find("upgrade_price") != m.end() && !m["upgrade_price"].empty()) {
      upgradePrice = make_shared<long>(boost::any_cast<long>(m["upgrade_price"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList : public Darabonba::Model {
public:
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinDesc{};
  shared_ptr<long> cabinDiscount{};
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq> changeOtaItemRuleRq{};
  shared_ptr<string> childCabin{};
  shared_ptr<string> leftNum{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList>> modifyPriceList{};
  shared_ptr<string> otaItemid{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinDesc) {
      res["cabin_desc"] = boost::any(*cabinDesc);
    }
    if (cabinDiscount) {
      res["cabin_discount"] = boost::any(*cabinDiscount);
    }
    if (changeOtaItemRuleRq) {
      res["change_ota_item_rule_rq"] = changeOtaItemRuleRq ? boost::any(changeOtaItemRuleRq->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (childCabin) {
      res["child_cabin"] = boost::any(*childCabin);
    }
    if (leftNum) {
      res["left_num"] = boost::any(*leftNum);
    }
    if (modifyPriceList) {
      vector<boost::any> temp1;
      for(auto item1:*modifyPriceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["modify_price_list"] = boost::any(temp1);
    }
    if (otaItemid) {
      res["ota_itemid"] = boost::any(*otaItemid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_desc") != m.end() && !m["cabin_desc"].empty()) {
      cabinDesc = make_shared<string>(boost::any_cast<string>(m["cabin_desc"]));
    }
    if (m.find("cabin_discount") != m.end() && !m["cabin_discount"].empty()) {
      cabinDiscount = make_shared<long>(boost::any_cast<long>(m["cabin_discount"]));
    }
    if (m.find("change_ota_item_rule_rq") != m.end() && !m["change_ota_item_rule_rq"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_ota_item_rule_rq"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_ota_item_rule_rq"]));
        changeOtaItemRuleRq = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq>(model1);
      }
    }
    if (m.find("child_cabin") != m.end() && !m["child_cabin"].empty()) {
      childCabin = make_shared<string>(boost::any_cast<string>(m["child_cabin"]));
    }
    if (m.find("left_num") != m.end() && !m["left_num"].empty()) {
      leftNum = make_shared<string>(boost::any_cast<string>(m["left_num"]));
    }
    if (m.find("modify_price_list") != m.end() && !m["modify_price_list"].empty()) {
      if (typeid(vector<boost::any>) == m["modify_price_list"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["modify_price_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modifyPriceList = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList>>(expect1);
      }
    }
    if (m.find("ota_itemid") != m.end() && !m["ota_itemid"].empty()) {
      otaItemid = make_shared<string>(boost::any_cast<string>(m["ota_itemid"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice : public Darabonba::Model {
public:
  shared_ptr<long> passengerType{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> upgradeFee{};
  shared_ptr<long> upgradePrice{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (upgradeFee) {
      res["upgrade_fee"] = boost::any(*upgradeFee);
    }
    if (upgradePrice) {
      res["upgrade_price"] = boost::any(*upgradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<long>(boost::any_cast<long>(m["passenger_type"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("upgrade_fee") != m.end() && !m["upgrade_fee"].empty()) {
      upgradeFee = make_shared<long>(boost::any_cast<long>(m["upgrade_fee"]));
    }
    if (m.find("upgrade_price") != m.end() && !m["upgrade_price"].empty()) {
      upgradePrice = make_shared<long>(boost::any_cast<long>(m["upgrade_price"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoList : public Darabonba::Model {
public:
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo> airlineInfo{};
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo> arrAirportInfo{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList>> cabinList{};
  shared_ptr<string> carrierAirline{};
  shared_ptr<string> carrierNo{};
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo> depAirportInfo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> flightNo{};
  shared_ptr<bool> isShare{};
  shared_ptr<string> lowestCabin{};
  shared_ptr<string> lowestCabinClass{};
  shared_ptr<string> lowestCabinDesc{};
  shared_ptr<string> lowestCabinNum{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice>> lowestCabinPrice{};
  shared_ptr<string> modifyFlightArrTime{};
  shared_ptr<string> modifyFlightDepDate{};
  shared_ptr<string> modifyFlightDepTime{};
  shared_ptr<string> sessionId{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoList() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cabinList) {
      vector<boost::any> temp1;
      for(auto item1:*cabinList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cabin_list"] = boost::any(temp1);
    }
    if (carrierAirline) {
      res["carrier_airline"] = boost::any(*carrierAirline);
    }
    if (carrierNo) {
      res["carrier_no"] = boost::any(*carrierNo);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (isShare) {
      res["is_share"] = boost::any(*isShare);
    }
    if (lowestCabin) {
      res["lowest_cabin"] = boost::any(*lowestCabin);
    }
    if (lowestCabinClass) {
      res["lowest_cabin_class"] = boost::any(*lowestCabinClass);
    }
    if (lowestCabinDesc) {
      res["lowest_cabin_desc"] = boost::any(*lowestCabinDesc);
    }
    if (lowestCabinNum) {
      res["lowest_cabin_num"] = boost::any(*lowestCabinNum);
    }
    if (lowestCabinPrice) {
      vector<boost::any> temp1;
      for(auto item1:*lowestCabinPrice){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["lowest_cabin_price"] = boost::any(temp1);
    }
    if (modifyFlightArrTime) {
      res["modify_flight_arr_time"] = boost::any(*modifyFlightArrTime);
    }
    if (modifyFlightDepDate) {
      res["modify_flight_dep_date"] = boost::any(*modifyFlightDepDate);
    }
    if (modifyFlightDepTime) {
      res["modify_flight_dep_time"] = boost::any(*modifyFlightDepTime);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo>(model1);
      }
    }
    if (m.find("cabin_list") != m.end() && !m["cabin_list"].empty()) {
      if (typeid(vector<boost::any>) == m["cabin_list"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cabin_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cabinList = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList>>(expect1);
      }
    }
    if (m.find("carrier_airline") != m.end() && !m["carrier_airline"].empty()) {
      carrierAirline = make_shared<string>(boost::any_cast<string>(m["carrier_airline"]));
    }
    if (m.find("carrier_no") != m.end() && !m["carrier_no"].empty()) {
      carrierNo = make_shared<string>(boost::any_cast<string>(m["carrier_no"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo>(model1);
      }
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("is_share") != m.end() && !m["is_share"].empty()) {
      isShare = make_shared<bool>(boost::any_cast<bool>(m["is_share"]));
    }
    if (m.find("lowest_cabin") != m.end() && !m["lowest_cabin"].empty()) {
      lowestCabin = make_shared<string>(boost::any_cast<string>(m["lowest_cabin"]));
    }
    if (m.find("lowest_cabin_class") != m.end() && !m["lowest_cabin_class"].empty()) {
      lowestCabinClass = make_shared<string>(boost::any_cast<string>(m["lowest_cabin_class"]));
    }
    if (m.find("lowest_cabin_desc") != m.end() && !m["lowest_cabin_desc"].empty()) {
      lowestCabinDesc = make_shared<string>(boost::any_cast<string>(m["lowest_cabin_desc"]));
    }
    if (m.find("lowest_cabin_num") != m.end() && !m["lowest_cabin_num"].empty()) {
      lowestCabinNum = make_shared<string>(boost::any_cast<string>(m["lowest_cabin_num"]));
    }
    if (m.find("lowest_cabin_price") != m.end() && !m["lowest_cabin_price"].empty()) {
      if (typeid(vector<boost::any>) == m["lowest_cabin_price"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["lowest_cabin_price"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lowestCabinPrice = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice>>(expect1);
      }
    }
    if (m.find("modify_flight_arr_time") != m.end() && !m["modify_flight_arr_time"].empty()) {
      modifyFlightArrTime = make_shared<string>(boost::any_cast<string>(m["modify_flight_arr_time"]));
    }
    if (m.find("modify_flight_dep_date") != m.end() && !m["modify_flight_dep_date"].empty()) {
      modifyFlightDepDate = make_shared<string>(boost::any_cast<string>(m["modify_flight_dep_date"]));
    }
    if (m.find("modify_flight_dep_time") != m.end() && !m["modify_flight_dep_time"].empty()) {
      modifyFlightDepTime = make_shared<string>(boost::any_cast<string>(m["modify_flight_dep_time"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoList() = default;
};
class TicketChangingEnquiryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoList>> flightInfoList{};

  TicketChangingEnquiryResponseBodyModule() {}

  explicit TicketChangingEnquiryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_info_list") != m.end() && !m["flight_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_info_list"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightInfoList = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoList>>(expect1);
      }
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModule() = default;
};
class TicketChangingEnquiryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TicketChangingEnquiryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TicketChangingEnquiryResponseBody() {}

  explicit TicketChangingEnquiryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TicketChangingEnquiryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TicketChangingEnquiryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBody() = default;
};
class TicketChangingEnquiryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TicketChangingEnquiryResponseBody> body{};

  TicketChangingEnquiryResponse() {}

  explicit TicketChangingEnquiryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TicketChangingEnquiryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TicketChangingEnquiryResponseBody>(model1);
      }
    }
  }


  virtual ~TicketChangingEnquiryResponse() = default;
};
class TicketChangingFlightListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TicketChangingFlightListHeaders() {}

  explicit TicketChangingFlightListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TicketChangingFlightListHeaders() = default;
};
class TicketChangingFlightListRequestTravelerInfoList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> depCity{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> userId{};

  TicketChangingFlightListRequestTravelerInfoList() {}

  explicit TicketChangingFlightListRequestTravelerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TicketChangingFlightListRequestTravelerInfoList() = default;
};
class TicketChangingFlightListRequest : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depDate{};
  shared_ptr<string> disOrderId{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<vector<TicketChangingFlightListRequestTravelerInfoList>> travelerInfoList{};

  TicketChangingFlightListRequest() {}

  explicit TicketChangingFlightListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (travelerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("traveler_info_list") != m.end() && !m["traveler_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_info_list"].type()) {
        vector<TicketChangingFlightListRequestTravelerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingFlightListRequestTravelerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerInfoList = make_shared<vector<TicketChangingFlightListRequestTravelerInfoList>>(expect1);
      }
    }
  }


  virtual ~TicketChangingFlightListRequest() = default;
};
class TicketChangingFlightListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depDate{};
  shared_ptr<string> disOrderId{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<string> travelerInfoListShrink{};

  TicketChangingFlightListShrinkRequest() {}

  explicit TicketChangingFlightListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (travelerInfoListShrink) {
      res["traveler_info_list"] = boost::any(*travelerInfoListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("traveler_info_list") != m.end() && !m["traveler_info_list"].empty()) {
      travelerInfoListShrink = make_shared<string>(boost::any_cast<string>(m["traveler_info_list"]));
    }
  }


  virtual ~TicketChangingFlightListShrinkRequest() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};

  TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList : public Darabonba::Model {
public:
  shared_ptr<long> passengerType{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> upgradeFee{};
  shared_ptr<long> upgradePrice{};

  TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (upgradeFee) {
      res["upgrade_fee"] = boost::any(*upgradeFee);
    }
    if (upgradePrice) {
      res["upgrade_price"] = boost::any(*upgradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<long>(boost::any_cast<long>(m["passenger_type"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("upgrade_fee") != m.end() && !m["upgrade_fee"].empty()) {
      upgradeFee = make_shared<long>(boost::any_cast<long>(m["upgrade_fee"]));
    }
    if (m.find("upgrade_price") != m.end() && !m["upgrade_price"].empty()) {
      upgradePrice = make_shared<long>(boost::any_cast<long>(m["upgrade_price"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList : public Darabonba::Model {
public:
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinDesc{};
  shared_ptr<long> cabinDiscount{};
  shared_ptr<string> childCabin{};
  shared_ptr<string> leftNum{};
  shared_ptr<vector<TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList>> modifyPriceList{};
  shared_ptr<string> otaItemid{};

  TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinDesc) {
      res["cabin_desc"] = boost::any(*cabinDesc);
    }
    if (cabinDiscount) {
      res["cabin_discount"] = boost::any(*cabinDiscount);
    }
    if (childCabin) {
      res["child_cabin"] = boost::any(*childCabin);
    }
    if (leftNum) {
      res["left_num"] = boost::any(*leftNum);
    }
    if (modifyPriceList) {
      vector<boost::any> temp1;
      for(auto item1:*modifyPriceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["modify_price_list"] = boost::any(temp1);
    }
    if (otaItemid) {
      res["ota_itemid"] = boost::any(*otaItemid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_desc") != m.end() && !m["cabin_desc"].empty()) {
      cabinDesc = make_shared<string>(boost::any_cast<string>(m["cabin_desc"]));
    }
    if (m.find("cabin_discount") != m.end() && !m["cabin_discount"].empty()) {
      cabinDiscount = make_shared<long>(boost::any_cast<long>(m["cabin_discount"]));
    }
    if (m.find("child_cabin") != m.end() && !m["child_cabin"].empty()) {
      childCabin = make_shared<string>(boost::any_cast<string>(m["child_cabin"]));
    }
    if (m.find("left_num") != m.end() && !m["left_num"].empty()) {
      leftNum = make_shared<string>(boost::any_cast<string>(m["left_num"]));
    }
    if (m.find("modify_price_list") != m.end() && !m["modify_price_list"].empty()) {
      if (typeid(vector<boost::any>) == m["modify_price_list"].type()) {
        vector<TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["modify_price_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modifyPriceList = make_shared<vector<TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList>>(expect1);
      }
    }
    if (m.find("ota_itemid") != m.end() && !m["ota_itemid"].empty()) {
      otaItemid = make_shared<string>(boost::any_cast<string>(m["ota_itemid"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice : public Darabonba::Model {
public:
  shared_ptr<long> passengerType{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> upgradeFee{};
  shared_ptr<long> upgradePrice{};

  TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (upgradeFee) {
      res["upgrade_fee"] = boost::any(*upgradeFee);
    }
    if (upgradePrice) {
      res["upgrade_price"] = boost::any(*upgradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<long>(boost::any_cast<long>(m["passenger_type"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("upgrade_fee") != m.end() && !m["upgrade_fee"].empty()) {
      upgradeFee = make_shared<long>(boost::any_cast<long>(m["upgrade_fee"]));
    }
    if (m.find("upgrade_price") != m.end() && !m["upgrade_price"].empty()) {
      upgradePrice = make_shared<long>(boost::any_cast<long>(m["upgrade_price"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoList : public Darabonba::Model {
public:
  shared_ptr<TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo> airlineInfo{};
  shared_ptr<TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo> arrAirportInfo{};
  shared_ptr<vector<TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList>> cabinList{};
  shared_ptr<string> carrierAirline{};
  shared_ptr<string> carrierNo{};
  shared_ptr<TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo> depAirportInfo{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> flightSize{};
  shared_ptr<string> flightType{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<bool> isShare{};
  shared_ptr<bool> isStop{};
  shared_ptr<string> lowestCabin{};
  shared_ptr<string> lowestCabinClass{};
  shared_ptr<string> lowestCabinDesc{};
  shared_ptr<string> lowestCabinNum{};
  shared_ptr<vector<TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice>> lowestCabinPrice{};
  shared_ptr<string> mealDesc{};
  shared_ptr<string> modifyFlightArrTime{};
  shared_ptr<string> modifyFlightDepDate{};
  shared_ptr<string> modifyFlightDepTime{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};

  TicketChangingFlightListResponseBodyModuleFlightInfoList() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cabinList) {
      vector<boost::any> temp1;
      for(auto item1:*cabinList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cabin_list"] = boost::any(temp1);
    }
    if (carrierAirline) {
      res["carrier_airline"] = boost::any(*carrierAirline);
    }
    if (carrierNo) {
      res["carrier_no"] = boost::any(*carrierNo);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (isShare) {
      res["is_share"] = boost::any(*isShare);
    }
    if (isStop) {
      res["is_stop"] = boost::any(*isStop);
    }
    if (lowestCabin) {
      res["lowest_cabin"] = boost::any(*lowestCabin);
    }
    if (lowestCabinClass) {
      res["lowest_cabin_class"] = boost::any(*lowestCabinClass);
    }
    if (lowestCabinDesc) {
      res["lowest_cabin_desc"] = boost::any(*lowestCabinDesc);
    }
    if (lowestCabinNum) {
      res["lowest_cabin_num"] = boost::any(*lowestCabinNum);
    }
    if (lowestCabinPrice) {
      vector<boost::any> temp1;
      for(auto item1:*lowestCabinPrice){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["lowest_cabin_price"] = boost::any(temp1);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (modifyFlightArrTime) {
      res["modify_flight_arr_time"] = boost::any(*modifyFlightArrTime);
    }
    if (modifyFlightDepDate) {
      res["modify_flight_dep_date"] = boost::any(*modifyFlightDepDate);
    }
    if (modifyFlightDepTime) {
      res["modify_flight_dep_time"] = boost::any(*modifyFlightDepTime);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo>(model1);
      }
    }
    if (m.find("cabin_list") != m.end() && !m["cabin_list"].empty()) {
      if (typeid(vector<boost::any>) == m["cabin_list"].type()) {
        vector<TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cabin_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cabinList = make_shared<vector<TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList>>(expect1);
      }
    }
    if (m.find("carrier_airline") != m.end() && !m["carrier_airline"].empty()) {
      carrierAirline = make_shared<string>(boost::any_cast<string>(m["carrier_airline"]));
    }
    if (m.find("carrier_no") != m.end() && !m["carrier_no"].empty()) {
      carrierNo = make_shared<string>(boost::any_cast<string>(m["carrier_no"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo>(model1);
      }
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("is_share") != m.end() && !m["is_share"].empty()) {
      isShare = make_shared<bool>(boost::any_cast<bool>(m["is_share"]));
    }
    if (m.find("is_stop") != m.end() && !m["is_stop"].empty()) {
      isStop = make_shared<bool>(boost::any_cast<bool>(m["is_stop"]));
    }
    if (m.find("lowest_cabin") != m.end() && !m["lowest_cabin"].empty()) {
      lowestCabin = make_shared<string>(boost::any_cast<string>(m["lowest_cabin"]));
    }
    if (m.find("lowest_cabin_class") != m.end() && !m["lowest_cabin_class"].empty()) {
      lowestCabinClass = make_shared<string>(boost::any_cast<string>(m["lowest_cabin_class"]));
    }
    if (m.find("lowest_cabin_desc") != m.end() && !m["lowest_cabin_desc"].empty()) {
      lowestCabinDesc = make_shared<string>(boost::any_cast<string>(m["lowest_cabin_desc"]));
    }
    if (m.find("lowest_cabin_num") != m.end() && !m["lowest_cabin_num"].empty()) {
      lowestCabinNum = make_shared<string>(boost::any_cast<string>(m["lowest_cabin_num"]));
    }
    if (m.find("lowest_cabin_price") != m.end() && !m["lowest_cabin_price"].empty()) {
      if (typeid(vector<boost::any>) == m["lowest_cabin_price"].type()) {
        vector<TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["lowest_cabin_price"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lowestCabinPrice = make_shared<vector<TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice>>(expect1);
      }
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("modify_flight_arr_time") != m.end() && !m["modify_flight_arr_time"].empty()) {
      modifyFlightArrTime = make_shared<string>(boost::any_cast<string>(m["modify_flight_arr_time"]));
    }
    if (m.find("modify_flight_dep_date") != m.end() && !m["modify_flight_dep_date"].empty()) {
      modifyFlightDepDate = make_shared<string>(boost::any_cast<string>(m["modify_flight_dep_date"]));
    }
    if (m.find("modify_flight_dep_time") != m.end() && !m["modify_flight_dep_time"].empty()) {
      modifyFlightDepTime = make_shared<string>(boost::any_cast<string>(m["modify_flight_dep_time"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoList() = default;
};
class TicketChangingFlightListResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<TicketChangingFlightListResponseBodyModuleFlightInfoList>> flightInfoList{};

  TicketChangingFlightListResponseBodyModule() {}

  explicit TicketChangingFlightListResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_info_list") != m.end() && !m["flight_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_info_list"].type()) {
        vector<TicketChangingFlightListResponseBodyModuleFlightInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingFlightListResponseBodyModuleFlightInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightInfoList = make_shared<vector<TicketChangingFlightListResponseBodyModuleFlightInfoList>>(expect1);
      }
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModule() = default;
};
class TicketChangingFlightListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TicketChangingFlightListResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TicketChangingFlightListResponseBody() {}

  explicit TicketChangingFlightListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TicketChangingFlightListResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TicketChangingFlightListResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBody() = default;
};
class TicketChangingFlightListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TicketChangingFlightListResponseBody> body{};

  TicketChangingFlightListResponse() {}

  explicit TicketChangingFlightListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TicketChangingFlightListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TicketChangingFlightListResponseBody>(model1);
      }
    }
  }


  virtual ~TicketChangingFlightListResponse() = default;
};
class TicketChangingPayHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TicketChangingPayHeaders() {}

  explicit TicketChangingPayHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TicketChangingPayHeaders() = default;
};
class TicketChangingPayRequest : public Darabonba::Model {
public:
  shared_ptr<long> corpPayPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<map<string, string>> extra{};
  shared_ptr<long> personalPayPrice{};
  shared_ptr<long> totalPayPrice{};

  TicketChangingPayRequest() {}

  explicit TicketChangingPayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpPayPrice) {
      res["corp_pay_price"] = boost::any(*corpPayPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (personalPayPrice) {
      res["personal_pay_price"] = boost::any(*personalPayPrice);
    }
    if (totalPayPrice) {
      res["total_pay_price"] = boost::any(*totalPayPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_pay_price") != m.end() && !m["corp_pay_price"].empty()) {
      corpPayPrice = make_shared<long>(boost::any_cast<long>(m["corp_pay_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["extra"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extra = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("personal_pay_price") != m.end() && !m["personal_pay_price"].empty()) {
      personalPayPrice = make_shared<long>(boost::any_cast<long>(m["personal_pay_price"]));
    }
    if (m.find("total_pay_price") != m.end() && !m["total_pay_price"].empty()) {
      totalPayPrice = make_shared<long>(boost::any_cast<long>(m["total_pay_price"]));
    }
  }


  virtual ~TicketChangingPayRequest() = default;
};
class TicketChangingPayShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> corpPayPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<string> extraShrink{};
  shared_ptr<long> personalPayPrice{};
  shared_ptr<long> totalPayPrice{};

  TicketChangingPayShrinkRequest() {}

  explicit TicketChangingPayShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpPayPrice) {
      res["corp_pay_price"] = boost::any(*corpPayPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (extraShrink) {
      res["extra"] = boost::any(*extraShrink);
    }
    if (personalPayPrice) {
      res["personal_pay_price"] = boost::any(*personalPayPrice);
    }
    if (totalPayPrice) {
      res["total_pay_price"] = boost::any(*totalPayPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_pay_price") != m.end() && !m["corp_pay_price"].empty()) {
      corpPayPrice = make_shared<long>(boost::any_cast<long>(m["corp_pay_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extraShrink = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("personal_pay_price") != m.end() && !m["personal_pay_price"].empty()) {
      personalPayPrice = make_shared<long>(boost::any_cast<long>(m["personal_pay_price"]));
    }
    if (m.find("total_pay_price") != m.end() && !m["total_pay_price"].empty()) {
      totalPayPrice = make_shared<long>(boost::any_cast<long>(m["total_pay_price"]));
    }
  }


  virtual ~TicketChangingPayShrinkRequest() = default;
};
class TicketChangingPayResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<bool> canRetry{};
  shared_ptr<long> payPrice{};
  shared_ptr<long> payStatus{};
  shared_ptr<string> payTime{};
  shared_ptr<string> tradeNo{};

  TicketChangingPayResponseBodyModule() {}

  explicit TicketChangingPayResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canRetry) {
      res["can_retry"] = boost::any(*canRetry);
    }
    if (payPrice) {
      res["pay_price"] = boost::any(*payPrice);
    }
    if (payStatus) {
      res["pay_status"] = boost::any(*payStatus);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (tradeNo) {
      res["trade_no"] = boost::any(*tradeNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("can_retry") != m.end() && !m["can_retry"].empty()) {
      canRetry = make_shared<bool>(boost::any_cast<bool>(m["can_retry"]));
    }
    if (m.find("pay_price") != m.end() && !m["pay_price"].empty()) {
      payPrice = make_shared<long>(boost::any_cast<long>(m["pay_price"]));
    }
    if (m.find("pay_status") != m.end() && !m["pay_status"].empty()) {
      payStatus = make_shared<long>(boost::any_cast<long>(m["pay_status"]));
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<string>(boost::any_cast<string>(m["pay_time"]));
    }
    if (m.find("trade_no") != m.end() && !m["trade_no"].empty()) {
      tradeNo = make_shared<string>(boost::any_cast<string>(m["trade_no"]));
    }
  }


  virtual ~TicketChangingPayResponseBodyModule() = default;
};
class TicketChangingPayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TicketChangingPayResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TicketChangingPayResponseBody() {}

  explicit TicketChangingPayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TicketChangingPayResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TicketChangingPayResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TicketChangingPayResponseBody() = default;
};
class TicketChangingPayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TicketChangingPayResponseBody> body{};

  TicketChangingPayResponse() {}

  explicit TicketChangingPayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TicketChangingPayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TicketChangingPayResponseBody>(model1);
      }
    }
  }


  virtual ~TicketChangingPayResponse() = default;
};
class TrainBillSettlementQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  TrainBillSettlementQueryHeaders() {}

  explicit TrainBillSettlementQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~TrainBillSettlementQueryHeaders() = default;
};
class TrainBillSettlementQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};

  TrainBillSettlementQueryRequest() {}

  explicit TrainBillSettlementQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
  }


  virtual ~TrainBillSettlementQueryRequest() = default;
};
class TrainBillSettlementQueryResponseBodyModuleDataList : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> applyId{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> arrStation{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> billRecordTime{};
  shared_ptr<string> bookTime{};
  shared_ptr<string> bookerId{};
  shared_ptr<string> bookerJobNo{};
  shared_ptr<string> bookerName{};
  shared_ptr<string> capitalDirection{};
  shared_ptr<string> cascadeDepartment{};
  shared_ptr<double> changeFee{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<double> coupon{};
  shared_ptr<string> department{};
  shared_ptr<string> departmentId{};
  shared_ptr<string> deptDate{};
  shared_ptr<string> deptStation{};
  shared_ptr<string> deptTime{};
  shared_ptr<string> feeType{};
  shared_ptr<string> index{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> orderId{};
  shared_ptr<double> orderPrice{};
  shared_ptr<string> overApplyId{};
  shared_ptr<long> primaryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<double> refundFee{};
  shared_ptr<string> remark{};
  shared_ptr<string> runTime{};
  shared_ptr<string> seatNo{};
  shared_ptr<string> seatType{};
  shared_ptr<double> serviceFee{};
  shared_ptr<double> settlementFee{};
  shared_ptr<double> settlementGrantFee{};
  shared_ptr<string> settlementTime{};
  shared_ptr<string> settlementType{};
  shared_ptr<long> status{};
  shared_ptr<string> ticketNo{};
  shared_ptr<double> ticketPrice{};
  shared_ptr<string> trainNo{};
  shared_ptr<string> trainType{};
  shared_ptr<string> travelerId{};
  shared_ptr<string> travelerJobNo{};
  shared_ptr<string> travelerName{};
  shared_ptr<long> voucherType{};

  TrainBillSettlementQueryResponseBodyModuleDataList() {}

  explicit TrainBillSettlementQueryResponseBodyModuleDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (arrStation) {
      res["arr_station"] = boost::any(*arrStation);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (billRecordTime) {
      res["bill_record_time"] = boost::any(*billRecordTime);
    }
    if (bookTime) {
      res["book_time"] = boost::any(*bookTime);
    }
    if (bookerId) {
      res["booker_id"] = boost::any(*bookerId);
    }
    if (bookerJobNo) {
      res["booker_job_no"] = boost::any(*bookerJobNo);
    }
    if (bookerName) {
      res["booker_name"] = boost::any(*bookerName);
    }
    if (capitalDirection) {
      res["capital_direction"] = boost::any(*capitalDirection);
    }
    if (cascadeDepartment) {
      res["cascade_department"] = boost::any(*cascadeDepartment);
    }
    if (changeFee) {
      res["change_fee"] = boost::any(*changeFee);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (coupon) {
      res["coupon"] = boost::any(*coupon);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (departmentId) {
      res["department_id"] = boost::any(*departmentId);
    }
    if (deptDate) {
      res["dept_date"] = boost::any(*deptDate);
    }
    if (deptStation) {
      res["dept_station"] = boost::any(*deptStation);
    }
    if (deptTime) {
      res["dept_time"] = boost::any(*deptTime);
    }
    if (feeType) {
      res["fee_type"] = boost::any(*feeType);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderPrice) {
      res["order_price"] = boost::any(*orderPrice);
    }
    if (overApplyId) {
      res["over_apply_id"] = boost::any(*overApplyId);
    }
    if (primaryId) {
      res["primary_id"] = boost::any(*primaryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (runTime) {
      res["run_time"] = boost::any(*runTime);
    }
    if (seatNo) {
      res["seat_no"] = boost::any(*seatNo);
    }
    if (seatType) {
      res["seat_type"] = boost::any(*seatType);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (settlementFee) {
      res["settlement_fee"] = boost::any(*settlementFee);
    }
    if (settlementGrantFee) {
      res["settlement_grant_fee"] = boost::any(*settlementGrantFee);
    }
    if (settlementTime) {
      res["settlement_time"] = boost::any(*settlementTime);
    }
    if (settlementType) {
      res["settlement_type"] = boost::any(*settlementType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (trainNo) {
      res["train_no"] = boost::any(*trainNo);
    }
    if (trainType) {
      res["train_type"] = boost::any(*trainType);
    }
    if (travelerId) {
      res["traveler_id"] = boost::any(*travelerId);
    }
    if (travelerJobNo) {
      res["traveler_job_no"] = boost::any(*travelerJobNo);
    }
    if (travelerName) {
      res["traveler_name"] = boost::any(*travelerName);
    }
    if (voucherType) {
      res["voucher_type"] = boost::any(*voucherType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("arr_station") != m.end() && !m["arr_station"].empty()) {
      arrStation = make_shared<string>(boost::any_cast<string>(m["arr_station"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("bill_record_time") != m.end() && !m["bill_record_time"].empty()) {
      billRecordTime = make_shared<string>(boost::any_cast<string>(m["bill_record_time"]));
    }
    if (m.find("book_time") != m.end() && !m["book_time"].empty()) {
      bookTime = make_shared<string>(boost::any_cast<string>(m["book_time"]));
    }
    if (m.find("booker_id") != m.end() && !m["booker_id"].empty()) {
      bookerId = make_shared<string>(boost::any_cast<string>(m["booker_id"]));
    }
    if (m.find("booker_job_no") != m.end() && !m["booker_job_no"].empty()) {
      bookerJobNo = make_shared<string>(boost::any_cast<string>(m["booker_job_no"]));
    }
    if (m.find("booker_name") != m.end() && !m["booker_name"].empty()) {
      bookerName = make_shared<string>(boost::any_cast<string>(m["booker_name"]));
    }
    if (m.find("capital_direction") != m.end() && !m["capital_direction"].empty()) {
      capitalDirection = make_shared<string>(boost::any_cast<string>(m["capital_direction"]));
    }
    if (m.find("cascade_department") != m.end() && !m["cascade_department"].empty()) {
      cascadeDepartment = make_shared<string>(boost::any_cast<string>(m["cascade_department"]));
    }
    if (m.find("change_fee") != m.end() && !m["change_fee"].empty()) {
      changeFee = make_shared<double>(boost::any_cast<double>(m["change_fee"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("coupon") != m.end() && !m["coupon"].empty()) {
      coupon = make_shared<double>(boost::any_cast<double>(m["coupon"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("department_id") != m.end() && !m["department_id"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["department_id"]));
    }
    if (m.find("dept_date") != m.end() && !m["dept_date"].empty()) {
      deptDate = make_shared<string>(boost::any_cast<string>(m["dept_date"]));
    }
    if (m.find("dept_station") != m.end() && !m["dept_station"].empty()) {
      deptStation = make_shared<string>(boost::any_cast<string>(m["dept_station"]));
    }
    if (m.find("dept_time") != m.end() && !m["dept_time"].empty()) {
      deptTime = make_shared<string>(boost::any_cast<string>(m["dept_time"]));
    }
    if (m.find("fee_type") != m.end() && !m["fee_type"].empty()) {
      feeType = make_shared<string>(boost::any_cast<string>(m["fee_type"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("order_price") != m.end() && !m["order_price"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["order_price"]));
    }
    if (m.find("over_apply_id") != m.end() && !m["over_apply_id"].empty()) {
      overApplyId = make_shared<string>(boost::any_cast<string>(m["over_apply_id"]));
    }
    if (m.find("primary_id") != m.end() && !m["primary_id"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["primary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<double>(boost::any_cast<double>(m["refund_fee"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("run_time") != m.end() && !m["run_time"].empty()) {
      runTime = make_shared<string>(boost::any_cast<string>(m["run_time"]));
    }
    if (m.find("seat_no") != m.end() && !m["seat_no"].empty()) {
      seatNo = make_shared<string>(boost::any_cast<string>(m["seat_no"]));
    }
    if (m.find("seat_type") != m.end() && !m["seat_type"].empty()) {
      seatType = make_shared<string>(boost::any_cast<string>(m["seat_type"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("settlement_fee") != m.end() && !m["settlement_fee"].empty()) {
      settlementFee = make_shared<double>(boost::any_cast<double>(m["settlement_fee"]));
    }
    if (m.find("settlement_grant_fee") != m.end() && !m["settlement_grant_fee"].empty()) {
      settlementGrantFee = make_shared<double>(boost::any_cast<double>(m["settlement_grant_fee"]));
    }
    if (m.find("settlement_time") != m.end() && !m["settlement_time"].empty()) {
      settlementTime = make_shared<string>(boost::any_cast<string>(m["settlement_time"]));
    }
    if (m.find("settlement_type") != m.end() && !m["settlement_type"].empty()) {
      settlementType = make_shared<string>(boost::any_cast<string>(m["settlement_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<double>(boost::any_cast<double>(m["ticket_price"]));
    }
    if (m.find("train_no") != m.end() && !m["train_no"].empty()) {
      trainNo = make_shared<string>(boost::any_cast<string>(m["train_no"]));
    }
    if (m.find("train_type") != m.end() && !m["train_type"].empty()) {
      trainType = make_shared<string>(boost::any_cast<string>(m["train_type"]));
    }
    if (m.find("traveler_id") != m.end() && !m["traveler_id"].empty()) {
      travelerId = make_shared<string>(boost::any_cast<string>(m["traveler_id"]));
    }
    if (m.find("traveler_job_no") != m.end() && !m["traveler_job_no"].empty()) {
      travelerJobNo = make_shared<string>(boost::any_cast<string>(m["traveler_job_no"]));
    }
    if (m.find("traveler_name") != m.end() && !m["traveler_name"].empty()) {
      travelerName = make_shared<string>(boost::any_cast<string>(m["traveler_name"]));
    }
    if (m.find("voucher_type") != m.end() && !m["voucher_type"].empty()) {
      voucherType = make_shared<long>(boost::any_cast<long>(m["voucher_type"]));
    }
  }


  virtual ~TrainBillSettlementQueryResponseBodyModuleDataList() = default;
};
class TrainBillSettlementQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> category{};
  shared_ptr<string> corpId{};
  shared_ptr<vector<TrainBillSettlementQueryResponseBodyModuleDataList>> dataList{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};
  shared_ptr<long> totalNum{};

  TrainBillSettlementQueryResponseBodyModule() {}

  explicit TrainBillSettlementQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_list"] = boost::any(temp1);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    if (totalNum) {
      res["total_num"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["category"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("data_list") != m.end() && !m["data_list"].empty()) {
      if (typeid(vector<boost::any>) == m["data_list"].type()) {
        vector<TrainBillSettlementQueryResponseBodyModuleDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainBillSettlementQueryResponseBodyModuleDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<TrainBillSettlementQueryResponseBodyModuleDataList>>(expect1);
      }
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
    if (m.find("total_num") != m.end() && !m["total_num"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["total_num"]));
    }
  }


  virtual ~TrainBillSettlementQueryResponseBodyModule() = default;
};
class TrainBillSettlementQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TrainBillSettlementQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainBillSettlementQueryResponseBody() {}

  explicit TrainBillSettlementQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TrainBillSettlementQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TrainBillSettlementQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainBillSettlementQueryResponseBody() = default;
};
class TrainBillSettlementQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainBillSettlementQueryResponseBody> body{};

  TrainBillSettlementQueryResponse() {}

  explicit TrainBillSettlementQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainBillSettlementQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainBillSettlementQueryResponseBody>(model1);
      }
    }
  }


  virtual ~TrainBillSettlementQueryResponse() = default;
};
class TrainExceedApplyQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  TrainExceedApplyQueryHeaders() {}

  explicit TrainExceedApplyQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~TrainExceedApplyQueryHeaders() = default;
};
class TrainExceedApplyQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};

  TrainExceedApplyQueryRequest() {}

  explicit TrainExceedApplyQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
  }


  virtual ~TrainExceedApplyQueryRequest() = default;
};
class TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrStation{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depStation{};
  shared_ptr<string> depTime{};
  shared_ptr<long> price{};
  shared_ptr<string> seatName{};
  shared_ptr<string> trainNo{};
  shared_ptr<string> trainTypeDesc{};
  shared_ptr<long> type{};

  TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO() {}

  explicit TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrStation) {
      res["arr_station"] = boost::any(*arrStation);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depStation) {
      res["dep_station"] = boost::any(*depStation);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (seatName) {
      res["seat_name"] = boost::any(*seatName);
    }
    if (trainNo) {
      res["train_no"] = boost::any(*trainNo);
    }
    if (trainTypeDesc) {
      res["train_type_desc"] = boost::any(*trainTypeDesc);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_station") != m.end() && !m["arr_station"].empty()) {
      arrStation = make_shared<string>(boost::any_cast<string>(m["arr_station"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_station") != m.end() && !m["dep_station"].empty()) {
      depStation = make_shared<string>(boost::any_cast<string>(m["dep_station"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("seat_name") != m.end() && !m["seat_name"].empty()) {
      seatName = make_shared<string>(boost::any_cast<string>(m["seat_name"]));
    }
    if (m.find("train_no") != m.end() && !m["train_no"].empty()) {
      trainNo = make_shared<string>(boost::any_cast<string>(m["train_no"]));
    }
    if (m.find("train_type_desc") != m.end() && !m["train_type_desc"].empty()) {
      trainTypeDesc = make_shared<string>(boost::any_cast<string>(m["train_type_desc"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO() = default;
};
class TrainExceedApplyQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO> applyIntentionInfoDO{};
  shared_ptr<string> btripCause{};
  shared_ptr<string> corpId{};
  shared_ptr<string> exceedReason{};
  shared_ptr<long> exceedType{};
  shared_ptr<string> originStandard{};
  shared_ptr<long> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartCorpId{};
  shared_ptr<string> userId{};

  TrainExceedApplyQueryResponseBodyModule() {}

  explicit TrainExceedApplyQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (applyIntentionInfoDO) {
      res["apply_intention_info_d_o"] = applyIntentionInfoDO ? boost::any(applyIntentionInfoDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (btripCause) {
      res["btrip_cause"] = boost::any(*btripCause);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (exceedReason) {
      res["exceed_reason"] = boost::any(*exceedReason);
    }
    if (exceedType) {
      res["exceed_type"] = boost::any(*exceedType);
    }
    if (originStandard) {
      res["origin_standard"] = boost::any(*originStandard);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (submitTime) {
      res["submit_time"] = boost::any(*submitTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartCorpId) {
      res["thirdpart_corp_id"] = boost::any(*thirdpartCorpId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("apply_intention_info_d_o") != m.end() && !m["apply_intention_info_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["apply_intention_info_d_o"].type()) {
        TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["apply_intention_info_d_o"]));
        applyIntentionInfoDO = make_shared<TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO>(model1);
      }
    }
    if (m.find("btrip_cause") != m.end() && !m["btrip_cause"].empty()) {
      btripCause = make_shared<string>(boost::any_cast<string>(m["btrip_cause"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("exceed_reason") != m.end() && !m["exceed_reason"].empty()) {
      exceedReason = make_shared<string>(boost::any_cast<string>(m["exceed_reason"]));
    }
    if (m.find("exceed_type") != m.end() && !m["exceed_type"].empty()) {
      exceedType = make_shared<long>(boost::any_cast<long>(m["exceed_type"]));
    }
    if (m.find("origin_standard") != m.end() && !m["origin_standard"].empty()) {
      originStandard = make_shared<string>(boost::any_cast<string>(m["origin_standard"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("submit_time") != m.end() && !m["submit_time"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["submit_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_corp_id") != m.end() && !m["thirdpart_corp_id"].empty()) {
      thirdpartCorpId = make_shared<string>(boost::any_cast<string>(m["thirdpart_corp_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainExceedApplyQueryResponseBodyModule() = default;
};
class TrainExceedApplyQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TrainExceedApplyQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainExceedApplyQueryResponseBody() {}

  explicit TrainExceedApplyQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TrainExceedApplyQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TrainExceedApplyQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainExceedApplyQueryResponseBody() = default;
};
class TrainExceedApplyQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainExceedApplyQueryResponseBody> body{};

  TrainExceedApplyQueryResponse() {}

  explicit TrainExceedApplyQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainExceedApplyQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainExceedApplyQueryResponseBody>(model1);
      }
    }
  }


  virtual ~TrainExceedApplyQueryResponse() = default;
};
class TrainOrderListQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  TrainOrderListQueryHeaders() {}

  explicit TrainOrderListQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~TrainOrderListQueryHeaders() = default;
};
class TrainOrderListQueryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allApply{};
  shared_ptr<long> applyId{};
  shared_ptr<string> departId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> updateEndTime{};
  shared_ptr<string> updateStartTime{};
  shared_ptr<string> userId{};

  TrainOrderListQueryRequest() {}

  explicit TrainOrderListQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allApply) {
      res["all_apply"] = boost::any(*allApply);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (updateEndTime) {
      res["update_end_time"] = boost::any(*updateEndTime);
    }
    if (updateStartTime) {
      res["update_start_time"] = boost::any(*updateStartTime);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_apply") != m.end() && !m["all_apply"].empty()) {
      allApply = make_shared<bool>(boost::any_cast<bool>(m["all_apply"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("update_end_time") != m.end() && !m["update_end_time"].empty()) {
      updateEndTime = make_shared<string>(boost::any_cast<string>(m["update_end_time"]));
    }
    if (m.find("update_start_time") != m.end() && !m["update_start_time"].empty()) {
      updateStartTime = make_shared<string>(boost::any_cast<string>(m["update_start_time"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderListQueryRequest() = default;
};
class TrainOrderListQueryResponseBodyModuleCostCenter : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> number{};

  TrainOrderListQueryResponseBodyModuleCostCenter() {}

  explicit TrainOrderListQueryResponseBodyModuleCostCenter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (number) {
      res["number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("number") != m.end() && !m["number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["number"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBodyModuleCostCenter() = default;
};
class TrainOrderListQueryResponseBodyModuleInvoice : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  TrainOrderListQueryResponseBodyModuleInvoice() {}

  explicit TrainOrderListQueryResponseBodyModuleInvoice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBodyModuleInvoice() = default;
};
class TrainOrderListQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<long> categoryType{};
  shared_ptr<string> endCity{};
  shared_ptr<string> endTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> originalTrainNo{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> seatType{};
  shared_ptr<string> startCity{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tradeId{};
  shared_ptr<string> trainNo{};
  shared_ptr<long> type{};

  TrainOrderListQueryResponseBodyModulePriceInfoList() {}

  explicit TrainOrderListQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (categoryType) {
      res["category_type"] = boost::any(*categoryType);
    }
    if (endCity) {
      res["end_city"] = boost::any(*endCity);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (originalTrainNo) {
      res["original_train_no"] = boost::any(*originalTrainNo);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (seatType) {
      res["seat_type"] = boost::any(*seatType);
    }
    if (startCity) {
      res["start_city"] = boost::any(*startCity);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (trainNo) {
      res["train_no"] = boost::any(*trainNo);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("category_type") != m.end() && !m["category_type"].empty()) {
      categoryType = make_shared<long>(boost::any_cast<long>(m["category_type"]));
    }
    if (m.find("end_city") != m.end() && !m["end_city"].empty()) {
      endCity = make_shared<string>(boost::any_cast<string>(m["end_city"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("original_train_no") != m.end() && !m["original_train_no"].empty()) {
      originalTrainNo = make_shared<string>(boost::any_cast<string>(m["original_train_no"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("seat_type") != m.end() && !m["seat_type"].empty()) {
      seatType = make_shared<string>(boost::any_cast<string>(m["seat_type"]));
    }
    if (m.find("start_city") != m.end() && !m["start_city"].empty()) {
      startCity = make_shared<string>(boost::any_cast<string>(m["start_city"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("train_no") != m.end() && !m["train_no"].empty()) {
      trainNo = make_shared<string>(boost::any_cast<string>(m["train_no"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBodyModulePriceInfoList() = default;
};
class TrainOrderListQueryResponseBodyModuleUserAffiliateList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  TrainOrderListQueryResponseBodyModuleUserAffiliateList() {}

  explicit TrainOrderListQueryResponseBodyModuleUserAffiliateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBodyModuleUserAffiliateList() = default;
};
class TrainOrderListQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrStation{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> contactName{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<TrainOrderListQueryResponseBodyModuleCostCenter> costCenter{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depStation{};
  shared_ptr<string> depTime{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<TrainOrderListQueryResponseBodyModuleInvoice> invoice{};
  shared_ptr<vector<TrainOrderListQueryResponseBodyModulePriceInfoList>> priceInfoList{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> riderName{};
  shared_ptr<string> runTime{};
  shared_ptr<string> seatType{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdPartProjectId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> ticketCount{};
  shared_ptr<string> ticketNo12306{};
  shared_ptr<string> trainNumber{};
  shared_ptr<string> trainType{};
  shared_ptr<vector<TrainOrderListQueryResponseBodyModuleUserAffiliateList>> userAffiliateList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  TrainOrderListQueryResponseBodyModule() {}

  explicit TrainOrderListQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrStation) {
      res["arr_station"] = boost::any(*arrStation);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (costCenter) {
      res["cost_center"] = costCenter ? boost::any(costCenter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depStation) {
      res["dep_station"] = boost::any(*depStation);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (invoice) {
      res["invoice"] = invoice ? boost::any(invoice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (riderName) {
      res["rider_name"] = boost::any(*riderName);
    }
    if (runTime) {
      res["run_time"] = boost::any(*runTime);
    }
    if (seatType) {
      res["seat_type"] = boost::any(*seatType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdPartProjectId) {
      res["third_part_project_id"] = boost::any(*thirdPartProjectId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (ticketCount) {
      res["ticket_count"] = boost::any(*ticketCount);
    }
    if (ticketNo12306) {
      res["ticket_no12306"] = boost::any(*ticketNo12306);
    }
    if (trainNumber) {
      res["train_number"] = boost::any(*trainNumber);
    }
    if (trainType) {
      res["train_type"] = boost::any(*trainType);
    }
    if (userAffiliateList) {
      vector<boost::any> temp1;
      for(auto item1:*userAffiliateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["user_affiliate_list"] = boost::any(temp1);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_station") != m.end() && !m["arr_station"].empty()) {
      arrStation = make_shared<string>(boost::any_cast<string>(m["arr_station"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      if (typeid(map<string, boost::any>) == m["cost_center"].type()) {
        TrainOrderListQueryResponseBodyModuleCostCenter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cost_center"]));
        costCenter = make_shared<TrainOrderListQueryResponseBodyModuleCostCenter>(model1);
      }
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_station") != m.end() && !m["dep_station"].empty()) {
      depStation = make_shared<string>(boost::any_cast<string>(m["dep_station"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("invoice") != m.end() && !m["invoice"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice"].type()) {
        TrainOrderListQueryResponseBodyModuleInvoice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice"]));
        invoice = make_shared<TrainOrderListQueryResponseBodyModuleInvoice>(model1);
      }
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<TrainOrderListQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderListQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<TrainOrderListQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("rider_name") != m.end() && !m["rider_name"].empty()) {
      riderName = make_shared<string>(boost::any_cast<string>(m["rider_name"]));
    }
    if (m.find("run_time") != m.end() && !m["run_time"].empty()) {
      runTime = make_shared<string>(boost::any_cast<string>(m["run_time"]));
    }
    if (m.find("seat_type") != m.end() && !m["seat_type"].empty()) {
      seatType = make_shared<string>(boost::any_cast<string>(m["seat_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("third_part_project_id") != m.end() && !m["third_part_project_id"].empty()) {
      thirdPartProjectId = make_shared<string>(boost::any_cast<string>(m["third_part_project_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("ticket_count") != m.end() && !m["ticket_count"].empty()) {
      ticketCount = make_shared<long>(boost::any_cast<long>(m["ticket_count"]));
    }
    if (m.find("ticket_no12306") != m.end() && !m["ticket_no12306"].empty()) {
      ticketNo12306 = make_shared<string>(boost::any_cast<string>(m["ticket_no12306"]));
    }
    if (m.find("train_number") != m.end() && !m["train_number"].empty()) {
      trainNumber = make_shared<string>(boost::any_cast<string>(m["train_number"]));
    }
    if (m.find("train_type") != m.end() && !m["train_type"].empty()) {
      trainType = make_shared<string>(boost::any_cast<string>(m["train_type"]));
    }
    if (m.find("user_affiliate_list") != m.end() && !m["user_affiliate_list"].empty()) {
      if (typeid(vector<boost::any>) == m["user_affiliate_list"].type()) {
        vector<TrainOrderListQueryResponseBodyModuleUserAffiliateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["user_affiliate_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderListQueryResponseBodyModuleUserAffiliateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userAffiliateList = make_shared<vector<TrainOrderListQueryResponseBodyModuleUserAffiliateList>>(expect1);
      }
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBodyModule() = default;
};
class TrainOrderListQueryResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalNumber{};

  TrainOrderListQueryResponseBodyPageInfo() {}

  explicit TrainOrderListQueryResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalNumber) {
      res["total_number"] = boost::any(*totalNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_number") != m.end() && !m["total_number"].empty()) {
      totalNumber = make_shared<long>(boost::any_cast<long>(m["total_number"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBodyPageInfo() = default;
};
class TrainOrderListQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<TrainOrderListQueryResponseBodyModule>> module{};
  shared_ptr<TrainOrderListQueryResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainOrderListQueryResponseBody() {}

  explicit TrainOrderListQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<TrainOrderListQueryResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderListQueryResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<TrainOrderListQueryResponseBodyModule>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        TrainOrderListQueryResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<TrainOrderListQueryResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBody() = default;
};
class TrainOrderListQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainOrderListQueryResponseBody> body{};

  TrainOrderListQueryResponse() {}

  explicit TrainOrderListQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainOrderListQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainOrderListQueryResponseBody>(model1);
      }
    }
  }


  virtual ~TrainOrderListQueryResponse() = default;
};
class TrainOrderQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  TrainOrderQueryHeaders() {}

  explicit TrainOrderQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~TrainOrderQueryHeaders() = default;
};
class TrainOrderQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<string> userId{};

  TrainOrderQueryRequest() {}

  explicit TrainOrderQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryRequest() = default;
};
class TrainOrderQueryResponseBodyModuleChangeTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> changeCoachNo{};
  shared_ptr<double> changeGapFee{};
  shared_ptr<double> changeHandlingFee{};
  shared_ptr<string> changeSeatNo{};
  shared_ptr<string> changeSeatTypeName{};
  shared_ptr<double> changeServiceFee{};
  shared_ptr<string> changeTrainNo{};
  shared_ptr<string> changeTrainTypeName{};
  shared_ptr<string> checkInTime{};
  shared_ptr<string> checkOutTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> fromStationName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> originTicketNo{};
  shared_ptr<string> outTicketStatus{};
  shared_ptr<string> startTime{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> toStationName{};

  TrainOrderQueryResponseBodyModuleChangeTicketInfoList() {}

  explicit TrainOrderQueryResponseBodyModuleChangeTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeCoachNo) {
      res["change_coach_no"] = boost::any(*changeCoachNo);
    }
    if (changeGapFee) {
      res["change_gap_fee"] = boost::any(*changeGapFee);
    }
    if (changeHandlingFee) {
      res["change_handling_fee"] = boost::any(*changeHandlingFee);
    }
    if (changeSeatNo) {
      res["change_seat_no"] = boost::any(*changeSeatNo);
    }
    if (changeSeatTypeName) {
      res["change_seat_type_name"] = boost::any(*changeSeatTypeName);
    }
    if (changeServiceFee) {
      res["change_service_fee"] = boost::any(*changeServiceFee);
    }
    if (changeTrainNo) {
      res["change_train_no"] = boost::any(*changeTrainNo);
    }
    if (changeTrainTypeName) {
      res["change_train_type_name"] = boost::any(*changeTrainTypeName);
    }
    if (checkInTime) {
      res["check_in_time"] = boost::any(*checkInTime);
    }
    if (checkOutTime) {
      res["check_out_time"] = boost::any(*checkOutTime);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (fromStationName) {
      res["from_station_name"] = boost::any(*fromStationName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (originTicketNo) {
      res["origin_ticket_no"] = boost::any(*originTicketNo);
    }
    if (outTicketStatus) {
      res["out_ticket_status"] = boost::any(*outTicketStatus);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (toStationName) {
      res["to_station_name"] = boost::any(*toStationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("change_coach_no") != m.end() && !m["change_coach_no"].empty()) {
      changeCoachNo = make_shared<string>(boost::any_cast<string>(m["change_coach_no"]));
    }
    if (m.find("change_gap_fee") != m.end() && !m["change_gap_fee"].empty()) {
      changeGapFee = make_shared<double>(boost::any_cast<double>(m["change_gap_fee"]));
    }
    if (m.find("change_handling_fee") != m.end() && !m["change_handling_fee"].empty()) {
      changeHandlingFee = make_shared<double>(boost::any_cast<double>(m["change_handling_fee"]));
    }
    if (m.find("change_seat_no") != m.end() && !m["change_seat_no"].empty()) {
      changeSeatNo = make_shared<string>(boost::any_cast<string>(m["change_seat_no"]));
    }
    if (m.find("change_seat_type_name") != m.end() && !m["change_seat_type_name"].empty()) {
      changeSeatTypeName = make_shared<string>(boost::any_cast<string>(m["change_seat_type_name"]));
    }
    if (m.find("change_service_fee") != m.end() && !m["change_service_fee"].empty()) {
      changeServiceFee = make_shared<double>(boost::any_cast<double>(m["change_service_fee"]));
    }
    if (m.find("change_train_no") != m.end() && !m["change_train_no"].empty()) {
      changeTrainNo = make_shared<string>(boost::any_cast<string>(m["change_train_no"]));
    }
    if (m.find("change_train_type_name") != m.end() && !m["change_train_type_name"].empty()) {
      changeTrainTypeName = make_shared<string>(boost::any_cast<string>(m["change_train_type_name"]));
    }
    if (m.find("check_in_time") != m.end() && !m["check_in_time"].empty()) {
      checkInTime = make_shared<string>(boost::any_cast<string>(m["check_in_time"]));
    }
    if (m.find("check_out_time") != m.end() && !m["check_out_time"].empty()) {
      checkOutTime = make_shared<string>(boost::any_cast<string>(m["check_out_time"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("from_station_name") != m.end() && !m["from_station_name"].empty()) {
      fromStationName = make_shared<string>(boost::any_cast<string>(m["from_station_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("origin_ticket_no") != m.end() && !m["origin_ticket_no"].empty()) {
      originTicketNo = make_shared<string>(boost::any_cast<string>(m["origin_ticket_no"]));
    }
    if (m.find("out_ticket_status") != m.end() && !m["out_ticket_status"].empty()) {
      outTicketStatus = make_shared<string>(boost::any_cast<string>(m["out_ticket_status"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("to_station_name") != m.end() && !m["to_station_name"].empty()) {
      toStationName = make_shared<string>(boost::any_cast<string>(m["to_station_name"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModuleChangeTicketInfoList() = default;
};
class TrainOrderQueryResponseBodyModuleInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  TrainOrderQueryResponseBodyModuleInvoiceInfo() {}

  explicit TrainOrderQueryResponseBodyModuleInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModuleInvoiceInfo() = default;
};
class TrainOrderQueryResponseBodyModuleOrderBaseInfo : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> contactName{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> exceedApplyId{};
  shared_ptr<string> exceedThirdPartApplyId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> orderId{};
  shared_ptr<long> orderStatus{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartCorpId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> tripType{};
  shared_ptr<string> userId{};

  TrainOrderQueryResponseBodyModuleOrderBaseInfo() {}

  explicit TrainOrderQueryResponseBodyModuleOrderBaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (exceedApplyId) {
      res["exceed_apply_id"] = boost::any(*exceedApplyId);
    }
    if (exceedThirdPartApplyId) {
      res["exceed_third_part_apply_id"] = boost::any(*exceedThirdPartApplyId);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartCorpId) {
      res["thirdpart_corp_id"] = boost::any(*thirdpartCorpId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("exceed_apply_id") != m.end() && !m["exceed_apply_id"].empty()) {
      exceedApplyId = make_shared<string>(boost::any_cast<string>(m["exceed_apply_id"]));
    }
    if (m.find("exceed_third_part_apply_id") != m.end() && !m["exceed_third_part_apply_id"].empty()) {
      exceedThirdPartApplyId = make_shared<string>(boost::any_cast<string>(m["exceed_third_part_apply_id"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_corp_id") != m.end() && !m["thirdpart_corp_id"].empty()) {
      thirdpartCorpId = make_shared<string>(boost::any_cast<string>(m["thirdpart_corp_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModuleOrderBaseInfo() = default;
};
class TrainOrderQueryResponseBodyModulePassengerInfoList : public Darabonba::Model {
public:
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartProjectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> userType{};

  TrainOrderQueryResponseBodyModulePassengerInfoList() {}

  explicit TrainOrderQueryResponseBodyModulePassengerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartProjectId) {
      res["thirdpart_project_id"] = boost::any(*thirdpartProjectId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_project_id") != m.end() && !m["thirdpart_project_id"].empty()) {
      thirdpartProjectId = make_shared<string>(boost::any_cast<string>(m["thirdpart_project_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModulePassengerInfoList() = default;
};
class TrainOrderQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  TrainOrderQueryResponseBodyModulePriceInfoList() {}

  explicit TrainOrderQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModulePriceInfoList() = default;
};
class TrainOrderQueryResponseBodyModuleRefundTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<double> refundFee{};
  shared_ptr<double> refundServiceFee{};
  shared_ptr<string> ticketNo{};

  TrainOrderQueryResponseBodyModuleRefundTicketInfoList() {}

  explicit TrainOrderQueryResponseBodyModuleRefundTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundServiceFee) {
      res["refund_service_fee"] = boost::any(*refundServiceFee);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<double>(boost::any_cast<double>(m["refund_fee"]));
    }
    if (m.find("refund_service_fee") != m.end() && !m["refund_service_fee"].empty()) {
      refundServiceFee = make_shared<double>(boost::any_cast<double>(m["refund_service_fee"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModuleRefundTicketInfoList() = default;
};
class TrainOrderQueryResponseBodyModuleTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<bool> changed{};
  shared_ptr<string> checkInTime{};
  shared_ptr<string> checkOutTime{};
  shared_ptr<string> coachNo{};
  shared_ptr<string> endTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> outTicketStatus{};
  shared_ptr<long> payType{};
  shared_ptr<string> seatNo{};
  shared_ptr<string> seatTypeName{};
  shared_ptr<double> serviceFee{};
  shared_ptr<string> startTime{};
  shared_ptr<string> ticketNo{};
  shared_ptr<double> ticketPrice{};
  shared_ptr<long> ticketStatus{};
  shared_ptr<string> trainTypeName{};
  shared_ptr<string> userId{};

  TrainOrderQueryResponseBodyModuleTicketInfoList() {}

  explicit TrainOrderQueryResponseBodyModuleTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changed) {
      res["changed"] = boost::any(*changed);
    }
    if (checkInTime) {
      res["check_in_time"] = boost::any(*checkInTime);
    }
    if (checkOutTime) {
      res["check_out_time"] = boost::any(*checkOutTime);
    }
    if (coachNo) {
      res["coach_no"] = boost::any(*coachNo);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (outTicketStatus) {
      res["out_ticket_status"] = boost::any(*outTicketStatus);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (seatNo) {
      res["seat_no"] = boost::any(*seatNo);
    }
    if (seatTypeName) {
      res["seat_type_name"] = boost::any(*seatTypeName);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (ticketStatus) {
      res["ticket_status"] = boost::any(*ticketStatus);
    }
    if (trainTypeName) {
      res["train_type_name"] = boost::any(*trainTypeName);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("changed") != m.end() && !m["changed"].empty()) {
      changed = make_shared<bool>(boost::any_cast<bool>(m["changed"]));
    }
    if (m.find("check_in_time") != m.end() && !m["check_in_time"].empty()) {
      checkInTime = make_shared<string>(boost::any_cast<string>(m["check_in_time"]));
    }
    if (m.find("check_out_time") != m.end() && !m["check_out_time"].empty()) {
      checkOutTime = make_shared<string>(boost::any_cast<string>(m["check_out_time"]));
    }
    if (m.find("coach_no") != m.end() && !m["coach_no"].empty()) {
      coachNo = make_shared<string>(boost::any_cast<string>(m["coach_no"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("out_ticket_status") != m.end() && !m["out_ticket_status"].empty()) {
      outTicketStatus = make_shared<string>(boost::any_cast<string>(m["out_ticket_status"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("seat_no") != m.end() && !m["seat_no"].empty()) {
      seatNo = make_shared<string>(boost::any_cast<string>(m["seat_no"]));
    }
    if (m.find("seat_type_name") != m.end() && !m["seat_type_name"].empty()) {
      seatTypeName = make_shared<string>(boost::any_cast<string>(m["seat_type_name"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<double>(boost::any_cast<double>(m["ticket_price"]));
    }
    if (m.find("ticket_status") != m.end() && !m["ticket_status"].empty()) {
      ticketStatus = make_shared<long>(boost::any_cast<long>(m["ticket_status"]));
    }
    if (m.find("train_type_name") != m.end() && !m["train_type_name"].empty()) {
      trainTypeName = make_shared<string>(boost::any_cast<string>(m["train_type_name"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModuleTicketInfoList() = default;
};
class TrainOrderQueryResponseBodyModuleTrainInfo : public Darabonba::Model {
public:
  shared_ptr<string> arrTime{};
  shared_ptr<string> depTime{};
  shared_ptr<string> fromStationName{};
  shared_ptr<long> runTime{};
  shared_ptr<string> toStationName{};
  shared_ptr<string> trainNo{};

  TrainOrderQueryResponseBodyModuleTrainInfo() {}

  explicit TrainOrderQueryResponseBodyModuleTrainInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (fromStationName) {
      res["from_station_name"] = boost::any(*fromStationName);
    }
    if (runTime) {
      res["run_time"] = boost::any(*runTime);
    }
    if (toStationName) {
      res["to_station_name"] = boost::any(*toStationName);
    }
    if (trainNo) {
      res["train_no"] = boost::any(*trainNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("from_station_name") != m.end() && !m["from_station_name"].empty()) {
      fromStationName = make_shared<string>(boost::any_cast<string>(m["from_station_name"]));
    }
    if (m.find("run_time") != m.end() && !m["run_time"].empty()) {
      runTime = make_shared<long>(boost::any_cast<long>(m["run_time"]));
    }
    if (m.find("to_station_name") != m.end() && !m["to_station_name"].empty()) {
      toStationName = make_shared<string>(boost::any_cast<string>(m["to_station_name"]));
    }
    if (m.find("train_no") != m.end() && !m["train_no"].empty()) {
      trainNo = make_shared<string>(boost::any_cast<string>(m["train_no"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModuleTrainInfo() = default;
};
class TrainOrderQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<TrainOrderQueryResponseBodyModuleChangeTicketInfoList>> changeTicketInfoList{};
  shared_ptr<TrainOrderQueryResponseBodyModuleInvoiceInfo> invoiceInfo{};
  shared_ptr<TrainOrderQueryResponseBodyModuleOrderBaseInfo> orderBaseInfo{};
  shared_ptr<vector<TrainOrderQueryResponseBodyModulePassengerInfoList>> passengerInfoList{};
  shared_ptr<vector<TrainOrderQueryResponseBodyModulePriceInfoList>> priceInfoList{};
  shared_ptr<vector<TrainOrderQueryResponseBodyModuleRefundTicketInfoList>> refundTicketInfoList{};
  shared_ptr<vector<TrainOrderQueryResponseBodyModuleTicketInfoList>> ticketInfoList{};
  shared_ptr<TrainOrderQueryResponseBodyModuleTrainInfo> trainInfo{};

  TrainOrderQueryResponseBodyModule() {}

  explicit TrainOrderQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*changeTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["change_ticket_info_list"] = boost::any(temp1);
    }
    if (invoiceInfo) {
      res["invoice_info"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderBaseInfo) {
      res["order_base_info"] = orderBaseInfo ? boost::any(orderBaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passengerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_info_list"] = boost::any(temp1);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    if (refundTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*refundTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_ticket_info_list"] = boost::any(temp1);
    }
    if (ticketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*ticketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ticket_info_list"] = boost::any(temp1);
    }
    if (trainInfo) {
      res["train_info"] = trainInfo ? boost::any(trainInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("change_ticket_info_list") != m.end() && !m["change_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["change_ticket_info_list"].type()) {
        vector<TrainOrderQueryResponseBodyModuleChangeTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["change_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryResponseBodyModuleChangeTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeTicketInfoList = make_shared<vector<TrainOrderQueryResponseBodyModuleChangeTicketInfoList>>(expect1);
      }
    }
    if (m.find("invoice_info") != m.end() && !m["invoice_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice_info"].type()) {
        TrainOrderQueryResponseBodyModuleInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice_info"]));
        invoiceInfo = make_shared<TrainOrderQueryResponseBodyModuleInvoiceInfo>(model1);
      }
    }
    if (m.find("order_base_info") != m.end() && !m["order_base_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["order_base_info"].type()) {
        TrainOrderQueryResponseBodyModuleOrderBaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["order_base_info"]));
        orderBaseInfo = make_shared<TrainOrderQueryResponseBodyModuleOrderBaseInfo>(model1);
      }
    }
    if (m.find("passenger_info_list") != m.end() && !m["passenger_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_info_list"].type()) {
        vector<TrainOrderQueryResponseBodyModulePassengerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryResponseBodyModulePassengerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerInfoList = make_shared<vector<TrainOrderQueryResponseBodyModulePassengerInfoList>>(expect1);
      }
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<TrainOrderQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<TrainOrderQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
    if (m.find("refund_ticket_info_list") != m.end() && !m["refund_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_ticket_info_list"].type()) {
        vector<TrainOrderQueryResponseBodyModuleRefundTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryResponseBodyModuleRefundTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundTicketInfoList = make_shared<vector<TrainOrderQueryResponseBodyModuleRefundTicketInfoList>>(expect1);
      }
    }
    if (m.find("ticket_info_list") != m.end() && !m["ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["ticket_info_list"].type()) {
        vector<TrainOrderQueryResponseBodyModuleTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryResponseBodyModuleTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ticketInfoList = make_shared<vector<TrainOrderQueryResponseBodyModuleTicketInfoList>>(expect1);
      }
    }
    if (m.find("train_info") != m.end() && !m["train_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["train_info"].type()) {
        TrainOrderQueryResponseBodyModuleTrainInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["train_info"]));
        trainInfo = make_shared<TrainOrderQueryResponseBodyModuleTrainInfo>(model1);
      }
    }
  }


  virtual ~TrainOrderQueryResponseBodyModule() = default;
};
class TrainOrderQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TrainOrderQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainOrderQueryResponseBody() {}

  explicit TrainOrderQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TrainOrderQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TrainOrderQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainOrderQueryResponseBody() = default;
};
class TrainOrderQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainOrderQueryResponseBody> body{};

  TrainOrderQueryResponse() {}

  explicit TrainOrderQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainOrderQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainOrderQueryResponseBody>(model1);
      }
    }
  }


  virtual ~TrainOrderQueryResponse() = default;
};
class TrainOrderQueryV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TrainOrderQueryV2Headers() {}

  explicit TrainOrderQueryV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TrainOrderQueryV2Headers() = default;
};
class TrainOrderQueryV2Request : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<string> userId{};

  TrainOrderQueryV2Request() {}

  explicit TrainOrderQueryV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryV2Request() = default;
};
class TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> changeCoachNo{};
  shared_ptr<double> changeGapFee{};
  shared_ptr<double> changeHandlingFee{};
  shared_ptr<string> changeSeatNo{};
  shared_ptr<string> changeSeatTypeName{};
  shared_ptr<double> changeServiceFee{};
  shared_ptr<string> changeTrainNo{};
  shared_ptr<string> changeTrainTypeName{};
  shared_ptr<string> checkInTime{};
  shared_ptr<string> checkOutTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> fromCityName{};
  shared_ptr<string> fromStationName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> originTicketNo{};
  shared_ptr<string> outTicketStatus{};
  shared_ptr<long> segmentIndex{};
  shared_ptr<string> startTime{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> toCityName{};
  shared_ptr<string> toStationName{};
  shared_ptr<string> useTicket{};
  shared_ptr<string> userId{};

  TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList() {}

  explicit TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeCoachNo) {
      res["change_coach_no"] = boost::any(*changeCoachNo);
    }
    if (changeGapFee) {
      res["change_gap_fee"] = boost::any(*changeGapFee);
    }
    if (changeHandlingFee) {
      res["change_handling_fee"] = boost::any(*changeHandlingFee);
    }
    if (changeSeatNo) {
      res["change_seat_no"] = boost::any(*changeSeatNo);
    }
    if (changeSeatTypeName) {
      res["change_seat_type_name"] = boost::any(*changeSeatTypeName);
    }
    if (changeServiceFee) {
      res["change_service_fee"] = boost::any(*changeServiceFee);
    }
    if (changeTrainNo) {
      res["change_train_no"] = boost::any(*changeTrainNo);
    }
    if (changeTrainTypeName) {
      res["change_train_type_name"] = boost::any(*changeTrainTypeName);
    }
    if (checkInTime) {
      res["check_in_time"] = boost::any(*checkInTime);
    }
    if (checkOutTime) {
      res["check_out_time"] = boost::any(*checkOutTime);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (fromCityName) {
      res["from_city_name"] = boost::any(*fromCityName);
    }
    if (fromStationName) {
      res["from_station_name"] = boost::any(*fromStationName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (originTicketNo) {
      res["origin_ticket_no"] = boost::any(*originTicketNo);
    }
    if (outTicketStatus) {
      res["out_ticket_status"] = boost::any(*outTicketStatus);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (toCityName) {
      res["to_city_name"] = boost::any(*toCityName);
    }
    if (toStationName) {
      res["to_station_name"] = boost::any(*toStationName);
    }
    if (useTicket) {
      res["use_ticket"] = boost::any(*useTicket);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("change_coach_no") != m.end() && !m["change_coach_no"].empty()) {
      changeCoachNo = make_shared<string>(boost::any_cast<string>(m["change_coach_no"]));
    }
    if (m.find("change_gap_fee") != m.end() && !m["change_gap_fee"].empty()) {
      changeGapFee = make_shared<double>(boost::any_cast<double>(m["change_gap_fee"]));
    }
    if (m.find("change_handling_fee") != m.end() && !m["change_handling_fee"].empty()) {
      changeHandlingFee = make_shared<double>(boost::any_cast<double>(m["change_handling_fee"]));
    }
    if (m.find("change_seat_no") != m.end() && !m["change_seat_no"].empty()) {
      changeSeatNo = make_shared<string>(boost::any_cast<string>(m["change_seat_no"]));
    }
    if (m.find("change_seat_type_name") != m.end() && !m["change_seat_type_name"].empty()) {
      changeSeatTypeName = make_shared<string>(boost::any_cast<string>(m["change_seat_type_name"]));
    }
    if (m.find("change_service_fee") != m.end() && !m["change_service_fee"].empty()) {
      changeServiceFee = make_shared<double>(boost::any_cast<double>(m["change_service_fee"]));
    }
    if (m.find("change_train_no") != m.end() && !m["change_train_no"].empty()) {
      changeTrainNo = make_shared<string>(boost::any_cast<string>(m["change_train_no"]));
    }
    if (m.find("change_train_type_name") != m.end() && !m["change_train_type_name"].empty()) {
      changeTrainTypeName = make_shared<string>(boost::any_cast<string>(m["change_train_type_name"]));
    }
    if (m.find("check_in_time") != m.end() && !m["check_in_time"].empty()) {
      checkInTime = make_shared<string>(boost::any_cast<string>(m["check_in_time"]));
    }
    if (m.find("check_out_time") != m.end() && !m["check_out_time"].empty()) {
      checkOutTime = make_shared<string>(boost::any_cast<string>(m["check_out_time"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("from_city_name") != m.end() && !m["from_city_name"].empty()) {
      fromCityName = make_shared<string>(boost::any_cast<string>(m["from_city_name"]));
    }
    if (m.find("from_station_name") != m.end() && !m["from_station_name"].empty()) {
      fromStationName = make_shared<string>(boost::any_cast<string>(m["from_station_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("origin_ticket_no") != m.end() && !m["origin_ticket_no"].empty()) {
      originTicketNo = make_shared<string>(boost::any_cast<string>(m["origin_ticket_no"]));
    }
    if (m.find("out_ticket_status") != m.end() && !m["out_ticket_status"].empty()) {
      outTicketStatus = make_shared<string>(boost::any_cast<string>(m["out_ticket_status"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("to_city_name") != m.end() && !m["to_city_name"].empty()) {
      toCityName = make_shared<string>(boost::any_cast<string>(m["to_city_name"]));
    }
    if (m.find("to_station_name") != m.end() && !m["to_station_name"].empty()) {
      toStationName = make_shared<string>(boost::any_cast<string>(m["to_station_name"]));
    }
    if (m.find("use_ticket") != m.end() && !m["use_ticket"].empty()) {
      useTicket = make_shared<string>(boost::any_cast<string>(m["use_ticket"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList() = default;
};
class TrainOrderQueryV2ResponseBodyModuleInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  TrainOrderQueryV2ResponseBodyModuleInvoiceInfo() {}

  explicit TrainOrderQueryV2ResponseBodyModuleInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleInvoiceInfo() = default;
};
class TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhone{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> exceedApplyId{};
  shared_ptr<string> exceedThirdpartApplyId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> orderId{};
  shared_ptr<long> orderStatus{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartDepartId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> tripType{};
  shared_ptr<string> userId{};
  shared_ptr<string> userNick{};

  TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo() {}

  explicit TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (contactPhone) {
      res["contact_phone"] = boost::any(*contactPhone);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (exceedApplyId) {
      res["exceed_apply_id"] = boost::any(*exceedApplyId);
    }
    if (exceedThirdpartApplyId) {
      res["exceed_thirdpart_apply_id"] = boost::any(*exceedThirdpartApplyId);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartDepartId) {
      res["thirdpart_depart_id"] = boost::any(*thirdpartDepartId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userNick) {
      res["user_nick"] = boost::any(*userNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("contact_phone") != m.end() && !m["contact_phone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["contact_phone"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("exceed_apply_id") != m.end() && !m["exceed_apply_id"].empty()) {
      exceedApplyId = make_shared<string>(boost::any_cast<string>(m["exceed_apply_id"]));
    }
    if (m.find("exceed_thirdpart_apply_id") != m.end() && !m["exceed_thirdpart_apply_id"].empty()) {
      exceedThirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["exceed_thirdpart_apply_id"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_depart_id") != m.end() && !m["thirdpart_depart_id"].empty()) {
      thirdpartDepartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_depart_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_nick") != m.end() && !m["user_nick"].empty()) {
      userNick = make_shared<string>(boost::any_cast<string>(m["user_nick"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo() = default;
};
class TrainOrderQueryV2ResponseBodyModulePassengerInfoList : public Darabonba::Model {
public:
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<string> thirdpartProjectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> userType{};

  TrainOrderQueryV2ResponseBodyModulePassengerInfoList() {}

  explicit TrainOrderQueryV2ResponseBodyModulePassengerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (thirdpartProjectId) {
      res["thirdpart_project_id"] = boost::any(*thirdpartProjectId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("thirdpart_project_id") != m.end() && !m["thirdpart_project_id"].empty()) {
      thirdpartProjectId = make_shared<string>(boost::any_cast<string>(m["thirdpart_project_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModulePassengerInfoList() = default;
};
class TrainOrderQueryV2ResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  TrainOrderQueryV2ResponseBodyModulePriceInfoList() {}

  explicit TrainOrderQueryV2ResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModulePriceInfoList() = default;
};
class TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<double> refundFee{};
  shared_ptr<double> refundServiceFee{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> userId{};

  TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList() {}

  explicit TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundServiceFee) {
      res["refund_service_fee"] = boost::any(*refundServiceFee);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<double>(boost::any_cast<double>(m["refund_fee"]));
    }
    if (m.find("refund_service_fee") != m.end() && !m["refund_service_fee"].empty()) {
      refundServiceFee = make_shared<double>(boost::any_cast<double>(m["refund_service_fee"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList() = default;
};
class TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos : public Darabonba::Model {
public:
  shared_ptr<bool> changed{};
  shared_ptr<string> checkInTime{};
  shared_ptr<string> checkOutTime{};
  shared_ptr<string> coachNo{};
  shared_ptr<string> endTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> outTicketStatus{};
  shared_ptr<long> payType{};
  shared_ptr<string> seatNo{};
  shared_ptr<string> seatTypeName{};
  shared_ptr<long> segmentIndex{};
  shared_ptr<double> serviceFee{};
  shared_ptr<string> startTime{};
  shared_ptr<string> ticketNo{};
  shared_ptr<double> ticketPrice{};
  shared_ptr<long> ticketStatus{};
  shared_ptr<string> trainTypeName{};
  shared_ptr<string> useTicket{};
  shared_ptr<string> userId{};

  TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos() {}

  explicit TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changed) {
      res["changed"] = boost::any(*changed);
    }
    if (checkInTime) {
      res["check_in_time"] = boost::any(*checkInTime);
    }
    if (checkOutTime) {
      res["check_out_time"] = boost::any(*checkOutTime);
    }
    if (coachNo) {
      res["coach_no"] = boost::any(*coachNo);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (outTicketStatus) {
      res["out_ticket_status"] = boost::any(*outTicketStatus);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (seatNo) {
      res["seat_no"] = boost::any(*seatNo);
    }
    if (seatTypeName) {
      res["seat_type_name"] = boost::any(*seatTypeName);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (ticketStatus) {
      res["ticket_status"] = boost::any(*ticketStatus);
    }
    if (trainTypeName) {
      res["train_type_name"] = boost::any(*trainTypeName);
    }
    if (useTicket) {
      res["use_ticket"] = boost::any(*useTicket);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("changed") != m.end() && !m["changed"].empty()) {
      changed = make_shared<bool>(boost::any_cast<bool>(m["changed"]));
    }
    if (m.find("check_in_time") != m.end() && !m["check_in_time"].empty()) {
      checkInTime = make_shared<string>(boost::any_cast<string>(m["check_in_time"]));
    }
    if (m.find("check_out_time") != m.end() && !m["check_out_time"].empty()) {
      checkOutTime = make_shared<string>(boost::any_cast<string>(m["check_out_time"]));
    }
    if (m.find("coach_no") != m.end() && !m["coach_no"].empty()) {
      coachNo = make_shared<string>(boost::any_cast<string>(m["coach_no"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("out_ticket_status") != m.end() && !m["out_ticket_status"].empty()) {
      outTicketStatus = make_shared<string>(boost::any_cast<string>(m["out_ticket_status"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("seat_no") != m.end() && !m["seat_no"].empty()) {
      seatNo = make_shared<string>(boost::any_cast<string>(m["seat_no"]));
    }
    if (m.find("seat_type_name") != m.end() && !m["seat_type_name"].empty()) {
      seatTypeName = make_shared<string>(boost::any_cast<string>(m["seat_type_name"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<double>(boost::any_cast<double>(m["ticket_price"]));
    }
    if (m.find("ticket_status") != m.end() && !m["ticket_status"].empty()) {
      ticketStatus = make_shared<long>(boost::any_cast<long>(m["ticket_status"]));
    }
    if (m.find("train_type_name") != m.end() && !m["train_type_name"].empty()) {
      trainTypeName = make_shared<string>(boost::any_cast<string>(m["train_type_name"]));
    }
    if (m.find("use_ticket") != m.end() && !m["use_ticket"].empty()) {
      useTicket = make_shared<string>(boost::any_cast<string>(m["use_ticket"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos() = default;
};
class TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList : public Darabonba::Model {
public:
  shared_ptr<string> arrTime{};
  shared_ptr<string> depTime{};
  shared_ptr<string> fromCityName{};
  shared_ptr<string> fromStationName{};
  shared_ptr<long> itemId{};
  shared_ptr<long> runTime{};
  shared_ptr<string> toCityName{};
  shared_ptr<string> toStationName{};
  shared_ptr<string> trainNo{};
  shared_ptr<vector<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos>> trainTicketInfos{};

  TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList() {}

  explicit TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (fromCityName) {
      res["from_city_name"] = boost::any(*fromCityName);
    }
    if (fromStationName) {
      res["from_station_name"] = boost::any(*fromStationName);
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (runTime) {
      res["run_time"] = boost::any(*runTime);
    }
    if (toCityName) {
      res["to_city_name"] = boost::any(*toCityName);
    }
    if (toStationName) {
      res["to_station_name"] = boost::any(*toStationName);
    }
    if (trainNo) {
      res["train_no"] = boost::any(*trainNo);
    }
    if (trainTicketInfos) {
      vector<boost::any> temp1;
      for(auto item1:*trainTicketInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["train_ticket_infos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("from_city_name") != m.end() && !m["from_city_name"].empty()) {
      fromCityName = make_shared<string>(boost::any_cast<string>(m["from_city_name"]));
    }
    if (m.find("from_station_name") != m.end() && !m["from_station_name"].empty()) {
      fromStationName = make_shared<string>(boost::any_cast<string>(m["from_station_name"]));
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["item_id"]));
    }
    if (m.find("run_time") != m.end() && !m["run_time"].empty()) {
      runTime = make_shared<long>(boost::any_cast<long>(m["run_time"]));
    }
    if (m.find("to_city_name") != m.end() && !m["to_city_name"].empty()) {
      toCityName = make_shared<string>(boost::any_cast<string>(m["to_city_name"]));
    }
    if (m.find("to_station_name") != m.end() && !m["to_station_name"].empty()) {
      toStationName = make_shared<string>(boost::any_cast<string>(m["to_station_name"]));
    }
    if (m.find("train_no") != m.end() && !m["train_no"].empty()) {
      trainNo = make_shared<string>(boost::any_cast<string>(m["train_no"]));
    }
    if (m.find("train_ticket_infos") != m.end() && !m["train_ticket_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["train_ticket_infos"].type()) {
        vector<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["train_ticket_infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trainTicketInfos = make_shared<vector<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos>>(expect1);
      }
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList() = default;
};
class TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo : public Darabonba::Model {
public:
  shared_ptr<string> costTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> fromCityName{};
  shared_ptr<string> fromStationName{};
  shared_ptr<string> middleCity{};
  shared_ptr<string> middleDate{};
  shared_ptr<string> middleStation{};
  shared_ptr<string> middleType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> toCityName{};
  shared_ptr<string> toStationName{};
  shared_ptr<string> waitTime{};

  TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo() {}

  explicit TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costTime) {
      res["cost_time"] = boost::any(*costTime);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (fromCityName) {
      res["from_city_name"] = boost::any(*fromCityName);
    }
    if (fromStationName) {
      res["from_station_name"] = boost::any(*fromStationName);
    }
    if (middleCity) {
      res["middle_city"] = boost::any(*middleCity);
    }
    if (middleDate) {
      res["middle_date"] = boost::any(*middleDate);
    }
    if (middleStation) {
      res["middle_station"] = boost::any(*middleStation);
    }
    if (middleType) {
      res["middle_type"] = boost::any(*middleType);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (toCityName) {
      res["to_city_name"] = boost::any(*toCityName);
    }
    if (toStationName) {
      res["to_station_name"] = boost::any(*toStationName);
    }
    if (waitTime) {
      res["wait_time"] = boost::any(*waitTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost_time") != m.end() && !m["cost_time"].empty()) {
      costTime = make_shared<string>(boost::any_cast<string>(m["cost_time"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("from_city_name") != m.end() && !m["from_city_name"].empty()) {
      fromCityName = make_shared<string>(boost::any_cast<string>(m["from_city_name"]));
    }
    if (m.find("from_station_name") != m.end() && !m["from_station_name"].empty()) {
      fromStationName = make_shared<string>(boost::any_cast<string>(m["from_station_name"]));
    }
    if (m.find("middle_city") != m.end() && !m["middle_city"].empty()) {
      middleCity = make_shared<string>(boost::any_cast<string>(m["middle_city"]));
    }
    if (m.find("middle_date") != m.end() && !m["middle_date"].empty()) {
      middleDate = make_shared<string>(boost::any_cast<string>(m["middle_date"]));
    }
    if (m.find("middle_station") != m.end() && !m["middle_station"].empty()) {
      middleStation = make_shared<string>(boost::any_cast<string>(m["middle_station"]));
    }
    if (m.find("middle_type") != m.end() && !m["middle_type"].empty()) {
      middleType = make_shared<string>(boost::any_cast<string>(m["middle_type"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("to_city_name") != m.end() && !m["to_city_name"].empty()) {
      toCityName = make_shared<string>(boost::any_cast<string>(m["to_city_name"]));
    }
    if (m.find("to_station_name") != m.end() && !m["to_station_name"].empty()) {
      toStationName = make_shared<string>(boost::any_cast<string>(m["to_station_name"]));
    }
    if (m.find("wait_time") != m.end() && !m["wait_time"].empty()) {
      waitTime = make_shared<string>(boost::any_cast<string>(m["wait_time"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo() = default;
};
class TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo : public Darabonba::Model {
public:
  shared_ptr<vector<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList>> trainInfoList{};
  shared_ptr<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo> trainTransferInfo{};

  TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo() {}

  explicit TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trainInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*trainInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["train_info_list"] = boost::any(temp1);
    }
    if (trainTransferInfo) {
      res["train_transfer_info"] = trainTransferInfo ? boost::any(trainTransferInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("train_info_list") != m.end() && !m["train_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["train_info_list"].type()) {
        vector<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["train_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trainInfoList = make_shared<vector<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList>>(expect1);
      }
    }
    if (m.find("train_transfer_info") != m.end() && !m["train_transfer_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["train_transfer_info"].type()) {
        TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["train_transfer_info"]));
        trainTransferInfo = make_shared<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo>(model1);
      }
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo() = default;
};
class TrainOrderQueryV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList>> changeTicketInfoList{};
  shared_ptr<TrainOrderQueryV2ResponseBodyModuleInvoiceInfo> invoiceInfo{};
  shared_ptr<TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo> orderBaseInfo{};
  shared_ptr<vector<TrainOrderQueryV2ResponseBodyModulePassengerInfoList>> passengerInfoList{};
  shared_ptr<vector<TrainOrderQueryV2ResponseBodyModulePriceInfoList>> priceInfoList{};
  shared_ptr<vector<TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList>> refundTicketInfoList{};
  shared_ptr<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo> trainOrderInfo{};

  TrainOrderQueryV2ResponseBodyModule() {}

  explicit TrainOrderQueryV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*changeTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["change_ticket_info_list"] = boost::any(temp1);
    }
    if (invoiceInfo) {
      res["invoice_info"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderBaseInfo) {
      res["order_base_info"] = orderBaseInfo ? boost::any(orderBaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passengerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_info_list"] = boost::any(temp1);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    if (refundTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*refundTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_ticket_info_list"] = boost::any(temp1);
    }
    if (trainOrderInfo) {
      res["train_order_info"] = trainOrderInfo ? boost::any(trainOrderInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("change_ticket_info_list") != m.end() && !m["change_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["change_ticket_info_list"].type()) {
        vector<TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["change_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeTicketInfoList = make_shared<vector<TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList>>(expect1);
      }
    }
    if (m.find("invoice_info") != m.end() && !m["invoice_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice_info"].type()) {
        TrainOrderQueryV2ResponseBodyModuleInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice_info"]));
        invoiceInfo = make_shared<TrainOrderQueryV2ResponseBodyModuleInvoiceInfo>(model1);
      }
    }
    if (m.find("order_base_info") != m.end() && !m["order_base_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["order_base_info"].type()) {
        TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["order_base_info"]));
        orderBaseInfo = make_shared<TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo>(model1);
      }
    }
    if (m.find("passenger_info_list") != m.end() && !m["passenger_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_info_list"].type()) {
        vector<TrainOrderQueryV2ResponseBodyModulePassengerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryV2ResponseBodyModulePassengerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerInfoList = make_shared<vector<TrainOrderQueryV2ResponseBodyModulePassengerInfoList>>(expect1);
      }
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<TrainOrderQueryV2ResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryV2ResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<TrainOrderQueryV2ResponseBodyModulePriceInfoList>>(expect1);
      }
    }
    if (m.find("refund_ticket_info_list") != m.end() && !m["refund_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_ticket_info_list"].type()) {
        vector<TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundTicketInfoList = make_shared<vector<TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList>>(expect1);
      }
    }
    if (m.find("train_order_info") != m.end() && !m["train_order_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["train_order_info"].type()) {
        TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["train_order_info"]));
        trainOrderInfo = make_shared<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo>(model1);
      }
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModule() = default;
};
class TrainOrderQueryV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TrainOrderQueryV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainOrderQueryV2ResponseBody() {}

  explicit TrainOrderQueryV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TrainOrderQueryV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TrainOrderQueryV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBody() = default;
};
class TrainOrderQueryV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainOrderQueryV2ResponseBody> body{};

  TrainOrderQueryV2Response() {}

  explicit TrainOrderQueryV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainOrderQueryV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainOrderQueryV2ResponseBody>(model1);
      }
    }
  }


  virtual ~TrainOrderQueryV2Response() = default;
};
class TrainStationSearchHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  TrainStationSearchHeaders() {}

  explicit TrainStationSearchHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~TrainStationSearchHeaders() = default;
};
class TrainStationSearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};

  TrainStationSearchRequest() {}

  explicit TrainStationSearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["keyword"] = boost::any(*keyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("keyword") != m.end() && !m["keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["keyword"]));
    }
  }


  virtual ~TrainStationSearchRequest() = default;
};
class TrainStationSearchResponseBodyModuleCities : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  TrainStationSearchResponseBodyModuleCities() {}

  explicit TrainStationSearchResponseBodyModuleCities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~TrainStationSearchResponseBodyModuleCities() = default;
};
class TrainStationSearchResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<TrainStationSearchResponseBodyModuleCities>> cities{};

  TrainStationSearchResponseBodyModule() {}

  explicit TrainStationSearchResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cities) {
      vector<boost::any> temp1;
      for(auto item1:*cities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cities"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cities") != m.end() && !m["cities"].empty()) {
      if (typeid(vector<boost::any>) == m["cities"].type()) {
        vector<TrainStationSearchResponseBodyModuleCities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainStationSearchResponseBodyModuleCities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cities = make_shared<vector<TrainStationSearchResponseBodyModuleCities>>(expect1);
      }
    }
  }


  virtual ~TrainStationSearchResponseBodyModule() = default;
};
class TrainStationSearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TrainStationSearchResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainStationSearchResponseBody() {}

  explicit TrainStationSearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TrainStationSearchResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TrainStationSearchResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainStationSearchResponseBody() = default;
};
class TrainStationSearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainStationSearchResponseBody> body{};

  TrainStationSearchResponse() {}

  explicit TrainStationSearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainStationSearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainStationSearchResponseBody>(model1);
      }
    }
  }


  virtual ~TrainStationSearchResponse() = default;
};
class TrainTicketScanQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  TrainTicketScanQueryHeaders() {}

  explicit TrainTicketScanQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~TrainTicketScanQueryHeaders() = default;
};
class TrainTicketScanQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};
  shared_ptr<long> billId{};
  shared_ptr<long> invoiceSubTaskId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  TrainTicketScanQueryRequest() {}

  explicit TrainTicketScanQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (billId) {
      res["bill_id"] = boost::any(*billId);
    }
    if (invoiceSubTaskId) {
      res["invoice_sub_task_id"] = boost::any(*invoiceSubTaskId);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("bill_id") != m.end() && !m["bill_id"].empty()) {
      billId = make_shared<long>(boost::any_cast<long>(m["bill_id"]));
    }
    if (m.find("invoice_sub_task_id") != m.end() && !m["invoice_sub_task_id"].empty()) {
      invoiceSubTaskId = make_shared<long>(boost::any_cast<long>(m["invoice_sub_task_id"]));
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
  }


  virtual ~TrainTicketScanQueryRequest() = default;
};
class TrainTicketScanQueryResponseBodyModuleItems : public Darabonba::Model {
public:
  shared_ptr<string> arrStation{};
  shared_ptr<string> billDate{};
  shared_ptr<string> coachName{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> depStation{};
  shared_ptr<string> depTime{};
  shared_ptr<string> department{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<long> orderId{};
  shared_ptr<string> ossUrl{};
  shared_ptr<string> passenger{};
  shared_ptr<string> price{};
  shared_ptr<string> project{};
  shared_ptr<string> seat{};
  shared_ptr<string> seatNo{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> taxAmount{};
  shared_ptr<string> taxRate{};

  TrainTicketScanQueryResponseBodyModuleItems() {}

  explicit TrainTicketScanQueryResponseBodyModuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrStation) {
      res["arr_station"] = boost::any(*arrStation);
    }
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (coachName) {
      res["coach_name"] = boost::any(*coachName);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (depStation) {
      res["dep_station"] = boost::any(*depStation);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (ossUrl) {
      res["oss_url"] = boost::any(*ossUrl);
    }
    if (passenger) {
      res["passenger"] = boost::any(*passenger);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (project) {
      res["project"] = boost::any(*project);
    }
    if (seat) {
      res["seat"] = boost::any(*seat);
    }
    if (seatNo) {
      res["seat_no"] = boost::any(*seatNo);
    }
    if (serialNumber) {
      res["serial_number"] = boost::any(*serialNumber);
    }
    if (taxAmount) {
      res["tax_amount"] = boost::any(*taxAmount);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_station") != m.end() && !m["arr_station"].empty()) {
      arrStation = make_shared<string>(boost::any_cast<string>(m["arr_station"]));
    }
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("coach_name") != m.end() && !m["coach_name"].empty()) {
      coachName = make_shared<string>(boost::any_cast<string>(m["coach_name"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("dep_station") != m.end() && !m["dep_station"].empty()) {
      depStation = make_shared<string>(boost::any_cast<string>(m["dep_station"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("oss_url") != m.end() && !m["oss_url"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["oss_url"]));
    }
    if (m.find("passenger") != m.end() && !m["passenger"].empty()) {
      passenger = make_shared<string>(boost::any_cast<string>(m["passenger"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<string>(boost::any_cast<string>(m["price"]));
    }
    if (m.find("project") != m.end() && !m["project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["project"]));
    }
    if (m.find("seat") != m.end() && !m["seat"].empty()) {
      seat = make_shared<string>(boost::any_cast<string>(m["seat"]));
    }
    if (m.find("seat_no") != m.end() && !m["seat_no"].empty()) {
      seatNo = make_shared<string>(boost::any_cast<string>(m["seat_no"]));
    }
    if (m.find("serial_number") != m.end() && !m["serial_number"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["serial_number"]));
    }
    if (m.find("tax_amount") != m.end() && !m["tax_amount"].empty()) {
      taxAmount = make_shared<string>(boost::any_cast<string>(m["tax_amount"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
  }


  virtual ~TrainTicketScanQueryResponseBodyModuleItems() = default;
};
class TrainTicketScanQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<TrainTicketScanQueryResponseBodyModuleItems>> items{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalPage{};
  shared_ptr<long> totalSize{};

  TrainTicketScanQueryResponseBodyModule() {}

  explicit TrainTicketScanQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalPage) {
      res["total_page"] = boost::any(*totalPage);
    }
    if (totalSize) {
      res["total_size"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<TrainTicketScanQueryResponseBodyModuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainTicketScanQueryResponseBodyModuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<TrainTicketScanQueryResponseBodyModuleItems>>(expect1);
      }
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_page") != m.end() && !m["total_page"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["total_page"]));
    }
    if (m.find("total_size") != m.end() && !m["total_size"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["total_size"]));
    }
  }


  virtual ~TrainTicketScanQueryResponseBodyModule() = default;
};
class TrainTicketScanQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TrainTicketScanQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainTicketScanQueryResponseBody() {}

  explicit TrainTicketScanQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TrainTicketScanQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TrainTicketScanQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainTicketScanQueryResponseBody() = default;
};
class TrainTicketScanQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainTicketScanQueryResponseBody> body{};

  TrainTicketScanQueryResponse() {}

  explicit TrainTicketScanQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainTicketScanQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainTicketScanQueryResponseBody>(model1);
      }
    }
  }


  virtual ~TrainTicketScanQueryResponse() = default;
};
class UserQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  UserQueryHeaders() {}

  explicit UserQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~UserQueryHeaders() = default;
};
class UserQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> modifiedTimeGreaterOrEqualThan{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pageToken{};
  shared_ptr<string> thirdPartJobNo{};

  UserQueryRequest() {}

  explicit UserQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modifiedTimeGreaterOrEqualThan) {
      res["modified_time_greater_or_equal_than"] = boost::any(*modifiedTimeGreaterOrEqualThan);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (pageToken) {
      res["page_token"] = boost::any(*pageToken);
    }
    if (thirdPartJobNo) {
      res["third_part_job_no"] = boost::any(*thirdPartJobNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("modified_time_greater_or_equal_than") != m.end() && !m["modified_time_greater_or_equal_than"].empty()) {
      modifiedTimeGreaterOrEqualThan = make_shared<string>(boost::any_cast<string>(m["modified_time_greater_or_equal_than"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("page_token") != m.end() && !m["page_token"].empty()) {
      pageToken = make_shared<string>(boost::any_cast<string>(m["page_token"]));
    }
    if (m.find("third_part_job_no") != m.end() && !m["third_part_job_no"].empty()) {
      thirdPartJobNo = make_shared<string>(boost::any_cast<string>(m["third_part_job_no"]));
    }
  }


  virtual ~UserQueryRequest() = default;
};
class UserQueryResponseBodyModuleItems : public Darabonba::Model {
public:
  shared_ptr<string> employeeNick{};
  shared_ptr<long> leaveStatus{};
  shared_ptr<string> thirdPartEmployeeId{};
  shared_ptr<string> thirdPartJobNo{};

  UserQueryResponseBodyModuleItems() {}

  explicit UserQueryResponseBodyModuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (employeeNick) {
      res["employee_nick"] = boost::any(*employeeNick);
    }
    if (leaveStatus) {
      res["leave_status"] = boost::any(*leaveStatus);
    }
    if (thirdPartEmployeeId) {
      res["third_part_employee_id"] = boost::any(*thirdPartEmployeeId);
    }
    if (thirdPartJobNo) {
      res["third_part_job_no"] = boost::any(*thirdPartJobNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("employee_nick") != m.end() && !m["employee_nick"].empty()) {
      employeeNick = make_shared<string>(boost::any_cast<string>(m["employee_nick"]));
    }
    if (m.find("leave_status") != m.end() && !m["leave_status"].empty()) {
      leaveStatus = make_shared<long>(boost::any_cast<long>(m["leave_status"]));
    }
    if (m.find("third_part_employee_id") != m.end() && !m["third_part_employee_id"].empty()) {
      thirdPartEmployeeId = make_shared<string>(boost::any_cast<string>(m["third_part_employee_id"]));
    }
    if (m.find("third_part_job_no") != m.end() && !m["third_part_job_no"].empty()) {
      thirdPartJobNo = make_shared<string>(boost::any_cast<string>(m["third_part_job_no"]));
    }
  }


  virtual ~UserQueryResponseBodyModuleItems() = default;
};
class UserQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<UserQueryResponseBodyModuleItems>> items{};
  shared_ptr<string> pageToken{};
  shared_ptr<long> total{};

  UserQueryResponseBodyModule() {}

  explicit UserQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["has_more"] = boost::any(*hasMore);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (pageToken) {
      res["page_token"] = boost::any(*pageToken);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("has_more") != m.end() && !m["has_more"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["has_more"]));
    }
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<UserQueryResponseBodyModuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UserQueryResponseBodyModuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<UserQueryResponseBodyModuleItems>>(expect1);
      }
    }
    if (m.find("page_token") != m.end() && !m["page_token"].empty()) {
      pageToken = make_shared<string>(boost::any_cast<string>(m["page_token"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~UserQueryResponseBodyModule() = default;
};
class UserQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<UserQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UserQueryResponseBody() {}

  explicit UserQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        UserQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<UserQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~UserQueryResponseBody() = default;
};
class UserQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UserQueryResponseBody> body{};

  UserQueryResponse() {}

  explicit UserQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UserQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UserQueryResponseBody>(model1);
      }
    }
  }


  virtual ~UserQueryResponse() = default;
};
class VatInvoiceScanQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  VatInvoiceScanQueryHeaders() {}

  explicit VatInvoiceScanQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~VatInvoiceScanQueryHeaders() = default;
};
class VatInvoiceScanQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};
  shared_ptr<long> billId{};
  shared_ptr<long> invoiceSubTaskId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  VatInvoiceScanQueryRequest() {}

  explicit VatInvoiceScanQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (billId) {
      res["bill_id"] = boost::any(*billId);
    }
    if (invoiceSubTaskId) {
      res["invoice_sub_task_id"] = boost::any(*invoiceSubTaskId);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("bill_id") != m.end() && !m["bill_id"].empty()) {
      billId = make_shared<long>(boost::any_cast<long>(m["bill_id"]));
    }
    if (m.find("invoice_sub_task_id") != m.end() && !m["invoice_sub_task_id"].empty()) {
      invoiceSubTaskId = make_shared<long>(boost::any_cast<long>(m["invoice_sub_task_id"]));
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
  }


  virtual ~VatInvoiceScanQueryRequest() = default;
};
class VatInvoiceScanQueryResponseBodyModuleItems : public Darabonba::Model {
public:
  shared_ptr<string> amountWithTax{};
  shared_ptr<string> amountWithoutTax{};
  shared_ptr<string> billDate{};
  shared_ptr<string> invoiceCode{};
  shared_ptr<string> invoiceDay{};
  shared_ptr<string> invoiceDetail{};
  shared_ptr<string> invoiceNo{};
  shared_ptr<long> invoiceSubTaskId{};
  shared_ptr<long> invoiceType{};
  shared_ptr<string> invoiceTypeDesc{};
  shared_ptr<string> ossUrl{};
  shared_ptr<string> purchaserName{};
  shared_ptr<string> purchaserTaxNo{};
  shared_ptr<string> sellerName{};
  shared_ptr<string> sellerTaxNo{};
  shared_ptr<string> taxAmount{};
  shared_ptr<string> taxRate{};

  VatInvoiceScanQueryResponseBodyModuleItems() {}

  explicit VatInvoiceScanQueryResponseBodyModuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amountWithTax) {
      res["amount_with_tax"] = boost::any(*amountWithTax);
    }
    if (amountWithoutTax) {
      res["amount_without_tax"] = boost::any(*amountWithoutTax);
    }
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (invoiceCode) {
      res["invoice_code"] = boost::any(*invoiceCode);
    }
    if (invoiceDay) {
      res["invoice_day"] = boost::any(*invoiceDay);
    }
    if (invoiceDetail) {
      res["invoice_detail"] = boost::any(*invoiceDetail);
    }
    if (invoiceNo) {
      res["invoice_no"] = boost::any(*invoiceNo);
    }
    if (invoiceSubTaskId) {
      res["invoice_sub_task_id"] = boost::any(*invoiceSubTaskId);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (invoiceTypeDesc) {
      res["invoice_type_desc"] = boost::any(*invoiceTypeDesc);
    }
    if (ossUrl) {
      res["oss_url"] = boost::any(*ossUrl);
    }
    if (purchaserName) {
      res["purchaser_name"] = boost::any(*purchaserName);
    }
    if (purchaserTaxNo) {
      res["purchaser_tax_no"] = boost::any(*purchaserTaxNo);
    }
    if (sellerName) {
      res["seller_name"] = boost::any(*sellerName);
    }
    if (sellerTaxNo) {
      res["seller_tax_no"] = boost::any(*sellerTaxNo);
    }
    if (taxAmount) {
      res["tax_amount"] = boost::any(*taxAmount);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount_with_tax") != m.end() && !m["amount_with_tax"].empty()) {
      amountWithTax = make_shared<string>(boost::any_cast<string>(m["amount_with_tax"]));
    }
    if (m.find("amount_without_tax") != m.end() && !m["amount_without_tax"].empty()) {
      amountWithoutTax = make_shared<string>(boost::any_cast<string>(m["amount_without_tax"]));
    }
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("invoice_code") != m.end() && !m["invoice_code"].empty()) {
      invoiceCode = make_shared<string>(boost::any_cast<string>(m["invoice_code"]));
    }
    if (m.find("invoice_day") != m.end() && !m["invoice_day"].empty()) {
      invoiceDay = make_shared<string>(boost::any_cast<string>(m["invoice_day"]));
    }
    if (m.find("invoice_detail") != m.end() && !m["invoice_detail"].empty()) {
      invoiceDetail = make_shared<string>(boost::any_cast<string>(m["invoice_detail"]));
    }
    if (m.find("invoice_no") != m.end() && !m["invoice_no"].empty()) {
      invoiceNo = make_shared<string>(boost::any_cast<string>(m["invoice_no"]));
    }
    if (m.find("invoice_sub_task_id") != m.end() && !m["invoice_sub_task_id"].empty()) {
      invoiceSubTaskId = make_shared<long>(boost::any_cast<long>(m["invoice_sub_task_id"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("invoice_type_desc") != m.end() && !m["invoice_type_desc"].empty()) {
      invoiceTypeDesc = make_shared<string>(boost::any_cast<string>(m["invoice_type_desc"]));
    }
    if (m.find("oss_url") != m.end() && !m["oss_url"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["oss_url"]));
    }
    if (m.find("purchaser_name") != m.end() && !m["purchaser_name"].empty()) {
      purchaserName = make_shared<string>(boost::any_cast<string>(m["purchaser_name"]));
    }
    if (m.find("purchaser_tax_no") != m.end() && !m["purchaser_tax_no"].empty()) {
      purchaserTaxNo = make_shared<string>(boost::any_cast<string>(m["purchaser_tax_no"]));
    }
    if (m.find("seller_name") != m.end() && !m["seller_name"].empty()) {
      sellerName = make_shared<string>(boost::any_cast<string>(m["seller_name"]));
    }
    if (m.find("seller_tax_no") != m.end() && !m["seller_tax_no"].empty()) {
      sellerTaxNo = make_shared<string>(boost::any_cast<string>(m["seller_tax_no"]));
    }
    if (m.find("tax_amount") != m.end() && !m["tax_amount"].empty()) {
      taxAmount = make_shared<string>(boost::any_cast<string>(m["tax_amount"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
  }


  virtual ~VatInvoiceScanQueryResponseBodyModuleItems() = default;
};
class VatInvoiceScanQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<VatInvoiceScanQueryResponseBodyModuleItems>> items{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalPage{};
  shared_ptr<long> totalSize{};

  VatInvoiceScanQueryResponseBodyModule() {}

  explicit VatInvoiceScanQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalPage) {
      res["total_page"] = boost::any(*totalPage);
    }
    if (totalSize) {
      res["total_size"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<VatInvoiceScanQueryResponseBodyModuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            VatInvoiceScanQueryResponseBodyModuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<VatInvoiceScanQueryResponseBodyModuleItems>>(expect1);
      }
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_page") != m.end() && !m["total_page"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["total_page"]));
    }
    if (m.find("total_size") != m.end() && !m["total_size"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["total_size"]));
    }
  }


  virtual ~VatInvoiceScanQueryResponseBodyModule() = default;
};
class VatInvoiceScanQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<VatInvoiceScanQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  VatInvoiceScanQueryResponseBody() {}

  explicit VatInvoiceScanQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        VatInvoiceScanQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<VatInvoiceScanQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~VatInvoiceScanQueryResponseBody() = default;
};
class VatInvoiceScanQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VatInvoiceScanQueryResponseBody> body{};

  VatInvoiceScanQueryResponse() {}

  explicit VatInvoiceScanQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VatInvoiceScanQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VatInvoiceScanQueryResponseBody>(model1);
      }
    }
  }


  virtual ~VatInvoiceScanQueryResponse() = default;
};
class WaitApplyInvoiceTaskDetailQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  WaitApplyInvoiceTaskDetailQueryHeaders() {}

  explicit WaitApplyInvoiceTaskDetailQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~WaitApplyInvoiceTaskDetailQueryHeaders() = default;
};
class WaitApplyInvoiceTaskDetailQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};

  WaitApplyInvoiceTaskDetailQueryRequest() {}

  explicit WaitApplyInvoiceTaskDetailQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
  }


  virtual ~WaitApplyInvoiceTaskDetailQueryRequest() = default;
};
class WaitApplyInvoiceTaskDetailQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> contact{};
  shared_ptr<string> email{};
  shared_ptr<string> flightInvoiceFee{};
  shared_ptr<string> fuPointInvoiceFee{};
  shared_ptr<string> hotelNormalInvoiceFee{};
  shared_ptr<string> hotelSpecialInvoiceFee{};
  shared_ptr<string> internationalFlightInvoiceFee{};
  shared_ptr<string> invoiceThirdPartId{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> mailAddress{};
  shared_ptr<string> mailCity{};
  shared_ptr<string> mailFullAddress{};
  shared_ptr<string> mailProvince{};
  shared_ptr<string> penaltyFee{};
  shared_ptr<string> remark{};
  shared_ptr<string> serviceFee{};
  shared_ptr<string> telephone{};
  shared_ptr<string> trainInvoiceFee{};
  shared_ptr<string> vehicleInvoiceFee{};

  WaitApplyInvoiceTaskDetailQueryResponseBodyModule() {}

  explicit WaitApplyInvoiceTaskDetailQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contact) {
      res["contact"] = boost::any(*contact);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (flightInvoiceFee) {
      res["flight_invoice_fee"] = boost::any(*flightInvoiceFee);
    }
    if (fuPointInvoiceFee) {
      res["fu_point_invoice_fee"] = boost::any(*fuPointInvoiceFee);
    }
    if (hotelNormalInvoiceFee) {
      res["hotel_normal_invoice_fee"] = boost::any(*hotelNormalInvoiceFee);
    }
    if (hotelSpecialInvoiceFee) {
      res["hotel_special_invoice_fee"] = boost::any(*hotelSpecialInvoiceFee);
    }
    if (internationalFlightInvoiceFee) {
      res["international_flight_invoice_fee"] = boost::any(*internationalFlightInvoiceFee);
    }
    if (invoiceThirdPartId) {
      res["invoice_third_part_id"] = boost::any(*invoiceThirdPartId);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (mailAddress) {
      res["mail_address"] = boost::any(*mailAddress);
    }
    if (mailCity) {
      res["mail_city"] = boost::any(*mailCity);
    }
    if (mailFullAddress) {
      res["mail_full_address"] = boost::any(*mailFullAddress);
    }
    if (mailProvince) {
      res["mail_province"] = boost::any(*mailProvince);
    }
    if (penaltyFee) {
      res["penalty_fee"] = boost::any(*penaltyFee);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (telephone) {
      res["telephone"] = boost::any(*telephone);
    }
    if (trainInvoiceFee) {
      res["train_invoice_fee"] = boost::any(*trainInvoiceFee);
    }
    if (vehicleInvoiceFee) {
      res["vehicle_invoice_fee"] = boost::any(*vehicleInvoiceFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact") != m.end() && !m["contact"].empty()) {
      contact = make_shared<string>(boost::any_cast<string>(m["contact"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("flight_invoice_fee") != m.end() && !m["flight_invoice_fee"].empty()) {
      flightInvoiceFee = make_shared<string>(boost::any_cast<string>(m["flight_invoice_fee"]));
    }
    if (m.find("fu_point_invoice_fee") != m.end() && !m["fu_point_invoice_fee"].empty()) {
      fuPointInvoiceFee = make_shared<string>(boost::any_cast<string>(m["fu_point_invoice_fee"]));
    }
    if (m.find("hotel_normal_invoice_fee") != m.end() && !m["hotel_normal_invoice_fee"].empty()) {
      hotelNormalInvoiceFee = make_shared<string>(boost::any_cast<string>(m["hotel_normal_invoice_fee"]));
    }
    if (m.find("hotel_special_invoice_fee") != m.end() && !m["hotel_special_invoice_fee"].empty()) {
      hotelSpecialInvoiceFee = make_shared<string>(boost::any_cast<string>(m["hotel_special_invoice_fee"]));
    }
    if (m.find("international_flight_invoice_fee") != m.end() && !m["international_flight_invoice_fee"].empty()) {
      internationalFlightInvoiceFee = make_shared<string>(boost::any_cast<string>(m["international_flight_invoice_fee"]));
    }
    if (m.find("invoice_third_part_id") != m.end() && !m["invoice_third_part_id"].empty()) {
      invoiceThirdPartId = make_shared<string>(boost::any_cast<string>(m["invoice_third_part_id"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("mail_address") != m.end() && !m["mail_address"].empty()) {
      mailAddress = make_shared<string>(boost::any_cast<string>(m["mail_address"]));
    }
    if (m.find("mail_city") != m.end() && !m["mail_city"].empty()) {
      mailCity = make_shared<string>(boost::any_cast<string>(m["mail_city"]));
    }
    if (m.find("mail_full_address") != m.end() && !m["mail_full_address"].empty()) {
      mailFullAddress = make_shared<string>(boost::any_cast<string>(m["mail_full_address"]));
    }
    if (m.find("mail_province") != m.end() && !m["mail_province"].empty()) {
      mailProvince = make_shared<string>(boost::any_cast<string>(m["mail_province"]));
    }
    if (m.find("penalty_fee") != m.end() && !m["penalty_fee"].empty()) {
      penaltyFee = make_shared<string>(boost::any_cast<string>(m["penalty_fee"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<string>(boost::any_cast<string>(m["service_fee"]));
    }
    if (m.find("telephone") != m.end() && !m["telephone"].empty()) {
      telephone = make_shared<string>(boost::any_cast<string>(m["telephone"]));
    }
    if (m.find("train_invoice_fee") != m.end() && !m["train_invoice_fee"].empty()) {
      trainInvoiceFee = make_shared<string>(boost::any_cast<string>(m["train_invoice_fee"]));
    }
    if (m.find("vehicle_invoice_fee") != m.end() && !m["vehicle_invoice_fee"].empty()) {
      vehicleInvoiceFee = make_shared<string>(boost::any_cast<string>(m["vehicle_invoice_fee"]));
    }
  }


  virtual ~WaitApplyInvoiceTaskDetailQueryResponseBodyModule() = default;
};
class WaitApplyInvoiceTaskDetailQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<WaitApplyInvoiceTaskDetailQueryResponseBodyModule>> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  WaitApplyInvoiceTaskDetailQueryResponseBody() {}

  explicit WaitApplyInvoiceTaskDetailQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<WaitApplyInvoiceTaskDetailQueryResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WaitApplyInvoiceTaskDetailQueryResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<WaitApplyInvoiceTaskDetailQueryResponseBodyModule>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~WaitApplyInvoiceTaskDetailQueryResponseBody() = default;
};
class WaitApplyInvoiceTaskDetailQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WaitApplyInvoiceTaskDetailQueryResponseBody> body{};

  WaitApplyInvoiceTaskDetailQueryResponse() {}

  explicit WaitApplyInvoiceTaskDetailQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WaitApplyInvoiceTaskDetailQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WaitApplyInvoiceTaskDetailQueryResponseBody>(model1);
      }
    }
  }


  virtual ~WaitApplyInvoiceTaskDetailQueryResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AccessTokenResponse accessTokenWithOptions(shared_ptr<AccessTokenRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AccessTokenResponse accessToken(shared_ptr<AccessTokenRequest> request);
  AddressGetResponse addressGetWithOptions(shared_ptr<AddressGetRequest> request, shared_ptr<AddressGetHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddressGetResponse addressGet(shared_ptr<AddressGetRequest> request);
  AirportSearchResponse airportSearchWithOptions(shared_ptr<AirportSearchRequest> request, shared_ptr<AirportSearchHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AirportSearchResponse airportSearch(shared_ptr<AirportSearchRequest> request);
  AllBaseCityInfoQueryResponse allBaseCityInfoQueryWithOptions(shared_ptr<AllBaseCityInfoQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllBaseCityInfoQueryResponse allBaseCityInfoQuery();
  ApplyAddResponse applyAddWithOptions(shared_ptr<ApplyAddRequest> tmpReq, shared_ptr<ApplyAddHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyAddResponse applyAdd(shared_ptr<ApplyAddRequest> request);
  ApplyApproveResponse applyApproveWithOptions(shared_ptr<ApplyApproveRequest> request, shared_ptr<ApplyApproveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyApproveResponse applyApprove(shared_ptr<ApplyApproveRequest> request);
  ApplyInvoiceTaskResponse applyInvoiceTaskWithOptions(shared_ptr<ApplyInvoiceTaskRequest> tmpReq, shared_ptr<ApplyInvoiceTaskHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyInvoiceTaskResponse applyInvoiceTask(shared_ptr<ApplyInvoiceTaskRequest> request);
  ApplyListQueryResponse applyListQueryWithOptions(shared_ptr<ApplyListQueryRequest> request, shared_ptr<ApplyListQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyListQueryResponse applyListQuery(shared_ptr<ApplyListQueryRequest> request);
  ApplyModifyResponse applyModifyWithOptions(shared_ptr<ApplyModifyRequest> tmpReq, shared_ptr<ApplyModifyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyModifyResponse applyModify(shared_ptr<ApplyModifyRequest> request);
  ApplyQueryResponse applyQueryWithOptions(shared_ptr<ApplyQueryRequest> request, shared_ptr<ApplyQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyQueryResponse applyQuery(shared_ptr<ApplyQueryRequest> request);
  BtripBillInfoAdjustResponse btripBillInfoAdjustWithOptions(shared_ptr<BtripBillInfoAdjustRequest> request, shared_ptr<BtripBillInfoAdjustHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BtripBillInfoAdjustResponse btripBillInfoAdjust(shared_ptr<BtripBillInfoAdjustRequest> request);
  CarApplyAddResponse carApplyAddWithOptions(shared_ptr<CarApplyAddRequest> request, shared_ptr<CarApplyAddHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CarApplyAddResponse carApplyAdd(shared_ptr<CarApplyAddRequest> request);
  CarApplyModifyResponse carApplyModifyWithOptions(shared_ptr<CarApplyModifyRequest> request, shared_ptr<CarApplyModifyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CarApplyModifyResponse carApplyModify(shared_ptr<CarApplyModifyRequest> request);
  CarApplyQueryResponse carApplyQueryWithOptions(shared_ptr<CarApplyQueryRequest> request, shared_ptr<CarApplyQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CarApplyQueryResponse carApplyQuery(shared_ptr<CarApplyQueryRequest> request);
  CarBillSettlementQueryResponse carBillSettlementQueryWithOptions(shared_ptr<CarBillSettlementQueryRequest> request, shared_ptr<CarBillSettlementQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CarBillSettlementQueryResponse carBillSettlementQuery(shared_ptr<CarBillSettlementQueryRequest> request);
  CarOrderListQueryResponse carOrderListQueryWithOptions(shared_ptr<CarOrderListQueryRequest> request, shared_ptr<CarOrderListQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CarOrderListQueryResponse carOrderListQuery(shared_ptr<CarOrderListQueryRequest> request);
  CarOrderQueryResponse carOrderQueryWithOptions(shared_ptr<CarOrderQueryRequest> request, shared_ptr<CarOrderQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CarOrderQueryResponse carOrderQuery(shared_ptr<CarOrderQueryRequest> request);
  CitySearchResponse citySearchWithOptions(shared_ptr<CitySearchRequest> request, shared_ptr<CitySearchHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CitySearchResponse citySearch(shared_ptr<CitySearchRequest> request);
  CommonApplyQueryResponse commonApplyQueryWithOptions(shared_ptr<CommonApplyQueryRequest> request, shared_ptr<CommonApplyQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CommonApplyQueryResponse commonApplyQuery(shared_ptr<CommonApplyQueryRequest> request);
  CommonApplySyncResponse commonApplySyncWithOptions(shared_ptr<CommonApplySyncRequest> request, shared_ptr<CommonApplySyncHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CommonApplySyncResponse commonApplySync(shared_ptr<CommonApplySyncRequest> request);
  CorpAuthLinkInfoQueryResponse corpAuthLinkInfoQueryWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CorpAuthLinkInfoQueryResponse corpAuthLinkInfoQuery();
  CorpTokenResponse corpTokenWithOptions(shared_ptr<CorpTokenRequest> request, shared_ptr<CorpTokenHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CorpTokenResponse corpToken(shared_ptr<CorpTokenRequest> request);
  CostCenterDeleteResponse costCenterDeleteWithOptions(shared_ptr<CostCenterDeleteRequest> request, shared_ptr<CostCenterDeleteHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CostCenterDeleteResponse costCenterDelete(shared_ptr<CostCenterDeleteRequest> request);
  CostCenterModifyResponse costCenterModifyWithOptions(shared_ptr<CostCenterModifyRequest> request, shared_ptr<CostCenterModifyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CostCenterModifyResponse costCenterModify(shared_ptr<CostCenterModifyRequest> request);
  CostCenterQueryResponse costCenterQueryWithOptions(shared_ptr<CostCenterQueryRequest> request, shared_ptr<CostCenterQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CostCenterQueryResponse costCenterQuery(shared_ptr<CostCenterQueryRequest> request);
  CostCenterSaveResponse costCenterSaveWithOptions(shared_ptr<CostCenterSaveRequest> request, shared_ptr<CostCenterSaveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CostCenterSaveResponse costCenterSave(shared_ptr<CostCenterSaveRequest> request);
  DepartmentSaveResponse departmentSaveWithOptions(shared_ptr<DepartmentSaveRequest> tmpReq, shared_ptr<DepartmentSaveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DepartmentSaveResponse departmentSave(shared_ptr<DepartmentSaveRequest> request);
  EntityAddResponse entityAddWithOptions(shared_ptr<EntityAddRequest> tmpReq, shared_ptr<EntityAddHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EntityAddResponse entityAdd(shared_ptr<EntityAddRequest> request);
  EntityDeleteResponse entityDeleteWithOptions(shared_ptr<EntityDeleteRequest> tmpReq, shared_ptr<EntityDeleteHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EntityDeleteResponse entityDelete(shared_ptr<EntityDeleteRequest> request);
  EntitySetResponse entitySetWithOptions(shared_ptr<EntitySetRequest> tmpReq, shared_ptr<EntitySetHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EntitySetResponse entitySet(shared_ptr<EntitySetRequest> request);
  EstimatedPriceQueryResponse estimatedPriceQueryWithOptions(shared_ptr<EstimatedPriceQueryRequest> request, shared_ptr<EstimatedPriceQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EstimatedPriceQueryResponse estimatedPriceQuery(shared_ptr<EstimatedPriceQueryRequest> request);
  ExceedApplySyncResponse exceedApplySyncWithOptions(shared_ptr<ExceedApplySyncRequest> request, shared_ptr<ExceedApplySyncHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExceedApplySyncResponse exceedApplySync(shared_ptr<ExceedApplySyncRequest> request);
  FlightBillSettlementQueryResponse flightBillSettlementQueryWithOptions(shared_ptr<FlightBillSettlementQueryRequest> request, shared_ptr<FlightBillSettlementQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightBillSettlementQueryResponse flightBillSettlementQuery(shared_ptr<FlightBillSettlementQueryRequest> request);
  FlightCancelOrderResponse flightCancelOrderWithOptions(shared_ptr<FlightCancelOrderRequest> request, shared_ptr<FlightCancelOrderHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightCancelOrderResponse flightCancelOrder(shared_ptr<FlightCancelOrderRequest> request);
  FlightCreateOrderResponse flightCreateOrderWithOptions(shared_ptr<FlightCreateOrderRequest> tmpReq, shared_ptr<FlightCreateOrderHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightCreateOrderResponse flightCreateOrder(shared_ptr<FlightCreateOrderRequest> request);
  FlightExceedApplyQueryResponse flightExceedApplyQueryWithOptions(shared_ptr<FlightExceedApplyQueryRequest> request, shared_ptr<FlightExceedApplyQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightExceedApplyQueryResponse flightExceedApplyQuery(shared_ptr<FlightExceedApplyQueryRequest> request);
  FlightItineraryScanQueryResponse flightItineraryScanQueryWithOptions(shared_ptr<FlightItineraryScanQueryRequest> request, shared_ptr<FlightItineraryScanQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightItineraryScanQueryResponse flightItineraryScanQuery(shared_ptr<FlightItineraryScanQueryRequest> request);
  FlightListingSearchResponse flightListingSearchWithOptions(shared_ptr<FlightListingSearchRequest> request, shared_ptr<FlightListingSearchHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightListingSearchResponse flightListingSearch(shared_ptr<FlightListingSearchRequest> request);
  FlightOrderDetailInfoResponse flightOrderDetailInfoWithOptions(shared_ptr<FlightOrderDetailInfoRequest> request, shared_ptr<FlightOrderDetailInfoHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightOrderDetailInfoResponse flightOrderDetailInfo(shared_ptr<FlightOrderDetailInfoRequest> request);
  FlightOrderListQueryResponse flightOrderListQueryWithOptions(shared_ptr<FlightOrderListQueryRequest> request, shared_ptr<FlightOrderListQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightOrderListQueryResponse flightOrderListQuery(shared_ptr<FlightOrderListQueryRequest> request);
  FlightOrderQueryResponse flightOrderQueryWithOptions(shared_ptr<FlightOrderQueryRequest> request, shared_ptr<FlightOrderQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightOrderQueryResponse flightOrderQuery(shared_ptr<FlightOrderQueryRequest> request);
  FlightOtaSearchResponse flightOtaSearchWithOptions(shared_ptr<FlightOtaSearchRequest> request, shared_ptr<FlightOtaSearchHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightOtaSearchResponse flightOtaSearch(shared_ptr<FlightOtaSearchRequest> request);
  FlightPayOrderResponse flightPayOrderWithOptions(shared_ptr<FlightPayOrderRequest> tmpReq, shared_ptr<FlightPayOrderHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightPayOrderResponse flightPayOrder(shared_ptr<FlightPayOrderRequest> request);
  FlightRefundApplyResponse flightRefundApplyWithOptions(shared_ptr<FlightRefundApplyRequest> tmpReq, shared_ptr<FlightRefundApplyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightRefundApplyResponse flightRefundApply(shared_ptr<FlightRefundApplyRequest> request);
  FlightRefundDetailResponse flightRefundDetailWithOptions(shared_ptr<FlightRefundDetailRequest> request, shared_ptr<FlightRefundDetailHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightRefundDetailResponse flightRefundDetail(shared_ptr<FlightRefundDetailRequest> request);
  FlightRefundPreCalResponse flightRefundPreCalWithOptions(shared_ptr<FlightRefundPreCalRequest> tmpReq, shared_ptr<FlightRefundPreCalHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightRefundPreCalResponse flightRefundPreCal(shared_ptr<FlightRefundPreCalRequest> request);
  FlightSearchListResponse flightSearchListWithOptions(shared_ptr<FlightSearchListRequest> request, shared_ptr<FlightSearchListHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightSearchListResponse flightSearchList(shared_ptr<FlightSearchListRequest> request);
  HotelBillSettlementQueryResponse hotelBillSettlementQueryWithOptions(shared_ptr<HotelBillSettlementQueryRequest> request, shared_ptr<HotelBillSettlementQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelBillSettlementQueryResponse hotelBillSettlementQuery(shared_ptr<HotelBillSettlementQueryRequest> request);
  HotelExceedApplyQueryResponse hotelExceedApplyQueryWithOptions(shared_ptr<HotelExceedApplyQueryRequest> request, shared_ptr<HotelExceedApplyQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelExceedApplyQueryResponse hotelExceedApplyQuery(shared_ptr<HotelExceedApplyQueryRequest> request);
  HotelOrderListQueryResponse hotelOrderListQueryWithOptions(shared_ptr<HotelOrderListQueryRequest> request, shared_ptr<HotelOrderListQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelOrderListQueryResponse hotelOrderListQuery(shared_ptr<HotelOrderListQueryRequest> request);
  HotelOrderQueryResponse hotelOrderQueryWithOptions(shared_ptr<HotelOrderQueryRequest> request, shared_ptr<HotelOrderQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelOrderQueryResponse hotelOrderQuery(shared_ptr<HotelOrderQueryRequest> request);
  IeFlightBillSettlementQueryResponse ieFlightBillSettlementQueryWithOptions(shared_ptr<IeFlightBillSettlementQueryRequest> request, shared_ptr<IeFlightBillSettlementQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  IeFlightBillSettlementQueryResponse ieFlightBillSettlementQuery(shared_ptr<IeFlightBillSettlementQueryRequest> request);
  InvoiceAddResponse invoiceAddWithOptions(shared_ptr<InvoiceAddRequest> request, shared_ptr<InvoiceAddHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvoiceAddResponse invoiceAdd(shared_ptr<InvoiceAddRequest> request);
  InvoiceDeleteResponse invoiceDeleteWithOptions(shared_ptr<InvoiceDeleteRequest> request, shared_ptr<InvoiceDeleteHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvoiceDeleteResponse invoiceDelete(shared_ptr<InvoiceDeleteRequest> request);
  InvoiceModifyResponse invoiceModifyWithOptions(shared_ptr<InvoiceModifyRequest> request, shared_ptr<InvoiceModifyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvoiceModifyResponse invoiceModify(shared_ptr<InvoiceModifyRequest> request);
  InvoiceRuleSaveResponse invoiceRuleSaveWithOptions(shared_ptr<InvoiceRuleSaveRequest> tmpReq, shared_ptr<InvoiceRuleSaveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvoiceRuleSaveResponse invoiceRuleSave(shared_ptr<InvoiceRuleSaveRequest> request);
  InvoiceSearchResponse invoiceSearchWithOptions(shared_ptr<InvoiceSearchRequest> request, shared_ptr<InvoiceSearchHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvoiceSearchResponse invoiceSearch(shared_ptr<InvoiceSearchRequest> request);
  IsvRuleSaveResponse isvRuleSaveWithOptions(shared_ptr<IsvRuleSaveRequest> request, shared_ptr<IsvRuleSaveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  IsvRuleSaveResponse isvRuleSave(shared_ptr<IsvRuleSaveRequest> request);
  IsvUserSaveResponse isvUserSaveWithOptions(shared_ptr<IsvUserSaveRequest> tmpReq, shared_ptr<IsvUserSaveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  IsvUserSaveResponse isvUserSave(shared_ptr<IsvUserSaveRequest> request);
  MonthBillConfirmResponse monthBillConfirmWithOptions(shared_ptr<MonthBillConfirmRequest> request, shared_ptr<MonthBillConfirmHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MonthBillConfirmResponse monthBillConfirm(shared_ptr<MonthBillConfirmRequest> request);
  MonthBillGetResponse monthBillGetWithOptions(shared_ptr<MonthBillGetRequest> request, shared_ptr<MonthBillGetHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MonthBillGetResponse monthBillGet(shared_ptr<MonthBillGetRequest> request);
  ProjectAddResponse projectAddWithOptions(shared_ptr<ProjectAddRequest> request, shared_ptr<ProjectAddHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ProjectAddResponse projectAdd(shared_ptr<ProjectAddRequest> request);
  ProjectDeleteResponse projectDeleteWithOptions(shared_ptr<ProjectDeleteRequest> request, shared_ptr<ProjectDeleteHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ProjectDeleteResponse projectDelete(shared_ptr<ProjectDeleteRequest> request);
  ProjectModifyResponse projectModifyWithOptions(shared_ptr<ProjectModifyRequest> request, shared_ptr<ProjectModifyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ProjectModifyResponse projectModify(shared_ptr<ProjectModifyRequest> request);
  QueryReimbursementOrderResponse queryReimbursementOrderWithOptions(shared_ptr<QueryReimbursementOrderRequest> request, shared_ptr<QueryReimbursementOrderHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryReimbursementOrderResponse queryReimbursementOrder(shared_ptr<QueryReimbursementOrderRequest> request);
  SyncSingleUserResponse syncSingleUserWithOptions(shared_ptr<SyncSingleUserRequest> tmpReq, shared_ptr<SyncSingleUserHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncSingleUserResponse syncSingleUser(shared_ptr<SyncSingleUserRequest> request);
  TicketChangingApplyResponse ticketChangingApplyWithOptions(shared_ptr<TicketChangingApplyRequest> tmpReq, shared_ptr<TicketChangingApplyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TicketChangingApplyResponse ticketChangingApply(shared_ptr<TicketChangingApplyRequest> request);
  TicketChangingCancelResponse ticketChangingCancelWithOptions(shared_ptr<TicketChangingCancelRequest> request, shared_ptr<TicketChangingCancelHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TicketChangingCancelResponse ticketChangingCancel(shared_ptr<TicketChangingCancelRequest> request);
  TicketChangingDetailResponse ticketChangingDetailWithOptions(shared_ptr<TicketChangingDetailRequest> request, shared_ptr<TicketChangingDetailHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TicketChangingDetailResponse ticketChangingDetail(shared_ptr<TicketChangingDetailRequest> request);
  TicketChangingEnquiryResponse ticketChangingEnquiryWithOptions(shared_ptr<TicketChangingEnquiryRequest> request, shared_ptr<TicketChangingEnquiryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TicketChangingEnquiryResponse ticketChangingEnquiry(shared_ptr<TicketChangingEnquiryRequest> request);
  TicketChangingFlightListResponse ticketChangingFlightListWithOptions(shared_ptr<TicketChangingFlightListRequest> tmpReq, shared_ptr<TicketChangingFlightListHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TicketChangingFlightListResponse ticketChangingFlightList(shared_ptr<TicketChangingFlightListRequest> request);
  TicketChangingPayResponse ticketChangingPayWithOptions(shared_ptr<TicketChangingPayRequest> tmpReq, shared_ptr<TicketChangingPayHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TicketChangingPayResponse ticketChangingPay(shared_ptr<TicketChangingPayRequest> request);
  TrainBillSettlementQueryResponse trainBillSettlementQueryWithOptions(shared_ptr<TrainBillSettlementQueryRequest> request, shared_ptr<TrainBillSettlementQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainBillSettlementQueryResponse trainBillSettlementQuery(shared_ptr<TrainBillSettlementQueryRequest> request);
  TrainExceedApplyQueryResponse trainExceedApplyQueryWithOptions(shared_ptr<TrainExceedApplyQueryRequest> request, shared_ptr<TrainExceedApplyQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainExceedApplyQueryResponse trainExceedApplyQuery(shared_ptr<TrainExceedApplyQueryRequest> request);
  TrainOrderListQueryResponse trainOrderListQueryWithOptions(shared_ptr<TrainOrderListQueryRequest> request, shared_ptr<TrainOrderListQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainOrderListQueryResponse trainOrderListQuery(shared_ptr<TrainOrderListQueryRequest> request);
  TrainOrderQueryResponse trainOrderQueryWithOptions(shared_ptr<TrainOrderQueryRequest> request, shared_ptr<TrainOrderQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainOrderQueryResponse trainOrderQuery(shared_ptr<TrainOrderQueryRequest> request);
  TrainOrderQueryV2Response trainOrderQueryV2WithOptions(shared_ptr<TrainOrderQueryV2Request> request, shared_ptr<TrainOrderQueryV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainOrderQueryV2Response trainOrderQueryV2(shared_ptr<TrainOrderQueryV2Request> request);
  TrainStationSearchResponse trainStationSearchWithOptions(shared_ptr<TrainStationSearchRequest> request, shared_ptr<TrainStationSearchHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainStationSearchResponse trainStationSearch(shared_ptr<TrainStationSearchRequest> request);
  TrainTicketScanQueryResponse trainTicketScanQueryWithOptions(shared_ptr<TrainTicketScanQueryRequest> request, shared_ptr<TrainTicketScanQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainTicketScanQueryResponse trainTicketScanQuery(shared_ptr<TrainTicketScanQueryRequest> request);
  UserQueryResponse userQueryWithOptions(shared_ptr<UserQueryRequest> request, shared_ptr<UserQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UserQueryResponse userQuery(shared_ptr<UserQueryRequest> request);
  VatInvoiceScanQueryResponse vatInvoiceScanQueryWithOptions(shared_ptr<VatInvoiceScanQueryRequest> request, shared_ptr<VatInvoiceScanQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VatInvoiceScanQueryResponse vatInvoiceScanQuery(shared_ptr<VatInvoiceScanQueryRequest> request);
  WaitApplyInvoiceTaskDetailQueryResponse waitApplyInvoiceTaskDetailQueryWithOptions(shared_ptr<WaitApplyInvoiceTaskDetailQueryRequest> request, shared_ptr<WaitApplyInvoiceTaskDetailQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  WaitApplyInvoiceTaskDetailQueryResponse waitApplyInvoiceTaskDetailQuery(shared_ptr<WaitApplyInvoiceTaskDetailQueryRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_BtripOpen20220520

#endif
